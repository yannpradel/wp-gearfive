/**
 *	Cup of the Day qualifications mode
 */
#Extends "Modes/Nadeo/Trackmania/Base/TrackmaniaBase.Script.txt"

#Const CompatibleMapTypes	"TrackMania\\TM_Race,TM_Race"
#Const Version						"1.1.0+2023-10-09"
#Const ScriptName					"Modes/TrackMania/TM_COTDQualifications_Online.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/CMGame/Utils/Task.Script.txt" as Task
#Include "Libs/Nadeo/TMGame/Utils/Tracking.Script.txt" as Tracking
#Include "Libs/Nadeo/Trackmania/MainMenu/Constants.Script.txt" as MenuConst
#Include "Libs/Nadeo/Trackmania/Modes/COTDQualifications/StateManager.Script.txt" as StateMgr
#Include "Libs/Nadeo/Trackmania/Modes/COTDQualifications/COTD.Script.txt" as COTD
#Include "Libs/Nadeo/Trackmania/Modes/ServerAuth.Script.txt" as ServerAuth
#Include "Libs/Nadeo/Trackmania/Modes/TrophyRanking.Script.txt" as TrophyRanking
#Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/Checkpoint_Server.Script.txt" as UIModules_Checkpoint
#Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/PauseMenuOnline_Server.Script.txt" as UIModules_PauseMenu_Online
#Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/TimeGap_Server.Script.txt" as UIModules_TimeGap
#Include "Libs/Nadeo/Trackmania/Modes/COTDQualifications/UIModules/QualificationsProgress_Server.Script.txt" as UIModules_QualificationsProgress
#Include "Libs/Nadeo/Trackmania/Modes/TimeAttack/UIModules/EndMatchTrophy_Server.Script.txt" as UIModules_EndMatchTrophy

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Settings
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Setting S_TimeLimit 300 as _("Time limit") ///< Time limit before going to the next map
#Setting S_ForceLapsNb 0
#Setting S_PlayerPartition "" as "<hidden>" //< Players partition on servers (crossplay or not) see: /trackmania-next/tmnext/-/issues/4938
#Setting S_BasicAuthHeader "Basic xxx" as "<hidden>"
#Setting S_IntroMaxDuration 15 as "<hidden>"
#Setting S_RankedCompetitionType "" as "<hidden>" //< Is it the main COTD or a rerun
#Setting S_EnableJoinLeaveNotifications False

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_ModeName "Cup of the Day qualifications"
//L16N [COTD qualifications] Description of the mode rules
#Const Description _("Race for 15 minutes on today's track. You will be able to join the knockout phase afterwards and earn even more trophies.\nYou can see your global rank among all servers on the left of your screen.")

#Const C_HudModulePath "" //< Path to the hud module
#Const C_ManiaAppUrl "file://Media/ManiaApps/Nadeo/Trackmania/Modes/COTDQualifications.Script.txt" //< Url of the mania app
#Const C_FakeUsersNb 0
#Const C_DebugCOTD False

#Const C_UploadRecord True
#Const C_DisplayRecordGhost True
#Const C_DisplayRecordMedal True
#Const C_CelebrateRecordGhost True
#Const C_CelebrateRecordMedal True
#Const C_DisplayWorldTop False

#Const C_TrophyTaskTimeout 5000
#Const C_TrophyAnimationDuration 4000
#Const C_TrophyDisplayDuration 7000

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Extends
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
***Match_LogVersions***
***
Log::RegisterScript(ScriptName, Version);
Log::RegisterScript(Task::ScriptName, Task::Version);
Log::RegisterScript(Tracking::ScriptName, Tracking::Version);
Log::RegisterScript(MenuConst::ScriptName, MenuConst::Version);
Log::RegisterScript(StateMgr::ScriptName, StateMgr::Version);
Log::RegisterScript(COTD::ScriptName, COTD::Version);
Log::RegisterScript(ServerAuth::ScriptName, ServerAuth::Version);
Log::RegisterScript(TrophyRanking::ScriptName, TrophyRanking::Version);
Log::RegisterScript(UIModules_Checkpoint::ScriptName, UIModules_Checkpoint::Version);
Log::RegisterScript(UIModules_PauseMenu_Online::ScriptName, UIModules_PauseMenu_Online::Version);
Log::RegisterScript(UIModules_TimeGap::ScriptName, UIModules_TimeGap::Version);
Log::RegisterScript(UIModules_QualificationsProgress::ScriptName, UIModules_QualificationsProgress::Version);
Log::RegisterScript(UIModules_EndMatchTrophy::ScriptName, UIModules_EndMatchTrophy::Version);
***

***Match_LoadLibraries***
***
ServerAuth::Init([ServerAuth::C_Services_Club]);
StateMgr::Load();
***

***Match_UnloadLibraries***
***
StateMgr::Unload();
***

***Match_Settings***
***
MB_Settings_UseDefaultHud = (C_HudModulePath == "");
MB_Settings_UseDefaultTimer = False;
MB_Settings_UseDefaultPodiumSequence = False;
***

***Match_Rules***
***
ModeInfo::SetName(C_ModeName);
ModeInfo::SetType(ModeInfo::C_Type_FreeForAll);
ModeInfo::SetRules(Description);
ModeInfo::SetStatusMessage("");
***

***Match_LoadHud***
***
if (C_HudModulePath != "") Hud_Load(C_HudModulePath);
***

***Match_AfterLoadHud***
***
ClientManiaAppUrl = C_ManiaAppUrl;
UIManager.UISequenceMaxDuration = ML::Max(0, (S_IntroMaxDuration * 1000) - Race::C_SpawnDuration);
Race::SortScores(GetScoresSortCriteria(Race::IsIndependentLaps()));
UIModules_PauseMenu_Online::SetHelp(Description);
UIModules_Checkpoint::SetRankMode(UIModules_Checkpoint::C_RankMode_BestRace);
UIModules_TimeGap::SetTimeGapMode(UIModules_TimeGap::C_TimeGapMode_BestRace);
UIModules_Sign16x9Small::SetScoreMode(UIModules_Sign16x9Small::C_ScoreMode_BestRaceTime);
UIModules_Record::SetSpecialVisibility(False);
UIModules_QualificationsProgress::SetCanDisplayPopUp(False);
***

***Match_Yield***
***
declare COTD::K_Qualifications Map_COTDQualifications for This = COTD::C_Qualifications_Null;

foreach (Event in PendingEvents) {
	switch (Event.Type) {
		// Initialize players when they join the server
		case CSmModeEvent::EType::OnPlayerAdded: {
			StateMgr::InitializePlayer(Event.Player);
			CarRank::InitializePlayer(Event.Player);
			if (Event.Player != Null) {
				declare Boolean Server_CanForceTrophyRankUpdate for This = False;
				TrophyRanking::InitializeUser(Event.Player.User, Server_CanForceTrophyRankUpdate);
				Map_COTDQualifications = COTD::InitializePlayer(Map_COTDQualifications, Event.Player);
			}
		}
	}
}

ServerAuth::Yield();
StateMgr::Yield();
TrophyRanking::Yield();

Map_COTDQualifications = COTD::Yield(Map_COTDQualifications);
***

***Match_InitServer***
***
declare Boolean Server_CanForceTrophyRankUpdate for This = False;
declare Boolean Server_CanPlayCOTD;
***

***Match_StartServer***
***
// Initialize mode
Server_CanForceTrophyRankUpdate = False;
Server_CanPlayCOTD = True;
GiveUpBehaviour_RespawnAfter = True;
CrudeExtrapolation_AllowDelay = True;
CarRank::Reset();
Clans::SetClansNb(0);
WarmUp::SetAvailability(False);
StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
Race::SetRespawnBehaviour(Race::C_RespawnBehaviour_GiveUpBeforeFirstCheckpoint);
Race::SetupRecord(
	MenuConst::C_ScopeType_Season,
	MenuConst::C_ScopeType_PersonalBest,
	MenuConst::C_GameMode_TimeAttack,
	"",
	C_UploadRecord,
	C_DisplayRecordGhost,
	C_DisplayRecordMedal,
	C_CelebrateRecordGhost,
	C_CelebrateRecordMedal,
	C_DisplayWorldTop
);
***

***Match_AfterLoadMap***
***
Server_CanForceTrophyRankUpdate = True;
***

***Match_InitMap***
***
StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);

declare COTD::K_Qualifications Map_COTDQualifications for This = COTD::C_Qualifications_Null;
if (Server_CanPlayCOTD) {
	Server_CanPlayCOTD = False;

	Map_COTDQualifications = COTD::NewQualifications(
		Map_COTDQualifications,
		S_BasicAuthHeader,
		S_PlayerPartition,
		S_RankedCompetitionType,
		C_DebugCOTD,
		Map
	);
	foreach (Player in AllPlayers) {
		// Initialize `StateMgr` first, otherwise it could override other UI updates
		Map_COTDQualifications = COTD::InitializePlayer(Map_COTDQualifications, Player);
	}
	UIModules_QualificationsProgress::SetCanDisplayPopUp(COTD::QualificationsAreOver(Map_COTDQualifications));

	if (COTD::WaitQualificationsStart(Map_COTDQualifications)) {
		UIManager.UIAll.Spectator_SetForcedTarget_Landmark(Map::GetStart());
		while (COTD::WaitQualificationsStart(Map_COTDQualifications)) MB_Yield();
		UIManager.UIAll.Spectator_SetForcedTarget_Clear();
	}
} else {
	Map_COTDQualifications = COTD::DestroyQualifications(Map_COTDQualifications);
}
***

***Match_InitRound***
***
declare Integer Round_RoundStartTime;
***

***Match_StartRound***
***
// Initialize round
Users_SetNbFakeUsers(C_FakeUsersNb, 0);
SetScoresTableScoreMode(Race::IsIndependentLaps(), False);
UIModules_Record::SetSpecialVisibility(!COTD::IsInProgress(Map_COTDQualifications));
Race::SetupRecord(
	MenuConst::C_ScopeType_Season,
	MenuConst::C_ScopeType_PersonalBest,
	MenuConst::C_GameMode_TimeAttack,
	"",
	C_UploadRecord,
	C_DisplayRecordGhost,
	C_DisplayRecordMedal,
	C_CelebrateRecordGhost,
	C_CelebrateRecordMedal,
	!COTD::IsInProgress(Map_COTDQualifications)
);

// Initialize scores
Scores::Clear();

// Initialize race
StartTime = Now + Race::C_SpawnDuration;
Round_RoundStartTime = StartTime;
SetTimeLimit(
	COTD::QualificationsAreOngoing(Map_COTDQualifications),
	Map_COTDQualifications.QualificationsStartTime,
	Map_COTDQualifications.QualificationsEndTime,
	Round_RoundStartTime,
	S_TimeLimit
);

// Spawn players for the race
foreach (Player in Players) {
	Race::Start(Player, StartTime);
}

StateMgr::ForcePlayersStates([StateMgr::C_State_Playing]);
CarRank::Update(CarRank::C_SortCriteria_BestRace);
Race::EnableIntroDuringMatch(True);
UIModules_QualificationsProgress::SetCanDisplayPopUp(COTD::QualificationsAreOver(Map_COTDQualifications));
***

***Match_PlayLoop***
***
// Manage race events
declare Events::K_RaceEvent[] RacePendingEvents = Race::GetPendingEvents();
foreach (Event in RacePendingEvents) {
	Race::ValidEvent(Event);

	// Waypoint
	if (Event.Type == Events::C_Type_Waypoint) {
		if (Event.Player != Null) {
			if (Event.IsEndLap) {
				Scores::UpdatePlayerBestLapIfBetter(Event.Player);
				Scores::UpdatePlayerPrevLap(Event.Player);
			}
			if (Event.IsEndRace || (Event.IsEndLap && Event.IsIndependentLaps)) {
				// The qualifications are played on multiple servers
				// The only important ranking is the one displayed on the left of the screen
				// The scores table displays only the local times, so we can skip it
				if (COTD::QualificationsAreOngoing(Map_COTDQualifications)) {
					Race::StopSkipScoresTable(Event.Player);
				}

				declare Boolean BetterRace = Scores::UpdatePlayerBestRaceIfBetter(Event.Player);
				Scores::UpdatePlayerPrevRace(Event.Player);
				if (BetterRace) {
					CarRank::ThrottleUpdate(CarRank::C_SortCriteria_BestRace);
					if (Event.RaceTime > 0) {
						Map_COTDQualifications = COTD::SetPlayerRecord(Map_COTDQualifications, Event.Player, Event.RaceTime);
					}
				}
			}
		}
	}
}

// Manage mode events
foreach (Event in PendingEvents) {
	if (Event.HasBeenPassed || Event.HasBeenDiscarded) continue;
	Events::Invalid(Event);
}

// Spawn players
if (PlayersNbDead > 0) { //< Check for unspawned players only if at least one player is unspawned
	foreach (Player in Players) {
		if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && Race::IsReadyToStart(Player)) {
			Race::Start(Player);
		}
	}
}

// End the race when time limit is reached
if (EndTime > 0 && Now >= EndTime) {
	if (COTD::IsInProgress(Map_COTDQualifications)) {
		MB_StopRound();
	} else {
		MB_StopMatch();
	}
}
***

***Match_EndRound***
***
// Stop race
EndTime = -1;
declare Integer RoundDuration = ML::Max(0, Now - Round_RoundStartTime);
StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
Race::StopSkipOutroAll();
Race::EnableIntroDuringMatch(False);
UIModules_QualificationsProgress::ResetButtonClicked();
Race::SortScores(GetScoresSortCriteria(Race::IsIndependentLaps()));
TrophyRanking::UpdateUsersRank();
CarRank::Update(CarRank::C_SortCriteria_BestRace);

// Find winner
declare CSmScore WinnerScore <=> Scores::GetBestPlayer(GetLadderSortCriteria(Race::IsIndependentLaps()));
Scores::SetPlayerWinner(WinnerScore);

// Compute ranking for tracking
declare Integer PreviousRaceTime = 0;
declare Integer Rank = 0;
foreach (Key => Score in Scores) {
	declare Integer BestRaceTime = Scores::GetPlayerBestRaceTime(Score);
	if (
		Key == 0 || (
			BestRaceTime > 0 &&
			PreviousRaceTime < BestRaceTime
		) || (
			BestRaceTime <= 0 &&
			PreviousRaceTime > 0
		)
	) {
		PreviousRaceTime = BestRaceTime;
		Rank = Key + 1;
	}
	Tracking::SendPlayerMatchResult(UIManager, Score.User, Rank, WinnerScore == Score && Scores.count > 1 && BestRaceTime > 0);
}

if (COTD::IsInProgress(Map_COTDQualifications) && Now < Map_COTDQualifications.KnockoutTooLateToJoinTime) {
	//L16N [COTD qualifications] Message displayed after qualifications end, before the Knockout match. "Knockout" is a game mode and translation should be consistent with it
	UIModules_BigMessage::SetMessage(_("Qualifications are over. Knockout will start soon."));
} else if (WinnerScore == Null) {
	UIModules_BigMessage::SetMessage(_("|Match|Draw"));
} else if (MB_MatchIsRunning()) {
	UIModules_BigMessage::SetMessage(_("$<%1$> wins the track!"), WinnerScore.User.WebServicesUserId);
} else {
	UIModules_BigMessage::SetMessage(_("$<%1$> wins the match!"), WinnerScore.User.WebServicesUserId);
}

// Compute trophies
Trophy_LiveTimeAttackAchievement_ClearResultList();
Race::SortScores(GetScoresSortCriteria(Race::IsIndependentLaps()));
foreach (Key => Score in Scores) {
	if (Score.BestRaceTimes.count > 0 && Score.BestRaceTimes[Score.BestRaceTimes.count - 1] >= 0) {
		declare Integer UserTrophyRank = TrophyRanking::C_DefaultRank;
		if (TrophyRanking::UserIsRanked(Score.User)) {
			UserTrophyRank = TrophyRanking::GetUserRank(Score.User);
		}
		Trophy_LiveTimeAttackAchievement_AddResult(Score.User.WebServicesUserId, Key + 1, UserTrophyRank);
	}
}
declare Task::K_Task TrophySendResultTask = Task::Create(This, Trophy_LiveTimeAttackAchievement_SendResultList(RoundDuration / 1000));
declare Integer TrophySendResultTaskEndTime = Now + C_TrophyTaskTimeout;
UIModules_ScoresTable::ResetTrophies();
UIModules_EndMatchTrophy::ResetTrophyAnimation();

// Play the first part of the podium sequence
ModeUtils::PushAndApplyUISequence(UIManager.UIAll, CUIConfig::EUISequence::Podium);
MB_Sleep((S_ChatTime * 1000) / 2);

// Wait until the trophy task is complete
TrophySendResultTask = Task::Update(TrophySendResultTask);
while (Task::IsInitialized(TrophySendResultTask) && Task::IsRunning(TrophySendResultTask) && Now < TrophySendResultTaskEndTime) {
	MB_Yield();
	TrophySendResultTask = Task::Update(TrophySendResultTask);
}
if (Task::IsInitialized(TrophySendResultTask)) {
	TrophySendResultTask = Task::Update(TrophySendResultTask);
	declare Integer[Integer][Text] AccountsTrophies;
	if (!Task::IsRunning(TrophySendResultTask)) {
		declare CTaskResult_AccountTrophyGainList SourceTask = Task::GetSourceTask_AccountTrophyGainList(TrophySendResultTask);
		if (Task::IsSuccess(TrophySendResultTask) && SourceTask != Null) {
			foreach (AccountTrophyGain in SourceTask.AccountTrophyGainList) {
				declare Integer[Integer] AccountTrophies = UIModules_ScoresTable::ConvertAccountTrophyGain(AccountTrophyGain);
				if (AccountTrophies.count > 0) {
					AccountsTrophies[AccountTrophyGain.WebServicesUserId] = AccountTrophies;
				}
			}
		}
	}
	if (AccountsTrophies.count > 0) {
		foreach (Player in AllPlayers) {
			if (Player.User != Null) {
				declare Integer[Integer] Trophies = AccountsTrophies.get(Player.User.WebServicesUserId, []);
				if (Trophies.count > 0) {
					Tracking::SendPlayerTrophiesEarned(UIManager, Player, Trophies);
				}
			}
		}
	}
	TrophySendResultTask = Task::Destroy(TrophySendResultTask);
	UIModules_ScoresTable::SetTrophies(AccountsTrophies);
	UIModules_EndMatchTrophy::PlayTrophyAnimation(AccountsTrophies);
	StateMgr::ForcePlayersStates([StateMgr::C_State_TrophyAnimation]);
	MB_Sleep(C_TrophyAnimationDuration);
	StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
}

// Play the second part of the podium sequence
ModeUtils::PushAndApplyScoresTableVisibility(UIManager.UIAll, CUIConfig::EVisibility::ForcedVisible);
MB_Sleep((S_ChatTime * 1000) / 2);
SetScoresTableScoreMode(Race::IsIndependentLaps(), True);
MB_Sleep(C_TrophyDisplayDuration);
SetScoresTableScoreMode(Race::IsIndependentLaps(), False);
ModeUtils::PopAndApplyScoresTableVisibility(UIManager.UIAll);
ModeUtils::PopAndApplyUISequence(UIManager.UIAll);
UIModules_BigMessage::SetMessage("");
UIModules_ScoresTable::ResetTrophies();
***

***Match_EndMap***
***
// Ensure that we stop the match (after a vote for the next map, ...)
MB_StopMatch();
***

***Match_BeforeUnloadMap***
***
Server_CanForceTrophyRankUpdate = False;
***

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Select the scores table score mode
Void SetScoresTableScoreMode(Boolean _IsIndependentLaps, Boolean _DisplayTrophies) {
	if (_DisplayTrophies) UIModules_ScoresTable::SetScoreMode(UIModules_ScoresTable::C_Mode_Trophy);
	else if (_IsIndependentLaps) UIModules_ScoresTable::SetScoreMode(UIModules_ScoresTable::C_Mode_LapTime);
	else UIModules_ScoresTable::SetScoreMode(UIModules_ScoresTable::C_Mode_BestTime);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the race time limit
Void SetTimeLimit(
	Boolean _QualificationsAreOngoing,
	Integer _QualificationsStartTime,
	Integer _QualificationsEndTime,
	Integer _TimeAttackStartTime,
	Integer _TimeAttackTimeLimit
) {
	if (_QualificationsAreOngoing) {
		if (_QualificationsEndTime <= 0) {
			EndTime = -1;
			UIModules_ScoresTable::SetFooterInfo("");
		} else {
			EndTime = _QualificationsEndTime;
			if (_QualificationsEndTime - _QualificationsStartTime <= 0) {
				UIModules_ScoresTable::SetFooterInfo("");
			} else {
				UIModules_ScoresTable::SetFooterInfo(TL::Compose("%1 "^TL::TimeToText(_QualificationsEndTime - _QualificationsStartTime), _("Time Limit")));
			}
		}
	} else if (_TimeAttackTimeLimit <= 0) {
		EndTime = -1;
		UIModules_ScoresTable::SetFooterInfo("");
	} else {
		EndTime = _TimeAttackStartTime + (_TimeAttackTimeLimit * 1000);
		UIModules_ScoresTable::SetFooterInfo(TL::Compose("%1 "^TL::TimeToText(_TimeAttackTimeLimit * 1000), _("Time Limit")));
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the right sort criteria for the scores
Integer GetScoresSortCriteria(Boolean _IsIndependentLaps) {
	if (_IsIndependentLaps) return Race::C_Sort_BestLapTime;
	return Race::C_Sort_BestRaceTime;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the right sort criteria for the ladder
Integer GetLadderSortCriteria(Boolean _IsIndependentLaps) {
	if (_IsIndependentLaps) return Scores::C_Sort_BestLapTime;
	return Scores::C_Sort_BestRaceTime;
}