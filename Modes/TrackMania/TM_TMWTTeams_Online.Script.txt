/**
 *	TrackMania World Tour - Teams mode
 */
#Extends "Modes/Nadeo/Trackmania/Base/TrackmaniaRoundsBase.Script.txt"

#Const CompatibleMapTypes	"TrackMania\\TM_Race,TM_Race"
#Const Version						"1.0.1+2023-09-25"
#Const ScriptName					"Modes/TrackMania/TM_TMWTTeams_Online.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/CMGame/Utils/Semver.Script.txt" as Semver
#Include "Libs/Nadeo/TMGame/Utils/Tracking.Script.txt" as Tracking
#Include "Libs/Nadeo/CMGame/Utils/Utils.Script.txt" as CommonUtils
#Include "Libs/Nadeo/Trackmania/Modes/Matchmaking.Script.txt" as Matchmaking
#Include "Libs/Nadeo/Trackmania/MainMenu/Constants.Script.txt" as MenuConst
#Include "Libs/Nadeo/Trackmania/Modes/TMWTTeams/StateManager.Script.txt" as StateMgr
#Include "Libs/Nadeo/Trackmania/Modes/TMWTCommon/Shared.Script.txt" as Shared
#Include "Libs/Nadeo/Trackmania/Modes/TMWTCommon/TMWTMarkers.Script.txt" as TMWTMarkers
#Include "Libs/Nadeo/Trackmania/Modes/TMWTCommon/Teams.Script.txt" as Teams
#Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/Checkpoint_Server.Script.txt" as UIModules_Checkpoint
#Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/Chrono_Server.Script.txt" as UIModules_Chrono
#Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/PauseMenuOnline_Server.Script.txt" as UIModules_PauseMenu_Online
#Include "Libs/Nadeo/Trackmania/Modes/TMWTCommon/UIModules/EventMessage_Server.Script.txt" as UIModules_EventMessage
#Include "Libs/Nadeo/Trackmania/Modes/TMWTCommon/UIModules/EventPoints_Server.Script.txt" as UIModules_EventPoints
#Include "Libs/Nadeo/Trackmania/Modes/TMWTCommon/UIModules/Header_Server.Script.txt" as UIModules_Header
#Include "Libs/Nadeo/Trackmania/Modes/TMWTCommon/UIModules/LiveRanking_Server.Script.txt" as UIModules_LiveRanking
#Include "Libs/Nadeo/Trackmania/Modes/TMWTCommon/UIModules/MapInfo_Server.Script.txt" as UIModules_MapInfo
#Include "Libs/Nadeo/Trackmania/Modes/TMWTTeams/UIModules/Sponsors_Server.Script.txt" as UIModules_Sponsors
#Include "Libs/Nadeo/Trackmania/Modes/TMWTCommon/UIModules/Sign2x3_Server.Script.txt" as UIModules_Sign2x3
#Include "Libs/Nadeo/Trackmania/Modes/TMWTCommon/UIModules/Sign16x9_Server.Script.txt" as UIModules_Sign16x9
#Include "Libs/Nadeo/Trackmania/Modes/TMWTCommon/UIModules/Sign64x10_Server.Script.txt" as UIModules_Sign64x10

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Settings
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Setting S_MapPointsLimit 10 as _("Track points limit")
#Setting S_MatchPointsLimit 4 as _("Match points limit")
#Setting S_FinishTimeout -1 as _("Finish timeout")
#Setting S_WarmUpNb 1	as _("Number of warm up")
#Setting S_WarmUpDuration 20 as _("Duration of one warm up")
#Setting S_WarmUpTimeout -1 as _("Warm up timeout")
#Setting S_MatchInfo "Trackmania Grand League" as _("Match info displayed in the UI")
#Setting S_TeamsUrl "" as _("Teams URL") //< URL where to get the teams info. Check `Teams::C_TeamUrl_XXX` for TMGL, TMCL and debug teams.
#Setting S_SponsorsUrl "file://Media/Manialinks/Nadeo/Trackmania/Modes/TMWT/UI/KAPORAL_512x80.dds" as _("Sponsors URL") //< URLs separated by a space "https://www.a.com/a.png file://Media/b.dds"
#Setting S_ForceRoadSpectatorsNb -1 as "<hidden>" //< Force the number of spectators displayed on the border of the road
#Setting S_EarlyEndMatchCallback True as "<hidden>"
#Setting S_EnableDossardColor True as "<hidden>"
#Setting S_IsMatchmaking False as "<hidden>" //< Enable matchmaking features
#Setting S_PickAndBan_Enable True
#Setting S_PickAndBan_Style """{
	"Background": "file://Media/Manialinks/Nadeo/Trackmania/Modes/TMWT/UI/TMWT_MatchIntroBackground.dds",
	"TopLeftLogo": "file://Media/Manialinks/Nadeo/Trackmania/Modes/TMWT/BrandsLogo/TMWT_Logo.dds",
	"TopRightLogo": "file://Media/Manialinks/Nadeo/Trackmania/Modes/TMWT/BrandsLogo/TMWT_TMGL.dds",
	"BottomLogo": "file://Media/Manialinks/Nadeo/Trackmania/Modes/TMWT/BrandsLogo/TMWT_Kaporal.dds"
}"""
#Setting S_ChatTime 600

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Structures
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Struct K_PreMatch {
	Integer RespawnBehaviour;
	Boolean RespawnAfter;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_ModeName "TrackMania World Tour - Teams"
//L16N [TrackMania World Tour - Teams] Description of the mode rules
#Const Description _("""Two teams compete in a series of races. The first team to reach the point limit wins the track. The first team to win enough tracks wins the match.""")

#Const C_HudModulePath "" //< Path to the hud module
#Const C_ManiaAppUrl "file://Media/ManiaApps/Nadeo/Trackmania/Modes/TMWTTeams.Script.txt" //< Url of the mania app
#Const C_FakeUsersNb_Clan1 0
#Const C_FakeUsersNb_Clan2 0
#Const C_ClansNb 2
#Const C_SignLiveCameraCheckInterval 5000
#Const C_UseEsportsProgrammation True
#Const C_DNF 0
#Const C_Debug_DisableIntro False

#Const C_Img_Sign2x3Default "file://Media/Manialinks/Nadeo/Trackmania/Modes/TMWT/Sign2x3/Default.dds"
#Const C_Img_Sign16x9Default "file://Media/Manialinks/Nadeo/Trackmania/Modes/TMWT/Sign16x9/TMWT_16x9.dds"
#Const C_Img_Sign64x10Default "file://Media/Manialinks/Nadeo/Trackmania/Modes/TMWT/Sign64x10/Default.dds"

#Const C_MatchIntroDuration 10000
#Const C_StartRoundMessageDuration 5000
#Const C_EndRoundSequenceDuration 6000
#Const C_EndMapSequenceDuration 5000

#Const C_Points_Ace 3
#Const C_Points_VictoryWin 2
#Const C_Points_VictoryLose 1
#Const C_Points_Draw 1

#Const C_UploadRecord True
#Const C_DisplayRecordGhost False
#Const C_DisplayRecordMedal False
#Const C_CelebrateRecordGhost False
#Const C_CelebrateRecordMedal False

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Extends
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
***Match_LogVersions***
***
Log::RegisterScript(ScriptName, Version);
Log::RegisterScript(Semver::ScriptName, Semver::Version);
Log::RegisterScript(Tracking::ScriptName, Tracking::Version);
Log::RegisterScript(CommonUtils::ScriptName, CommonUtils::Version);
Log::RegisterScript(Matchmaking::ScriptName, Matchmaking::Version);
Log::RegisterScript(MenuConst::ScriptName, MenuConst::Version);
Log::RegisterScript(StateMgr::ScriptName, StateMgr::Version);
Log::RegisterScript(Shared::ScriptName, Shared::Version);
Log::RegisterScript(TMWTMarkers::ScriptName, TMWTMarkers::Version);
Log::RegisterScript(Teams::ScriptName, Teams::Version);
Log::RegisterScript(UIModules_Checkpoint::ScriptName, UIModules_Checkpoint::Version);
Log::RegisterScript(UIModules_Chrono::ScriptName, UIModules_Chrono::Version);
Log::RegisterScript(UIModules_PauseMenu_Online::ScriptName, UIModules_PauseMenu_Online::Version);
Log::RegisterScript(UIModules_Header::ScriptName, UIModules_Header::Version);
Log::RegisterScript(UIModules_LiveRanking::ScriptName, UIModules_LiveRanking::Version);
Log::RegisterScript(UIModules_EventMessage::ScriptName, UIModules_EventMessage::Version);
Log::RegisterScript(UIModules_Sponsors::ScriptName, UIModules_Sponsors::Version);
Log::RegisterScript(UIModules_MapInfo::ScriptName, UIModules_MapInfo::Version);
Log::RegisterScript(UIModules_EventPoints::ScriptName, UIModules_EventPoints::Version);
***

***Match_LoadLibraries***
***
Matchmaking::Load();
TMWTMarkers::Load();
StateMgr::Load();
***

***Match_UnloadLibraries***
***
StateMgr::Unload();
TMWTMarkers::Unload();
Matchmaking::Unload();
***

***Match_Settings***
***
MB_Settings_UseDefaultHud = (C_HudModulePath == "");
MB_Settings_UseDefaultPodiumSequence = False;
***

***Match_Rules***
***
ModeInfo::SetName(C_ModeName);
ModeInfo::SetType(ModeInfo::C_Type_FreeForAll);
ModeInfo::SetRules(Description);
ModeInfo::SetStatusMessage("");
***

***Match_LoadHud***
***
if (C_HudModulePath != "") Hud_Load(C_HudModulePath);
***

***Match_AfterLoadHud***
***
ClientManiaAppUrl = C_ManiaAppUrl;
Race::SortScores(Race::C_Sort_TotalPoints);
WarmUp::SetVisibleFor(WarmUp::C_VisibleFor_PlayersOnly);
WarmUp::SetStartRoundMessage("");
UIModules_ScoresTable::SetScoreMode(UIModules_ScoresTable::C_Mode_Points);
UIModules_ScoresTable::SetHideSpectators(True);
UIModules_Checkpoint::SetVisibilityTimeDiff(False, True);
UIModules_Checkpoint::SetRankMode(UIModules_Checkpoint::C_RankMode_CurrentRace);
UIModules_Checkpoint::SetVisibleFor(UIModules_Checkpoint::C_Target_Players);
UIModules_Chrono::SetVisibleFor(UIModules_Chrono::C_VisibleFor_PlayersOnly);
UIModules_SpectatorBase::HidePlayerName(True);
UIModules_TimeGap::HideForSpectators(True);
UIModules_PauseMenu_Online::SetHelp(Description);
UIModules_EventMessage::TriggerEvent(UIModules_EventMessage::C_Type_Reset);
UIModules_Sign2x3::SetDefaultImageUrl(C_Img_Sign2x3Default);
UIModules_Sign16x9::SetDefaultImageUrl(C_Img_Sign16x9Default);
UIModules_Sign64x10::SetDefaultImageUrl(C_Img_Sign64x10Default);
UIModules_Sign16x9Small::SetDisplayMode(UIModules_Sign16x9Small::C_DisplayMode_Ranked);
UIModules_PickAndBan::SetMatchInfo(S_MatchInfo);
Shared::Initialize(This);
UpdateHeader(S_MatchPointsLimit, S_MapPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2), Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2), S_MatchInfo);

// Markers are handled by TMWTMarkers
UIManager.UIAll.AlliesLabelsVisibility = CUIConfig::ELabelsVisibility::Never;
UIManager.UIAll.TeamLabelsVisibility = CUIConfig::ELabelsVisibility::Never;
UIManager.UIAll.OpposingTeamLabelsVisibility = CUIConfig::ELabelsVisibility::Never;
***

***Match_Yield***
***
// Manage XmlRpc events
foreach (Event in XmlRpc.PendingEvents) {
	if (Event.Type == CXmlRpcEvent::EType::CallbackArray) {
		switch (Event.ParamArray1) {
			case Matchmaking::C_Method_MatchStarted: {
				declare Boolean Server_IsMatchmaking for This = S_IsMatchmaking;
				if (Server_IsMatchmaking) {
					declare Boolean Server_IsPreMatch for This = Server_IsMatchmaking;
					Server_IsPreMatch = False;
				}
			}
			case Matchmaking::C_Method_MatchCompleted: {
				declare Boolean Server_IsMatchmaking for This = S_IsMatchmaking;
				if (Server_IsMatchmaking) {
					declare Boolean Server_IsPreMatch for This = Server_IsMatchmaking;
					Server_IsPreMatch = True;
					Teams::ResetMatchmakingClans();
				}
			}
			case Matchmaking::C_Method_AddPlayer: {
				declare Boolean Server_IsMatchmaking for This = S_IsMatchmaking;
				if (Server_IsMatchmaking) {
					declare Matchmaking::K_Method_AddPlayer EventInfo = Matchmaking::GetEventInfo_Method_AddPlayer(Event);
					if (EventInfo.AccountId != "" && EventInfo.Clan > 0) {
						Teams::SetMatchmakingClan(EventInfo.AccountId, EventInfo.Clan);
						// Unspawn player to spawn them in the right team
						declare CSmPlayer Player = ModeUtils::GetPlayerFromAccountId(EventInfo.AccountId);
						if (Player != Null) {
							if (Player.CurrentClan != Teams::GetPlayerRequestedClan(Player, Server_IsMatchmaking)) {
								if (Race::IsRacing(Player)) Race::StopSkipOutro(Player);
								Teams::MovePlayerToRequestedClan(This, Player, Server_IsMatchmaking);
							}
							if (Player.Score != Null) {
								WarmUp::CanPlay(Player.Score, Teams::CanPlay(Player, Server_IsMatchmaking));
							}
						}
					}
				}
			}
			case Matchmaking::C_Method_RemovePlayer: {
				declare Boolean Server_IsMatchmaking for This = S_IsMatchmaking;
				if (Server_IsMatchmaking) {
					declare Text AccountId = Matchmaking::GetEventInfo_Method_RemovePlayer(Event);
					if (AccountId != "") {
						Teams::ResetMatchmakingClan(AccountId);
						// Unspawn player if they are not in a team anymore
						declare CSmPlayer Player = ModeUtils::GetPlayerFromAccountId(AccountId);
						if (Player != Null && Race::IsRacing(Player)) {
							Race::StopSkipOutro(Player);
						}
					}
				}
			}
		}
	}
}

foreach (Event in PendingEvents) {
	switch (Event.Type) {
		// Initialize players when they join the server
		case CSmModeEvent::EType::OnPlayerAdded: {
			StateMgr::InitializePlayer(Event.Player);
			CarRank::InitializePlayer(Event.Player);
			UIModules_LiveRanking::ForceUpdate();
			UIModules_ScoresTable::SetCustomNames(Teams::GetScoresTableNames(This));
			declare Boolean Server_IsMatchmaking for This = S_IsMatchmaking;
			Teams::SetPlayerClanOnJoin(This, Event.Player, Server_IsMatchmaking);

			if (Event.Player != Null) {
				// Enable the esports programmation in the signs
				// see: https://confluence.ubisoft.com/pages/viewpage.action?pageId=1366903390#
				declare CUIConfig UI <=> UIManager.GetUI(Event.Player);
				if (UI != Null && UI.DisplayControl_UseEsportsProgrammation != C_UseEsportsProgrammation) {
					UI.DisplayControl_UseEsportsProgrammation = C_UseEsportsProgrammation;
				}

				if (Event.Player.Score != Null) {
					WarmUp::CanPlay(Event.Player.Score, Teams::CanPlay(Event.Player, Server_IsMatchmaking));
				}
			}
		}
		case CSmModeEvent::EType::OnPlayerRemoved: {
			UIModules_LiveRanking::ForceUpdate();
		}
	}
}

// Force the number of spectators on the border of the road
if (S_ForceRoadSpectatorsNb >= 0) {
	declare Integer Server_ForceRoadSpectatorsNb for This = -1;
	if (Server_ForceRoadSpectatorsNb != S_ForceRoadSpectatorsNb) {
		Server_ForceRoadSpectatorsNb = S_ForceRoadSpectatorsNb;
		if (ServerAdmin != Null) ServerAdmin.SetViewerCount(Server_ForceRoadSpectatorsNb);
	}
}

// Enable automatic team selection until a point is scored in the match
declare Boolean Server_AutoSelectTeams for This = False;
if (Server_AutoSelectTeams) {
	Teams::AutoSelectTeams(This);
}

TMWTMarkers::Yield();
StateMgr::Yield();
***

***Match_InitServer***
***
declare Boolean Server_IsMatchmaking for This = S_IsMatchmaking;
declare Boolean Server_IsPreMatch for This = S_IsMatchmaking;
declare Boolean Server_AutoSelectTeams for This = False;

Server_IsMatchmaking = S_IsMatchmaking;
***

***Match_StartServer***
***
// Initialize mode
Clans::SetClansNb(C_ClansNb);
Scores::SaveInScore(Scores::C_Points_Match);
StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
WarmUp::SetAvailability(True);
WarmUp::SetSpawnInRequestedClan(False);
Race::UseAutomaticDossardColor(S_EnableDossardColor);
Race::SetRespawnBehaviour(Race::C_RespawnBehaviour_NeverGiveUp);
Race::SetupRecord(
	MenuConst::C_ScopeType_Season,
	MenuConst::C_ScopeType_PersonalBest,
	MenuConst::C_GameMode_TimeAttack,
	"",
	C_UploadRecord,
	C_DisplayRecordGhost,
	C_DisplayRecordMedal,
	C_CelebrateRecordGhost,
	C_CelebrateRecordMedal
);
***

***Match_InitMatch***
***
declare Integer Match_MapNb;
***

***Match_StartMatch***
***
Server_IsMatchmaking = S_IsMatchmaking;
Server_AutoSelectTeams = True;
Match_MapNb = 1;

Clans::SetUseForcedClans(Server_IsMatchmaking);
if (!Server_IsMatchmaking) {
	Teams::ResetMatchmakingClans();
}
***

***Match_InitMap***
***
declare Integer Map_RoundNb = 1;
declare Boolean Map_Skipped;
declare Teams::K_TeamsLoading TeamsLoading = Teams::C_TeamsLoading_Null;

UIModules_LiveRanking::ResetRace();
UIModules_Sponsors::SetSponsorsURL(S_SponsorsUrl);
UIModules_MapInfo::SetMatchProgression(Match_MapNb, Map_RoundNb, S_MatchPointsLimit);
UpdateHeader(S_MatchPointsLimit, S_MapPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2), Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2), S_MatchInfo);

if (Match_MapNb == 1) {
	TeamsLoading = Teams::LoadTeams(S_TeamsUrl);
}
***

***Match_StartMap***
***
// Add bot when necessary
Users_SetNbFakeUsers(C_FakeUsersNb_Clan1, C_FakeUsersNb_Clan2);

Map_Skipped = True;
CarRank::Reset();
EnableSignESportsMode(C_UseEsportsProgrammation);

// Wait end of teams loading
if (Match_MapNb == 1) {
	while (Teams::IsLoading(TeamsLoading)) {
		MB_Yield();
		TeamsLoading = Teams::UpdateLoading(TeamsLoading);
	}
	Teams::SetTeamsInfo(TeamsLoading.Teams);
	Teams::SelectTeams(This);
	UIModules_ScoresTable::SetCustomNames(Teams::GetScoresTableNames(This));
	// These logs are intended, do not remove them
	log("~~~~~~ Loaded teams JSON ~~~~~~");
	log(TeamsLoading.Teams.tojson());
	log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
}

// Wait for players
while (MB_MapIsRunning() && Players.count < 1) MB_Sleep(1000);

UpdateHeader(S_MatchPointsLimit, S_MapPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2), Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2), S_MatchInfo);

// Pre-match on Club competition system
if (Server_IsPreMatch) {
	declare K_PreMatch PreMatch = PreMatchStart(Server_IsMatchmaking);
	while (MB_MapIsRunning() && Server_IsPreMatch) {
		PreMatchLoop(Server_IsMatchmaking);
	}
	PreMatchEnd(PreMatch);
	UpdateHeader(S_MatchPointsLimit, S_MapPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2), Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2), S_MatchInfo);
}

// Match intro
if (Match_MapNb == 1 && !C_Debug_DisableIntro) {
	StateMgr::ForcePlayersStates([StateMgr::C_State_MatchIntro]);
	declare Integer MatchIntroEndTime = Now + C_MatchIntroDuration;
	while (MB_MapIsRunning() && Now < MatchIntroEndTime) {
		MB_Yield();
		foreach (Player in Players) {
			if (Player.CurrentClan != Teams::GetPlayerRequestedClan(Player, Server_IsMatchmaking)) {
				Teams::MovePlayerToRequestedClan(This, Player, Server_IsMatchmaking);
			}
		}
	}
	StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
}

// Warm up
UIModules_ScoresTable::SetFooterInfo(_("Warm up"));
EnableSignLiveCamera(True);
foreach (Score in Scores) {
	WarmUp::CanPlay(Score, True);
}
foreach (Player in AllPlayers) {
	WarmUp::CanPlay(Player.Score, Teams::CanPlay(Player, Server_IsMatchmaking));
}
//L16N [TrackMania World Tour - Teams] Message displayed at the end of the warm up, just before the race start.
MB_WarmUp(S_WarmUpNb, S_WarmUpDuration * 1000, S_WarmUpTimeout * 1000, TL::Compose("$i%1", _("Race starting")), False);
EnableSignLiveCamera(False);
UIModules_ScoresTable::SetFooterInfo("");
***

***Match_StartWarmUp***
***
TMWTMarkers::Enable();
UIModules_LiveRanking::ResetRace();
StateMgr::ForcePlayersStates([StateMgr::C_State_Playing]);
***

***Match_WarmUpLoop***
***
declare Boolean Server_IsMatchmaking for This = S_IsMatchmaking;
foreach (Player in Players) {
	if (Player.CurrentClan != Teams::GetPlayerRequestedClan(Player, Server_IsMatchmaking)) {
		Race::Wait(Player);
		Teams::MovePlayerToRequestedClan(This, Player, Server_IsMatchmaking);
	}
}
***

***Match_EndWarmUp***
***
StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
TMWTMarkers::Disable();
***

***Match_InitRound***
***
declare Integer Round_SignLiveCameraCheckTime;
***

***Rounds_StartPause***
***
MB_Race_EnablePlayMode(True);
UIModules_LiveRanking::ResetRace();
Shared::SetIsPause(This, True);
TMWTMarkers::Enable();
StateMgr::ForcePlayersStates([StateMgr::C_State_Playing]);
***

***Rounds_EndPause***
***
StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
TMWTMarkers::Disable();
Shared::SetIsPause(This, False);
MB_Race_EnablePlayMode(False);
***

***Match_StartRound***
***
// Enable live camera in 16/9 signs for spectators
Round_SignLiveCameraCheckTime = Now + C_SignLiveCameraCheckInterval;
EnableSignLiveCamera(True);
EnableSignESportsMode(C_UseEsportsProgrammation);

declare Integer Clan1MapPoints = Scores::GetClanMapPoints(1);
declare Integer Clan2MapPoints = Scores::GetClanMapPoints(2);
declare Integer Clan1MatchPoints = Scores::GetClanMatchPoints(1);
declare Integer Clan2MatchPoints = Scores::GetClanMatchPoints(2);
if (Clan1MapPoints >= S_MapPointsLimit && Clan2MapPoints >= S_MapPointsLimit) {
	UIModules_EventMessage::TriggerEvent(UIModules_EventMessage::C_Type_Overtime);
} else {
	declare Boolean Clan1TrackPoint = Clan1MapPoints >= S_MapPointsLimit - C_Points_Ace;
	declare Boolean Clan1MatchPoint = Clan1TrackPoint && Clan1MatchPoints >= S_MatchPointsLimit - 1;
	declare Boolean Clan2TrackPoint = Clan2MapPoints >= S_MapPointsLimit - C_Points_Ace;
	declare Boolean Clan2MatchPoint = Clan2TrackPoint && Clan2MatchPoints >= S_MatchPointsLimit - 1;
	if (Clan1MatchPoint && Clan2MatchPoint) {
		UIModules_EventMessage::TriggerEvent(UIModules_EventMessage::C_Type_MatchPoint);
	} else if (Clan1MatchPoint) {
		UIModules_EventMessage::TriggerEventForClan(UIModules_EventMessage::C_Type_MatchPoint, 1);
	} else if (Clan2MatchPoint) {
		UIModules_EventMessage::TriggerEventForClan(UIModules_EventMessage::C_Type_MatchPoint, 2);
	} else if (Clan1TrackPoint && Clan2TrackPoint) {
		UIModules_EventMessage::TriggerEvent(UIModules_EventMessage::C_Type_TrackPoint);
	} else if (Clan1TrackPoint) {
		UIModules_EventMessage::TriggerEventForClan(UIModules_EventMessage::C_Type_TrackPoint, 1);
	} else if (Clan2TrackPoint) {
		UIModules_EventMessage::TriggerEventForClan(UIModules_EventMessage::C_Type_TrackPoint, 2);
	}
}

TMWTMarkers::Enable();
UIModules_LiveRanking::ResetRace();
UIModules_Sponsors::SetSponsorsURL(S_SponsorsUrl);
UIModules_MapInfo::SetMatchProgression(Match_MapNb, Map_RoundNb, S_MatchPointsLimit);
StateMgr::ForcePlayersStates([StateMgr::C_State_Playing]);
UpdateHeader(S_MatchPointsLimit, S_MapPointsLimit, Clan1MatchPoints, Clan2MatchPoints, Clan1MapPoints, Clan2MapPoints, S_MatchInfo);
***

***Rounds_CheckCanSpawn***
***
declare Boolean Server_IsMatchmaking for This = S_IsMatchmaking;
if (!Teams::CanPlay(_Player, Server_IsMatchmaking)) return False;
***

***Rounds_SpawnPlayer***
***
Teams::MovePlayerToRequestedClan(This, Player, Server_IsMatchmaking);
Race::Start(Player, StartTime);
***

***Rounds_PlayerSpawned***
***
CarRank::ThrottleUpdate(CarRank::C_SortCriteria_CurrentRaceProgression);
***

***Match_PlayLoop***
***
// Manage race events
declare Events::K_RaceEvent[] RacePendingEvents = Race::GetPendingEvents();
foreach (Event in RacePendingEvents) {
	Race::ValidEvent(Event);

	// Waypoint
	if (Event.Type == Events::C_Type_Waypoint) {
		CarRank::ThrottleUpdate(CarRank::C_SortCriteria_CurrentRaceProgression);
		if (Event.Player != Null) {
			if (Event.IsEndRace) {
				Scores::UpdatePlayerBestRaceIfBetter(Event.Player);
				Scores::UpdatePlayerBestLapIfBetter(Event.Player);
				Scores::UpdatePlayerPrevRace(Event.Player);

				Race::StopSkipScoresTable(Event.Player);
				UIModules_LiveRanking::PlayerFinishRace(Event.Player);

				// Start the countdown if it's the first player to finish
				if (EndTime <= 0) {
					EndTime = Race::GetFinishTimeout(S_FinishTimeout, Race::GetLapsNb(), Map);
				}
			}
			if (Event.IsEndLap) {
				Scores::UpdatePlayerBestLapIfBetter(Event.Player);
			}
		}
	}
}

// Enable live camera in 16/9 signs for spectators
if (Round_SignLiveCameraCheckTime <= Now) {
	Round_SignLiveCameraCheckTime = Now + C_SignLiveCameraCheckInterval;
	EnableSignLiveCamera(True);
}

// Manage mode events
foreach (Event in PendingEvents) {
	if (Event.HasBeenPassed || Event.HasBeenDiscarded) continue;
	Events::Invalid(Event);
}
***

***Match_EndPlayLoop***
***
EnableSignLiveCamera(False);
TMWTMarkers::Disable();
***

***Match_EndRound***
***
Race::StopSkipOutroAll();
EndTime = -1;
StateMgr::ForcePlayersStates([StateMgr::C_State_EndRound]);
CarRank::Update(CarRank::C_SortCriteria_CurrentRaceProgression);
UpdateHeader(S_MatchPointsLimit, S_MapPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2), Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2), S_MatchInfo);

if (Semver::Compare(XmlRpc::GetApiVersion(), ">=", "2.1.1")) {
	Scores::XmlRpc_SendScores(Scores::C_Section_PreEndRound, "");
}

if (Round_ForceEndRound || Round_SkipPauseRound || Round_Skipped) {
	// Cancel points
	foreach (Score in Scores) {
		Scores::SetPlayerRoundPoints(Score, 0);
	}
	// Do not launch the forced end round sequence after a pause
	if (!Round_SkipPauseRound) {
		ForcedEndRoundSequence();
	}
	MB_SetValidRound(False);
} else {
	Map_RoundNb += 1;
	Server_AutoSelectTeams = False;
	GiveClansRacePoints(GetClansRaceRanking());
	Race::SortScores(Race::C_Sort_TotalPoints);
	UIModules_LiveRanking::ForceUpdate();
	UpdateHeader(S_MatchPointsLimit, S_MapPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2), Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2), S_MatchInfo);

	MB_Sleep(C_EndRoundSequenceDuration);

	if (MapIsOver(S_MapPointsLimit)) {
		Map_Skipped = False;
		MB_StopMap();
	}
}
StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);

// Wait for at least one player that can play before trying to start the next round
while (MB_MapIsRunning() && !HasAPlayerThatCanPlay(Server_IsMatchmaking)) {
	MB_Sleep(1000);
}
***

***Match_EndMap***
***
if (!Map_Skipped) {
	// Give a match point to the winning team
	if (Scores::GetClanMapPoints(1) > Scores::GetClanMapPoints(2)) {
		Scores::AddClanMatchPoints(1, 1);
		Scores::SetClanWinner(1);
	} else if (Scores::GetClanMapPoints(2) > Scores::GetClanMapPoints(1)) {
		Scores::AddClanMatchPoints(2, 1);
		Scores::SetClanWinner(2);
	}
	UpdateHeader(S_MatchPointsLimit, S_MapPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2), Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2), S_MatchInfo);

	Match_MapNb += 1;
} else {
	MB_SetValidMap(False);
}

if (MatchIsOver(S_MatchPointsLimit)) MB_StopMatch();

if (!MB_MatchIsRunning()) {
	declare Integer WinningTeam = -1;
	if (Scores::GetClanMatchPoints(1) > Scores::GetClanMatchPoints(2)) {
		WinningTeam = 1;
	} else if (Scores::GetClanMatchPoints(2) > Scores::GetClanMatchPoints(1)) {
		WinningTeam = 2;
	}
	Scores::SetClanWinner(WinningTeam);
	UIModules_Sign16x9Small::SetWinningClan(WinningTeam);

	foreach (Player in Players) {
		if (Player.CurrentClan == 1 || Player.CurrentClan == 2) {
			if (Player.CurrentClan == WinningTeam) {
				Tracking::SendPlayerMatchResult(UIManager, Player, 1, True);
			} else {
				Tracking::SendPlayerMatchResult(UIManager, Player, 2, False);
			}
		}
	}
}
***

***Match_BeforePodiumSequence***
***
// Send the EndMatch callback sooner to speed up the TMWT API update
if (S_EarlyEndMatchCallback && !MB_MatchIsRunning()) {
	Scores::EndMatch();
	Scores::XmlRpc_SendScores(Scores::C_Section_EndMatch, ""); //< send "Trackmania.Scores"
}

declare Integer WinningClan = Scores::GetClanWinner();
if (WinningClan == 1 || WinningClan == 2) {
	if (MB_MatchIsRunning()) {
		UIModules_EventMessage::TriggerEventForClan(UIModules_EventMessage::C_Type_TrackWin, WinningClan);
	} else {
		UIModules_EventMessage::TriggerEventForClan(UIModules_EventMessage::C_Type_MatchWin, WinningClan);
	}

	// Display random players from the winning team on the podium
	declare Text[] Logins;
	declare Text[Text] PlayersNames;
	foreach (Player in Players) {
		if (Player.CurrentClan == WinningClan && Player.User != Null) {
			Logins.add(Player.User.Login);
			PlayersNames[Player.User.WebServicesUserId] = Teams::GetPlayerName(Player.User);
		}
	}
	UIModules_Sign16x9Small::SetPlayersNames(PlayersNames);
	UIManager.UIAll.UISequence_PodiumPlayersWin = "";
	while (Logins.count > 0) {
		declare Integer Key = ML::Rand(0, Logins.count - 1);
		if (UIManager.UIAll.UISequence_PodiumPlayersWin == "") {
			UIManager.UIAll.UISequence_PodiumPlayersWin = Logins[Key];
		} else {
			UIManager.UIAll.UISequence_PodiumPlayersWin ^= ","^Logins[Key];
		}
		Logins.removekey(Key);
	}
}
***

***Match_PodiumSequence***
***
if (MB_MatchIsRunning()) {
	MB_Sleep(C_EndMapSequenceDuration);
} else {
	ModeUtils::PushAndApplyUISequence(UIManager.UIAll, CUIConfig::EUISequence::Podium);
	MB_Sleep(S_ChatTime * 1000);
	ModeUtils::PopAndApplyUISequence(UIManager.UIAll);
}
***

***Match_BeforeUnloadMap***
***
UIModules_EventMessage::TriggerEvent(UIModules_EventMessage::C_Type_Reset);
***

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Check if there is at least one player that can play
Boolean HasAPlayerThatCanPlay(Boolean _IsMatchmaking) {
	foreach (Player in Players) {
		if (Teams::CanPlay(Player, _IsMatchmaking)) return True;
	}
	return False;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the ranking of clans in the race
 *	The key is the rank and the value the clan
 *	So [1 => 1, 2 => 2, 3 => 2, 4 => 1] means clan 1 in first and fourth place,
 *	clan 2 in second and third place.
 */
Integer[Integer] GetClansRaceRanking() {
	declare Integer[][Ident] PlayerTimes;
	foreach (Score in Scores) {
		if (Scores::GetPlayerPrevRaceTime(Score) > 0) {
			PlayerTimes[Score.Id] = CommonUtils::ToScriptArray(Score.PrevRaceTimes);
		}
	}
	declare Ident[][Integer] SortedScoreIds = Scores::SortIdsByWaypointTimes(PlayerTimes);
	declare Integer[Integer] ClansRanking;
	foreach (ScoreIds in SortedScoreIds) {
		foreach (ScoreId in ScoreIds) {
			ClansRanking[ClansRanking.count + 1] = Scores[ScoreId].TeamNum;
		}
	}
	return ClansRanking;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Give points to the clans based on their rank in the race
Void GiveClansRacePoints(Integer[Integer] _ClansRaceRanking) {
	declare Integer FirstPlaceClan = _ClansRaceRanking.get(1, C_DNF);
	declare Integer SecondPlaceClan = _ClansRaceRanking.get(2, C_DNF);
	declare Integer ThirdPlaceClan = _ClansRaceRanking.get(3, C_DNF);

	if (FirstPlaceClan != C_DNF) {
		// Ace -> [A, A, B, B] - [A, A, B, DNF] - [A, A, DNF, DNF] - [A, DNF, DNF, DNF]
		if (FirstPlaceClan == SecondPlaceClan || SecondPlaceClan == C_DNF) {
			Scores::AddClanMapPoints(FirstPlaceClan, C_Points_Ace);
			UIModules_EventMessage::TriggerEventForClan(UIModules_EventMessage::C_Type_Ace, FirstPlaceClan);
		}
		// Victory [A, B, A, B] - [A, B, A, DNF] - [A, B, DNF, DNF]
		else if (FirstPlaceClan == ThirdPlaceClan || ThirdPlaceClan == C_DNF) {
			Scores::AddClanMapPoints(FirstPlaceClan, C_Points_VictoryWin);
			Scores::AddClanMapPoints(SecondPlaceClan, C_Points_VictoryLose);
			UIModules_EventMessage::TriggerEventForClan(UIModules_EventMessage::C_Type_Victory, FirstPlaceClan);
		}
		// Draw [A, B, B, A] - [A, B, B, DNF]
		else {
			Scores::AddClanMapPoints(FirstPlaceClan, C_Points_Draw);
			Scores::AddClanMapPoints(SecondPlaceClan, C_Points_Draw);
			UIModules_EventMessage::TriggerEvent(UIModules_EventMessage::C_Type_Draw);
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Check if a points limit is reached without a tie between the two clans
 *
 *	@param	_PointsLimit	The number of points to win a track
 *	@param	_Clan1Points	The number of points of clan 1
 *	@param	_Clan2Points	The number of points of clan 2
 *
 *	@return		True if it is the case, false otherwise
 */
Boolean PointsLimitReached(Integer _PointsLimit, Integer _Clan1Points, Integer _Clan2Points) {
	return (_Clan1Points != _Clan2Points && (_Clan1Points >= _PointsLimit || _Clan2Points >= _PointsLimit));
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Check if we should go to the next track
 *
 *	@param	_MapPointsLimit		The number of points to win a track
 *
 *	@return		True if it is the case, false otherwise
 */
Boolean MapIsOver(Integer _MapPointsLimit) {
	return PointsLimitReached(_MapPointsLimit, Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2));
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Check if we should go to the next match
 *
 *	@param	_MatchPointsLimit		The number of points to win a match
 *
 *	@return		True if it is the case, false otherwise
 */
Boolean MatchIsOver(Integer _MatchPointsLimit) {
	return PointsLimitReached(_MatchPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2));
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Start the pre-match
K_PreMatch PreMatchStart(Boolean _IsMatchmaking) {
	StateMgr::ForcePlayersStates([StateMgr::C_State_PreMatch]);
	Race::StopSkipOutroAll();
	MB_Yield();

	declare K_PreMatch PreMatch = K_PreMatch {
		RespawnBehaviour = Race::GetRespawnBehaviour(),
		RespawnAfter = GiveUpBehaviour_RespawnAfter
	};
	Race::SetRespawnBehaviour(Race::C_RespawnBehaviour_Normal);
	GiveUpBehaviour_RespawnAfter = True;

	MB_Race_EnablePlayMode(True);
	StartTime = Now + Race::C_SpawnDuration;
	EndTime = -1;

	foreach (Player in Players) {
		if (Race::IsReadyToStart(Player) && Teams::CanPlay(Player, _IsMatchmaking)) {
			Teams::MovePlayerToRequestedClan(This, Player, _IsMatchmaking);
			Race::Start(Player);
		}
	}

	return PreMatch;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Run the pre-match
Void PreMatchLoop(Boolean _IsMatchmaking) {
	MB_Yield();

	declare Events::K_RaceEvent[] RacePendingEvents = Race::GetPendingEvents();
	foreach (Event in RacePendingEvents) {
		Race::ValidEvent(Event);
		if (Event.Type == Events::C_Type_Waypoint && Event.IsEndRace) {
			// We do not need to see the scores table during the pre-match
			if (Event.Player != Null) Race::StopSkipScoresTable(Event.Player);
		}
	}
	foreach (Event in PendingEvents) {
		if (Event.HasBeenPassed || Event.HasBeenDiscarded) continue;
		Events::Invalid(Event);
	}

	foreach (Player in Players) {
		if (Player.CurrentClan != Teams::GetPlayerRequestedClan(Player, _IsMatchmaking)) {
			Race::Wait(Player);
		}
		if (Race::IsReadyToStart(Player) && Teams::CanPlay(Player, _IsMatchmaking)) {
			Teams::MovePlayerToRequestedClan(This, Player, _IsMatchmaking);
			Race::Start(Player);
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// End the pre-match
Void PreMatchEnd(K_PreMatch _PreMatch) {
	Race::StopSkipOutroAll();
	StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);

	MB_Race_EnablePlayMode(False);
	StartTime = -1;
	EndTime = -1;

	Race::SetRespawnBehaviour(_PreMatch.RespawnBehaviour);
	GiveUpBehaviour_RespawnAfter = _PreMatch.RespawnAfter;

	MB_Yield();
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Toggle on/off the live camera in 16/9 signs for spectators
Void EnableSignLiveCamera(Boolean _Enabled) {
	foreach (Spectator in Spectators) {
		declare CUIConfig UI <=> UIManager.GetUI(Spectator);
		if (UI != Null && UI.DisplayControl_UseLiveCamera != _Enabled) {
			UI.DisplayControl_UseLiveCamera = _Enabled;
		}
	}
	foreach (Player in Players) {
		declare CUIConfig UI <=> UIManager.GetUI(Player);
		if (UI != Null && UI.DisplayControl_UseLiveCamera) {
			UI.DisplayControl_UseLiveCamera = False;
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Enable the esports programmation in the signs
 *	see: https://confluence.ubisoft.com/pages/viewpage.action?pageId=1366903390#
 */
Void EnableSignESportsMode(Boolean _Enabled) {
	foreach (Player in AllPlayers) {
		declare CUIConfig UI <=> UIManager.GetUI(Player);
		if (UI != Null && UI.DisplayControl_UseEsportsProgrammation != _Enabled) {
			UI.DisplayControl_UseEsportsProgrammation = _Enabled;
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the info displayed in the header UI
Void UpdateHeader(
	Integer _MatchPointsLimit,
	Integer _MapPointsLimit,
	Integer _Clan1MatchPoints,
	Integer _Clan2MatchPoints,
	Integer _Clan1MapPoints,
	Integer _Clan2MapPoints,
	Text _MatchInfo
) {
	UIModules_Header::SetMatchPointsLimit(_MatchPointsLimit);
	UIModules_Header::SetMapPointsLimit(_MapPointsLimit);
	UIModules_Header::SetClansMatchPoints(_Clan1MatchPoints, _Clan2MatchPoints);
	UIModules_Header::SetClansMapPoints(_Clan1MapPoints, _Clan2MapPoints);
	UIModules_EventPoints::SetClansMapPoints(_Clan1MapPoints, _Clan2MapPoints);
	Shared::SetMatchInfo(This, _MatchInfo);
}