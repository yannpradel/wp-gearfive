/**
 *	Laps mode for OGL with Club API
 */
#Extends "Modes/TrackMania/TM_Laps_Online.Script.txt"

#Const C_LapsOGL_Version		"1.0.0+2022-08-05"
#Const C_LapsOGL_ScriptName	"Modes/TrackMania/Deprecated/TM_LapsOGL_Online.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/Trackmania/Modes/LapsOGL/StateManager.Script.txt" as LapsOGL_StateMgr
#Include "Libs/Nadeo/Trackmania/Modes/OGLCommon/OGLRequestManager.Script.txt" as RequestManager
#Include "Libs/Nadeo/Trackmania/Modes/LapsOGL/UIModules/EndMatchPopUp_Server.Script.txt" as UIModules_EndMatchPopUp
#Include "Libs/Nadeo/Trackmania/Modes/LapsOGL/UIModules/RulesPopUp_Server.Script.txt" as UIModules_RulesPopUp


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Settings
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Setting S_ChallengeId "124" as "<hidden>"
#Setting S_CompetitionId "LID-COMP-pc1clmkmph134tw" as "<hidden>"
#Setting S_RulesTimeLimit -1 as "<hidden>"
#Setting S_InfiniteLaps True
#Setting S_TimeLimit 180
#Setting S_ChallengeExtraWarmUpNb 1 as "<hidden>" // Club challenge plugin needs a TA warmup played only once while waiting for the challenge to start
#Setting S_ChallengeExtraWarmUpDuration 5 as "<hidden>"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_LapsOGL_ModeName "Laps"
//L16N [Laps] Description of the mode rules
#Const C_LapsOGL_Description _("$zIn $<$t$6F9Laps$> mode, the goal is to drive as far as possible by passing $<$t$6F9checkpoints$>.\n\nThe laps mode takes place on multilap (cyclical) tracks, and is played in one go for every track.\n\nWhen the time is up, the $<$t$6F9winner$> is the player who passed the most $<$t$6F9checkpoints$>. In case of draws, the winner is the player who passed the last checkpoint first.")
#Const C_LapsOGL_ManiaAppUrl "file://Media/ManiaApps/Nadeo/Trackmania/Modes/LapsOGL.Script.txt" //< Url of the mania app

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Extends
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
***Match_LogVersions***
***
Log::RegisterScript(C_LapsOGL_ScriptName, C_LapsOGL_Version);
Log::RegisterScript(LapsOGL_StateMgr::ScriptName, LapsOGL_StateMgr::Version);
***

***Match_LoadLibraries***
***
LapsOGL_StateMgr::Load();
***

***Match_UnloadLibraries***
***
LapsOGL_StateMgr::Unload();
***

***Match_Settings***
***
Laps_Settings_EndMatchIfAllPlayersUnspawned = False;
***

***Match_Rules***
***
ModeInfo::SetName(C_LapsOGL_ModeName);
ModeInfo::SetRules(C_LapsOGL_Description);
***

***Match_AfterLoadHud***
***
ClientManiaAppUrl = C_LapsOGL_ManiaAppUrl;
***

***Match_Yield***
***
// Apply Laps_StateMgr states to LapsOGL_StateMgr
if (
	StateMgr::GetForcedStates().count != LapsOGL_StateMgr::GetForcedStates().count ||
	!StateMgr::GetForcedStates().containsonly(LapsOGL_StateMgr::GetForcedStates()) ||
	!LapsOGL_StateMgr::GetForcedStates().containsonly(StateMgr::GetForcedStates())
) {
	LapsOGL_StateMgr::ForcePlayersStates(StateMgr::GetForcedStates());
}
LapsOGL_StateMgr::Yield();

foreach (Event in XmlRpc.PendingEvents) {
	if (Event.ParamArray1 == "Challenge.Completed") {
		log("Received Challenge.Completed event. "); // Do not remove please
		declare Boolean Server_LapsOGL_ChallengeIsOver for This;
		Server_LapsOGL_ChallengeIsOver = True;
		MB_Settings_UseDefaultIntroSequence = False;
		RequestManager::ListenToChallengeStatus();
	}
}
foreach (Event in PendingEvents) {
	// ~~~~~~~~~~~~~~~~~~ //
	// Player connection
	if (Event.Type == CSmModeEvent::EType::OnPlayerAdded) {
		declare Boolean Server_LapsOGL_ChallengeIsOver for This;
		if (Event.Player != Null && Server_LapsOGL_ChallengeIsOver) RequestManager::RequestResults([Event.Player.User.WebServicesUserId]);
		LapsOGL_StateMgr::ForcePlayersStates(StateMgr::GetForcedStates());
	}
}
RequestManager::Yield();
***

***Match_InitServer***
***
declare Boolean Server_LapsOGL_ChallengeIsOver for This;
declare Boolean Server_LapsOGL_NeedChallengeWarmup for This = True;
***

***Match_StartServer***
***
RequestManager::Init(S_ChallengeId, S_CompetitionId);
SendTimeLimitToRulesPopUp(S_TimeLimit, S_RulesTimeLimit);
***

***Match_InitMap***
***
UIModules_EndMatchPopUp::SetMapsInfoFromMapList();

declare Integer Map_RulesTimeLimit;
declare Integer Map_LapsTimeLimit;
***

***Laps_Warmup***
***
// Check if challenge is over
if (Server_LapsOGL_ChallengeIsOver) {
	Race::StopSkipOutroAll();
	StateMgr::ForcePlayersStates([LibLaps_Constants::C_State_EndMatch]);
	MB_Sleep(900000);
}

// otherwise start warmup
Race::SetRespawnBehaviour(Race::C_RespawnBehaviour_Normal);
if (Server_LapsOGL_NeedChallengeWarmup) {
	Server_LapsOGL_NeedChallengeWarmup = False;
	MB_WarmUp(S_ChallengeExtraWarmUpNb, S_ChallengeExtraWarmUpDuration * 1000);
}
MB_WarmUp(S_WarmUpNb, S_WarmUpDuration * 1000, S_WarmUpTimeout * 1000);
***

***Match_StartMap***
***
Map_LapsTimeLimit = S_TimeLimit;
Map_RulesTimeLimit = S_RulesTimeLimit;
SendTimeLimitToRulesPopUp(S_TimeLimit, S_RulesTimeLimit);
***

***Match_PlayLoop***
***
if (Server_LapsOGL_ChallengeIsOver) MB_StopMatch();

// Update the map duration setting
if (Map_LapsTimeLimit != S_TimeLimit || Map_RulesTimeLimit != S_RulesTimeLimit) {
	Map_LapsTimeLimit = S_TimeLimit;
	Map_RulesTimeLimit = S_RulesTimeLimit;
	SendTimeLimitToRulesPopUp(S_TimeLimit, S_RulesTimeLimit);
}
***

***Match_EndMap***
***
/// Send Results to challenge plugin ///
// First, caclulate the max length of a player time at Checkpoint
declare Integer MaxTimeLength;
if (S_TimeLimit > 0) {
	MaxTimeLength = TL::Length(""^ S_TimeLimit) + 3; // Time limit in seconds + 3 for ms
} else {
	declare ObjectiveNbLaps = Map.TMObjective_NbLaps;
	if (ObjectiveNbLaps <= 0) ObjectiveNbLaps = 1;
	declare TimePerLap = ML::NearestInteger((Map.TMObjective_BronzeTime + (Map.TMObjective_BronzeTime * 0.1)) / ObjectiveNbLaps);
	MaxTimeLength = TL::Length(""^ (TimePerLap * Race::GetLapsNb()));
}
// Set players score
log("XMLRPC SEND SCORES\n******"); // Do not remove please
foreach(Score in Scores) {
	declare Integer Callback_Points = 0;
	if (Score.BestRaceTimes.count > 0) {
		declare Integer Callback_CpCount = Score.BestRaceTimes.count;
		declare Integer Callback_CpCountCoefficient = ML::NearestInteger(ML::Pow(10., MaxTimeLength*1.));
		Callback_Points = (Callback_CpCount+1) * Callback_CpCountCoefficient - 1 - Score.BestRaceTimes[Score.BestRaceTimes.count-1];
	}
	Scores::SetPlayerMatchPoints(Score, Callback_Points);
	log(Score.User.WebServicesUserId ^": "^Callback_Points^" points"); // Do not remove please
}
Scores::EndMatch();
Scores::XmlRpc_SendScores(Scores::C_Section_EndMatch, "");
log("******"); // Do not remove please
***

***Match_AfterPodiumSequence***
***
if (Server_LapsOGL_ChallengeIsOver) {
	StateMgr::ForcePlayersStates([LibLaps_Constants::C_State_EndMatch]);
	MB_Sleep(900000);
}
***

Void SendTimeLimitToRulesPopUp(Integer _LapsTimeLimit, Integer _RulesTimeLimit) {
	declare Integer TimeLimit = _RulesTimeLimit;
	if (TimeLimit <= 0) TimeLimit = _LapsTimeLimit;
	UIModules_RulesPopUp::SetTimeLimit(TimeLimit);
}