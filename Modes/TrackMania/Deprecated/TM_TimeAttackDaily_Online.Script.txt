/**
 *	Time Attack Daily mode
 *	This mode is not used anymore in Cup of The Day
 *	It was replaced by TM_COTDQualifications_Online.Script.txt
 */
#Extends "Modes/Nadeo/Trackmania/Base/TrackmaniaBase.Script.txt"

#Const	CompatibleMapTypes	"TrackMania\\TM_Race,TM_Race"
#Const	Version							"1.0.1+2023-09-01"
#Const	ScriptName					"Modes/TrackMania/TM_TimeAttackDaily_Online.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "TimeLib" as TiL
#Include "Libs/Nadeo/CMGame/Utils/Task.Script.txt" as Task
#Include "Libs/Nadeo/Trackmania/Modes/TimeAttackDaily/StateManager.Script.txt" as StateMgr
#Include "Libs/Nadeo/Trackmania/Modes/TrophyRanking.Script.txt" as TrophyRanking
#Include "Libs/Nadeo/Trackmania/MainMenu/Constants.Script.txt" as MenuConsts
#Include "Libs/Nadeo/TMGame/Utils/Tracking.Script.txt" as Tracking
// UI from Race
#Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/TimeGap_Server.Script.txt" as UIModules_TimeGap
#Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/Checkpoint_Server.Script.txt" as UIModules_Checkpoint
#Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/PauseMenuOnline_Server.Script.txt" as UIModules_PauseMenu_Online
#Include "Libs/Nadeo/Trackmania/Modes/TimeAttack/UIModules/EndMatchTrophy_Server.Script.txt" as UIModules_EndMatchTrophy

#Include "Libs/Nadeo/Trackmania/Modes/TimeAttackDaily/DailyRequestManager.Script.txt" as RequestManager
#Include "Libs/Nadeo/Trackmania/Modes/TimeAttackDaily/DailyStructs.Script.txt" as DailyStructs
#Include "Libs/Nadeo/Trackmania/Modes/TimeAttackDaily/UIModules/DailyTrackerTA_Server.Script.txt" as UIModules_DailyTracker
#Include "Libs/Nadeo/Trackmania/Modes/TimeAttackDaily/UIModules/NextMatchTracker_Server.Script.txt" as UIModules_NextMatchTracker
#Include "Libs/Nadeo/Trackmania/Modes/TimeAttackDaily/UIModules/NetShare_Server.Script.txt" as UIModules_NetShare
#Include "Libs/Nadeo/Trackmania/Modes/TimeAttackDaily/Constants.Script.txt" as Constants
#Include "Libs/Nadeo/Trackmania/Modes/TimeAttackDaily/CupState.Script.txt" as CupState
#Include "Libs/Nadeo/Trackmania/Modes/TimeAttackDaily/Logs.Script.txt" as DailyLogs

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Settings
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Setting S_WarmUpNb 0 as _("Number of warm up")
#Setting S_WarmUpDuration 0 as _("Duration of one warm up")
#Setting S_WarmUpTimeout -1 as _("Warm up timeout")
#Setting S_ForceLapsNb 0
#Setting S_BasicAuthHeader "Basic xxx" as "<hidden>"
#Setting S_ScriptEnvironment "production" ///< "development", "test", "production"
#Setting S_LogLevel 3 ///< 3 debug, 2 info, 1 error, 0 none. Should be 1 by default.
#Setting S_RankedCompetitionType ""
#Setting S_PlayerPartition "" //< Players partition on servers (crossplay or not) see: /trackmania-next/tmnext/-/issues/4938

// DO NOT MODIFY the following settings without updating Knockout server generaton time on API.
#Setting S_TimeLimit 900 as _("Time limit") ///< Time limit (s) for the qualifications
#Setting S_IntroMaxDuration 15 as "<hidden>"
#Setting S_QualificationsEndTime_MinMargin 30000 // Time (ms) before matches_generation_date to stop the match
//

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_ModeName "Time Attack Daily"
//L16N [Time Attack] Description of the mode rules
#Const Description _("$zIn $<$t$6F9Time Attack$> mode, the goal is to set the $<$t$6F9best time$>.\n\nYou have as many tries as you want, and you can $<$t$6F9retry$> when you want by pressing the respawn button.\n\nWhen the time is up, the $<$t$6F9winner$> is the player with the $<$t$6F9best time$>.")

#Const C_HudModulePath "" //< Path to the hud module
#Const C_ManiaAppUrl "file://Media/ManiaApps/Nadeo/Trackmania/Modes/TimeAttackDaily.Script.txt" //< Url of the mania app
#Const C_FakeUsersNb 0

#Const C_UploadRecord True
#Const C_DisplayRecordGhost True
#Const C_DisplayRecordMedal True
#Const C_CelebrateRecordGhost True
#Const C_CelebrateRecordMedal True
#Const C_DisplayWorldTop False

#Const C_TrophyTaskTimeout 5000
#Const C_TrophyAnimationDuration 4000
#Const C_TrophyDisplayDuration 7000

#Const C_FakeCup False
#Const C_DebugJoinMatchAccountIds [""]
#Const C_GatherMatchData True
#Const C_LogUnprocessedEvents_Frenquency 1000

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Extends
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
***Match_LogVersions***
***
Log::RegisterScript(ScriptName, Version);
Log::RegisterScript(StateMgr::ScriptName, StateMgr::Version);
***

***Match_LoadLibraries***
***
StateMgr::Load();
***

***Match_UnloadLibraries***
***
StateMgr::Unload();
***

***Match_Settings***
***
MB_Settings_UseDefaultTimer = False;
MB_Settings_UseDefaultHud = (C_HudModulePath == "");
MB_Settings_UseDefaultPodiumSequence = False;
***

***Match_Rules***
***
ModeInfo::SetName(C_ModeName);
ModeInfo::SetType(ModeInfo::C_Type_FreeForAll);
ModeInfo::SetRules(Description);
ModeInfo::SetStatusMessage(_("TYPE: Free for all\nOBJECTIVE: Set the best time on the track."));
***

***Match_LoadHud***
***
if (C_HudModulePath != "") Hud_Load(C_HudModulePath);
***

***Match_AfterLoadHud***
***
UIManager.UIAll.ScoreTableOnlyManialink = True;
if (C_HudModulePath != "") Hud_Load(C_HudModulePath);
UIModules_Checkpoint::SetRankMode(UIModules_Checkpoint::C_RankMode_BestRace);
ClientManiaAppUrl = C_ManiaAppUrl;
Race::SortScores(GetScoresSortCriteria());
UIModules_TimeGap::SetTimeGapMode(UIModules_TimeGap::C_TimeGapMode_BestRace);
UIModules_PauseMenu_Online::SetHelp(Description);
UIModules_Sign16x9Small::SetScoreMode(UIModules_Sign16x9Small::C_ScoreMode_BestRaceTime);
UIManager.UIAll.OverlayHideCountdown = True;
UIManager.UIAll.OverlayHideSpectatorInfos = True;
UIManager.UISequenceMaxDuration = S_IntroMaxDuration*1000 - 1500; // -1500 for first 321go

DailyLogs::SetLogLevel(S_LogLevel);
***

***Match_Yield***
***
declare Integer Server_CupState for This = Constants::C_TimeAttackDaily_CupState_None;
declare Integer Server_QualificationsEndTime for This = -1;

foreach (Event in PendingEvents) {
	switch (Event.Type) {
		// Initialize players when they join the server
		case CSmModeEvent::EType::OnPlayerAdded: {
			StateMgr::InitializePlayer(Event.Player);
			CarRank::InitializePlayer(Event.Player);
			if (Event.Player != Null) {
				declare Boolean Match_CanForceTrophyRankUpdate for This;
				TrophyRanking::InitializeUser(Event.Player.User, Match_CanForceTrophyRankUpdate);
				RequestManager::CheckPlayerRegistration(Event.Player.User.WebServicesUserId);
			}
		}
	}
}

declare Integer LogUnprocessedEventsTime for This = Now;
if (LogUnprocessedEventsTime > 0 && LogUnprocessedEventsTime <= Now) {
	LogUnprocessedEventsTime = Now + C_LogUnprocessedEvents_Frenquency;
	declare RacePendingEvents = Race::GetPendingEvents();
	if (RacePendingEvents.count > 0) {
		DailyLogs::LogDebug("Unprocessed race waypoint events: ");
		foreach (Event in RacePendingEvents) {
			if (Event.Type == Events::C_Type_Waypoint) {
				if (Event.IsEndRace) {
					declare TextToLog = "    ";
					if (Event.Player != Null) {
						TextToLog ^= Event.Player.User.Name^" ("^Event.Player.User.WebServicesUserId^") has unprocessed EndRaceEvent with RaceWaypointTimes: "^Event.Player.RaceWaypointTimes;
					} else {
						TextToLog ^= "Null player EndRace event";
					}
					DailyLogs::LogDebug(TextToLog, False);
				}
			}
		}
	}
}

if (Server_CupState > Constants::C_TimeAttackDaily_CupState_NotStarted) {
	Server_CupState = CupState::SetCupState(Server_CupState, Server_QualificationsEndTime);
}

StateMgr::Yield();
TrophyRanking::Yield();
RequestManager::Yield();
***

***Match_InitServer***
***
declare Integer Server_CupState for This;
declare Integer Server_QualificationsEndTime for This;
declare Boolean Server_QualificationsStopped;
***

***Match_StartServer***
***
// Initialize mode
Server_QualificationsStopped = False;
Clans::SetClansNb(0);
GiveUpBehaviour_RespawnAfter = True;
CrudeExtrapolation_AllowDelay = True;
Race::SetRespawnBehaviour(Race::C_RespawnBehaviour_GiveUpBeforeFirstCheckpoint);
StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
WarmUp::SetAvailability(True);
Race::SetupRecord(
	MenuConsts::C_ScopeType_Season,
	MenuConsts::C_ScopeType_PersonalBest,
	MenuConsts::C_GameMode_TimeAttack,
	"",
	C_UploadRecord,
	C_DisplayRecordGhost,
	C_DisplayRecordMedal,
	C_CelebrateRecordGhost,
	C_CelebrateRecordMedal,
	C_DisplayWorldTop

);
CarRank::Reset();

//Initialize daily
RequestManager::Init(S_BasicAuthHeader, S_IntroMaxDuration, S_TimeLimit, S_QualificationsEndTime_MinMargin, C_FakeCup);
Server_CupState = Constants::C_TimeAttackDaily_CupState_None;
UIModules_Record::SetSpecialVisibility(False);
UIModules_NetShare::SetCupState(Server_CupState);
UIModules_NextMatchTracker::CanDisplayPopUp(False);
Server_QualificationsEndTime = -1;
***

***Match_InitMatch***
***
declare Task::K_Task Match_TrophyTask;
declare Integer Match_TrophyTaskEndTime;
declare Integer Match_MatchDuration;
declare Boolean Match_CanForceTrophyRankUpdate for This = False;
***

***Match_AfterLoadMap***
***
Match_CanForceTrophyRankUpdate = True;
***

***Match_InitMap***
***
declare Integer Map_TimeLimit;

if (C_FakeCup && C_DebugJoinMatchAccountIds.count > 0 && C_DebugJoinMatchAccountIds[0] != "") {
	UIModules_NextMatchTracker::CanDisplayPopUp(True);
	UIModules_NextMatchTracker::SetRegistrationsEndTime(Now);
	//UIModules_NextMatchTracker::SetAutoJoinTime(Now + Constants::C_TimeAttackDaily_AutoJoinDelay);
	declare Boolean[Text] Registrations;
	declare DailyStructs::K_Result[Text] PlayerResults;
	declare Text[Text] Joinlinks;
	foreach (Key => AccountId in C_DebugJoinMatchAccountIds) {
		Registrations[AccountId] = True;
		PlayerResults[AccountId] = DailyStructs::K_Result { Rank = Key + 1, BestTime = (Key + 1) * 1000, WaitingForNewRank = False };
		Joinlinks[AccountId] = "#join=127.0.0.1::2350";
	}
	UIModules_NextMatchTracker::ConfirmRegistrations(Registrations);
	UIModules_NetShare::SetPlayerResults(PlayerResults);
	UIModules_NetShare::SetCupState(Constants::C_TimeAttackDaily_CupState_WaitingForMatch);
	RequestManager::SendJoinlinks(Joinlinks);
	MB_Sleep(120000);
}

// Yield until cup status is known and started
if (Server_CupState <= Constants::C_TimeAttackDaily_CupState_NotStarted) {
	UIModules_NextMatchTracker::SetCompetitionType(S_RankedCompetitionType);
	RequestManager::SetCompetitionType(S_RankedCompetitionType);
	RequestManager::SetPlayerPartition(S_PlayerPartition);
	UIManager.UIAll.SpectatorForceCameraType = 0;
	UIManager.UIAll.Spectator_SetForcedTarget_Landmark(Map::GetStart());
	RequestManager::ListenToMatchStatus(True);
	declare MatchStartDate = "";
	while (
		MatchStartDate == "" ||
		TiL::GetDelta(MatchStartDate, TiL::GetCurrent()) > 0
	) {
		MB_Yield();
		if (MatchStartDate == "") {
			MatchStartDate = RequestManager::MatchStartDate();
			if (MatchStartDate != "") {
				UIModules_NextMatchTracker::SetMatchStartTime(RequestManager::MatchStartTime());
				Server_CupState = Constants::C_TimeAttackDaily_CupState_NotStarted;
				UIModules_NetShare::SetCupState(Server_CupState);
			}
		}
	}
	Server_QualificationsEndTime = RequestManager::QualificationsEndTime();
	Server_CupState = CupState::SetCupState(Server_CupState, Server_QualificationsEndTime);
	Server_QualificationsStopped = Server_CupState > Constants::C_TimeAttackDaily_CupState_Qualifications;

	UIModules_NextMatchTracker::SetRegistrationsEndTime(Server_QualificationsEndTime - Constants::C_TimeAttackDaily_RegistrationEndDelay);
	UIModules_NextMatchTracker::SetAutoJoinTime(Server_QualificationsEndTime + Constants::C_TimeAttackDaily_AutoJoinDelay);
	UIModules_NetShare::SetCupState(Server_CupState);
	RequestManager::ListenToMatchStatus(False);
	UIManager.UIAll.SpectatorForceCameraType = 15;
	UIManager.UIAll.Spectator_SetForcedTarget_Clear();
}

UIModules_NextMatchTracker::CanDisplayPopUp(Server_QualificationsStopped);
***

***Match_StartMap***
***
// Add bot when necessary
Users_SetNbFakeUsers(C_FakeUsersNb, 0);

// Warm up
UIModules_ScoresTable::SetFooterInfo(_("Warmup"));
GiveUpBehaviour_RespawnAfter = False;
MB_WarmUp(S_WarmUpNb, S_WarmUpDuration * 1000, S_WarmUpTimeout * 1000);
GiveUpBehaviour_RespawnAfter = True;

// Initialize race
SetScoresTableScoreMode(Race::IsIndependentLaps(), False);

RequestManager::SetCurrentMapUid(Map.MapInfo.MapUid);
***

***Match_InitRound***
***
declare Integer Round_MapStartTime;
***

***Match_StartRound***
***
// Initialize round
StartTime = Now + Race::C_SpawnDuration;
Map_TimeLimit = S_TimeLimit;
Round_MapStartTime = StartTime;
SetTimeLimit(StartTime, S_TimeLimit);

// Spawn players for the race
foreach (Player in Players) {
	Race::Start(Player, StartTime);
}

StateMgr::ForcePlayersStates([StateMgr::C_State_Playing]);
CarRank::Update(CarRank::C_SortCriteria_BestRace);
Race::EnableIntroDuringMatch(True);
if (Server_CupState == Constants::C_TimeAttackDaily_CupState_Qualifications) RequestManager::SetEndTime(EndTime);
UIModules_NextMatchTracker::CanDisplayPopUp(Server_QualificationsStopped);
***

***Match_PlayLoop***
***
// Manage race events
declare RacePendingEvents = Race::GetPendingEvents();
foreach (Event in RacePendingEvents) {
	Race::ValidEvent(Event);
	// Waypoint
	if (Event.Type == Events::C_Type_Waypoint) {
		if (Event.Player != Null) {
			declare Better = False;
			declare OldRank = 0;
			if (Event.IsEndRace) {
				// Check player registration
				if (
					Server_CupState == Constants::C_TimeAttackDaily_CupState_Qualifications &&
					Event.Player != Null
				) {
					UIModules_NextMatchTracker::AddRegisteredPlayersZones(Event.Player.Id);
				}

				// Computes old rank before changing Score
				foreach (Index => Score in Scores) {
					if (Score.Id == Event.Player.Score.Id) {
						if (Score.BestRaceTimes.count != 0) {
							OldRank = Index + 1;
						} else {
							OldRank = -123;
						}
						break;
					}
				}
				// Change Score
				Better = Scores::UpdatePlayerBestRaceIfBetter(Event.Player);
				DailyLogs::LogPlayerEndRaceResult(Event.Player, Better);
				declare BetterLap = Scores::UpdatePlayerBestLapIfBetter(Event.Player);
				Scores::UpdatePlayerPrevRace(Event.Player);
				Race::SortScores(GetScoresSortCriteria());
				if (
					Better &&
					Event.Player != Null &&
					Event.Player.Score != Null &&
					Event.Player.Score.BestRaceTimes.count > 0 &&
					(
						Server_CupState == Constants::C_TimeAttackDaily_CupState_Qualifications ||
						Server_CupState == Constants::C_TimeAttackDaily_CupState_RegistrationsOver
					)
				) {
					RequestManager::PostBetterResult(Event.Player.Score);
				}
			} else if (Event.IsEndLap) {
				declare BetterLap = Scores::UpdatePlayerBestLapIfBetter(Event.Player);
				if (Race::IsIndependentLaps()) {
					// Computes old rank before changing Score
					foreach (Index => Score in Scores) {
						if (Score.Id == Event.Player.Score.Id) {
							if (Score.BestLapTimes.count != 0) {
								OldRank = Index + 1;
							} else {
								OldRank = -123;
							}
							break;
						}
					}
					// Change Score
					Better = BetterLap;
					if (Better) Scores::UpdatePlayerBestRace(Event.Player);
					Scores::UpdatePlayerPrevLap(Event.Player);
				}
				Race::SortScores(GetScoresSortCriteria());
			}
			if (Better) {
				declare NewRank = 0;
				foreach (Index => Score in Scores) {
					if (Score.Id == Event.Player.Score.Id) {
						NewRank = Index + 1;
						break;
					}
				}
				if (OldRank != NewRank) {
					if (0 < NewRank && NewRank < 4) {
						foreach (Player in AllPlayers) {
							UIModules_DisplayMessage::SendLiveMessage_RankUpdate(Player, Event.Player.User, NewRank);
						}
					} else if (0 < NewRank) {
						UIModules_DisplayMessage::SendLiveMessage_RankUpdate(Event.Player, Event.Player.User, NewRank);
					}
				}

				CarRank::ThrottleUpdate(CarRank::C_SortCriteria_BestRace);
			}
		}
	}
}

// Manage mode events
foreach (Event in PendingEvents) {
	if (Event.HasBeenPassed || Event.HasBeenDiscarded) continue;
	Events::Invalid(Event);
}

// Spawn players
if (PlayersNbDead > 0) { //< Check for unspawned players only if at least one player is unspawned
	foreach (Player in Players) {
		if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && Race::IsReadyToStart(Player)) {
			Race::Start(Player);
		}
	}
}

// Update the map duration setting
if (Map_TimeLimit != S_TimeLimit) {
	Map_TimeLimit = S_TimeLimit;
	SetTimeLimit(StartTime, S_TimeLimit);
}

// End the race when time limit is reached
if (EndTime > 0 && Now >= EndTime) {
	if (Server_QualificationsStopped) {
		MB_StopMatch();
	} else {
		Server_QualificationsStopped = True;
		MB_StopRound();
	}
}

if (
	Server_CupState == Constants::C_TimeAttackDaily_CupState_Qualifications &&
	Server_QualificationsEndTime > 0 &&
	EndTime > 0 &&
	EndTime > Server_QualificationsEndTime
) {
	EndTime = Server_QualificationsEndTime;
	RequestManager::SetEndTime(EndTime);
}
***

***Match_EndRound***
***
EndTime = -1;
Match_MatchDuration = ML::Max(0, Now - Round_MapStartTime);
StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
Race::EnableIntroDuringMatch(False);

Race::SortScores(GetScoresSortCriteria());
TrophyRanking::UpdateUsersRank();
CarRank::Update(CarRank::C_SortCriteria_BestRace);
declare CSmScore Winner <=> Scores::GetBestPlayer(GetLadderSortCriteria());
Scores::SetPlayerWinner(Winner);
Race::StopSkipOutroAll();
UIModules_NextMatchTracker::ResetButtonClicked();

// Compute ranking for tracking
declare Integer PreviousRaceTime = 0;
declare Integer Rank = 0;
foreach (Key => Score in Scores) {
	declare Integer BestRaceTime = Scores::GetPlayerBestRaceTime(Score);
	if (
		Key == 0 || (
			BestRaceTime > 0 &&
			PreviousRaceTime < BestRaceTime
		) || (
			PreviousRaceTime > 0 &&
			BestRaceTime <= 0
		)
	) {
		PreviousRaceTime = BestRaceTime;
		Rank = Key + 1;
	}
	Tracking::SendPlayerMatchResult(UIManager, Score.User, Rank, Winner == Score && Scores.count > 1 && BestRaceTime > 0);
}

+++Round_BeforePodiumSequence+++
+++Round_PodiumSequence+++
+++Round_AfterPodiumSequence+++
***

***Round_BeforePodiumSequence***
***
ModeUtils::PlaySound(CUIConfig::EUISound::EndRound, 0);

//L16N [Time Attack Daily] Message displayed after qualifications end, before the Knockout match. "Knockout" is a game mode and translation should be consistent with it
if (
	Server_CupState != Constants::C_TimeAttackDaily_CupState_Qualifications &&
	Server_CupState != Constants::C_TimeAttackDaily_CupState_WaitingForMatch
) {
	declare CSmScore WinnerScore <=> Scores::GetPlayerWinner();
	if (WinnerScore != Null) {
		if (!MB_MatchIsRunning()) {
			UIModules_BigMessage::SetMessage(_("$<%1$> wins the match!"), WinnerScore.User.WebServicesUserId);
		} else {
			UIModules_BigMessage::SetMessage(_("$<%1$> wins the track!"), WinnerScore.User.WebServicesUserId);
		}
	}
} else {
	UIModules_BigMessage::SetMessage(_("Qualifications are over. Knockout will start soon."));
}

// Compute round trophies as if it was a match
Trophy_LiveTimeAttackAchievement_ClearResultList();
Race::SortScores(GetScoresSortCriteria());
foreach (Key => Score in Scores) {
	if (TrophyRanking::UserIsRanked(Score.User) && Score.BestRaceTimes.count > 0 && Score.BestRaceTimes[Score.BestRaceTimes.count - 1] >= 0) {
		Trophy_LiveTimeAttackAchievement_AddResult(Score.User.WebServicesUserId, Key + 1, TrophyRanking::GetUserRank(Score.User));
	}
}
Match_TrophyTask = Task::Create(This, Trophy_LiveTimeAttackAchievement_SendResultList(Match_MatchDuration / 1000));
Match_TrophyTaskEndTime = Now + C_TrophyTaskTimeout;
UIModules_ScoresTable::ResetTrophies();
UIModules_EndMatchTrophy::ResetTrophyAnimation();
***

***Round_PodiumSequence***
***
declare CUIConfig::EUISequence PrevUISequence = UIManager.UIAll.UISequence;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
MB_Private_Sleep((S_ChatTime*1000)/2);

// Wait until the trophy task is complete
Match_TrophyTask = Task::Update(Match_TrophyTask);
while (Task::IsInitialized(Match_TrophyTask) && Task::IsRunning(Match_TrophyTask) && Now < Match_TrophyTaskEndTime) {
	MB_Yield();
	Match_TrophyTask = Task::Update(Match_TrophyTask);
}
if (Task::IsInitialized(Match_TrophyTask)) {
	Match_TrophyTask = Task::Update(Match_TrophyTask);
	declare Integer[Integer][Text] AccountsTrophies;
	if (!Task::IsRunning(Match_TrophyTask)) {
		declare CTaskResult_AccountTrophyGainList SourceTask = Task::GetSourceTask_AccountTrophyGainList(Match_TrophyTask);
		if (Task::IsSuccess(Match_TrophyTask) && SourceTask != Null) {
			foreach (AccountTrophyGain in SourceTask.AccountTrophyGainList) {
				declare Integer[Integer] AccountTrophies = UIModules_ScoresTable::ConvertAccountTrophyGain(AccountTrophyGain);
				if (AccountTrophies.count > 0) {
					AccountsTrophies[AccountTrophyGain.WebServicesUserId] = AccountTrophies;
				}
			}
		}
	}
	if (AccountsTrophies.count > 0) {
		foreach (Player in AllPlayers) {
			if (Player.User != Null) {
				declare Integer[Integer] Trophies = AccountsTrophies.get(Player.User.WebServicesUserId, []);
				if (Trophies.count > 0) {
					Tracking::SendPlayerTrophiesEarned(UIManager, Player, Trophies);
				}
			}
		}
	}
	Match_TrophyTask = Task::Destroy(Match_TrophyTask);
	UIModules_ScoresTable::SetTrophies(AccountsTrophies);
	UIModules_EndMatchTrophy::PlayTrophyAnimation(AccountsTrophies);
	StateMgr::ForcePlayersStates([StateMgr::C_State_TrophyAnimation]);
	MB_Private_Sleep(C_TrophyAnimationDuration);
	StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
}

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
MB_Private_Sleep((S_ChatTime*1000)/2);
SetScoresTableScoreMode(Race::IsIndependentLaps(), True);
MB_Private_Sleep(C_TrophyDisplayDuration);
SetScoresTableScoreMode(Race::IsIndependentLaps(), False);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.UISequence = PrevUISequence;
***

***Round_AfterPodiumSequence***
***
UIModules_BigMessage::SetMessage("");
UIModules_ScoresTable::ResetTrophies();
***

***Match_EndMap***
***
// Ensure that we stop the match (after a vote for the next map, ...)
MB_StopMatch();
***

***Match_BeforeUnloadMap***
***
DailyLogs::LogGatheredMatchData();
Match_CanForceTrophyRankUpdate = False;
***

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Select the scores table score mode
Void SetScoresTableScoreMode(Boolean _IsIndependentLaps, Boolean _DisplayTrophies) {
	if (_DisplayTrophies) UIModules_ScoresTable::SetScoreMode(UIModules_ScoresTable::C_Mode_Trophy);
	else if (_IsIndependentLaps) UIModules_ScoresTable::SetScoreMode(UIModules_ScoresTable::C_Mode_LapTime);
	else UIModules_ScoresTable::SetScoreMode(UIModules_ScoresTable::C_Mode_BestTime);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Update the time limit
 *
 *	@param	_StartTime								The starting time of the map
 *	@param	_NewTimeLimit							The time limit before going to the next map
 */
Void SetTimeLimit(Integer _StartTime, Integer _NewTimeLimit) {
	if (_NewTimeLimit <= 0) {
		EndTime = -1;
		UIModules_ScoresTable::SetFooterInfo(TL::Compose("%1 -", _("Time Limit")));
	} else {
		EndTime = _StartTime + (_NewTimeLimit * 1000);
		UIModules_ScoresTable::SetFooterInfo(TL::Compose("%1 "^TL::TimeToText(_NewTimeLimit*1000), _("Time Limit")));
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the right sort criteria for
 *	the scores
 *
 *	@return														The sort criteria
 */
Integer GetScoresSortCriteria() {
	if (Race::IsIndependentLaps()) return Race::C_Sort_BestLapTime;
	return Race::C_Sort_BestRaceTime;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the right sort criteria for
 *	the ladder
 *
 *	@return														The sort criteria
 */
Integer GetLadderSortCriteria() {
	if (Race::IsIndependentLaps()) return Scores::C_Sort_BestLapTime;
	return Scores::C_Sort_BestRaceTime;
}