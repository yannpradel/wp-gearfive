/**
 *	TrackMania World Tour - Matchmaking mode
 */
#Extends "Libs/Nadeo/TMNext/TrackMania/Modes/TMNextRoundsBase.Script.txt"

#Const CompatibleMapTypes	"TrackMania\\TM_Race,TM_Race"
#Const Version						"2023-03-18"
#Const ScriptName					"Modes/TrackMania/TM_TMWTMatchmaking_Online.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/CommonLibs/Common/Semver.Script.txt" as Semver
#Include "Libs/Nadeo/CommonLibs/Common/Tracking.Script.txt" as Tracking
#Include "Libs/Nadeo/CommonLibs/Common/Utils.Script.txt" as CommonUtils
#Include "Libs/Nadeo/ModeLibs/Common/Matchmaking.Script.txt" as Matchmaking
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Constants.Script.txt" as MenuConst
#Include "Libs/Nadeo/TMNext/TrackMania/Modes/TMWTMatchmaking/StateManager.Script.txt" as StateMgr
#Include "Libs/Nadeo/TMNext/TrackMania/Modes/TMWTCommon/Shared.Script.txt" as Shared
#Include "Libs/Nadeo/TMNext/TrackMania/Modes/TMWTCommon/TMWTMarkers.Script.txt" as TMWTMarkers
#Include "Libs/Nadeo/TMNext/TrackMania/Modes/TMWTCommon/Teams.Script.txt" as Teams
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/Checkpoint_Server.Script.txt" as UIModules_Checkpoint
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/Chrono_Server.Script.txt" as UIModules_Chrono
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/PauseMenuOnline_Server.Script.txt" as UIModules_PauseMenu_Online
#Include "ManiaApps/Nadeo/TMNext/TrackMania/TMWTCommon/UIModules/EventMessage_Server.Script.txt" as UIModules_EventMessage
#Include "ManiaApps/Nadeo/TMNext/TrackMania/TMWTCommon/UIModules/EventPoints_Server.Script.txt" as UIModules_EventPoints
#Include "ManiaApps/Nadeo/TMNext/TrackMania/TMWTCommon/UIModules/Header_Server.Script.txt" as UIModules_Header
#Include "ManiaApps/Nadeo/TMNext/TrackMania/TMWTCommon/UIModules/LiveRanking_Server.Script.txt" as UIModules_LiveRanking
#Include "ManiaApps/Nadeo/TMNext/TrackMania/TMWTCommon/UIModules/MapInfo_Server.Script.txt" as UIModules_MapInfo

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Settings
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Setting S_MapPointsLimit 10 as _("Track points limit")
#Setting S_MatchPointsLimit 1 as _("Match points limit")
#Setting S_FinishTimeout -1 as _("Finish timeout")
#Setting S_WarmUpNb 0	as _("Number of warm up")
#Setting S_WarmUpDuration 0 as _("Duration of one warm up")
#Setting S_WarmUpTimeout -1 as _("Warm up timeout")
#Setting S_TeamsUrl "" as _("Teams URL") //< URL where to get the teams info. Check `Teams::C_TeamUrl_XXX` for TMGL, TMCL and debug teams.
#Setting S_EarlyEndMatchCallback True as "<hidden>"
#Setting S_ChatTime 600

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Structures
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Struct K_PreMatch {
	Integer RespawnBehaviour;
	Boolean RespawnAfter;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_ModeName "TrackMania World Tour - Matchmaking"
//L16N [TrackMania World Tour - Matchmaking] Description of the mode rules
#Const Description _("""Two teams compete in a series of races. The first team to reach the point limit wins the track. The first team to win enough tracks wins the match.""")

#Const C_HudModulePath "" //< Path to the hud module
#Const C_ManiaAppUrl "file://Media/ManiaApps/Nadeo/TMNext/TrackMania/TMWTMatchmaking/TMWTMatchmaking.Script.txt" //< Url of the mania app
#Const C_FakeUsersNb 0
#Const C_ClansNb 2
#Const C_DNF 0
#Const C_IsMatchmaking True

#Const C_MatchIntroDuration 10000
#Const C_StartRoundMessageDuration 5000
#Const C_EndRoundSequenceDuration 6000
#Const C_EndMapSequenceDuration 5000

#Const C_Points_Ace 3
#Const C_Points_VictoryWin 2
#Const C_Points_VictoryLose 1
#Const C_Points_Draw 1

#Const C_UploadRecord True
#Const C_DisplayRecordGhost False
#Const C_DisplayRecordMedal False
#Const C_CelebrateRecordGhost True
#Const C_CelebrateRecordMedal True

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Extends
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
***Match_LogVersions***
***
Log::RegisterScript(ScriptName, Version);
Log::RegisterScript(Semver::ScriptName, Semver::Version);
Log::RegisterScript(Tracking::ScriptName, Tracking::Version);
Log::RegisterScript(CommonUtils::ScriptName, CommonUtils::Version);
Log::RegisterScript(Matchmaking::ScriptName, Matchmaking::Version);
Log::RegisterScript(MenuConst::ScriptName, MenuConst::Version);
Log::RegisterScript(StateMgr::ScriptName, StateMgr::Version);
Log::RegisterScript(Shared::ScriptName, Shared::Version);
Log::RegisterScript(TMWTMarkers::ScriptName, TMWTMarkers::Version);
Log::RegisterScript(Teams::ScriptName, Teams::Version);
Log::RegisterScript(UIModules_Checkpoint::ScriptName, UIModules_Checkpoint::Version);
Log::RegisterScript(UIModules_Chrono::ScriptName, UIModules_Chrono::Version);
Log::RegisterScript(UIModules_PauseMenu_Online::ScriptName, UIModules_PauseMenu_Online::Version);
Log::RegisterScript(UIModules_EventMessage::ScriptName, UIModules_EventMessage::Version);
Log::RegisterScript(UIModules_EventPoints::ScriptName, UIModules_EventPoints::Version);
Log::RegisterScript(UIModules_MapInfo::ScriptName, UIModules_MapInfo::Version);
Log::RegisterScript(UIModules_LiveRanking::ScriptName, UIModules_LiveRanking::Version);
Log::RegisterScript(UIModules_Header::ScriptName, UIModules_Header::Version);
***

***Match_LoadLibraries***
***
Matchmaking::Load();
TMWTMarkers::Load();
StateMgr::Load();
***

***Match_UnloadLibraries***
***
StateMgr::Unload();
TMWTMarkers::Unload();
Matchmaking::Unload();
***

***Match_Settings***
***
MB_Settings_UseDefaultHud = (C_HudModulePath == "");
MB_Settings_UseDefaultPodiumSequence = False;
***

***Match_Rules***
***
ModeInfo::SetName(C_ModeName);
ModeInfo::SetType(ModeInfo::C_Type_FreeForAll);
ModeInfo::SetRules(Description);
ModeInfo::SetStatusMessage("");
***

***Match_LoadHud***
***
if (C_HudModulePath != "") Hud_Load(C_HudModulePath);
***

***Match_AfterLoadHud***
***
ClientManiaAppUrl = C_ManiaAppUrl;
Race::SortScores(Race::C_Sort_TotalPoints);
WarmUp::SetVisibleFor(WarmUp::C_VisibleFor_PlayersOnly);
WarmUp::SetStartRoundMessage("");
UIModules_ScoresTable::SetScoreMode(UIModules_ScoresTable::C_Mode_Points);
UIModules_ScoresTable::SetHideSpectators(True);
UIModules_Checkpoint::SetVisibilityTimeDiff(False, True);
UIModules_Checkpoint::SetRankMode(UIModules_Checkpoint::C_RankMode_CurrentRace);
UIModules_Checkpoint::SetVisibleFor(UIModules_Checkpoint::C_Target_Players);
UIModules_Chrono::SetVisibleFor(UIModules_Chrono::C_VisibleFor_PlayersOnly);
UIModules_SpectatorBase::HidePlayerName(True);
UIModules_TimeGap::HideForSpectators(True);
UIModules_PauseMenu_Online::SetHelp(Description);
UIModules_EventMessage::TriggerEvent(UIModules_EventMessage::C_Type_Reset);
UIModules_Sign16x9Small::SetDisplayMode(UIModules_Sign16x9Small::C_DisplayMode_Ranked);
Shared::Initialize(This);
UpdatePointsDisplay(S_MatchPointsLimit, S_MapPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2), Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2));
UpdateMVP();

// Markers are handled by TMWTMarkers
UIManager.UIAll.AlliesLabelsVisibility = CUIConfig::ELabelsVisibility::Never;
UIManager.UIAll.TeamLabelsVisibility = CUIConfig::ELabelsVisibility::Never;
UIManager.UIAll.OpposingTeamLabelsVisibility = CUIConfig::ELabelsVisibility::Never;
***

***Match_Yield***
***
// Manage XmlRpc events
foreach (Event in XmlRpc.PendingEvents) {
	if (Event.Type == CXmlRpcEvent::EType::CallbackArray) {
		switch (Event.ParamArray1) {
			case Matchmaking::C_Method_MatchStarted: {
				declare Boolean Server_IsPreMatch for This = C_IsMatchmaking;
				Server_IsPreMatch = False;
			}
			case Matchmaking::C_Method_MatchCompleted: {
				declare Boolean Server_IsPreMatch for This = C_IsMatchmaking;
				Server_IsPreMatch = True;
				Teams::ResetMatchmakingClans();
			}
			case Matchmaking::C_Method_AddPlayer: {
				declare Matchmaking::K_Method_AddPlayer EventInfo = Matchmaking::GetEventInfo_Method_AddPlayer(Event);
				if (EventInfo.AccountId != "" && EventInfo.Clan > 0) {
					Teams::SetMatchmakingClan(EventInfo.AccountId, EventInfo.Clan);
					// Unspawn player to spawn them in the right team
					declare CSmPlayer Player = ModeUtils::GetPlayerFromAccountId(EventInfo.AccountId);
					if (Player != Null) {
						if (Player.CurrentClan != Teams::GetPlayerRequestedClan(Player, C_IsMatchmaking)) {
							if (Race::IsRacing(Player)) Race::StopSkipOutro(Player);
							Teams::MovePlayerToRequestedClan(This, Player, C_IsMatchmaking);
						}
						if (Player.Score != Null) {
							WarmUp::CanPlay(Player.Score, Teams::CanPlay(Player, C_IsMatchmaking));
						}
					}
				}
			}
			case Matchmaking::C_Method_RemovePlayer: {
				declare Text AccountId = Matchmaking::GetEventInfo_Method_RemovePlayer(Event);
				if (AccountId != "") {
					Teams::ResetMatchmakingClan(AccountId);
					// Unspawn player if they are not in a team anymore
					declare CSmPlayer Player = ModeUtils::GetPlayerFromAccountId(AccountId);
					if (Player != Null && Race::IsRacing(Player)) {
						Race::StopSkipOutro(Player);
					}
				}
			}
		}
	}
}

foreach (Event in PendingEvents) {
	switch (Event.Type) {
		// Initialize players when they join the server
		case CSmModeEvent::EType::OnPlayerAdded: {
			StateMgr::InitializePlayer(Event.Player);
			CarRank::InitializePlayer(Event.Player);
			UIModules_LiveRanking::ForceUpdate();
			Teams::SetPlayerClanOnJoin(This, Event.Player, C_IsMatchmaking);

			if (Event.Player != Null && Event.Player.Score != Null) {
				WarmUp::CanPlay(Event.Player.Score, Teams::CanPlay(Event.Player, C_IsMatchmaking));
			}
		}
		case CSmModeEvent::EType::OnPlayerRemoved: {
			UIModules_LiveRanking::ForceUpdate();
		}
	}
}

// Enable automatic team selection until a point is scored in the match
declare Boolean Server_AutoSelectTeams for This = False;
if (Server_AutoSelectTeams) {
	Teams::AutoSelectTeams(This);
}

TMWTMarkers::Yield();
StateMgr::Yield();
***

***Match_InitServer***
***
declare Boolean Server_IsPreMatch for This = C_IsMatchmaking;
declare Boolean Server_AutoSelectTeams for This = False;
***

***Match_StartServer***
***
// Initialize mode
Clans::SetClansNb(C_ClansNb);
Scores::SaveInScore(Scores::C_Points_Match);
StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
WarmUp::SetAvailability(True);
WarmUp::SetSpawnInRequestedClan(False);
Race::SetRespawnBehaviour(Race::C_RespawnBehaviour_NeverGiveUp);
Race::SetupRecord(
	MenuConst::C_ScopeType_Season,
	MenuConst::C_ScopeType_PersonalBest,
	MenuConst::C_GameMode_TimeAttack,
	"",
	C_UploadRecord,
	C_DisplayRecordGhost,
	C_DisplayRecordMedal,
	C_CelebrateRecordGhost,
	C_CelebrateRecordMedal
);
***

***Match_InitMatch***
***
declare Integer Match_MapNb;
***

***Match_StartMatch***
***
Server_AutoSelectTeams = True;
Match_MapNb = 1;

Clans::SetUseForcedClans(C_IsMatchmaking);
***

***Match_InitMap***
***
declare Integer Map_RoundNb = 1;
declare Boolean Map_Skipped;
declare Teams::K_TeamsLoading TeamsLoading = Teams::C_TeamsLoading_Null;

UIModules_LiveRanking::ResetRace();
UIModules_MapInfo::SetMatchProgression(Match_MapNb, Map_RoundNb, S_MatchPointsLimit);
UpdatePointsDisplay(S_MatchPointsLimit, S_MapPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2), Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2));
UpdateMVP();

if (Match_MapNb == 1) {
	TeamsLoading = Teams::LoadTeams(S_TeamsUrl);
}
***

***Match_StartMap***
***
// Add bot when necessary
Users_SetNbFakeUsers(C_FakeUsersNb, 0);

Map_Skipped = True;
CarRank::Reset();

// Wait end of teams loading
if (Match_MapNb == 1) {
	while (Teams::IsLoading(TeamsLoading)) {
		MB_Yield();
		TeamsLoading = Teams::UpdateLoading(TeamsLoading);
	}
	Teams::SetTeamsInfo(TeamsLoading.Teams);
	Teams::SelectTeams(This);
	UIModules_ScoresTable::SetCustomNames(Teams::GetScoresTableNames(This));
}

// Wait for players
while (MB_MapIsRunning() && Players.count < 1) MB_Sleep(1000);

UpdatePointsDisplay(S_MatchPointsLimit, S_MapPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2), Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2));

// Pre-match on Club competition system
if (Server_IsPreMatch) {
	declare K_PreMatch PreMatch = PreMatchStart();
	while (MB_MapIsRunning() && Server_IsPreMatch) {
		PreMatchLoop();
	}
	PreMatchEnd(PreMatch);
	UpdatePointsDisplay(S_MatchPointsLimit, S_MapPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2), Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2));
}

// Match intro
if (Match_MapNb == 1) {
	StateMgr::ForcePlayersStates([StateMgr::C_State_MatchIntro]);
	declare Integer MatchIntroEndTime = Now + C_MatchIntroDuration;
	while (MB_MapIsRunning() && Now < MatchIntroEndTime) {
		MB_Yield();
		foreach (Player in Players) {
			if (Player.CurrentClan != Teams::GetPlayerRequestedClan(Player, C_IsMatchmaking)) {
				Teams::MovePlayerToRequestedClan(This, Player, C_IsMatchmaking);
			}
		}
	}
	StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
}

// Warm up
UIModules_ScoresTable::SetFooterInfo(_("Warm up"));
foreach (Score in Scores) {
	WarmUp::CanPlay(Score, True);
}
foreach (Player in AllPlayers) {
	WarmUp::CanPlay(Player.Score, Teams::CanPlay(Player, C_IsMatchmaking));
}
//L16N [TrackMania World Tour - Matchmaking] Message displayed at the end of the warm up, just before the race start.
MB_WarmUp(S_WarmUpNb, S_WarmUpDuration * 1000, S_WarmUpTimeout * 1000, TL::Compose("$i%1", _("Race starting")), False);
UIModules_ScoresTable::SetFooterInfo("");
***

***Match_StartWarmUp***
***
TMWTMarkers::Enable();
UIModules_LiveRanking::ResetRace();
StateMgr::ForcePlayersStates([StateMgr::C_State_WarmUp]);
***

***Match_WarmUpLoop***
***
foreach (Player in Players) {
	if (Player.CurrentClan != Teams::GetPlayerRequestedClan(Player, C_IsMatchmaking)) {
		Race::Wait(Player);
		Teams::MovePlayerToRequestedClan(This, Player, C_IsMatchmaking);
	}
}
***

***Match_EndWarmUp***
***
StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
TMWTMarkers::Disable();
***

***Rounds_StartPause***
***
MB_Race_EnablePlayMode(True);
UIModules_LiveRanking::ResetRace();
Shared::SetIsPause(This, True);
TMWTMarkers::Enable();
StateMgr::ForcePlayersStates([StateMgr::C_State_Playing]);
***

***Rounds_EndPause***
***
StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
TMWTMarkers::Disable();
Shared::SetIsPause(This, False);
MB_Race_EnablePlayMode(False);
***

***Match_StartRound***
***
declare Integer Clan1MapPoints = Scores::GetClanMapPoints(1);
declare Integer Clan2MapPoints = Scores::GetClanMapPoints(2);
declare Integer Clan1MatchPoints = Scores::GetClanMatchPoints(1);
declare Integer Clan2MatchPoints = Scores::GetClanMatchPoints(2);
if (Clan1MapPoints >= S_MapPointsLimit && Clan2MapPoints >= S_MapPointsLimit) {
	UIModules_EventMessage::TriggerEvent(UIModules_EventMessage::C_Type_Overtime);
} else {
	declare Boolean Clan1TrackPoint = Clan1MapPoints >= S_MapPointsLimit - C_Points_Ace;
	declare Boolean Clan1MatchPoint = Clan1TrackPoint && Clan1MatchPoints >= S_MatchPointsLimit - 1;
	declare Boolean Clan2TrackPoint = Clan2MapPoints >= S_MapPointsLimit - C_Points_Ace;
	declare Boolean Clan2MatchPoint = Clan2TrackPoint && Clan2MatchPoints >= S_MatchPointsLimit - 1;
	if (Clan1MatchPoint && Clan2MatchPoint) {
		UIModules_EventMessage::TriggerEvent(UIModules_EventMessage::C_Type_MatchPoint);
	} else if (Clan1MatchPoint) {
		UIModules_EventMessage::TriggerEventForClan(UIModules_EventMessage::C_Type_MatchPoint, 1);
	} else if (Clan2MatchPoint) {
		UIModules_EventMessage::TriggerEventForClan(UIModules_EventMessage::C_Type_MatchPoint, 2);
	} else if (Clan1TrackPoint && Clan2TrackPoint) {
		UIModules_EventMessage::TriggerEvent(UIModules_EventMessage::C_Type_TrackPoint);
	} else if (Clan1TrackPoint) {
		UIModules_EventMessage::TriggerEventForClan(UIModules_EventMessage::C_Type_TrackPoint, 1);
	} else if (Clan2TrackPoint) {
		UIModules_EventMessage::TriggerEventForClan(UIModules_EventMessage::C_Type_TrackPoint, 2);
	}
}

TMWTMarkers::Enable();
UIModules_LiveRanking::ResetRace();
UIModules_MapInfo::SetMatchProgression(Match_MapNb, Map_RoundNb, S_MatchPointsLimit);
StateMgr::ForcePlayersStates([StateMgr::C_State_Playing]);
UpdatePointsDisplay(S_MatchPointsLimit, S_MapPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2), Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2));
***

***Rounds_CheckCanSpawn***
***
if (!Teams::CanPlay(_Player, C_IsMatchmaking)) return False;
***

***Rounds_SpawnPlayer***
***
Teams::MovePlayerToRequestedClan(This, Player, C_IsMatchmaking);
Race::Start(Player, StartTime);
***

***Rounds_PlayerSpawned***
***
CarRank::ThrottleUpdate(CarRank::C_SortCriteria_CurrentRaceProgression);
***

***Match_PlayLoop***
***
// Manage race events
declare Events::K_RaceEvent[] RacePendingEvents = Race::GetPendingEvents();
foreach (Event in RacePendingEvents) {
	Race::ValidEvent(Event);
	
	// Waypoint
	if (Event.Type == Events::C_Type_Waypoint) {
		CarRank::ThrottleUpdate(CarRank::C_SortCriteria_CurrentRaceProgression);
		if (Event.Player != Null) {
			if (Event.IsEndLap) {
				Scores::UpdatePlayerBestLapIfBetter(Event.Player);
			}
			if (Event.IsEndRace) {
				Scores::UpdatePlayerBestRaceIfBetter(Event.Player);
				Scores::UpdatePlayerBestLapIfBetter(Event.Player);
				Scores::UpdatePlayerPrevRace(Event.Player);

				Race::StopSkipScoresTable(Event.Player);
				UIModules_LiveRanking::PlayerFinishRace(Event.Player);
				
				// Start the countdown if it's the first player to finish
				if (EndTime <= 0) {
					EndTime = Race::GetFinishTimeout(S_FinishTimeout, Race::GetLapsNb(), Map);
				}
			}
		}
	}
}

// Manage mode events
foreach (Event in PendingEvents) {
	if (Event.HasBeenPassed || Event.HasBeenDiscarded) continue;
	Events::Invalid(Event);
}
***

***Match_EndPlayLoop***
***
TMWTMarkers::Disable();
***

***Match_EndRound***
***
Race::StopSkipOutroAll();
EndTime = -1;
StateMgr::ForcePlayersStates([StateMgr::C_State_EndRound]);
CarRank::Update(CarRank::C_SortCriteria_CurrentRaceProgression);
UpdatePointsDisplay(S_MatchPointsLimit, S_MapPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2), Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2));

if (Semver::Compare(XmlRpc::GetApiVersion(), ">=", "2.1.1")) {
	Scores::XmlRpc_SendScores(Scores::C_Section_PreEndRound, "");
}

if (Round_ForceEndRound || Round_SkipPauseRound || Round_Skipped) {
	// Cancel points
	foreach (Score in Scores) {
		Scores::SetPlayerRoundPoints(Score, 0);
	}
	// Do not launch the forced end round sequence after a pause
	if (!Round_SkipPauseRound) {
		ForcedEndRoundSequence();
	}
} else {
	Map_RoundNb += 1;
	Server_AutoSelectTeams = False;
	GiveClansRacePoints(GetClansRaceRanking());
	Race::SortScores(Race::C_Sort_TotalPoints);
	UIModules_LiveRanking::ForceUpdate();
	UpdatePointsDisplay(S_MatchPointsLimit, S_MapPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2), Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2));
	UpdateMVP();

	MB_Sleep(C_EndRoundSequenceDuration);
	
	if (MapIsOver(S_MapPointsLimit)) {
		Map_Skipped = False;
		MB_StopMap();
	}
}
StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);

// Wait for at least one player that can play before trying to start the next round
while (MB_MapIsRunning() && !HasAPlayerThatCanPlay()) {
	MB_Sleep(1000);
}
***

***Match_EndMap***
***
if (!Map_Skipped) {
	// Give a match point to the winning team
	if (Scores::GetClanMapPoints(1) > Scores::GetClanMapPoints(2)) {
		Scores::AddClanMatchPoints(1, 1);
		Scores::SetClanWinner(1);
	} else if (Scores::GetClanMapPoints(2) > Scores::GetClanMapPoints(1)) {
		Scores::AddClanMatchPoints(2, 1);
		Scores::SetClanWinner(2);
	}
	UpdatePointsDisplay(S_MatchPointsLimit, S_MapPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2), Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2));

	Match_MapNb += 1;
}

if (MatchIsOver(S_MatchPointsLimit)) MB_StopMatch();

if (!MB_MatchIsRunning()) {
	declare Integer WinningTeam = -1;
	if (Scores::GetClanMatchPoints(1) > Scores::GetClanMatchPoints(2)) {
		WinningTeam = 1;
	} else if (Scores::GetClanMatchPoints(2) > Scores::GetClanMatchPoints(1)) {
		WinningTeam = 2;
	}
	Scores::SetClanWinner(WinningTeam);
	UIModules_Sign16x9Small::SetWinningClan(WinningTeam);

	foreach (Player in Players) {
		if (Player.CurrentClan == 1 || Player.CurrentClan == 2) {
			if (Player.CurrentClan == WinningTeam) {
				Tracking::SendPlayerMatchResult(UIManager, Player, 1, True);
			} else {
				Tracking::SendPlayerMatchResult(UIManager, Player, 2, False);
			}
		}
	}
}
***

***Match_BeforePodiumSequence***
***
// Send the EndMatch callback sooner to speed up the TMWT API update
if (S_EarlyEndMatchCallback && !MB_MatchIsRunning()) {
	Scores::EndMatch();
	Scores::XmlRpc_SendScores(Scores::C_Section_EndMatch, ""); //< send "Trackmania.Scores"
}

declare Integer WinningClan = Scores::GetClanWinner();
if (WinningClan == 1 || WinningClan == 2) {
	if (MB_MatchIsRunning()) {
		UIModules_EventMessage::TriggerEventForClan(UIModules_EventMessage::C_Type_TrackWin, WinningClan);
	} else {
		UIModules_EventMessage::TriggerEventForClan(UIModules_EventMessage::C_Type_MatchWin, WinningClan);
	}

	// Display random players from the winning team on the podium
	declare Text[] Logins;
	declare Text[Text] PlayersNames;
	foreach (Player in Players) {
		if (Player.CurrentClan == WinningClan && Player.User != Null) {
			Logins.add(Player.User.Login);
			PlayersNames[Player.User.WebServicesUserId] = Teams::GetPlayerName(Player.User);
		}
	}
	UIModules_Sign16x9Small::SetPlayersNames(PlayersNames);
	UIManager.UIAll.UISequence_PodiumPlayersWin = "";
	while (Logins.count > 0) {
		declare Integer Key = ML::Rand(0, Logins.count - 1);
		if (UIManager.UIAll.UISequence_PodiumPlayersWin == "") {
			UIManager.UIAll.UISequence_PodiumPlayersWin = Logins[Key];
		} else {
			UIManager.UIAll.UISequence_PodiumPlayersWin ^= ","^Logins[Key];
		}
		Logins.removekey(Key);
	}
}
***

***Match_PodiumSequence***
***
if (MB_MatchIsRunning()) {
	MB_Sleep(C_EndMapSequenceDuration);
} else {
	ModeUtils::PushAndApplyUISequence(UIManager.UIAll, CUIConfig::EUISequence::Podium);
	MB_Sleep(S_ChatTime * 1000);
	ModeUtils::PopAndApplyUISequence(UIManager.UIAll);
}
***

***Match_BeforeUnloadMap***
***
UIModules_EventMessage::TriggerEvent(UIModules_EventMessage::C_Type_Reset);
***

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Check if there is at least one player that can play
Boolean HasAPlayerThatCanPlay() {
	foreach (Player in Players) {
		if (Teams::CanPlay(Player, C_IsMatchmaking)) return True;
	}
	return False;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the ranking of clans in the race
 *	The key is the rank and the value the clan
 *	So [1 => 1, 2 => 2, 3 => 2, 4 => 1] means clan 1 in first and fourth place,
 *	clan 2 in second and third place.
 */
Integer[Integer] GetClansRaceRanking() {
	declare Integer[][Ident] PlayerTimes;
	foreach (Score in Scores) {
		if (Scores::GetPlayerPrevRaceTime(Score) > 0) {
			PlayerTimes[Score.Id] = CommonUtils::ToScriptArray(Score.PrevRaceTimes);
		}
	}
	declare Ident[][Integer] SortedScoreIds = Scores::SortIdsByWaypointTimes(PlayerTimes);
	declare Integer[Integer] ClansRanking;
	foreach (ScoreIds in SortedScoreIds) {
		foreach (ScoreId in ScoreIds) {
			ClansRanking[ClansRanking.count + 1] = Scores[ScoreId].TeamNum;
		}
	}
	return ClansRanking;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Give points to the clans based on their rank in the race
Void GiveClansRacePoints(Integer[Integer] _ClansRaceRanking) {
	declare Integer FirstPlaceClan = _ClansRaceRanking.get(1, C_DNF);
	declare Integer SecondPlaceClan = _ClansRaceRanking.get(2, C_DNF);
	declare Integer ThirdPlaceClan = _ClansRaceRanking.get(3, C_DNF);

	if (FirstPlaceClan != C_DNF) {
		// Ace -> [A, A, B, B] - [A, A, B, DNF] - [A, A, DNF, DNF] - [A, DNF, DNF, DNF]
		if (FirstPlaceClan == SecondPlaceClan || SecondPlaceClan == C_DNF) {
			Scores::AddClanMapPoints(FirstPlaceClan, C_Points_Ace);
			UIModules_EventMessage::TriggerEventForClan(UIModules_EventMessage::C_Type_Ace, FirstPlaceClan);
		}
		// Victory [A, B, A, B] - [A, B, A, DNF] - [A, B, DNF, DNF]
		else if (FirstPlaceClan == ThirdPlaceClan || ThirdPlaceClan == C_DNF) {
			Scores::AddClanMapPoints(FirstPlaceClan, C_Points_VictoryWin);
			Scores::AddClanMapPoints(SecondPlaceClan, C_Points_VictoryLose);
			UIModules_EventMessage::TriggerEventForClan(UIModules_EventMessage::C_Type_Victory, FirstPlaceClan);
		}
		// Draw [A, B, B, A] - [A, B, B, DNF]
		else {
			Scores::AddClanMapPoints(FirstPlaceClan, C_Points_Draw);
			Scores::AddClanMapPoints(SecondPlaceClan, C_Points_Draw);
			UIModules_EventMessage::TriggerEvent(UIModules_EventMessage::C_Type_Draw);
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Check if a points limit is reached without a tie between the two clans
 *
 *	@param	_PointsLimit	The number of points to win a track
 *	@param	_Clan1Points	The number of points of clan 1
 *	@param	_Clan2Points	The number of points of clan 2
 *
 *	@return		True if it is the case, false otherwise
 */
Boolean PointsLimitReached(Integer _PointsLimit, Integer _Clan1Points, Integer _Clan2Points) {
	return (_Clan1Points != _Clan2Points && (_Clan1Points >= _PointsLimit || _Clan2Points >= _PointsLimit));
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Check if we should go to the next track
 *
 *	@param	_MapPointsLimit		The number of points to win a track
 *
 *	@return		True if it is the case, false otherwise
 */
Boolean MapIsOver(Integer _MapPointsLimit) {
	return PointsLimitReached(_MapPointsLimit, Scores::GetClanMapPoints(1), Scores::GetClanMapPoints(2));
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Check if we should go to the next match
 *
 *	@param	_MatchPointsLimit		The number of points to win a match
 *
 *	@return		True if it is the case, false otherwise
 */
Boolean MatchIsOver(Integer _MatchPointsLimit) {
	return PointsLimitReached(_MatchPointsLimit, Scores::GetClanMatchPoints(1), Scores::GetClanMatchPoints(2));
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Start the pre-match
K_PreMatch PreMatchStart() {
	StateMgr::ForcePlayersStates([StateMgr::C_State_PreMatch]);
	Race::StopSkipOutroAll();
	MB_Yield();

	declare K_PreMatch PreMatch = K_PreMatch {
		RespawnBehaviour = Race::GetRespawnBehaviour(),
		RespawnAfter = GiveUpBehaviour_RespawnAfter
	};
	Race::SetRespawnBehaviour(Race::C_RespawnBehaviour_Normal);
	GiveUpBehaviour_RespawnAfter = True;

	MB_Race_EnablePlayMode(True);
	StartTime = Now + Race::C_SpawnDuration;
	EndTime = -1;

	foreach (Player in Players) {
		if (Race::IsReadyToStart(Player) && Teams::CanPlay(Player, C_IsMatchmaking)) {
			Teams::MovePlayerToRequestedClan(This, Player, C_IsMatchmaking);
			Race::Start(Player);
		}
	}

	return PreMatch;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Run the pre-match
Void PreMatchLoop() {
	MB_Yield();

	declare Events::K_RaceEvent[] RacePendingEvents = Race::GetPendingEvents();
	foreach (Event in RacePendingEvents) {
		Race::ValidEvent(Event);
		if (Event.Type == Events::C_Type_Waypoint && Event.IsEndRace) {
			// We do not need to see the scores table during the pre-match
			if (Event.Player != Null) Race::StopSkipScoresTable(Event.Player);
		}
	}
	foreach (Event in PendingEvents) {
		if (Event.HasBeenPassed || Event.HasBeenDiscarded) continue;
		Events::Invalid(Event);
	}

	foreach (Player in Players) {
		if (Player.CurrentClan != Teams::GetPlayerRequestedClan(Player, C_IsMatchmaking)) {
			Race::Wait(Player);
		}
		if (Race::IsReadyToStart(Player) && Teams::CanPlay(Player, C_IsMatchmaking)) {
			Teams::MovePlayerToRequestedClan(This, Player, C_IsMatchmaking);
			Race::Start(Player);
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// End the pre-match
Void PreMatchEnd(K_PreMatch _PreMatch) {
	Race::StopSkipOutroAll();
	StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);

	MB_Race_EnablePlayMode(False);
	StartTime = -1;
	EndTime = -1;

	Race::SetRespawnBehaviour(_PreMatch.RespawnBehaviour);
	GiveUpBehaviour_RespawnAfter = _PreMatch.RespawnAfter;

	MB_Yield();
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the info displayed in the header UI
Void UpdatePointsDisplay(
	Integer _MatchPointsLimit,
	Integer _MapPointsLimit,
	Integer _Clan1MatchPoints,
	Integer _Clan2MatchPoints,
	Integer _Clan1MapPoints,
	Integer _Clan2MapPoints
) {
	UIModules_EventPoints::SetClansMapPoints(_Clan1MapPoints, _Clan2MapPoints);
	UIModules_Header::SetMatchPointsLimit(_MatchPointsLimit);
	UIModules_Header::SetMapPointsLimit(_MapPointsLimit);
	UIModules_Header::SetClansMatchPoints(_Clan1MatchPoints, _Clan2MatchPoints);
	UIModules_Header::SetClansMapPoints(_Clan1MapPoints, _Clan2MapPoints);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Find the MVP of the match
Void UpdateMVP() {
	/* @Todo select an MVP
	declare CSmScore MVP <=> Scores::GetBestPlayer(Scores::C_Sort_MatchPointsOrBestTime);
	if (MVP != Null && MVP.User != Null) {
		Shared::SetMVP(This, MVP.User.WebServicesUserId);
	} else {
		Shared::SetMVP(This, "");
	}
	*/
	Shared::SetMVP(This, "");
}