/**
 *	Trackmania Royal
 *
 *	At least one start.
 *	At least one finish.
 *	No checkpoint or multilaps.
 */
#RequireContext CSmMapType
#Const Version "1.0.0"
#Const C_MapTypeVersion 1
#Const ScriptName "MapTypes/TrackMania/TM_Race.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "TextLib" as TL
#Include "Libs/Nadeo/CMGame/Modes/Legacy/MapType.Script.txt" as MapType
#Include "Libs/Nadeo/TMGame/Modes/Landmark.Script.txt" as Landmark
#Include "Libs/Nadeo/TMGame/Modes/MapSet.Script.txt" as MapSet
#Include "Libs/Nadeo/TMGame/Modes/MapGet.Script.txt" as MapGet
#Include "Modes/TrackMania/TM_RaceTest_Local.Script.txt" as RaceTest
#Include "Libs/Nadeo/Trackmania/MapEditor/MapType.Script.txt" as TMMapType
#Include "Libs/Nadeo/TMGame/Utils/Tracking.Script.txt" as Tracking
#Include "Libs/Nadeo/Trackmania/MapEditor/PlayMapAtSave.Script.txt" as PlayMapAtSave
#Include "Libs/Nadeo/CMGame/Utils/MenuSceneManager.Script.txt" as MenuSceneManager

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const Landmark::C_Types as C_LandmarkTypes
#Const C_ForceStartsNb 5
#Const C_ValidationMode "TrackMania/TM_RoyalValidation_Local"
#Const C_EnablePlayMapAtSave False

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get a new order that does not exists already
Integer GetNewOrder(Integer[] _ExistingOrders) {
	declare Integer[] ExistingOrders = _ExistingOrders.sort();
	foreach (Key => Order in ExistingOrders) {
		if (Key + 1 != Order) return Key + 1;
	}
	return ExistingOrders.count + 1;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Check if the map is valid
Void Private_UpdateValidability() {
	declare Integer StartsFinishes = 0;
	declare Integer Starts = 0;
	declare Integer Checkpoints = 0;
	declare Integer[] CheckpointGroups = [];
	declare Integer[] StartOrders = [];
	declare Integer[] FinishOrders = [];

	foreach (Anchor in AnchorData) {
		if (!C_LandmarkTypes.exists(Anchor.Tag)) {
			Anchor.Tag = Anchor.DefaultTag;
		}

		if (Anchor.WaypointType != CAnchorData::EWaypointType::None) {
			switch (Anchor.WaypointType) {
				case CAnchorData::EWaypointType::StartFinish: {
					StartsFinishes += 1;
					if (Anchor.Tag != Landmark::C_Type_Multilap) {
						Anchor.Tag = Landmark::C_Type_Multilap;
					}
				}
				case CAnchorData::EWaypointType::Start: {
					Starts += 1;
					if (Anchor.Order <= 0) {
						Anchor.Order = GetNewOrder(StartOrders);
					}
					StartOrders.add(Anchor.Order);
					if (Anchor.Tag != Landmark::C_Type_Start) {
						Anchor.Tag = Landmark::C_Type_Start;
					}
				}
				case CAnchorData::EWaypointType::Finish: {
					if (Anchor.Order <= 0) {
						Anchor.Order = GetNewOrder(FinishOrders);
					}
					FinishOrders.add(Anchor.Order);
					if (Anchor.Tag != Landmark::C_Type_Finish) {
						Anchor.Tag = Landmark::C_Type_Finish;
					}
				}
				case CAnchorData::EWaypointType::Checkpoint: {
					if (Anchor.Tag == Landmark::C_Type_LinkedCheckpoint) {
						if (!CheckpointGroups.exists(Anchor.Order)) {
							CheckpointGroups.add(Anchor.Order);
						}
					} else {
						Checkpoints += 1;
						if (Anchor.Tag != Landmark::C_Type_Checkpoint) {
							Anchor.Tag = Landmark::C_Type_Checkpoint;
						}
					}
				}
				default: {
					Anchor.Tag = Anchor.DefaultTag;
				}
			}
		} else {
			switch (Anchor.Tag) {
				case Landmark::C_Type_Multilap: StartsFinishes += 1;
				case Landmark::C_Type_Start: {
					Starts += 1;
					if (Anchor.Order <= 0) {
						Anchor.Order = GetNewOrder(StartOrders);
					}
					StartOrders.add(Anchor.Order);
				}
				case Landmark::C_Type_Finish: {
					if (Anchor.Order <= 0) {
						Anchor.Order = GetNewOrder(FinishOrders);
					}
					FinishOrders.add(Anchor.Order);
				}
				case Landmark::C_Type_Checkpoint: Checkpoints += 1;
				case Landmark::C_Type_LinkedCheckpoint: {
					if (!CheckpointGroups.exists(Anchor.Order)) {
						CheckpointGroups.add(Anchor.Order);
					}
				}
			}
		}
	}

	Checkpoints += CheckpointGroups.count;
	StartOrders = StartOrders.sort();
	FinishOrders = FinishOrders.sort();

	if (StartsFinishes > 0) {
		ValidationStatus = CMapType::ValidationStatus::NotValidable;
		//L16N [TrackEditor] Message explaining to the player that they cannot place a multilaps block in the track.
		ValidabilityRequirementsMessage = _("Multilaps blocks are not allowed in the track.");
		return;
	}

	if (Checkpoints > 0) {
		ValidationStatus = CMapType::ValidationStatus::NotValidable;
		//L16N [TrackEditor] Message explaining to the player that they cannot place a checkpoint block in the track.
		ValidabilityRequirementsMessage = _("Checkpoint blocks are not allowed in the track.");
		return;
	}

	if (C_ForceStartsNb > 0 && Starts != C_ForceStartsNb) {
		ValidationStatus = CMapType::ValidationStatus::NotValidable;
		//L16N [TrackEditor] Message explaining to the player that they must place exactly n start line blocks. %1 will be replaced by the required number of blocks and will always be above 1. %2 will be replaced by the number of starting points currently in the track. eg: "You must place exactly 5 starting points (currently 3).".
		ValidabilityRequirementsMessage = TL::Compose(_("You must place exactly %1 starting points (currently %2)."), ""^C_ForceStartsNb, ""^Starts);
		return;
	}

	if (Starts < 1) {
		ValidationStatus = CMapType::ValidationStatus::NotValidable;
		//L16N [TrackEditor] Message explaining to the player that a track has to contain at least one start line block.
		ValidabilityRequirementsMessage = _("You must place at least one starting point.");
		return;
	}

	declare Integer[] ValidStartOrders = [];
	foreach (Order in StartOrders) {
		if (Order < 1 || Order > StartOrders.count) {
			ValidationStatus = CMapType::ValidationStatus::NotValidable;
			//L16N [TrackEditor] Message explaining to the player that the start line blocks must be ordered properly. %1 will be replaced by the maximum order. %2 will be replaced by the wrong order. eg: "The starting points must be ordered from 1 to 5. 7 is not a valid order."
			ValidabilityRequirementsMessage = TL::Compose(_("The starting points must be ordered from 1 to %1. %2 is not a valid order."), ""^StartOrders.count, ""^Order);
			return;
		}

		if (ValidStartOrders.exists(Order)) {
			ValidationStatus = CMapType::ValidationStatus::NotValidable;
			//L16N [TrackEditor] Message explaining to the player that they cannot have multiple start line blocks with the same order. %1 will be replaced by the incorrect order. eg: "You cannot place two starting points with the same order 3."
			ValidabilityRequirementsMessage = TL::Compose(_("You cannot place two starting points with the same order %1."), ""^Order);
			return;
		}

		if (!FinishOrders.exists(Order)) {
			ValidationStatus = CMapType::ValidationStatus::NotValidable;
			//L16N [TrackEditor] Message explaining to the player that each start must be linked to at least one finish line with the same order. %1 will be replaced by the missing finish line order. eg: "Each starting point must be linked to at least one finish line of the same order. Finish line with order 4 is missing."
			ValidabilityRequirementsMessage = TL::Compose(_("Each starting point must be linked to at least one finish line of the same order. Finish line with order %1 is missing."), ""^Order);
			return;
		} else {
			ValidStartOrders.add(Order);
		}
	}

	foreach (Order in FinishOrders) {
		if (Order < 1 || Order > ValidStartOrders.count) {
			ValidationStatus = CMapType::ValidationStatus::NotValidable;
			//L16N [TrackEditor] Message explaining to the player that the finish line blocks must be ordered properly. %1 will be replaced by the maximum order. %2 will be replaced by the wrong order. eg: "The finish lines must be ordered from 1 to 5. 7 is not a valid order."
			ValidabilityRequirementsMessage = TL::Compose(_("The finish lines must be ordered from 1 to %1. %2 is not a valid order."), ""^ValidStartOrders.count, ""^Order);
			return;
		}

		if (!ValidStartOrders.exists(Order)) {
			ValidationStatus = CMapType::ValidationStatus::NotValidable;
			//L16N [TrackEditor] Message explaining to the player that the finish line blocks must be linked to a starting point with the same order. %1 will be replaced by the wrong order. eg: "The finish lines must be linked to a starting point with the same order. There are no starting point with the order 4."
			ValidabilityRequirementsMessage = TL::Compose(_("The finish lines must be linked to a starting point with the same order. There are no starting point with the order %1."), ""^Order);
			return;
		}
	}

	// If the objectives times are not valid, the author must revalidate their map
	if (!MapType::ObjectivesAreValid()) {
		ValidationStatus = CMapType::ValidationStatus::Validable;
		return;
	}

	ValidationStatus = CMapType::ValidationStatus::Validated;
}
Void UpdateValidability() {
	Private_UpdateValidability();
	if (ValidationStatus != CMapType::ValidationStatus::Validated) {
		MapType::ResetObjectives();
		MapSet::ResetAuthorRaceWaypointTimes();
		// Delete author ghost of race validation
		declare Ident Map_AuthorGhostId = MapGet::GetAuthorGhostId();
		if (Map_AuthorGhostId != NullId) {
			if (DataFileMgr.Ghosts.existskey(Map_AuthorGhostId)) DataFileMgr.Ghost_Release(Map_AuthorGhostId);
			MapGet::ShareAuthorGhostId(NullId);
		}
		SetAuthorTimeAndGhost(Null);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Start playing from a start or checkpoint
 *	with no validation
 */
Void PlayTestRun() {
	TMMapType::PlayTestRun_Yield();
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Do a full run of the race to validate
 *	it and register an author time
 */
Void PlayValidationRun() {
	TMMapType::PlayValidationRun_Yield(C_ValidationMode);

	declare Integer NewAuthorTime = MapGet::GetSharedAuthorTime();
	// Check author time in Map and not MapInfo. MapInfo is updated only when the map is saved.
	// Update the medals times only if the new validation time is better
	if (NewAuthorTime >= 0 && (NewAuthorTime < Map.TMObjective_AuthorTime || Map.TMObjective_AuthorTime < 0)) {
		// For some reason the C++ reset the medals times to -1
		// if we update the validation status and author time
		// after the validation.
		// To counter this behaviour we unvalidate the map, sleep
		// to let the C++ reset the medal times and update the
		// author time afterward
		MapType::ResetObjectives();
		ValidationStatus = CMapType::ValidationStatus::NotValidable;
		yield;
		MapType::SetObjectivesFromAuthorTime(NewAuthorTime);
	}

	UpdateValidability();
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Main
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
main() {
	HoldLoadingScreen = True;
	TMMapType::ApplyDecoImages();
	PlayMapAtSave::Enable(Map, C_EnablePlayMapAtSave);
	MenuSceneManager::IncrementSceneCount(LocalUser);

	// Reload author validation ghost
	// Do it before calling UpdateValidability()
	// because it will make sure that the ghost
	// is reset if the map is not valid anymore
	if (MapGet::GetAuthorGhostId() == NullId) {
		// Reload ghost from the map
		declare CGhost AuthorGhost = Mode.DataFileMgr.Map_GetAuthorGhost(Map);
		if (AuthorGhost != Null) {
			MapGet::ShareAuthorGhostId(AuthorGhost.Id);
		}
	}

	MapType::SetVersion(C_MapTypeVersion);
	UpdateValidability();

	HoldLoadingScreen = False;

	EnableMapTypeStartTest = True;	// declare that the script will take care of 'StartTest' event.

	while (True) {
		yield;

		Tracking::Yield(System, This);

		foreach(Event in PendingEvents) {
			switch(Event.Type) {
				case CMapEditorPluginEvent::Type::MapModified: {
					UpdateValidability();
					RaceTest::RemoveGhost();
				}
				case CMapEditorPluginEvent::Type::EditObjectives: {
					DisplayDefaultSetObjectivesDialog();
				}
				case CMapEditorPluginEvent::Type::StartValidation: {
					PlayValidationRun();
				}
				case CMapEditorPluginEvent::Type::StartTest: {
					PlayTestRun();
				}
			}
		}
	}
}