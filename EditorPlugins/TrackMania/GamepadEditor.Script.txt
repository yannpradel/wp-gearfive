/*
 *	Gamepad Editor
 */
#RequireContext CMapEditorPlugin

#Const	Version			"2023-02-15"
#Const	ScriptName		"GamepadEditor.Script.txt"
#Const	C_EditorVersion	"13.0.1"

#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "MapUnits" as MU
#Include "TimeLib" as TiL
#Include "Libs/Nadeo/TMConsole/UIPadButtons.Script.txt" as Buttons
#Include "Libs/Nadeo/TMConsole/Buttons.Script.txt" as Buttons2
#Include "Libs/Nadeo/TMConsole/SystemText.Script.txt" as SystemText
#Include "Libs/Nadeo/TMConsole/MapEditor/Utils.Script.txt" as Utils
#Include "Libs/Nadeo/TMConsole/MapEditor/Inputs.Script.txt" as Inputs
#Include "Libs/Nadeo/TMConsole/MapEditor/Sound.Script.txt" as Sound
#Include "Libs/Nadeo/TMConsole/MapEditor/Random.Script.txt" as Random
#Include "Libs/Nadeo/TMConsole/MapEditor/Macroblock.Script.txt" as Macroblock
#Include "Libs/Nadeo/TMConsole/MapEditor/MapContent.Script.txt" as MapContent
#Include "Libs/Nadeo/TMConsole/MapEditor/Placement.Script.txt" as Placement
#Include "Libs/Nadeo/TMConsole/MapEditor/ThemePack.Script.txt" as ThemePack
#Include "Libs/Nadeo/TMConsole/MapEditor/Layers.Script.txt" as Layers
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/Stylesheet.Script.txt" as Styles
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/Header.Script.txt" as UI_Header
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/StyleSelection.Script.txt" as UI_StyleSelection
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/BlockHelp.Script.txt" as UI_BlockHelp
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/TerrainPreview.Script.txt" as UI_TerrainPreview
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/MacroblockSelection.Script.txt" as UI_MacroblockSelection
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/SkinSelection.Script.txt" as UI_SkinSelection
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/SpawnSelection.Script.txt" as UI_SpawnSelection
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/DecoSelection.Script.txt" as UI_DecoSelection
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/PopUp.Script.txt" as UI_PopUp
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/SimpleChoice.Script.txt" as UI_SimpleChoice
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/Menu.Script.txt" as UI_Menu
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/SimpleMenu.Script.txt" as UI_SimpleMenu
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/RandomMenu.Script.txt" as UI_RandomMenu
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/ShadowMenu.Script.txt" as UI_ShadowMenu
//#Include "Libs/Nadeo/TMConsole/MapEditor/UI/MapStyleSelection.Script.txt" as UI_MapStyleSelection // TAG: MapStyleSelection
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/MenuOutro.Script.txt" as UI_MenuOutro
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/Tuto.Script.txt" as UI_Tuto
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/Progression.Script.txt" as UI_Progression
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/Multilaps.Script.txt" as UI_Multilaps
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/MouseControl.Script.txt" as UI_MouseControl
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/UI_Manager.Script.txt" as UI_Manager
#Include "Libs/Nadeo/TMConsole/MapEditor/UI/Save.Script.txt" as UI_Save
#Include "Libs/Nadeo/TMConsole/MapEditor/CutPaste.Script.txt" as CutPaste
#Include "Libs/Nadeo/TMConsole/MapEditor/Collection.Script.txt" as Collection
#Include "Libs/Nadeo/TMConsole/MapEditor/RandomStyles.Script.txt" as RandomStyles
#Include "Libs/Nadeo/TMConsole/MapEditor/Transitions.Script.txt" as Transitions
#Include "Libs/Nadeo/TMConsole/MapEditor/AutoFinish.Script.txt" as AutoFinish
#Include "Libs/Nadeo/TMConsole/MapEditor/BlockVariant.Script.txt" as BlockVariant
#Include "Libs/Nadeo/TMConsole/MapEditor/History2.Script.txt" as History2
#Include "Libs/Nadeo/TMConsole/MapEditor/Terrain.Script.txt" as Terrain
#Include "Libs/Nadeo/TMConsole/MapEditor/Selection.Script.txt" as Selection
#Include "Libs/Nadeo/TMConsole/MapEditor/WeightedListStack.Script.txt" as List
#Include "Libs/Nadeo/TMConsole/MapEditor/Share.Script.txt" as Share

// Settings
#Setting S_EditorLevel				2 // 0, 1, 2 for Beginner, Intermediate, Expert
#Setting S_CreateCopy					False
#Setting S_ShadowQuality			/*0//1/*/2/***/
#Setting S_RandomMap_Generate	False/*/True/***/
#Setting S_RandomMap_Validate	False/*/True/***/
#Setting S_RandomMap_Config		""
#Setting S_EnableSound				True

#Setting S_RandomMap_Seed		0
#Setting S_RandomMap_Length	""
#Setting S_RandomMap_Speed		""
#Setting S_RandomMap_Style		""
#Setting S_NoTerraforming		False // Prebuilt landscapes
#Setting S_NoExpertTerraforming		True // Expert handcrafted landscape edition
#Setting S_NoDecoration			True // For TMNext, don't show decoration progression, don't use random decoration. Expert can still place deco manually.
#Setting S_AutoName				True
#Setting S_CustomSavePrompt True

// Constants
#Const C_TerrainPreviewThreshold		1500		///< Duration before placing a terrain
#Const C_DefaultDecoAmount					0.			///< Default amount of deco of each type
#Const C_DefaultPodiumAmount				0.			///< Default amount of podium
#Const C_AutoFinish_MaxSteps				50			///< Maxium number of blocks to place when trying to auto-finish the track
#Const C_AutoFinish_MaxIterations	250			///< Maximum number of iterations during auto finish
#Const C_AutoFinish_PaddingTop			3				///< Minimum number of blocks between the clip and the top of the track
#Const C_RandomMap_MaxIterations		250			///< Maximum number of iterations during random track
#Const C_RandomMap_MaxTries				3				///< Maximum number of tries to generate a random track
#Const C_RandomDecorationDelay		500			///< Delay between two random decoration macroblock
#Const C_RandomTerrainId					"GamepadEditor_RandomTerrain"	///< Random terrain id
#Const C_InitialAutoRepeatDelay	250		///< Initial delay (in ms) before activating the autorepeat
#Const C_MaxAutoRepeatDelay			200		///< Maximum delay (in ms) between two press of a button to let the autorepeat active
#Const C_AutoRepeatTime			100				///< Time (in ms) between two activations of an autorepeat
#Const C_CursorVisibility		1.				///< Cursor visibility
#Const C_HideBlockHelpers		False			///< Hide block helpers
#Const C_Expert_AutoDir			False			///< Automatically direct the macroblock in a valid direction
#Const C_ShowPlacementGrid		False			///< Show the placement grid helper
#Const C_RandomLandscape			False			///< Use random terraforming in the normal editor
#Const C_FastTerraforming		True			///< Yield frequency during random terraforming
#Const C_FastLagoon					False			///< Speed up random generation on Lagoon
#Const C_CopperLimit_Soft		10000			///< Warn player that they are reaching the copper limit // currently m_CopperPriceThreshhold_WarningHigh
#Const C_CopperLimit_Hard		15000			///< Copper price limit // currently m_CopperPriceThreshhold_WarningVeryHigh
#Const C_CopperLimit_Deco		6000				///< Copper limit that start to lessen decoration
#Const C_DecoLimiter					0.5				///< Limit the decoration amount (1.=>full, 0.5=>medium, 0.=>empty)
#Const C_CheckpointGap				300.			///< Best distance between checkpoints
#Const C_RemoveAutoSwitchMode		False			///< Automatically switch to the mode of the removed block
#Const C_CutPasteBeginner			True			///< Allow cut paste in the beginner editor

#Const C_MapType "TrackMania\\TM_Race"

// Theme packs
#Const C_ThemePack_Beginner "file://Media/Config/Nadeo/TMConsole/MapEditor/BeginnerPack.xml"
#Const C_ThemePack_Advanced "file://Media/Config/Nadeo/TMConsole/MapEditor/ThemePacks.xml"
#Const C_ThemePack_Expert	"file://Media/Config/Nadeo/TMConsole/MapEditor/ExpertPacks.xml"

// Editor levels
#Const C_Editor_Beginner	0
#Const C_Editor_Advanced	1
#Const C_Editor_Expert		2

// Shadow quality
#Const C_Shadow_AlwaysAsk	0
#Const C_Shadow_Fast		1
#Const C_Shadow_Nice		2

// Ticks
#Const C_Tick_FilterMacroblockPlayer		75 ///< How much ticks the FilterMacroblocks2 can use when a player is creating a track. Lower ticks = lighter frames but more frames for a single action, feels more fluid
#Const C_Tick_FilterMacroblockRandom		150 ///< How much ticks the FilterMacroblocks2 can use when a track is being randomly generated. Higher ticks = heavier frames but less frames for a single action, goes faster
#Const C_Tick_GetFinishCoordBFS		100
#Const C_Tick_GetFinishCoordGBFS	100
#Const C_Tick_RandomDecorate		25
#Const C_Tick_BlockHelper			2500
#Const C_Tick_SaveMapContent		60

// Sequences
#Const C_Sequence_MainMenu				0	///< The player is in the main menu
#Const C_Sequence_PopUp					1	///< The player is in a pop up
#Const C_Sequence_SelectTerrain			2	///< The player must select a terrain
#Const C_Sequence_RandomTerrain			3	///< Random terrain settings
#Const C_Sequence_AutoTerrain			4	///< Terraforming the track automatically
#Const C_Sequence_PlaceStart			5	///< The player must place a start block
//#Const C_Sequence_ConnectMode			6	///< The player build the track after the start block in connect mode // Dead code, was never used
#Const C_Sequence_FreeMode				7	///< Free mode
#Const C_Sequence_TestMode				8	///< The player select a checkpoint to spawn
#Const C_Sequence_AutoFinish			9	///< Auto-finishing the track
#Const C_Sequence_EditTerrain			10	///< Terrain editing : add mode
#Const C_Sequence_AutoDecoration		11	///< Decorating the track automatically
#Const C_Sequence_EditDecoration		12	///< Decoration editing : add mode
#Const C_Sequence_RandomMap				13	///< Full random track generation
#Const C_Sequence_RerollMap				14	///< Reroll random track
//#Const C_Sequence_MapStyle				15	///< Track style selection // TAG: MapStyleSelection
#Const C_Sequence_Simple_Terraforming	16	///< Simple mode terraforming
#Const C_Sequence_Simple_AutoTerrain	17	///< Simple mode auto terraform terrain
#Const C_Sequence_Simple_PlaceStart		18	///< Simple mode place start
#Const C_Sequence_Simple_BuildTrack		19	///< Simple mode build track
#Const C_Sequence_Simple_MoveCursor		20	///< Simple mode move cursor
#Const C_Sequence_Simple_Test			21	///< Simple mode test
#Const C_Sequence_Simple_Deco			22	///< Simple mode decoration
#Const C_Sequence_Simple_Outro		23	///< Simple mode outro
#Const C_Sequence_Save						24	///< Save popup
#Const C_Sequence_None						-1	///< No sequence selected

// Simple choice events
#Const C_SimpleChoice_SelectLandscape	0	///< Select landscape
#Const C_SimpleChoice_StartTrack		1	///< Start track after selecting a landscape
#Const C_SimpleChoice_DecoGenerate		2	///< Generate random decoration
#Const C_SimpleChoise_DecoValid			3	///< Confirm decoration and start validation
#Const C_SimpleChoice_DecoCancel		4	///< Cancel decoration step and go back to track editing
#Const C_SimpleChoice_DecoDefault		5	///< Set the amount of each decoration category to their default value
#Const C_SimpleChoice_RandomGenerate	6	///< Generate a new random track
#Const C_SimpleChoice_RandomSave		7	///< Save the random track
#Const C_SimpleChoice_RandomPlay		8	///< Play on the random track
#Const C_SimpleChoice_RandomQuit		9	///< Quit Random track

// Category
#Const C_Categories [
	_("|Game mode - Edit Landscapes|Landscape"), 
	_("|Game mode - Edit Track|Track")
]
#Const C_Categories_Landscape	0
#Const C_Categories_Construct	1
// Modes
#Const C_Modes [
	_("|Game mode - Generation|Random"), 
	_("|Game mode - Prebuilt Landscapes|Postcards"),
	_("|Game mode - Edit Landscapes|Landscape"), 
	_("|Game mode - Edit Track|Track"), 
	_("|Game mode - Edit Decoration|Decoration")]
#Const C_Modes_LandscapeRandom		0
#Const C_Modes_LandscapePostcards	1
#Const C_Modes_ConstructTerrain		2
#Const C_Modes_ConstructTrack		3
#Const C_Modes_ConstructDeco		4

#Const C_Translations [
	_("|Blocks|Recent"), 
	_("|Blocks|Favorites")
]

// Auto repeat
#Const C_AutoRepeatDisabled [CMapEditorPluginEvent::EInput::Unknown, CMapEditorPluginEvent::EInput::Menu, CMapEditorPluginEvent::EInput::SwitchToRace, CMapEditorPluginEvent::EInput::CursorTurn, CMapEditorPluginEvent::EInput::CursorPick, CMapEditorPluginEvent::EInput::CursorPlace, CMapEditorPluginEvent::EInput::CursorDelete, CMapEditorPluginEvent::EInput::CameraZoomNext, CMapEditorPluginEvent::EInput::RemoveAll, CMapEditorPluginEvent::EInput::CursorTiltLeft, CMapEditorPluginEvent::EInput::CursorTiltRight]
#Const C_AutoRepeatEnabled [CMapEditorPluginEvent::EInput::Undo, CMapEditorPluginEvent::EInput::Redo, CMapEditorPluginEvent::EInput::CursorUp, CMapEditorPluginEvent::EInput::CursorRight, CMapEditorPluginEvent::EInput::CursorDown, CMapEditorPluginEvent::EInput::CursorLeft, CMapEditorPluginEvent::EInput::CursorRaise, CMapEditorPluginEvent::EInput::CursorLower, CMapEditorPluginEvent::EInput::CameraUp, CMapEditorPluginEvent::EInput::CameraRight, CMapEditorPluginEvent::EInput::CameraDown, CMapEditorPluginEvent::EInput::CameraLeft, CMapEditorPluginEvent::EInput::IconUp, CMapEditorPluginEvent::EInput::IconRight, CMapEditorPluginEvent::EInput::IconDown, CMapEditorPluginEvent::EInput::IconLeft]
#Const C_AutoRepeatCursor [CMapEditorPluginEvent::EInput::IconUp, CMapEditorPluginEvent::EInput::IconRight, CMapEditorPluginEvent::EInput::IconDown, CMapEditorPluginEvent::EInput::IconLeft, CMapEditorPluginEvent::EInput::CursorUp, CMapEditorPluginEvent::EInput::CursorRight, CMapEditorPluginEvent::EInput::CursorDown, CMapEditorPluginEvent::EInput::CursorLeft]
#Const C_AutoRepeatCamera [CMapEditorPluginEvent::EInput::CameraUp, CMapEditorPluginEvent::EInput::CameraRight, CMapEditorPluginEvent::EInput::CameraDown, CMapEditorPluginEvent::EInput::CameraLeft]
#Const C_StopGeneration [CMapEditorPluginEvent::EInput::Menu]

#Const C_Debug 				False	///< Global debug
#Const C_EnableLog			False	///< Global log switch
#Const C_LogToFile			False	///< Log to file
#Const C_LogThemePack		False	///< Log theme pack debug
#Const C_LogRandom 			False	///< Log random track generation progress
#Const C_DemoSony			False	///< Sony VR demo

// Avoid rewriting long variables everytime
#Const C_North 			CMapEditorPlugin::CardinalDirections::North
#Const C_East 			CMapEditorPlugin::CardinalDirections::East
#Const C_South 			CMapEditorPlugin::CardinalDirections::South
#Const C_West 			CMapEditorPlugin::CardinalDirections::West
#Const C_NorthEast 	CMapEditorPlugin::CardinalDirections8::NorthEast // be careful, you can use a CardinalDirections as a CardinalDirections8, but not the other way around
#Const C_SouthEast 	CMapEditorPlugin::CardinalDirections8::SouthEast
#Const C_SouthWest 	CMapEditorPlugin::CardinalDirections8::SouthWest
#Const C_NorthWest 	CMapEditorPlugin::CardinalDirections8::NorthWest

// Globales
declare Integer									G_CurrentSequence;		 ///< The current sequence
declare Integer									G_PrevSequence;			 ///< The previous sequence
declare Boolean									G_TestMode;				 ///< Player is in test mode
declare Integer									G_FreeModeVariant;		 ///< Force a variant in free mode
declare Integer									G_PreviewTerrainTime;	 ///< Time at which the terrain will be previewed
declare Text 									G_PreviewTerrainId;		 ///< Name of the terrain to preview
declare Boolean									G_GeneratingTerrain;	 ///< Editor is randomly generating terrain
declare Boolean									G_GeneratingDecoration;	 ///< Editor is randomly generating terrain
declare Boolean									G_RandomMapGeneration;	 ///< Generate a random track
declare Boolean									G_AutoFinishing;		 ///< Editor is trying to auto finish the track
declare Int3 									G_CursorCoord;			 ///< Real cursor coord
declare CMapEditorPlugin::CardinalDirections 	G_CursorDir; 			 ///< Real cursor dir
declare CMacroblockModel 						G_CursorMacroblockModel; ///< Real cursor macroblock model
declare Integer 								G_CursorConnectedTo;	 ///< Connection used for the current cursor
declare CMacroblockModel[][Text] 				G_AvailableMacroblocks;	///< Available macroblocks
declare Text[Ident] 							G_DiscardedMacroblocks;	///< Macroblocks discarded by the filtering
declare Integer[] 								G_AvailableConnectors;	 ///< Available connectors
declare Ident 									G_AvailableCheckpoint;	 ///< Is there a checkpoint available
declare Integer[CMapEditorPluginEvent::EInput] 	G_AutoRepeatInput; 		 ///< Input to auto repeat
declare Integer[CMapEditorPluginEvent::EInput] G_LastDeviceInput; ///< Last device use to do the input
declare CMapEditorPluginEvent::EInput[] 		G_InputBuffer;			 ///< Buffer the inputs
declare Integer[] 							G_DeviceBuffer;		///< Device used to generate the inputs
declare Text[][Text][] 					G_UIInputBuffer;	///< Buffer of UI inputs
declare Boolean 								G_CancelGeneration;		 ///< Stop the current auto-finish or random generation process
declare Boolean 								G_LeaveEditor;			 ///< Leave the editor
declare Boolean 								G_RestartGeneration;	 ///< Restart the random generation process
declare Boolean 								G_StartingNewMap;		 ///< True if we're starting a new track after placing the terrain
declare Boolean 								G_MainMenu;				 ///< True when in main menu
//declare Boolean 								G_MapStyleSelection;	 ///< True when in track style selection menu // TAG: MapStyleSelection
declare Integer 								G_Category;				 ///< Current category
declare Integer 								G_Mode;					 ///< Current mode
declare Boolean 								G_IsSkinning;			 ///< True when the player edit the skin of an object
declare Boolean 								G_IsEditing;			 ///< True when the player edit a macroblock
declare Int3 									G_ForcedCursorCoord;	 ///< Force the cursor coordinates
declare Int3[Integer] 							G_SavedCursorCoord; 	 ///< Saved cursor coordinates for differents sequences
declare Integer 								G_LastRandomPlace;		 ///< Last time a random macroblock was placed
declare Int3 									G_FilteringCoord;		 ///< Coordinates of the last macroblocks filter
declare Integer 								G_InactivityStartTime;	 ///< Time of the last player activity
declare Boolean 								G_AskForValidation;		 ///< Ask the player if they want to validate their track
declare Integer 								G_MacroblocksCount;		 ///< Number of macroblocks available
declare Integer 								G_Setting_EditorLevel;	 ///< Editor mode
declare Boolean 								G_WaitingRerollAnswer;	 ///< Waiting an answer to know if we reroll or not
declare Boolean 								G_RerollRandomMap;		 ///< Reroll random track or not
declare Boolean 								G_TestedRandomMap;		 ///< The random track was tested
declare CMapEditorPlugin::PlaceMode 			G_PlaceMode; 			 ///< Forced place mode
declare CMapEditorPlugin::EditMode				G_EditMode; 			 ///< Forced edit mode
declare Boolean 								G_HMD_IsActive;			 ///< HMD status
declare Boolean 								G_NeedRebuild;			 ///< Track must be rebuild to access history
declare Boolean 								G_MoveCursor;			 ///< Move cursor in simple mode
declare Boolean 								G_CanAskCheckpoint;		 ///< Can ask the player to place a checkpoint
declare Boolean 								G_TerrainCanPress;		 ///< Can press button to add terrain
declare CMacroblockModel[] 						G_RandomMacroblocks;	 ///< Macroblocks for the random generator
declare Boolean 								G_RebuildMap;			 ///< Trackbuilder is rebuilding a track
declare Text[Ident] 							G_CacheBlocksSkinsBg; 	 ///< Save the last Bg skin used on a block
declare Text[Ident] 							G_CacheBlocksSkinsFg; 	 ///< Save the last Fg skin used on a block
declare CBlockClipList 								G_FilterNextMacroblockClipList; ///< Used in FilterMacroblocks2, clips of next block
declare Boolean 								G_MustUnvalidate;		 ///< If the track has been modifield, it must be unvalidated
declare Integer[] 							G_AllowCameraRotation; // Sequences where you can turn the camera
declare Integer[] 							G_AllowCameraZoom; // Sequences where you can zoom the camera
declare Integer 								G_Platform;				///< Current platform used for the buttons
declare Boolean									G_AirModeMapping;
//declare Boolean									G_GhostModeMapping;	

// Functions

Void LogRandomMap(Text _Text) {
	if (C_LogRandom) Utils::Log(_Text);
}

Boolean InputIsDown(CMapEditorPluginEvent::EInput _Input) {
	switch (_Input) {
		case CMapEditorPluginEvent::EInput::Menu			: return EditorInputIsDown_Menu;
		case CMapEditorPluginEvent::EInput::SwitchToRace	: return EditorInputIsDown_SwitchToRace;
		case CMapEditorPluginEvent::EInput::Undo			: return EditorInputIsDown_Undo;
		case CMapEditorPluginEvent::EInput::Redo			: return EditorInputIsDown_Redo;
		case CMapEditorPluginEvent::EInput::CursorUp		: return EditorInputIsDown_CursorUp;
		case CMapEditorPluginEvent::EInput::CursorRight		: return EditorInputIsDown_CursorRight;
		case CMapEditorPluginEvent::EInput::CursorDown		: return EditorInputIsDown_CursorDown;
		case CMapEditorPluginEvent::EInput::CursorLeft		: return EditorInputIsDown_CursorLeft;
		case CMapEditorPluginEvent::EInput::CursorRaise		: return EditorInputIsDown_CursorRaise;
		case CMapEditorPluginEvent::EInput::CursorLower		: return EditorInputIsDown_CursorLower;
		case CMapEditorPluginEvent::EInput::CursorTurn		: return EditorInputIsDown_CursorTurn;
		case CMapEditorPluginEvent::EInput::CursorPick		: return EditorInputIsDown_CursorPick;
		case CMapEditorPluginEvent::EInput::CursorPlace		: return EditorInputIsDown_CursorPlace;
		case CMapEditorPluginEvent::EInput::CursorDelete	: return EditorInputIsDown_CursorDelete;
		case CMapEditorPluginEvent::EInput::CameraUp		: return EditorInputIsDown_CameraUp;
		case CMapEditorPluginEvent::EInput::CameraRight		: return EditorInputIsDown_CameraRight;
		case CMapEditorPluginEvent::EInput::CameraDown		: return EditorInputIsDown_CameraDown;
		case CMapEditorPluginEvent::EInput::CameraLeft		: return EditorInputIsDown_CameraLeft;
		case CMapEditorPluginEvent::EInput::CameraZoomNext	: return EditorInputIsDown_CameraZoomNext;
		case CMapEditorPluginEvent::EInput::IconUp			: return EditorInputIsDown_IconUp;
		case CMapEditorPluginEvent::EInput::IconRight		: return EditorInputIsDown_IconRight;
		case CMapEditorPluginEvent::EInput::IconDown		: return EditorInputIsDown_IconDown;
		case CMapEditorPluginEvent::EInput::IconLeft		: return EditorInputIsDown_IconLeft;
		case CMapEditorPluginEvent::EInput::RemoveAll		: return EditorInputIsDown_RemoveAll;
		case CMapEditorPluginEvent::EInput::CursorTiltLeft		: return EditorInputIsDown_CursorTiltLeft;
		case CMapEditorPluginEvent::EInput::CursorTiltRight		: return EditorInputIsDown_CursorTiltRight;
	}
	
	return False;
}

// ---------------------------------- //
/// Clear the input buffers
Void ClearInputBuffer() {
	G_InputBuffer.clear();
	G_DeviceBuffer.clear();
	G_UIInputBuffer.clear();
}


Void UpdateInputBuffer(CMapEditorPluginEvent::EInput _Input, Boolean _IsPad, Boolean _IsKeyboard, Boolean _IsMouse) {
	/*// Ignore mouse input
	if (_IsMouse) return;*/
	if (G_InputBuffer.exists(_Input)) return;

	if (UI_MacroblockSelection::IsSelecting() || C_AutoRepeatDisabled.exists(_Input)) {
		G_InputBuffer.add(_Input);
		G_DeviceBuffer.add(Buttons2::GetInputDevice(_IsPad, _IsKeyboard, _IsMouse));
	} else {
		if (!G_AutoRepeatInput.existskey(_Input)) G_AutoRepeatInput[_Input] = 0;
		
		if (Now > G_AutoRepeatInput[_Input]) {
			declare TimeSinceLastTrigger = Now - G_AutoRepeatInput[_Input];
			if (C_AutoRepeatCursor.exists(_Input)) {
				foreach (Input in C_AutoRepeatCursor) {
					if (!G_AutoRepeatInput.existskey(Input)) continue;
					if (Now - G_AutoRepeatInput[Input] < TimeSinceLastTrigger) {
						TimeSinceLastTrigger = Now - G_AutoRepeatInput[Input];
					}
				}
			} else if (C_AutoRepeatCamera.exists(_Input)) {
				foreach (Input in C_AutoRepeatCamera) {
					if (!G_AutoRepeatInput.existskey(Input)) continue;
					if (Now - G_AutoRepeatInput[Input] < TimeSinceLastTrigger) {
						TimeSinceLastTrigger = Now - G_AutoRepeatInput[Input];
					}
				}
			}
			
			declare NextTriggerTime = Now + C_InitialAutoRepeatDelay;
			if (TimeSinceLastTrigger <= C_MaxAutoRepeatDelay) {
				NextTriggerTime = Now + C_AutoRepeatTime;
			}
			G_AutoRepeatInput[_Input] = NextTriggerTime;
			G_InputBuffer.add(_Input);
			G_DeviceBuffer.add(Buttons2::GetInputDevice(_IsPad, _IsKeyboard, _IsMouse));
		}
	}
}

// ---------------------------------- //
/** Update the input buffer
 *
 *	@param	_Input					The input to add
 */
Void UpdateInputBuffer(CMapEditorPluginEvent::EInput _Input) {
	declare IsPad = False;
	declare IsKeyboard = False;
	declare IsMouse = False;
	
	if (G_LastDeviceInput.existskey(_Input)) {
		declare Device = G_LastDeviceInput[_Input];
		IsPad = (Device == Buttons2::Device_Pad());
		IsKeyboard = (Device == Buttons2::Device_Keyboard());
		IsMouse = (Device == Buttons2::Device_Mouse());
	}
	
	UpdateInputBuffer(_Input, IsPad, IsKeyboard, IsMouse);
}

// ---------------------------------- //
/** Update the UI input buffer
 *
 *	@param	_Type					The event type
 *	@param	_Data					The data
 */
Void UpdateUIInputBuffer(Text _Type, Text[] _Data) {
	G_UIInputBuffer.add([_Type => _Data]);
}

Text GetMapName() {
	declare metadata Text GamepadEditor_MapName for Map;
	return GamepadEditor_MapName;
}

// Check if we are in a given editor mode
Boolean IsEditor(Integer _Level) {
	if (S_RandomMap_Generate && _Level == C_Editor_Expert) return True; ///< Random editor is expert editor
	return (G_Setting_EditorLevel == _Level && !S_RandomMap_Generate);
}

// Check if the user is allowed to cut and paste
Boolean CutPasteIsAllowed() {
	return (
		!G_RandomMapGeneration && (
			IsEditor(C_Editor_Advanced) || (IsEditor(C_Editor_Beginner) && C_CutPasteBeginner)
		)
	);
}

Void ToggleAirMode() {
	G_AirModeMapping = !G_AirModeMapping; 
	UI_Header::SetAirMode(G_AirModeMapping);
}

/*Void ToggleGhostMode() {
	G_GhostModeMapping = !G_GhostModeMapping; 
	UI_Header::SetGhostMode(G_GhostModeMapping);
}*/

Void ToggleColor() {
	UI_Header::SetNextColor();
}

/// Display random generator menu
Void RandomMenu() {
	declare Wait = True;
	declare Answer = UI_RandomMenu::Selection_Null();
	if (G_CurrentSequence == C_Sequence_RandomMap) {
		UI_RandomMenu::SetOptions([UI_RandomMenu::Selection_Restart(), UI_RandomMenu::Selection_Quit(), UI_RandomMenu::Selection_Back()]);
	} else {
		if (S_RandomMap_Validate) {
			UI_RandomMenu::SetOptions([UI_RandomMenu::Selection_Quit(), UI_RandomMenu::Selection_Back()]);
		} else {
			UI_RandomMenu::SetOptions([UI_RandomMenu::Selection_Quit(), UI_RandomMenu::Selection_Back()]);
		}
	}
	UI_Manager::Show(UI_Manager::C_File_RandomMenu);
	Sound::Play("EditorPopUp");
	
	while (Wait) {
		yield; ///< Yield before events to remove first menu button press
		
		foreach (Event in PendingEvents) {
			if (Event.Type == CMapEditorPluginEvent::Type::EditorInput) {
				switch (Inputs::GetEventInput(Event.Input, Input.JapanStylePadButtons)) {
					case CMapEditorPluginEvent::EInput::Menu			: {
						Sound::Play("EditorMenuCancel");
						Wait = False;
					}
					case CMapEditorPluginEvent::EInput::CursorPlace	: {
						Answer = UI_RandomMenu::Valid();
						Wait = False;
					}
					case CMapEditorPluginEvent::EInput::CursorDelete	: {
						if (Event.IsFromPad) {
							Sound::Play("EditorMenuCancel");
							Wait = False;
						}
					}
					case CMapEditorPluginEvent::EInput::RemoveAll	: {
						if (Event.IsFromKeyboard) {
							Sound::Play("EditorMenuCancel");
							Wait = False;
						}
					}
					case CMapEditorPluginEvent::EInput::CursorUp		: UI_RandomMenu::Prev();
					case CMapEditorPluginEvent::EInput::CursorDown	: UI_RandomMenu::Next();
					case CMapEditorPluginEvent::EInput::IconUp			: UI_RandomMenu::Prev();
					case CMapEditorPluginEvent::EInput::IconDown		: UI_RandomMenu::Next();
				}
			} else if (Event.Type == CMapEditorPluginEvent::Type::LayerCustomEvent) {
				switch (Event.CustomEventType) {
					case UI_RandomMenu::Event_Hover(): UI_RandomMenu::Select(TL::ToInteger(Event.CustomEventData[0]), True);
					case UI_RandomMenu::Event_Click(): {
						UI_RandomMenu::Select(TL::ToInteger(Event.CustomEventData[0]));
						Answer = UI_RandomMenu::Valid();
						Wait = False;
					}
				}
			}
		}
	}

	switch (Answer) {
		case UI_RandomMenu::Selection_Restart(): {
			G_CancelGeneration = True;
			G_RestartGeneration = True;
		}
		case UI_RandomMenu::Selection_Quit(): {
			G_CancelGeneration = True;
			G_LeaveEditor = True;
		}
	}
	
	UI_Manager::Hide(UI_Manager::C_File_RandomMenu);
	
	// Clear input buffer
	ClearInputBuffer();
	G_TerrainCanPress = False;
}

/// Update the save status when the track is modified
Void MapModified() {
	if (GetMapName() == "") Utils::SetSaveStatus(Utils::SaveStatus_NotSaved());
	else Utils::SetSaveStatus(Utils::SaveStatus_Modified());
}

/// Check which help to display in the helper
Void CheckHelper() {
	tuningmark("CheckHelper");
	if (G_CurrentSequence == C_Sequence_FreeMode || G_CurrentSequence == C_Sequence_EditDecoration) {
		declare BlockHelp = [
			Buttons2::Editor_RaiseBlock() => _("|Infinitive - Elevate block cursor|Raise"),
			Buttons2::Editor_LowerBlock() => _("|Infinitive - Reduce block cursor height|Lower"),
			Buttons2::Editor_CameraMove() => _("|Move camera|Camera"),
			Buttons2::Editor_CameraZoom() => _("|Infinitive|Zoom")
		];

		if (G_IsEditing || G_IsSkinning) {
			BlockHelp[Buttons2::Editor_CopyBlock()] = _("|Infinitive|Copy");
			BlockHelp[Buttons2::Editor_RemoveBlock()] = _("|Infinitive|Remove");
		} else {
			BlockHelp[Buttons2::Editor_PlaceBlock()] = _("|Infinitive|Place");
			BlockHelp[Buttons2::Editor_TurnBlock()] = _("|Infinitive|Rotate");
			BlockHelp[Buttons2::Editor_Redo()] = _("|Infinitive - Ctrl Z System|Redo");
			BlockHelp[Buttons2::Editor_Undo()] = _("|Infinitive - Ctrl Z System|Undo");
			BlockHelp[Buttons2::Editor_BrowseBlocks()] = _("|Infinitive|Browse");
		}
		
		/*if (MapContent::HasStart()) 
			BlockHelp[Buttons2::Editor_OpenTest()] = _("|Infinitive - Try track|Test");*/
		
		UI_BlockHelp::SetOptions(BlockHelp);
	}
}

Boolean IsEnterPressedWhileInMenu(CMapEditorPluginEvent _Event){
	if(_Event.Type == CMapEditorPluginEvent::Type::KeyPress
			&& _Event.KeyName == "Return"
			&& (G_CurrentSequence == C_Sequence_MainMenu 
				|| G_CurrentSequence == C_Sequence_RerollMap 
				//|| G_CurrentSequence == C_Sequence_MapStyle // TAG: MapStyleSelection
				|| G_CurrentSequence == C_Sequence_SelectTerrain 
				|| G_CurrentSequence == C_Sequence_RandomTerrain 
				|| G_CurrentSequence == C_Sequence_Simple_Terraforming 
				|| G_CurrentSequence == C_Sequence_Simple_Deco 
				|| G_CurrentSequence == C_Sequence_Simple_Outro
				|| G_CurrentSequence == C_Sequence_Simple_Test) 
			)	return True;
	return False;
}


/// Check if we can display a tutorial to the player
Void CheckTuto() {
	if (G_RebuildMap) return; //< No tutorial during track rebuild
	tuningmark("CheckTuto");
	if (G_CurrentSequence == C_Sequence_Simple_BuildTrack) {
			
		declare LastCheckpointDistance = -1.; // we're trying to avoid calculating distance when unnecessary
		declare LastStopEngineDistance = -1.; // because it's a heavy operation
		
		// Checkpoint tuto
		if (IsEditor(C_Editor_Beginner)) {
			declare StartDistance = MapContent::GetDistanceTo(MapContent::Block_Start());
			if (StartDistance > 1500. && StartDistance < 2000.) {
				UI_Tuto::Enable(UI_Tuto::Tuto_Finish());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_Finish());
			}
			if(G_AvailableCheckpoint != NullId) LastCheckpointDistance = MapContent::GetDistanceTo(MapContent::Block_Checkpoint());
			if (LastCheckpointDistance != -1 && LastCheckpointDistance > C_CheckpointGap) {
				UI_Tuto::Enable(UI_Tuto::Tuto_Checkpoint());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_Checkpoint());
			}
		}
		
		// Switch tuto
		if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_Switch())) {
			if (UI_Tuto::Count(UI_Tuto::Tuto_Switch()) >= 1) {
				UI_Tuto::ValidateTuto(UI_Tuto::Tuto_Switch());
			} else if (G_AvailableConnectors.count > 1) {
				UI_Tuto::Enable(UI_Tuto::Tuto_Switch());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_Switch());
			}
		} else {
			UI_Tuto::Disable(UI_Tuto::Tuto_Switch());
		}
		
		// Test tuto
		if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_Test()) && MapContent::HasCheckpoint()) {
			UI_Tuto::Enable(UI_Tuto::Tuto_Test());
		} else {
			UI_Tuto::Disable(UI_Tuto::Tuto_Test());
		}
		
		if(!IsEditor(C_Editor_Beginner) && MapContent::Has(MapContent::Block_StopEngine())){ // Beginner mode has no stop engines
			// Stop engine tuto
			if(!UI_Tuto::IsValidated(UI_Tuto::Tuto_StopEngine()) || UI_Tuto::IsEnabled(UI_Tuto::Tuto_StopEngine())){
				LastStopEngineDistance = MapContent::GetDistanceTo(MapContent::Block_StopEngine());
				LastCheckpointDistance = MapContent::GetDistanceTo(MapContent::Block_Checkpoint());
			}
			if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_StopEngine()) && LastStopEngineDistance < LastCheckpointDistance) {
				UI_Tuto::Enable(UI_Tuto::Tuto_StopEngine());
			} else if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_StopEngine()) && LastStopEngineDistance >= LastCheckpointDistance) {
				UI_Tuto::ValidateTuto(UI_Tuto::Tuto_StopEngine());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_StopEngine());
			}
		}
	} else if (G_CurrentSequence == C_Sequence_Simple_MoveCursor) {
		// Connection modes tuto
		if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_ConnectMode())) {
			UI_Tuto::Enable(UI_Tuto::Tuto_ConnectMode());
		} else {
			UI_Tuto::Disable(UI_Tuto::Tuto_ConnectMode());
		}
	} else if (
		G_CurrentSequence == C_Sequence_FreeMode ||
		G_CurrentSequence == C_Sequence_PlaceStart ||
		G_CurrentSequence == C_Sequence_EditDecoration
	) {
		// Move tuto
		if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_MoveBlock()) && !G_IsEditing && !G_IsSkinning) {
			UI_Tuto::Enable(UI_Tuto::Tuto_MoveBlock());
		} else {
			UI_Tuto::Disable(UI_Tuto::Tuto_MoveBlock());
		}
		
		if (G_CurrentSequence == C_Sequence_PlaceStart) {
			// Multilaps tuto
			if (Cursor.MacroblockModel != Null && Cursor.MacroblockModel.HasMultilap && !UI_Tuto::IsValidated(UI_Tuto::Tuto_Multilaps())) {
				UI_Tuto::Enable(UI_Tuto::Tuto_Multilaps());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_Multilaps());
			}
		}
		
		if (G_CurrentSequence == C_Sequence_FreeMode || G_CurrentSequence == C_Sequence_EditDecoration) {
			// Macroblock selection tuto
			if (!G_IsEditing && !G_IsSkinning && !UI_Tuto::IsValidated(UI_Tuto::Tuto_Rosaces())) {
				UI_Tuto::Enable(UI_Tuto::Tuto_Rosaces());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_Rosaces());
			}
			
			// Switch build mode tuto
			if (!G_IsEditing && !G_IsSkinning && !UI_Tuto::IsValidated(UI_Tuto::Tuto_ChangeMode())) {
				UI_Tuto::Enable(UI_Tuto::Tuto_ChangeMode());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_ChangeMode());
			}
			
			// Editing tuto
			declare GamepadEditor_TutoEditCopy for This = False;
			if ((G_IsEditing || G_IsSkinning) && GamepadEditor_TutoEditCopy && !UI_Tuto::IsValidated(UI_Tuto::Tuto_Edit())) {
				UI_Tuto::Enable(UI_Tuto::Tuto_Edit());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_Edit());
			}
			
			// Skin tuto
			if (G_IsSkinning && !UI_Tuto::IsValidated(UI_Tuto::Tuto_Skin())) {
				UI_Tuto::Enable(UI_Tuto::Tuto_Skin());
			} else {
				UI_Tuto::Disable(UI_Tuto::Tuto_Skin());
			}
		}
	} else if (G_CurrentSequence == C_Sequence_EditTerrain) {
		// Edit terrain tuto
		if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_EditTerrain())) {
			UI_Tuto::Enable(UI_Tuto::Tuto_EditTerrain());
		} else {
			UI_Tuto::Disable(UI_Tuto::Tuto_EditTerrain());
		}
	}
}

Void Yield() {
	yield;
	
	
	if(G_MustUnvalidate){
		UnvalidatePlayfield();
		G_MustUnvalidate = False;
	}

	declare AskStopGeneration = False;
	
	foreach (Event in PendingEvents) {
		if(IsEnterPressedWhileInMenu(Event)){ // Hack to be able to press Enter in menus
			UpdateInputBuffer(CMapEditorPluginEvent::EInput::CursorPlace);
		}
		else if (Event.Type == CMapEditorPluginEvent::Type::EditorInput) {
			declare CMapEditorPluginEvent::EInput EventInput = Inputs::GetEventInput(Event.Input, Input.JapanStylePadButtons);
			// Save device used to generate input
			if (Event.IsFromPad) {
				G_LastDeviceInput[EventInput] = Buttons2::Device_Pad();
			} else if (Event.IsFromKeyboard) {
				G_LastDeviceInput[EventInput] = Buttons2::Device_Keyboard();
			} else if (Event.IsFromMouse) {
				G_LastDeviceInput[EventInput] = Buttons2::Device_Mouse();
			}
			
			if (UI_MacroblockSelection::IsSelecting() || C_AutoRepeatDisabled.exists(EventInput)) {
				UpdateInputBuffer(EventInput, Event.IsFromPad, Event.IsFromKeyboard, Event.IsFromMouse);
			}
			if (
				(G_CurrentSequence == C_Sequence_RandomMap || G_CurrentSequence == C_Sequence_AutoFinish) &&
				C_StopGeneration.exists(EventInput)
			) {
				AskStopGeneration = True;
			}
		} else if (Event.Type == CMapEditorPluginEvent::Type::MapModified) {
			MapModified();
		} else if (Event.Type == CMapEditorPluginEvent::Type::LayerCustomEvent) {
			declare Text[] Data;
			foreach (Value in Event.CustomEventData) Data.add(Value);
			UpdateUIInputBuffer(Event.CustomEventType, Data);
		}
	}
	
	foreach (Input in C_AutoRepeatEnabled) {
		if (!UI_MacroblockSelection::IsSelecting() && InputIsDown(Input)) {
			UpdateInputBuffer(Input);
		} else {
			G_AutoRepeatInput[Input] = 0;
		}
	}
	
	// Force cursor coordinates
	if (Cursor.Coord != G_ForcedCursorCoord)
		Cursor.Coord = G_ForcedCursorCoord;
	
	// Update platform
	declare Platform = UI_Tuto::GetPlatform();
	if (G_Platform != Platform) {
		G_Platform = Platform;
		CheckTuto();
	}
	
	// Block help
	if (UI_BlockHelp::CanBeVisible()) {
		UI_Manager::SetBlockHelpCanBeVisibleMode(False);
		// Force helper display when there are less than 5 blocks on the track
		if (
			IsEditor(C_Editor_Beginner) || 
			G_TestMode || 
			G_WaitingRerollAnswer ||
			(!IsEditor(C_Editor_Expert) && MapContent::Count() < 5)
		) {
			if (!UI_BlockHelp::LayerIsVisible()){
				CheckHelper();
				UI_Manager::Show(UI_Manager::C_File_BlockHelp);
			}
		} else {
			declare Activities = 
				PendingEvents.count > 0 || 
				G_InputBuffer.count > 0 || 
				G_UIInputBuffer.count > 0 ||
				IsEditor(C_Editor_Expert) && (
					UI_MacroblockSelection::IsSelecting()
				);
				
			if (UI_BlockHelp::LayerIsVisible()) {
				if (Activities) {
					UI_Manager::Hide(UI_Manager::C_File_BlockHelp);
					G_InactivityStartTime = Now;
				}
			} else {
				if (Activities) {
					G_InactivityStartTime = Now;
				} else if (G_InactivityStartTime + C_Tick_BlockHelper <= Now) {
					CheckHelper();
					UI_Manager::Show(UI_Manager::C_File_BlockHelp);
					Sound::Play("EditorBlockHelp");
				}
			}
		}
		UI_Manager::SetBlockHelpCanBeVisibleMode(True);
	}
	
	// Force place and edit modes
	if (PlaceMode != G_PlaceMode) PlaceMode = G_PlaceMode;
	if (EditMode != G_EditMode) EditMode = G_EditMode;
	
	//declare IgnoreCameraCollisions = (G_IsEditing || G_IsSkinning || IsEditor(C_Editor_Expert)); 
	//Camera.IgnoreCameraCollisions(IgnoreCameraCollisions);
		
	// Stop random generation ?
	if (AskStopGeneration) {
		// Cancel random track
		if (G_CurrentSequence == C_Sequence_RandomMap) {
			RandomMenu();
		} 
		// Cancel auto-finish
		else {
			UI_PopUp::Confirm(
				//L16N [MapEditor] Title of the pop-up asking the player if they really want to cancel the ongoing auto-finish process. The auto-finish is a function of the track editor that automatically places a finish block in an uncomplete track.
				_("Stop auto-finish"), 
				//L16N [MapEditor] Text of the pop-up asking the player if they really want to cancel the ongoing auto-finish process. The auto-finish is a function of the track editor that automatically places a finish block in an uncomplete track.
				_("Do you want to stop the auto-finish?"), 
				_("Yes"), 
				_("No")
			);
		
			Sound::Play("EditorPopUp");
		
			while (UI_PopUp::Wait()) yield;
			
			// Clear input buffer
			ClearInputBuffer();
			G_TerrainCanPress = False;
			
			G_CancelGeneration = UI_PopUp::Answer();
		}
	}
}

Void Sleep(Integer _Duration) {
	declare EndTime = Now + _Duration;
	while (Now < EndTime) {
		Yield();
	}
}

/// Wait for the editor to be ready
Void WaitReady() {
	while (!IsEditorReadyForRequest) Yield();
}

// Create a multilines Text from an array of messages
Text ComposeMultilines(Text[] _Messages) {
	if (_Messages.count <= 0) return "";
	
	declare ComposeMessage = "";
	for (I, 1, _Messages.count) {
		if (ComposeMessage != "") ComposeMessage ^= "\n";
		ComposeMessage ^= "%"^I;
	}
	
	declare Message = "";
	switch (_Messages.count) {
		case 1	: Message = TL::Compose(ComposeMessage, _Messages[0]);
		case 2	: Message = TL::Compose(ComposeMessage, _Messages[0], _Messages[1]);
		case 3	: Message = TL::Compose(ComposeMessage, _Messages[0], _Messages[1], _Messages[2]);
		case 4	: Message = TL::Compose(ComposeMessage, _Messages[0], _Messages[1], _Messages[2], _Messages[3]);
		default	: Message = TL::Compose(ComposeMessage, _Messages[0], _Messages[1], _Messages[2], _Messages[3], _Messages[4]);
	}
	
	return Message;
}

Void SetMapName(Text _MapName) {
	declare metadata Text GamepadEditor_MapName for Map;
	GamepadEditor_MapName = _MapName;
}

// Check if we are in a constrained editor mode
Boolean IsSimpleEditor() {
	return (!S_RandomMap_Generate && (G_Setting_EditorLevel == C_Editor_Beginner || G_Setting_EditorLevel == C_Editor_Advanced));
}

// Check if we can display a notification in the cursor helper
Boolean CanNotify() {
	return (
		!G_RebuildMap && (
			G_CurrentSequence == C_Sequence_Simple_PlaceStart ||
			G_CurrentSequence == C_Sequence_Simple_BuildTrack ||
			G_CurrentSequence == C_Sequence_Simple_MoveCursor ||
			G_CurrentSequence == C_Sequence_PlaceStart ||
			G_CurrentSequence == C_Sequence_FreeMode ||
			G_CurrentSequence == C_Sequence_EditTerrain ||
			G_CurrentSequence == C_Sequence_EditDecoration
		)
	);
}

// Check if we have to check coppers limit
Boolean MustCheckCoppersLimit() {
	return (
		!G_RandomMapGeneration &&
		!G_RebuildMap && (
			G_CurrentSequence == C_Sequence_FreeMode ||
			G_CurrentSequence == C_Sequence_EditTerrain ||
			G_CurrentSequence == C_Sequence_EditDecoration ||
			G_CurrentSequence == C_Sequence_Simple_BuildTrack ||
			G_CurrentSequence == C_Sequence_Simple_MoveCursor
		)
	);
}

//	Check if the track is terraformed
Boolean IsTerraformed() {
	if (!IsSimpleEditor() && !S_RandomMap_Generate) return True;
	
	declare metadata Boolean GamepadEditor_IsTerraformed for Map;
	return GamepadEditor_IsTerraformed;
}

// Check if the track is decorated in simple mode
Boolean IsDecorated() {
	declare metadata Boolean GamepadEditor_IsDecorated for Map;
	return GamepadEditor_IsDecorated;
}

// Check if the decoration was confirmed
Boolean DecoConfirmed() {
	declare metadata Boolean GamepadEditor_DecoConfirmed for Map;
	return GamepadEditor_DecoConfirmed;
}

// Check if the editor is busy generating terrain
Boolean IsGeneratingTerrain() {
	return G_GeneratingTerrain;
}

// Save if the track has a custom terrain or not
Void SetCustomTerrain(Boolean _Custom) {
	declare metadata Boolean GamepadEditor_IsCustomTerrain for Map;
	GamepadEditor_IsCustomTerrain = _Custom;
}

// Check if the terrain is customized
Boolean IsCustomTerrain() {
	declare metadata Boolean GamepadEditor_IsCustomTerrain for Map;
	return GamepadEditor_IsCustomTerrain;
}

// Check if the player is editing the terrain
Boolean IsEditingTerrain() {
	return G_Mode == C_Modes_ConstructTerrain;
}

// Check if the player is placing a start block
Boolean IsPlacingStart() {
	return G_CurrentSequence == C_Sequence_PlaceStart || G_CurrentSequence == C_Sequence_Simple_PlaceStart;
}

// Check if the editor is generating decoration
Boolean IsGeneratingDecoration() {
	return G_GeneratingDecoration;
}

// Check if the player is editing the decoration
Boolean IsEditingDecoration() {
	return (G_Mode == C_Modes_ConstructDeco);
}

// Check if the editor is auto-finishing the track
Boolean IsAutoFinishing() {
	return G_AutoFinishing;
}

// Check if the player is in free mode
Boolean IsFreeMode() {
	return (
		(!IsSimpleEditor() || (IsSimpleEditor() && G_MoveCursor)) && 
		!G_RandomMapGeneration && 
		G_Mode == C_Modes_ConstructTrack
	);
}

// Force a specific variant of block in free mode
Void SetFreeModeVariant(Integer _Variant) {
	if (!Macroblock::VariantExists(_Variant)) return;
	
	G_FreeModeVariant = _Variant;
}

// Turn on or off the underground mode based on the selected macroblock model
Void SetUndergroundMode(CMacroblockModel _MacroblockModel) {
	declare Variant <=> Macroblock::GetBlockModelVariant(_MacroblockModel);
	if (Variant != Null) {
		UndergroundMode = Variant.IsAllUnderground;
	} else {
		UndergroundMode = False;
	}
}

// Check if we can place a macroblock on the track with or without any transition
Boolean CustomCanPlaceMacroblock(CMacroblockModel _MacroblockModel, Int3 _Coord, CMapEditorPlugin::CardinalDirections _Dir, Boolean _AllowTransition) {
	tuningmark("CustomCanPlaceMacroblock 1");
	declare CanPlace = False;
	// Can we place macroblock directly ?
	CanPlace = CanPlaceMacroblock_NoTerrain(_MacroblockModel, _Coord, _Dir);
	// If not, check if we can place macroblock with a transition
	if (!CanPlace && _AllowTransition){
		CanPlace = Transitions::SearchTransitions(_MacroblockModel, _Coord, _Dir, False);
		if(CanPlace)
			G_MustUnvalidate = True;
	}
	// Allow terrain for some macroblocks
	if (!CanPlace && !G_RandomMapGeneration && !IsAutoFinishing() && ThemePack::CanPlaceTerrain(_MacroblockModel)) {
		CanPlace = CanPlaceMacroblock(_MacroblockModel, _Coord, _Dir);
	}
	tuningmark("CustomCanPlaceMacroblock 2");
	// Random generator
	if (CanPlace && (G_RandomMapGeneration || IsGeneratingDecoration())) {
		// If we can place the block normally, check if there's no collision with an existing custom collision block
		if (MapContent::HasCollisions()) {
			declare MacroblockUnitCoords = Macroblock::GetCoords(_MacroblockModel, _Coord, _Dir);
			declare CollisionsCoords = MapContent::GetCollisions();
			foreach (MacroblockUnitCoord in MacroblockUnitCoords) {
				if (CollisionsCoords.existskey(MacroblockUnitCoord)) {
					CanPlace = False;
					break;
				}
			}
		}
		tuningmark("CustomCanPlaceMacroblock 3");
		// If the block we're trying to place has custom collision blocks, check that it doesn't collide with another block
		if (CanPlace && Macroblock::HasCollision(_MacroblockModel)) {
			declare MacroblockCollisionsCoords = Macroblock::GetCollisionsCoords(_MacroblockModel, _Coord, _Dir);
			foreach (MacroblockCollisionCoord in MacroblockCollisionsCoords) {
				if(GetMacroblockInstanceFromUnitCoord(MacroblockCollisionCoord) != Null){
					CanPlace = False;
					break;
				}
			}
		}
	}
	
	return CanPlace;
}

// Get a new instance of the given macroblock instead of a possibly outdated reference
CMacroblockModel GetSafeMacroblockModel(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return Null;
	if (MacroblockModels.existskey(_MacroblockModel.Id)) return MacroblockModels[_MacroblockModel.Id];
	return Null;
}

// Set the cursor macroblock model
// @param	_NewMacroblockModel		The new macroblock model
// @param	_TargetMacroblockModel	The macroblock model to restore when possible
Void SetCursorMacroblockModel(CMacroblockModel _NewMacroblockModel, CMacroblockModel _TargetMacroblockModel) {

	Cursor.MacroblockModel = _NewMacroblockModel;
	G_CursorMacroblockModel = GetSafeMacroblockModel(_TargetMacroblockModel);
}
Void SetCursorMacroblockModel(CMacroblockModel _NewMacroblockModel) {
	Cursor.MacroblockModel = _NewMacroblockModel;
	G_CursorMacroblockModel = GetSafeMacroblockModel(_NewMacroblockModel);
}

/// Check if we can give an advice to the player
Void CheckAdvices() {
	if (!IsSimpleEditor() || G_RebuildMap) return; //< No advices during track rebuild
	if (G_CurrentSequence == C_Sequence_Simple_BuildTrack) {
		declare LastCheckpointDistance = MapContent::GetDistanceTo(MapContent::Block_Checkpoint());
		declare LastStopEngineDistance = MapContent::GetDistanceTo(MapContent::Block_StopEngine());
				
		if (G_MacroblocksCount <= 0) {
			UI_Header::SetTitle(_("Can't place any block from this family, try another one"), True, UI_Header::Status_Error());
		} else if (LastStopEngineDistance != -1 && LastStopEngineDistance < LastCheckpointDistance) {
			UI_Header::SetTitle(_("You can't accelerate until the next checkpoint"), True, UI_Header::Status_Alert());
		} else if (G_AvailableCheckpoint != NullId && LastCheckpointDistance > C_CheckpointGap) {
			UI_Header::SetTitle(_("Try to place checkpoints regularly"), True, UI_Header::Status_Alert());
		} else {
			UI_Header::SetTitle(_("|Infinitive|Build your track"), True);
		}
	}
}

/// Check the current progression of the player in the track creation process
Void CheckProgression() {
	if (IsEditor(C_Editor_Advanced) && !IsTerraformed() && !S_NoTerraforming) {
		UI_Progression::SetStep(UI_Progression::Step_Landscape());
	} else if (!MapContent::HasStart()) {
		UI_Progression::SetStep(UI_Progression::Step_Start());
	} else if (
		(!MapContent::HasFinish() && !MapContent::HasMultilap()) || 
		(MapContent::HasMultilap() && !MapContent::HasCheckpoint())
	) {
		UI_Progression::SetStep(UI_Progression::Step_Track());
	} else if(IsEditor(C_Editor_Advanced) && !DecoConfirmed() && !S_NoDecoration) {
		UI_Progression::SetStep(UI_Progression::Step_Deco());
	} else if (ValidationStatus != CMapEditorPlugin::ValidationStatus::Validated) {
		UI_Progression::SetStep(UI_Progression::Step_Validation());
	} else if (Utils::GetSaveStatus() != Utils::SaveStatus_Saved()) {
		UI_Progression::SetStep(UI_Progression::Step_Save());
	} else {
		UI_Progression::SetStep(UI_Progression::Step_Complete());
	}
}

// Automatically select the right position for the UIs
Void CheckUIPosition(Integer _Sequence) {
	// Simple choice
	if (_Sequence == C_Sequence_Simple_Terraforming) {
		UI_SimpleChoice::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 1.>, Styles::CircleSize_Bottom()).Y);
	} else if (_Sequence == C_Sequence_Simple_Deco) {
		UI_SimpleChoice::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 1.>, Styles::CircleSize_Bottom()).Y);
	} else if (_Sequence == C_Sequence_RerollMap) {
		if (ManiaPlanet != Null && ManiaPlanet.HMD_IsActive) {
			UI_SimpleChoice::SetPositionY(Styles::Margin_Top() - Styles::GetSize2(<0., 10.>, Styles::CircleSize_Bottom()).Y);
		} else {
			UI_SimpleChoice::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 1.>, Styles::CircleSize_Bottom()).Y);
		}
	}
	
	// Spawn selection
	if (_Sequence == C_Sequence_TestMode) {
		UI_SpawnSelection::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 5.>, Styles::CircleSize_Bottom()).Y);
	} else if (_Sequence == C_Sequence_Simple_Test) {
		UI_SpawnSelection::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 5.>, Styles::CircleSize_Bottom()).Y);
	}
	
	// Style selection
	if (_Sequence == C_Sequence_Simple_Terraforming) {
		UI_StyleSelection::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 2.>, Styles::CircleSize_Bottom()).Y);
	} else {
		UI_StyleSelection::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 6.>, Styles::CircleSize_Bottom()).Y);
		UI_StyleSelection::ShowLandscapeButtons(False, False, False);
	}
	
	// Progression
	if (_Sequence == C_Sequence_Simple_Outro) {
		declare FullHeaderSizeX = Styles::GetHeaderSize2() + 4.;
		declare PosX = (FullHeaderSizeX - 36.) - (FullHeaderSizeX * 0.5) + (36. * 0.5);
		UI_Progression::SetPosition(<0., Styles::Margin_Bottom()> + Styles::GetSize2(<PosX, 7.>, Styles::CircleSize_Bottom()));
		UI_Header::SetAuthorPosition(<0., Styles::Margin_Bottom()> + Styles::GetSize2(<PosX, 8.>, Styles::CircleSize_Bottom()));
	} else if (IsEditor(C_Editor_Expert)) {
		UI_Progression::SetPosition(Styles::GetSize2(<0., -3.>, Styles::CircleSize_Bottom())); // TAG: MapStyleSelection Use Y = -4. 
	} else if (_Sequence == C_Sequence_MainMenu) {
		UI_Progression::SetPosition(Styles::GetSize2(<0., -2.>, Styles::CircleSize_Bottom()));
	} else {
		UI_Header::SetVisibility(True, True, False);
	}
	
	// Header
	if (IsEditor(C_Editor_Beginner)) {
		UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 5.>, Styles::CircleSize_Bottom()).Y);
	} else if (IsEditor(C_Editor_Advanced)) {
		if (_Sequence == C_Sequence_Simple_Test) {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 4.>, Styles::CircleSize_Bottom()).Y);
		} else if (_Sequence == C_Sequence_Simple_Terraforming) {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 3.>, Styles::CircleSize_Bottom()).Y);
		} else if (_Sequence == C_Sequence_Simple_Deco) {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 4.>, Styles::CircleSize_Bottom()).Y);
		} else if (_Sequence == C_Sequence_Simple_Outro) {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 9.>, Styles::CircleSize_Bottom()).Y);
		} else {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 7.>, Styles::CircleSize_Bottom()).Y);
		}
	} else {
		if (_Sequence == C_Sequence_RerollMap) {
			if (ManiaPlanet != Null && ManiaPlanet.HMD_IsActive) {
				UI_Header::SetPositionY(Styles::Margin_Top());
			} else {
				UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 2.>, Styles::CircleSize_Bottom()).Y);
			}
		} else if (_Sequence == C_Sequence_TestMode) {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 7.>, Styles::CircleSize_Bottom()).Y);
		} else if (G_IsSkinning && _Sequence != C_Sequence_EditTerrain) {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 6.>, Styles::CircleSize_Bottom()).Y);
		} else {
			UI_Header::SetPositionY(Styles::Margin_Bottom() + Styles::GetSize2(<0., 2.>, Styles::CircleSize_Bottom()).Y);
		}
	}
}

// Get the coordinates of the edited block units
Int3[] GetEditedBlockUnits(Int3 _Coord) {
	tuningmark("GetEditedBlockUnits");
	declare SkinMacroblockInstance = GetMacroblockInstanceFromUnitCoord(Cursor.Coord);
	if (SkinMacroblockInstance == Null)
		SkinMacroblockInstance = GetMacroblockInstanceFromUnitCoord(_Coord);
	
	if (SkinMacroblockInstance != Null) {
		declare Type = SkinMacroblockInstance.UserData;
		declare MacroblockModel = SkinMacroblockInstance.MacroblockModel;
		declare Coord = SkinMacroblockInstance.Coord;
		declare Dir = SkinMacroblockInstance.Dir;
		
		if (Type == C_Modes_ConstructTrack || Type == C_Modes_ConstructDeco) 
		{
			if((MacroblockModel == G_CursorMacroblockModel && Coord == Cursor.Coord && Dir == Cursor.Dir)
					|| (Macroblock::Collide(MacroblockModel, Coord, Dir, G_CursorMacroblockModel, Cursor.Coord, Cursor.Dir)
							&& (MacroblockModel != G_CursorMacroblockModel || Dir != Cursor.Dir))) 
			{
				if (MacroblockModel != Null) {
					declare GamepadEditor_TutoEditCopy for This = False;
					GamepadEditor_TutoEditCopy = !MacroblockModel.HasStart && !MacroblockModel.HasMultilap;
				}
			}
			
			return Macroblock::GetCoords(MacroblockModel, Coord, Dir);
		}
	}
	return [];
}

// Hide or show the skin selection UI for a given coordinate
Void DisplaySkinSelection(Int3 _Coord) {
	tuningmark("DisplaySkinSelection");
	G_IsSkinning = False;
	if (IsSimpleEditor()) return;
	if (
		G_CurrentSequence != C_Sequence_FreeMode &&
		G_CurrentSequence != C_Sequence_PlaceStart &&
		G_CurrentSequence != C_Sequence_EditDecoration
	) return;
	
	UI_SkinSelection::CancelPreview();
	
	declare IsSkinnable = False;
	declare Int3[] SkinnableBlockCoords;
	declare Int3[] BlockUnitsCoords;
	declare SkinnableItemsFound = False;
	
	// Check if there's a macroblock at our cursor coord
	declare SkinMacroblockInstance = GetMacroblockInstanceFromUnitCoord(Cursor.Coord);
	
	// If not, check if there's a macroblock at the given coord
	if (SkinMacroblockInstance == Null)
		SkinMacroblockInstance = GetMacroblockInstanceFromUnitCoord(_Coord);
	
	// If still not, check if there's the exact macroblock that we have in the cursor (in case it's just been placed)
	if (SkinMacroblockInstance == Null) {
		declare UnitCoord = Macroblock::GetBlockUnitCoord(G_CursorMacroblockModel, Cursor.Coord, Cursor.Dir);
		declare MBInstance = GetMacroblockInstanceFromUnitCoord(UnitCoord);
		if (MBInstance != Null && G_CursorMacroblockModel != Null && MBInstance.MacroblockModel != Null 
			&& MBInstance.MacroblockModel.Id == G_CursorMacroblockModel.Id 
			&& Cursor.Coord == MBInstance.Coord && Cursor.Dir == MBInstance.Dir)
			SkinMacroblockInstance = MBInstance;
	}
		
	if (SkinMacroblockInstance != Null) {
		// get its unit coords to find its skinnable blocks
		BlockUnitsCoords = Macroblock::GetCoords(
			SkinMacroblockInstance.MacroblockModel,
			SkinMacroblockInstance.Coord,
			SkinMacroblockInstance.Dir
		);

		foreach (Coord in BlockUnitsCoords) {
			declare Block <=> GetBlock(Coord);
			if (Block == Null) continue;
			// Using the block.Coord directly for uniqueness didn't work: sometimes there's no blockunit at that coord
			declare UniqueSkinnableCoord = Block.Coord + Block.BlockUnits[0].AbsoluteOffset;
			
			if (UI_SkinSelection::IsSkinnable(Block) && !SkinnableBlockCoords.exists(UniqueSkinnableCoord)) {
				SkinnableBlockCoords.add(UniqueSkinnableCoord);
				IsSkinnable = True;
			}
		}
		
		// Some macroblocks just have items. If they do, consider they're automatically Multi skins.
		// However, don't compute this if we already know that we've got multiple skinnable coords
		// in which case we already have Multi Skins anyways. It's a bit heavy to compute, don't do it for nothing.
		if (SkinnableBlockCoords.count < 2) {
			ComputeItemsForMacroblockInstance(SkinMacroblockInstance);
			
			foreach (ResultItem in MacroblockInstanceItemsResults) {
				if(IsItemModelSkinnable(ResultItem.ItemModel)) {
					SkinnableItemsFound = True;
					break;
				}
			}
		}
		
		// If we have found skinnable blocks, we allow skinning, except for Multiskin macroblocks that are already skinned by default.
		// These are marked in the XML with randomskin="0"
		if (SkinnableBlockCoords.count > 1 || SkinnableItemsFound) {
			IsSkinnable = ThemePack::CanSkin(SkinMacroblockInstance.MacroblockModel);
		}
	}
	
	if (IsSkinnable) {
		G_IsSkinning = True;
		UI_SkinSelection::SetMacroblockInstance(SkinMacroblockInstance, SkinnableBlockCoords, SkinnableItemsFound);
		if (!UI_SkinSelection::LayerIsVisible()) {
			UI_Manager::Show(UI_Manager::C_File_SkinSelection);
			UI_Manager::Hide(UI_Manager::C_File_Header);
			UI_Manager::Hide(UI_Manager::C_File_MacroblockSelection);
			SetCursorMacroblockModel(Null, G_CursorMacroblockModel);
		}
		CustomSelectionCoords.clear();
		foreach (BlockCoord in BlockUnitsCoords) {
			CustomSelectionCoords.add(BlockCoord);
		}

		CustomSelectionRGB = <0.1, 0.1, 0.1>;
		
		if (CustomSelectionCoords.count > 0)
			Cursor.Brightness = 0.;
	} else {
		UI_SkinSelection::SetMacroblockInstance(Null, [], False);
		G_IsSkinning = False;
		if (UI_SkinSelection::LayerIsVisible()) {
			UI_Manager::Hide(UI_Manager::C_File_SkinSelection);
			UI_Manager::Show(UI_Manager::C_File_Header);
			UI_Manager::Show(UI_Manager::C_File_MacroblockSelection);
			SetCursorMacroblockModel(G_CursorMacroblockModel);
		}
	}
	
	CheckUIPosition(G_CurrentSequence);
}

/// Set the style of the cursor
Void SetCursorStyle() {
	tuningmark("SetCursorStyle");
	G_IsEditing = False;
	
	if (G_IsSkinning) {
		Cursor.Brightness = 0.;
		return;
	}
	
	declare CanPlaceTerrain = False;
	
	if (G_CurrentSequence == C_Sequence_EditDecoration || G_CurrentSequence == C_Sequence_FreeMode) {
		CustomSelectionCoords.clear();
		
		// Check si là où on pose le bloc il y a déjà exactement le meme bloc, meme dir, meme coord (ex : bloc vient d'être placé)
		declare UnitCoord = Macroblock::GetBlockUnitCoord(G_CursorMacroblockModel, Cursor.Coord, Cursor.Dir);
		declare MBInstance = GetMacroblockInstanceFromUnitCoord(UnitCoord);
		declare CursorMBInstance = GetMacroblockInstanceFromUnitCoord(Cursor.Coord);
		if((CursorMBInstance == Null || CursorMBInstance == MBInstance) && MBInstance != Null 
				&& G_CursorMacroblockModel != Null && 	MBInstance.MacroblockModel != Null 
				&& MBInstance.MacroblockModel.Id == G_CursorMacroblockModel.Id 
				&& Cursor.Coord == MBInstance.Coord && Cursor.Dir == MBInstance.Dir){
			// Cas: Le macroblock qu'on passe existe déjà dans exactement la meme position : le selectionner et passer tout autre test
			foreach(BlockUnitCoord in MBInstance.UnitCoords){
				CustomSelectionCoords.add(BlockUnitCoord);
			}
			
			CustomSelectionRGB = <0.1, 0.1, 0.1>;
			G_IsEditing = True;
			SetCursorMacroblockModel(Null, G_CursorMacroblockModel);
		}else{
			// Sinon, check si on peut placer le bloc directement
			if (CustomCanPlaceMacroblock(G_CursorMacroblockModel, Cursor.Coord, Cursor.Dir, True)) {
				// Cas: le bloc peut être posé, pas besoin d'édition
				SetCursorMacroblockModel(G_CursorMacroblockModel);
				CanPlaceTerrain = ThemePack::CanPlaceTerrain(Cursor.MacroblockModel);
			}else{
				declare BlockUnitsCoords = GetEditedBlockUnits(Cursor.Coord);
				if (BlockUnitsCoords.count > 0) {
					// Cas: On peut pas poser le bloc et notre curseur est sur un bloc sélectionnable
					foreach (BlockUnitCoord in BlockUnitsCoords) {
						CustomSelectionCoords.add(BlockUnitCoord);
					}

					CustomSelectionRGB = <0.1, 0.1, 0.1>;
					G_IsEditing = True;
					SetCursorMacroblockModel(Null, G_CursorMacroblockModel);
				}
				
				if(!G_IsEditing){
					// Cas: Aucun bloc n'a été selectionné: On met en rouge, le bloc ne peut être placé
					declare BlockUnitCoords = Macroblock::GetCoords(Cursor.MacroblockModel, Cursor.Coord, Cursor.Dir);
					foreach (BlockUnitCoord in BlockUnitCoords) {
						CustomSelectionCoords.add(BlockUnitCoord);
					}
					CustomSelectionRGB = <0.7, 0., 0.>;
				}
			}
		}
	} else if (G_CurrentSequence == C_Sequence_Simple_BuildTrack) {
		CustomSelectionCoords.clear();
		
		// At least one macroblock can be connected
		if (G_MacroblocksCount > 0) {
			// There are several clips available, display them
			if (G_AvailableConnectors.count > 1) {
				CustomSelectionRGB = <0.3, 0.3, 0.3>;
				declare PrevMacroblockInstance = GetMacroblockInstanceFromUnitCoord(G_FilteringCoord);
				if(PrevMacroblockInstance != Null && PrevMacroblockInstance.ClipList != Null){
					foreach(ClipId in G_AvailableConnectors){
						if (ClipId >= PrevMacroblockInstance.ClipList.Clips.count) continue;
						if (ClipId == G_CursorConnectedTo) continue;
						declare Coord = PrevMacroblockInstance.ClipList.Clips[ClipId].Coord;
						CustomSelectionCoords.add(Coord);
					}
				}
			}
		} 
		// No macroblock can be connected
		else {
			// Display the clips that can't be connected
			CustomSelectionRGB = <0.7, 0., 0.>;
			declare PrevMacroblockInstance = GetMacroblockInstanceFromUnitCoord(G_FilteringCoord);
			declare PrevDisconnectedClips = MapContent::GetDisconnectedClips(PrevMacroblockInstance);
			if (PrevDisconnectedClips.count > 0) {
				declare PrevClipList = PrevMacroblockInstance.ClipList;
				declare Count = 0;
				declare Total = <0, 0, 0>;
				foreach (PrevClipId in PrevDisconnectedClips) {
					if (PrevClipId >= PrevClipList.Clips.count) continue;
					CustomSelectionCoords.add(PrevClipList.Clips[PrevClipId].Coord);
					Count += 1;
					Total += PrevClipList.Clips[PrevClipId].Coord;
				}
			}
			if(PrevMacroblockInstance != Null)
				SetUndergroundMode(PrevMacroblockInstance.MacroblockModel);
		}
	} 
	// Can't place start block
	else if (		G_CurrentSequence == C_Sequence_PlaceStart
						|| G_CurrentSequence == C_Sequence_Simple_PlaceStart
						|| G_CurrentSequence == C_Sequence_Simple_MoveCursor) {
		CustomSelectionCoords.clear();
		
		if (!CustomCanPlaceMacroblock(Cursor.MacroblockModel, Cursor.Coord, Cursor.Dir, True)) {
			declare BlockUnitCoords = Macroblock::GetCoords(Cursor.MacroblockModel, Cursor.Coord, Cursor.Dir);
			foreach (BlockUnitCoord in BlockUnitCoords) {
				CustomSelectionCoords.add(BlockUnitCoord);
			}
			CustomSelectionRGB = <0.7, 0., 0.>;
		}
	} 
	// Special case for lagoon water
	else if (
		G_CurrentSequence == C_Sequence_EditTerrain &&
		!Selection::IsSelecting() &&
		Terrain::IsUndergroundTerrain(Cursor.TerrainBlockModel)
	) {
		CustomSelectionCoords.clear();
		CustomSelectionCoords.add(Cursor.Coord);
		CustomSelectionRGB = <0., 0.1, 0.>;
	} else {
		CustomSelectionCoords.clear();
	}
	
	// Enable box helper when creating terrain in advance mode
	if (G_CurrentSequence == C_Sequence_EditTerrain) {
		Cursor.Brightness = 1.;
	} else if (CanPlaceTerrain) {
		Cursor.Brightness = 1.;
	} else if(CustomSelectionCoords.count > 0 && CustomSelectionRGB != <0., 0., 0.>) {
		Cursor.Brightness = 0.;
	} else {
		Cursor.Brightness = C_CursorVisibility;
	}
}

// Get a valid coord from a possibly invalid one
Int3 SanitizeCursorCoord(Int3 _Coord) {
	declare NewCursorCoord = _Coord;
	if (NewCursorCoord.X < 0) NewCursorCoord.X = 0;
	if (NewCursorCoord.X > Map.Size.X-1) NewCursorCoord.X = Map.Size.X-1;
	if (NewCursorCoord.Y < 0) NewCursorCoord.Y = 0;
	if (NewCursorCoord.Y > Map.Size.Y-1) NewCursorCoord.Y = Map.Size.Y-1;
	if (NewCursorCoord.Z < 0) NewCursorCoord.Z = 0;
	if (NewCursorCoord.Z > Map.Size.Z-1) NewCursorCoord.Z = Map.Size.Z-1;
	
	return NewCursorCoord;
}

// Set the cursor coord
// @param	_NewCoord				The new cursor coord
// @param	_TargetCursorCoord		The coord to restore when possible
Void SetCursorCoord(Int3 _NewCoord, Int3 _TargetCursorCoord) {
	Cursor.Coord = SanitizeCursorCoord(_NewCoord);
	G_CursorCoord = SanitizeCursorCoord(_TargetCursorCoord);
	G_ForcedCursorCoord = Cursor.Coord;
	DisplaySkinSelection(Cursor.Coord);
	SetCursorStyle();
	CheckTuto();
}
Void SetCursorCoord(Int3 _NewCoord) {
	Cursor.Coord = SanitizeCursorCoord(_NewCoord);
	G_CursorCoord = Cursor.Coord;
	G_ForcedCursorCoord = Cursor.Coord;
	DisplaySkinSelection(Cursor.Coord);
	SetCursorStyle();
	CheckTuto();
}

// Set the cursor dir
// @param	_NewDir					The new cursor dir
// @param	_TargetDir				The dir to restore when possible
Void SetCursorDir(CMapEditorPlugin::CardinalDirections _NewDir, CMapEditorPlugin::CardinalDirections _TargetDir) {
	Cursor.Dir = _NewDir;
	G_CursorDir = _TargetDir;
	SetCursorStyle();
}
Void SetCursorDir(CMapEditorPlugin::CardinalDirections _NewDir) {
	Cursor.Dir = _NewDir;
	G_CursorDir = Cursor.Dir;
	SetCursorStyle();
}

// Get the list of the available decoration macroblocks sorted by type
// @param	_Random					True if we should only allow macroblocks for random generation
CMacroblockModel[][Text] GetDecorationMacroblocks(Boolean _Random) {
	declare CMacroblockModel[][Text] DecorationMacroblocks;
	
	foreach (MacroblockModel in MacroblockModels) {
		if (!Macroblock::GetValidity(MacroblockModel)) continue;
		if (!ThemePack::IsListed(MacroblockModel)) continue;
		if (_Random && ThemePack::IsRandomDisabled(MacroblockModel)) continue;
		
		if (!Macroblock::IsDeco(MacroblockModel)) continue;
		
		declare Type = "|Decoration|"^Macroblock::GetType(MacroblockModel);
		if (!DecorationMacroblocks.existskey(Type)) 
			DecorationMacroblocks[Type] = [];

		if (!DecorationMacroblocks[Type].exists(MacroblockModel)) 
			DecorationMacroblocks[Type].add(MacroblockModel);
	}
	return DecorationMacroblocks;
}

// Send the blocks list to the UI
Void SendMacroblockList(CMacroblockModel[][Text] _BlocksList) {
	tuningmark("SendMacroblockList");
	
	declare Ident[][Text] MacroblockModelsIds;
	declare Integer[][Text] Placements;
	declare Boolean[][Text] Availabilities;
	foreach (Family => Macroblocks in _BlocksList) {
		// Optim : don't MacroblockModelFamilies[Family].add(value), it cost more
		// Instead first create an array with the values, then MacroblockModelFamilies[Family] = [Values];
		declare Ident[] MacroblocksIds;
		declare Integer[] MacroblocksPlacements;
		declare Boolean[] MacroblocksAvailabilities;
		
		if (IsSimpleEditor() && !IsPlacingStart()) {			
			if (IsFreeMode()) {
				foreach (MacroblockModel in Macroblocks) {
					MacroblocksIds.add(MacroblockModel.Id);
					MacroblocksPlacements.add(-1);
					MacroblocksAvailabilities.add(True);
				}
			} else {
				foreach (MacroblockModel in Macroblocks) {
					declare Integer[] FoundConnectedBy;
					declare Placement::K_LibPlacement[] Placements for MacroblockModel;
					if (Placements.count <= 0) {
						MacroblocksIds.add(MacroblockModel.Id);
						MacroblocksPlacements.add(-1);
						MacroblocksAvailabilities.add(False);
						continue;
					}
					foreach (PlacementId => Placement in Placements) {
						if (G_CursorConnectedTo != -1 && Placement.ConnectedTo != G_CursorConnectedTo) continue;
						
						if (FoundConnectedBy.exists(Placement.ConnectedBy)) continue; // Happens only when multiple available connectors
						FoundConnectedBy.add(Placement.ConnectedBy);
						
						MacroblocksIds.add(MacroblockModel.Id);
						MacroblocksPlacements.add(PlacementId);
						MacroblocksAvailabilities.add(True);
					}
				}
			}
		} else {
			foreach (MacroblockModel in Macroblocks) {
				declare Placement::K_LibPlacement[] Placements for MacroblockModel;
				declare ConnectedToExists = False;
				foreach (Placement in Placements) {
					if(Placement.ConnectedTo == 0){
						ConnectedToExists = True;
						break;
					}
				}
				MacroblocksIds.add(MacroblockModel.Id);
				MacroblocksPlacements.add(-1);
				MacroblocksAvailabilities.add(ConnectedToExists);
			}
		}
		
		MacroblockModelsIds[Family] = MacroblocksIds;
		Placements[Family] = MacroblocksPlacements;
		Availabilities[Family] = MacroblocksAvailabilities;
	}
	
	declare Text Filter = ThemePack::GetTrackStyleFilterName();
	declare Text PrevFilter = ThemePack::GetTrackStylePrevFilterName();
	declare Text NextFilter = ThemePack::GetTrackStyleNextFilterName();
	
	if (!IsFreeMode() || IsPlacingStart()){
		Filter = "";
		PrevFilter = "";
		NextFilter = "";
	}
	
	UI_MacroblockSelection::SetFamiliesAndMacroblocks(MacroblockModelsIds, Placements, Availabilities, Filter, PrevFilter, NextFilter);
}

// Get a list of macroblocks sorted by categories
CMacroblockModel[][Text] SortMacroblocks(CMacroblockModel[] _MacroblockModels, Boolean _Terrain) {
	tuningmark("SortMacroblocks");
	declare AvailableMacroblocks = _MacroblockModels;
	declare CMacroblockModel[][Text] SortedMacroblocks;
	// Add all categories
	if (!_Terrain) {
		declare Categories = ThemePack::GetAllCategories();
		foreach (Category in Categories) {
			SortedMacroblocks[Category] = [];
		}
	}
	
	// We now have the AvailableMacroblocks in filtermacroblocks already sorted by index which removes the need of this sort & discarded macroblocks filter in most situations, but this causes an issue sometimes when placing blocks with multiple connectors where you can connect both the air block to one side and the ground block to the other side for example.
	if(G_AvailableConnectors.count > 1 && !G_MoveCursor){
			// Sort the macroblocks in the same order as the theme pack file
		declare CMacroblockModel[] OrderedMacroblocks;
		declare Integer[Integer] OrderedIndexes;
		foreach (Index => MacroblockModel in AvailableMacroblocks) {
			OrderedIndexes[Index] = ThemePack::GetOrder(MacroblockModel);
		}
		OrderedIndexes = OrderedIndexes.sort();
		foreach (Index => Order in OrderedIndexes) {
			OrderedMacroblocks.add(AvailableMacroblocks[Index]);
		}
		AvailableMacroblocks = OrderedMacroblocks;
		
		// Clean unavailable macroblocks
		foreach (MacroblockModel in AvailableMacroblocks) {
			declare FullName = Macroblock::GetFullName(MacroblockModel);
			while (G_DiscardedMacroblocks.exists(FullName)) {
				declare Removed = G_DiscardedMacroblocks.remove(FullName);
			}
		}
	}
	
	// If we have discarded any blocks that we couldn't place because of the terrain, add them here
	foreach (MacroblockModelId => MacroblockFullName in G_DiscardedMacroblocks) {
		AvailableMacroblocks.add(MacroblockModels[MacroblockModelId]);
	}
	// Sort blocks by category
	foreach (MacroblockModel in AvailableMacroblocks) {
		declare Category = "";
		if (_Terrain) {
			//L16N [MapEditor] Name of a blocks category that contains terrain blocks (hill, cliff, canyon, river, ...)
			Category = _("Terrain");
		} else {
			Category = ThemePack::GetCategory(MacroblockModel);
		}
		if (!SortedMacroblocks.existskey(Category)) SortedMacroblocks[Category] = [];
		SortedMacroblocks[Category].add(MacroblockModel);
	}
	
	return SortedMacroblocks;
}

Integer GetFilterMacroblocksTick(){
	if(G_RandomMapGeneration || IsGeneratingDecoration())
		return C_Tick_FilterMacroblockRandom;
	return C_Tick_FilterMacroblockPlayer;
}

// Get a list of macroblocks filtered by different params
CMacroblockModel[] FilterMacroblocks2(Boolean _ForceConnectedMode) {
	declare CMacroblockModel[] Result;
	tuningmark("FilterMacroblocks2");
	Transitions::ClearAllTransitions();
	declare NextTick = GetFilterMacroblocksTick();
	
	G_DiscardedMacroblocks.clear();
	// Editing and building
	// Add all macroblocks
	declare IsPlacingStart = IsPlacingStart();
	declare IsEditingDecoration = IsEditingDecoration();
	if (!_ForceConnectedMode && (IsFreeMode() || IsPlacingStart || IsEditingDecoration)) {
		// Save filtering coordinates
		G_FilteringCoord = Cursor.Coord;
		
		// Update cursor connected to 
		G_CursorConnectedTo = -1;
		
		declare CMacroblockModel[] AvailableMacroblockModels;
		if (G_RandomMapGeneration) {
			AvailableMacroblockModels = G_RandomMacroblocks;
		} else {
			AvailableMacroblockModels = ThemePack::GetMacroblockModels();
		}
		foreach (MacroblockModel in AvailableMacroblockModels) {
			declare GroundHeight = GetGroundHeight(Cursor.Coord.X, Cursor.Coord.Z);

			// We're on the ground, we will never place an "air" variant
			if (Cursor.Coord.Y == GroundHeight && !MacroblockModel.IsGround) continue; 
			
			// Cliplist of the next macroblock
			G_FilterNextMacroblockClipList = Macroblock::GetCreatedClipList(MacroblockModel);
			
			// we're in the air, we will never place a ground variant that doesn't occupy multiple blocks vertically.
			if (	 G_FilterNextMacroblockClipList == Null 
					|| (Cursor.Coord.Y > GroundHeight 
							&& MacroblockModel.IsGround
							&& G_FilterNextMacroblockClipList.Size.Y < 2)) continue; 
				
			// Skip not valid macroblock
			if (	( IsPlacingStart && !MacroblockModel.HasStart && !MacroblockModel.HasMultilap)
					||(!IsPlacingStart && (MacroblockModel.HasStart || MacroblockModel.HasMultilap)) 
					||( Macroblock::IsTerrain(MacroblockModel))
					||(!IsEditingDecoration && Macroblock::IsDeco(MacroblockModel))) continue;
						
			// Reduce script load
			NextTick -= 1;
			if (NextTick <= 0) {
				NextTick = GetFilterMacroblocksTick();
				Yield();
			}
			
			// Force a mode variant
			if (G_FreeModeVariant != Macroblock::VariantNull() && Macroblock::VariantExists(G_FreeModeVariant)) {
				if (Macroblock::HasVariant(MacroblockModel, G_FreeModeVariant) 
						&& Macroblock::GetVariant(MacroblockModel) != G_FreeModeVariant)
					continue;
			}

			// Add all macroblocks
			declare ValidPlacement = -1;
			Placement::Clear(MacroblockModel);
			for (Dir, 0, 3) {	
				// Always allow start placement
				if (IsPlacingStart || CustomCanPlaceMacroblock(MacroblockModel, Cursor.Coord, Utils::IntToDir(Dir), False)) { ///< Don't check for transition here, we will do it in Move() and PreviewMacroblock() anyway
					Placement::Add(MacroblockModel, Cursor.Coord, Utils::IntToDir(Dir), 0, 0);
					ValidPlacement = Placement::Count(MacroblockModel)-1;
				} else {
					Placement::Add(MacroblockModel, Cursor.Coord, Utils::IntToDir(Dir), -1, -1);
				}
			}
		
			// Select default placement
			if (Placement::Count(MacroblockModel) > 0) {
				if (ValidPlacement >= 0) {
					Placement::Select(MacroblockModel, ValidPlacement);
				} else {
					declare Placement::K_LibPlacement[] Placements for MacroblockModel;
					declare ValidPlacement = 0;
					foreach (PlacementId => Placement in Placements) {
						if(Placement.Dir == Cursor.Dir){
							ValidPlacement = PlacementId;
							break;
						}
					}
					Placement::Select(MacroblockModel, ValidPlacement);
				}
				Result.add(MacroblockModel);
			}
		}
	}
	// Filter macroblocks
	else {
		// Building
		// Check that the next macroblock can be connected to the previous one
		G_FilteringCoord = G_CursorCoord;
		declare MacroblocksDirty = True;
		// Update connectors
		G_CursorConnectedTo = -1;
		G_AvailableConnectors.clear();
		G_AvailableCheckpoint = NullId;
		
		declare PrevMacroblockInstance = GetMacroblockInstanceFromUnitCoord(G_FilteringCoord);
	
		if(PrevMacroblockInstance != Null){
			declare PrevDisconnectedClips = MapContent::GetDisconnectedClips(PrevMacroblockInstance);
			if (PrevDisconnectedClips.count > 0) {
				// Find clip used to connect the previous macroblock to the one before
				declare PrevClipList = PrevMacroblockInstance.ClipList;
				declare PrevConnectionToPrevious = MapContent::GetConnectionToPrevious(PrevMacroblockInstance);
				declare PrevConnection = PrevConnectionToPrevious[1];				
				declare PrevConnectionDir = C_North;
				if(PrevConnection != -1) PrevConnectionDir = PrevClipList.Clips[PrevConnection].Dir;
						
				declare CMacroblockModel[] AvailableMacroblockModels;
				if (G_RandomMapGeneration) {
					AvailableMacroblockModels = G_RandomMacroblocks;
				} else {
					AvailableMacroblockModels = ThemePack::GetMacroblockModels();
				}
				// Valid data for the next macroblock
				foreach (PrevClip in PrevClipList.Clips) {
					if(!PrevDisconnectedClips.exists(PrevClip.ClipId)) continue;
		
					declare ValidClipDir = MU::GetOpposedDir(PrevClip.Dir);
					declare ValidClipCoord = PrevClip.GetConnectableCoord();
					declare ValidClipNames = Macroblock::GetConnectableClips(PrevClip.Name);
					declare PrevClipHeight = PrevClip.Coord.Y;
					declare GroundHeight = GetGroundHeight(PrevClip.Coord.X, PrevClip.Coord.Z);

					foreach (NextMacroblockModel in AvailableMacroblockModels) {
						if (MacroblocksDirty) 
							Placement::Clear(NextMacroblockModel);
						if(ValidClipNames.count == 0) continue; // nothing can be attached anyways (ex: -In blocks)
							
						// We're on the ground, we will never place an "air" variant
						if (PrevClipHeight == GroundHeight && !NextMacroblockModel.IsGround) continue; 
							
						// Data of the next macroblock
						G_FilterNextMacroblockClipList = Macroblock::GetCreatedClipList(NextMacroblockModel);
						
						// we're in the air, we will never place a ground variant that doesn't occupy multiple blocks vertically.
						if (	G_FilterNextMacroblockClipList == Null 
									|| (PrevClipHeight - GroundHeight >= G_FilterNextMacroblockClipList.Size.Y
											&& NextMacroblockModel.IsGround)) continue; 
						
						// Skip not valid macroblock
						if (	(	NextMacroblockModel.HasStart || NextMacroblockModel.HasMultilap)
								||( Macroblock::IsDeco(NextMacroblockModel) 
										|| Macroblock::IsTerrain(NextMacroblockModel))) continue;
						
						// Reduce script load
						NextTick -= 1;
						if (NextTick <= 0) {
							NextTick = GetFilterMacroblocksTick();
							Yield();
						}
												
						// Save the new placements
						declare Integer[] NewPlacements;
						if(G_FilterNextMacroblockClipList != Null){
							declare PlacementFound = False;
							declare Discarded = False;
							declare IsGroundedAndHasDownClip = False;								
							if(IsEditor(C_Editor_Beginner) && NextMacroblockModel.IsGround){ // avoid down clips on ground
								foreach (NextClip in G_FilterNextMacroblockClipList.Clips) {
									declare ClipName = NextClip.Name;
									declare ClipNameLength = TL::Length(ClipName);
									declare Suffix = TL::SubString(NextClip.Name, ClipNameLength - 4, ClipNameLength);
									if (Suffix == "Down"){
										IsGroundedAndHasDownClip = True;
										break;
									} 
								}
							}
							
							if(IsGroundedAndHasDownClip) continue;
							
							foreach (NextClip in G_FilterNextMacroblockClipList.Clips) {
								declare ClipName = NextClip.Name;
								
								// Skip -out clip, we can't use them to connect the next macroblock 
								// & Skip clips that can't be connected
								if (Macroblock::IsOutClip(ClipName) || !ValidClipNames.exists(ClipName)) continue;
								
								if (!ValidClipNames.exists(ClipName)) continue;
								
								// Determine next block coord and dir
								declare NextBlockDir = MU::SubDirs(ValidClipDir, NextClip.Dir);
								declare NextBlockCoord = ValidClipCoord - MU::GetRotatedOffsetPositive(NextClip.Offset, NextBlockDir, G_FilterNextMacroblockClipList.Size);
							
								// Skip macroblock that can't be placed and have no transition
								if (!CustomCanPlaceMacroblock(NextMacroblockModel, NextBlockCoord, NextBlockDir, True)) {
									if(!Discarded && !PlacementFound){
										declare NextFullName = Macroblock::GetFullName(NextMacroblockModel);
										if (!G_DiscardedMacroblocks.exists(NextFullName) && !Result.exists(NextMacroblockModel)) {
											G_DiscardedMacroblocks[NextMacroblockModel.Id] = NextFullName;
											Discarded = True;
										}
									}
									continue;
								}
								// Add them to the possible placements for the next macroblock
								Placement::Add(NextMacroblockModel, NextBlockCoord, NextBlockDir, NextClip.ClipId, PrevClip.ClipId);
								
								// Save the new placements
								NewPlacements.add(Placement::Count(NextMacroblockModel) - 1);
								PlacementFound = True;
								if(Discarded)
									G_DiscardedMacroblocks.removekey(NextMacroblockModel.Id);
							}
						}
						// Select default placement and add macroblock to the result
						if (Placement::Count(NextMacroblockModel) > 0) {
							declare PlacementSelected = False;
							
							// Try to orient special macroblock (checkpoint, turbo) in the right direction
							if (
								(Macroblock::IsOriented(NextMacroblockModel) && !ThemePack::NoRespawn(NextMacroblockModel)) ||
								ThemePack::IsOriented(NextMacroblockModel)
							) {
								declare TargetDir = MU::GetOpposedDir(ValidClipDir);
								declare Oriented = False;
								declare BlockDirs = Placement::GetDirs(NextMacroblockModel);
								foreach (Placement => Dir in BlockDirs) {
									if (Dir == TargetDir) {
										Placement::Select(NextMacroblockModel, Placement);
										PlacementSelected = True;
										Oriented = True;
										break;
									}
								}
								
								// Remove oriented blocks that can't be placed
								// in the right direction
								if (!Oriented) {
									declare Shift = 0;
									foreach (Placement in NewPlacements) {
										Placement::Remove(NextMacroblockModel, Placement - Shift);
										Shift += 1;
									}
								}
								// Remove incorrect orientation on blocks that can be placed
								// in the right direction
								else {
									declare Shift = 0;
									foreach (Placement in NewPlacements) {
										if (Placement::GetPlacement(NextMacroblockModel) == Placement - Shift) continue;
										Placement::Remove(NextMacroblockModel, Placement - Shift);
										Shift += 1;
									}
								}
							} 
							// Try to keep the same orientation than the previous block
							else if (ThemePack::IsSymmetrical(NextMacroblockModel)) {
								declare Integer[] AlreadyConnectedTo;
								declare ConnectedTo = Placement::GetConnectedToClips(NextMacroblockModel);
								declare Shift = 0;
								foreach (Placement => ClipId in ConnectedTo) {
									if (AlreadyConnectedTo.exists(ClipId)) {
										Placement::Remove(NextMacroblockModel, Placement - Shift);
										Shift += 1;
									} else {
										AlreadyConnectedTo.add(ClipId);
									}
								}
							}
							// Repeat the orientation of the previous block if it's the same
							else if (PrevMacroblockInstance.MacroblockModel != Null && NextMacroblockModel.Id == PrevMacroblockInstance.MacroblockModel.Id) {
								declare BlockDirs = Placement::GetDirs(NextMacroblockModel);
								declare MinAngle = -1.;
								foreach (Placement => Dir in BlockDirs) {
									declare Angle = ML::Abs(ML::Angle(Utils::DirToVec3(PrevMacroblockInstance.Dir), Utils::DirToVec3(Dir)));
									if (MinAngle == -1. || Angle < MinAngle) {
										Placement::Select(NextMacroblockModel, Placement);
										PlacementSelected = True;
										MinAngle = Angle;
									}
								}
							}
							
							// Try to keep the same track orientation
							if (!PlacementSelected) {
								// Default orientation
								Placement::Select(NextMacroblockModel, 0);
								
								if (PrevConnection >= 0) {
									declare NextPlacementConnectedByClips = Placement::GetConnectedByClips(NextMacroblockModel);
									declare NextPlacementConnectedToClips = Placement::GetConnectedToClips(NextMacroblockModel);
									declare NextPlacementDirs = Placement::GetDirs(NextMacroblockModel);
									foreach (Placement => ClipId in NextPlacementConnectedByClips) {
										declare PlacementClipDir = MU::AddDirs(Macroblock::GetClipDir(NextMacroblockModel, ClipId), NextPlacementDirs[Placement]);
										if (PlacementClipDir == PrevConnectionDir) {
											Placement::Select(NextMacroblockModel, Placement);
											G_CursorConnectedTo = NextPlacementConnectedToClips[Placement];
											break;
										}
									}
								}
							}
							
							if (Placement::Count(NextMacroblockModel) > 0 && !Result.exists(NextMacroblockModel)) {
								Result.add(NextMacroblockModel);
								if (NextMacroblockModel.HasCheckpoint && G_AvailableCheckpoint == NullId) 
									G_AvailableCheckpoint = NextMacroblockModel.Id;
							}
							
							// Update connectors
							if (Placement::GetConnectedToClips(NextMacroblockModel).exists(PrevClip.ClipId)) {
								if (!G_AvailableConnectors.exists(PrevClip.ClipId)) G_AvailableConnectors.add(PrevClip.ClipId);							
								if (G_CursorConnectedTo < 0) G_CursorConnectedTo = PrevClip.ClipId;
							}
						}
					}
					MacroblocksDirty = False;
				}
			}
		}
		
	}
	G_MacroblocksCount = Result.count;
	return Result;
}

/// Find and display a list of blocks connectable to the previous one
Void BrowseMacroblocks2() {
	tuningmark("BrowseMacroblocks2");
	G_AvailableMacroblocks = SortMacroblocks(FilterMacroblocks2(False), False);
	// Send the block list to the UI
	SendMacroblockList(G_AvailableMacroblocks);
	if (G_CurrentSequence == C_Sequence_Simple_BuildTrack) {
		declare Text[Text] BlockHelp;
		BlockHelp[Buttons2::Editor_PlaceBlock()] = _("|Infinitive|Place");
		if (!CutPasteIsAllowed()) {
			BlockHelp[Buttons2::Editor_RemoveBlock()] = _("|Infinitive|Remove");
		} else {
			BlockHelp[Buttons2::Editor_CutBlock()] = _("|Infinitive|Cut");
		}
		if (G_AvailableConnectors.count > 1) {
			BlockHelp[Buttons2::Editor_SelectConnector()] = _("|Infinitive - Change choice|Switch");
		}
		//BlockHelp[Buttons2::Editor_OpenTest()] = _("|Infinitive - Try track|Test");
		BlockHelp[Buttons2::Editor_CameraMove()] = _("|Move camera|Camera");
		if (IsEditor(C_Editor_Advanced)) BlockHelp[Buttons2::Editor_Disconnect()] = _("|Infinitive|Disconnect");
		BlockHelp[Buttons2::Editor_CameraZoom()] = _("|Infinitive|Zoom");
		
		UI_BlockHelp::SetOptions(BlockHelp);
	}
}

/// Get a list of terrain macroblocks
CMacroblockModel[] FilterTerrainMacroblocks() {
	declare CMacroblockModel[] Result;
	foreach (MacroblockModel in MacroblockModels) {
		if (!Macroblock::IsTerrain(MacroblockModel)) continue;
		if (!Macroblock::GetValidity(MacroblockModel)) continue;
		if (!ThemePack::IsListed(MacroblockModel)) continue;
		
		// Terrain editing
		if (IsEditingTerrain() && Macroblock::GetType(MacroblockModel) == "Types") {
			Result.add(MacroblockModel);
		} 
		// Terrain selection
		else if (!IsEditingTerrain() && Macroblock::GetType(MacroblockModel) == "Terrains") {
			Placement::Clear(MacroblockModel);
			
			// Find right height
			for (PosY, 0, Map.Size.Y - 1) {
				declare CanBePlaced = CanPlaceMacroblock(MacroblockModel, <0, PosY, 0>, C_North);
				if (CanBePlaced) {
					Placement::Add(MacroblockModel, <0, PosY, 0>, C_North, -1, -1);
					
					// Test east, south and west directions
					declare Coords = [1 => <Map.Size.X - 1, PosY, 0>, 2 => <Map.Size.X - 1, PosY, Map.Size.Z - 1>, 3 => <0, PosY, Map.Size.Z - 1>];
					for (IntDir, 1, 3) {
						declare Coord = Coords[IntDir];
						declare Dir = Utils::IntToDir(IntDir);
						if (CanPlaceMacroblock(MacroblockModel, Coord, Dir)) {
							Placement::Add(MacroblockModel, Coord, Dir, -1, -1);
						}
					}
				}
			}
			
			if (Placement::Count(MacroblockModel) > 0) {
				Result.add(MacroblockModel);
			}
		}
	}
	
	G_MacroblocksCount = Result.count;
	
	return Result;
}

// Get a list of terrain macroblocks ids
Ident[] GetTerrainsIds() {
	declare Ident[] Result;
	
	declare Terrains = FilterTerrainMacroblocks();
	foreach (Terrain in Terrains) {
		Result.add(Terrain.Id);
	}
	
	return Result;
}

Void SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode _PlaceMode, CMapEditorPlugin::EditMode _EditMode) {
	if (PlaceMode != _PlaceMode) PlaceMode = _PlaceMode;
	G_PlaceMode = _PlaceMode;
	if (EditMode != _EditMode) EditMode = _EditMode;
	G_EditMode = _EditMode;
}


// Rotate the current macroblock
Void RotateMacroblock(Integer _Direction) {
	declare Angle = C_North;
	switch (ML::Abs(_Direction) % 4) {
		case 1: Angle = C_East;
		case 2: Angle = C_South;
		case 3: Angle = C_West;
	}
	
	declare TargetCursorDir = G_CursorDir;
	declare NewCursorDir = TargetCursorDir;
	if (_Direction < 0) {
		TargetCursorDir = MU::SubDirs(TargetCursorDir, Angle);
		NewCursorDir = TargetCursorDir;
	} else if (_Direction > 0) {
		TargetCursorDir = MU::AddDirs(TargetCursorDir, Angle);
		NewCursorDir = TargetCursorDir;
	}
	
	if (!G_RandomMapGeneration) Sound::Play("EditorBlockRotate");
	
	SetCursorDir(NewCursorDir, TargetCursorDir);
	if (CanNotify()) UI_BlockHelp::Notify(_("|Infinitive|Rotate"));
}

// Move the cursor in a direction, relative to the camera or relative to cardinal directions
Int3 Move(Int3 _Direction, Boolean _RelativeToCamera) {
	tuningmark("Move");
	declare RotatedDirection = _Direction;
	
	// Convert direction to match camera angle
	if (_RelativeToCamera) {
		declare Angle = CameraHAngle;
		if (Angle < 0.) {
			Angle = (2 * ML::Pi) + CameraHAngle;
		}
		declare UnitAngle = ML::Pi / 4.;
		
		// North must always be top or top-right in the current camera angle
		// North is North -> Y 1
		if (Angle <= UnitAngle || Angle > 7 * UnitAngle) {
			
		} 
		// North is East -> X -1
		else if (Angle > UnitAngle && Angle <= 3 * UnitAngle) {
			RotatedDirection = MU::GetRotatedOffset(_Direction, C_West);
		} 
		// North is South -> Y -1
		else if (Angle > 3 * UnitAngle && Angle <= 5 * UnitAngle) {
			RotatedDirection = MU::GetRotatedOffset(_Direction, C_South);
		} 
		// North is West -> X 1
		else if (Angle > 5 * UnitAngle && Angle <= 7 * UnitAngle) {
			RotatedDirection = MU::GetRotatedOffset(_Direction, C_East);
		}
	}
	
	declare TargetCursorCoord = G_CursorCoord + RotatedDirection;
	if (RotatedDirection.X != 0) TargetCursorCoord.X = Cursor.Coord.X + RotatedDirection.X;
	if (RotatedDirection.Y != 0) TargetCursorCoord.Y = Cursor.Coord.Y + RotatedDirection.Y;
	if (RotatedDirection.Z != 0) TargetCursorCoord.Z = Cursor.Coord.Z + RotatedDirection.Z;
	
	return TargetCursorCoord;
}

// Play a sound when moving a macroblock
Void PlayMoveSound(Int3 _Direction, Int3 _OldCoord, Int3 _NewCoord, Boolean _YSound) {
	if (_YSound && _Direction.Y > 0) {
		if (_OldCoord.Y < _NewCoord.Y) Sound::Play("EditorBlockMoveUp");
		else Sound::Play("EditorWrongAction");
	} else if (_YSound && _Direction.Y < 0) {
		if (_OldCoord.Y > _NewCoord.Y) Sound::Play("EditorBlockMoveDown");
		else Sound::Play("EditorWrongAction");
	} else if (_Direction.X != 0 || _Direction.Z != 0) {
		if (_OldCoord.X != _NewCoord.X || _OldCoord.Z != _NewCoord.Z) Sound::Play("EditorBlockMove");
		else Sound::Play("EditorWrongAction");
	}
}

// Move the cursor when using terrain
Void MoveTerrain(Int3 _Direction, Boolean _RelativeToCamera) {
	declare TargetCursorCoord = SanitizeCursorCoord(Move(_Direction, _RelativeToCamera));
	TargetCursorCoord.Y = GetGroundHeight(TargetCursorCoord.X, TargetCursorCoord.Z);
	declare OldCursorCoord = Cursor.Coord;
	
	SetCursorCoord(TargetCursorCoord);
	
	PlayMoveSound(_Direction, OldCursorCoord, Cursor.Coord, False);
	
	if (Selection::IsSelecting()) {
		Selection::Update(Cursor.Coord);
	}
}

// MoveTerrain overload
Void MoveTerrain(CMapEditorPluginEvent::EInput _Input) {
	switch (_Input) {
		case CMapEditorPluginEvent::EInput::IconUp			: MoveTerrain(<0, 0, 1>, True);
		case CMapEditorPluginEvent::EInput::IconRight	: MoveTerrain(<-1, 0, 0>, True);
		case CMapEditorPluginEvent::EInput::IconDown		: MoveTerrain(<0, 0, -1>, True);
		case CMapEditorPluginEvent::EInput::IconLeft		: MoveTerrain(<1, 0, 0>, True);	
		case CMapEditorPluginEvent::EInput::CursorUp		: MoveTerrain(<0, 0, 1>, True);
		case CMapEditorPluginEvent::EInput::CursorRight	: MoveTerrain(<-1, 0, 0>, True);
		case CMapEditorPluginEvent::EInput::CursorDown	: MoveTerrain(<0, 0, -1>, True);
		case CMapEditorPluginEvent::EInput::CursorLeft	: MoveTerrain(<1, 0, 0>, True);
	}
}

// Move the cursor
// @param _BrowseMacroblocks : whether we should refilter everything or not
Void MoveMacroblock(Int3 _Direction, Boolean _RelativeToCamera, Boolean _BrowseMacroblocks) {
	tuningmark("MoveMacroblock");
	declare TargetCursorCoord = SanitizeCursorCoord(Move(_Direction, _RelativeToCamera));
	SetFreeModeVariant(Macroblock::VariantNull());
	declare NewCursorCoord = TargetCursorCoord;
	declare OldCursorCoord = Cursor.Coord;
	declare CMacroblockModel SelectedMacroblockModel;
	
	if (G_CursorMacroblockModel != Null) {
		declare GroundHeight = GetGroundHeight(TargetCursorCoord.X, TargetCursorCoord.Z);
		declare GroundVariant = BlockVariant::GetVariant(<TargetCursorCoord.X, GroundHeight, TargetCursorCoord.Z>);
		//declare TargetBlock <=> GetBlock(TargetCursorCoord);
		
		// Find what kind of variant we want
		declare WantUnderground = False;
		declare WantGround = False;
		declare WantAir = False;
		/*if (TargetBlock != Null && TargetBlock.BlockModel.IsTerrain) WantGround = True;
		else*/ if (TargetCursorCoord.Y < GroundHeight) WantUnderground = True;
		else if (TargetCursorCoord.Y == GroundHeight) WantGround = True;
		else WantAir = True;
		
		// Find the variant closest to the wanted one
		declare Variants = Macroblock::GetVariants(G_CursorMacroblockModel);
		foreach (VariantId => VariantModelId in Variants) {
			declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(VariantModelId);
			declare Variant <=> Macroblock::GetBlockModelVariant(MacroblockModel);
			
			if (WantUnderground) {
				if (Variant.IsAllUnderground) {
					SelectedMacroblockModel <=> MacroblockModel;
					SetFreeModeVariant(VariantId);
					break;
				}
			} else if (WantGround) {
				if (MacroblockModel.IsGround || Variant.IsPartUnderground) {
					SelectedMacroblockModel <=> MacroblockModel;
					SetFreeModeVariant(VariantId);
					if (GroundVariant == Macroblock::GetVariant(MacroblockModel)) break;
				}
			} else if (WantAir) {
				if (!MacroblockModel.IsGround && !Variant.IsPartUnderground && !Variant.IsAllUnderground) {
					SelectedMacroblockModel <=> MacroblockModel;
					SetFreeModeVariant(VariantId);
					break;
				}
			}
		}
		
		// The macroblock does not have a variant matching the exact targeted coordinates
		// Find a variant that can be placed at any height of the targeted coordinates instead
		if (SelectedMacroblockModel == Null) {
			declare VariantFound = False;
			foreach (VariantId => VariantModelId in Variants) {
				declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(VariantModelId);
				declare Variant <=> Macroblock::GetBlockModelVariant(MacroblockModel);
				
				// Underground
				if (Variant.IsAllUnderground) {
					declare MaxHeight = GroundHeight - Variant.Size.Y;
					for (PosY, 0, MaxHeight) {
						if (CustomCanPlaceMacroblock(MacroblockModel, <TargetCursorCoord.X, PosY, TargetCursorCoord.Z>, Cursor.Dir, True)) {
							SelectedMacroblockModel <=> MacroblockModel;
							SetFreeModeVariant(VariantId);
							VariantFound = True;
							break;
						}
					}
				} 
				// Ground
				else if (MacroblockModel.IsGround || Variant.IsPartUnderground) {
					for (PosY, GroundHeight-Variant.Size.Y, GroundHeight) {
						if (CustomCanPlaceMacroblock(MacroblockModel, <TargetCursorCoord.X, PosY, TargetCursorCoord.Z>, Cursor.Dir, True)) {
							SelectedMacroblockModel <=> MacroblockModel;
							SetFreeModeVariant(VariantId);
							VariantFound = True;
							break;
						}
					}
				} 
				// Air
				else if (!MacroblockModel.IsGround && !Variant.IsPartUnderground && !Variant.IsAllUnderground) {
					declare MinHeight = GroundHeight + 1;
					for (PosY, MinHeight, Map.Size.Y-1) {
						if (CustomCanPlaceMacroblock(MacroblockModel, <TargetCursorCoord.X, PosY, TargetCursorCoord.Z>, Cursor.Dir, True)) {
							SelectedMacroblockModel <=> MacroblockModel;
							SetFreeModeVariant(VariantId);
							VariantFound = True;
							break;
						}
					}
				}
				
				// Select any existing variant by default
				if (SelectedMacroblockModel == Null) {
					SelectedMacroblockModel <=> MacroblockModel;
					SetFreeModeVariant(VariantId);
				}
				
				if (VariantFound) break;
			}
		}
		
		if (SelectedMacroblockModel == Null) SelectedMacroblockModel = G_CursorMacroblockModel;
		
		// Adjuste the variant height
		declare Variant <=> Macroblock::GetBlockModelVariant(SelectedMacroblockModel);
		// Underground
		if (Variant.IsAllUnderground) {
			// Force coordinates under ground
			declare MaxHeight = GroundHeight - Variant.Size.Y;
			if (TargetCursorCoord.Y > MaxHeight) NewCursorCoord.Y = MaxHeight;
		} 
		// Ground
		else if (SelectedMacroblockModel.IsGround || Variant.IsPartUnderground) {
			// Find right height
			if (!CustomCanPlaceMacroblock(SelectedMacroblockModel, TargetCursorCoord, Cursor.Dir, True)) {
				NewCursorCoord.Y = GroundHeight - Macroblock::GetGroundOffset(SelectedMacroblockModel);
				for (PosY, GroundHeight-Variant.Size.Y, GroundHeight) {
					if (CustomCanPlaceMacroblock(G_CursorMacroblockModel, <TargetCursorCoord.X, PosY, TargetCursorCoord.Z>, Cursor.Dir, True)) {
						NewCursorCoord.Y = PosY;
						break;
					}
				}
			}
		} 
		// Air
		else if (!SelectedMacroblockModel.IsGround && !Variant.IsPartUnderground && !Variant.IsAllUnderground) {
			// Force coordinates over ground
			declare MinHeight = GroundHeight + 1;
			if (TargetCursorCoord.Y < MinHeight) NewCursorCoord.Y = MinHeight;
		}
	}
	
	SetCursorCoord(NewCursorCoord, TargetCursorCoord);
	PlayMoveSound(_Direction, OldCursorCoord, Cursor.Coord, True);
	if(_BrowseMacroblocks)
		BrowseMacroblocks2();
	if (SelectedMacroblockModel != Null) {
		UI_MacroblockSelection::FindMacroblock(SelectedMacroblockModel.Id);
	}
	
	if (CanNotify()) {
		
		if (_Direction == <0, 1, 0>) {
			if (OldCursorCoord.Y != Cursor.Coord.Y) UI_BlockHelp::Notify(_("|Infinitive - Elevate block cursor|Raise"));
			else UI_BlockHelp::Notify(TL::Compose("$f00%1", _("|Infinitive - Elevate block cursor|Raise")));
		
		} else if (_Direction == <0, -1, 0>) {
			if (OldCursorCoord.Y != Cursor.Coord.Y) UI_BlockHelp::Notify(_("|Infinitive - Reduce block cursor height|Lower"));
			else UI_BlockHelp::Notify(TL::Compose("$f00%1", _("|Infinitive - Reduce block cursor height|Lower")));
		}
	}
}

// MoveMacroblock overload
Void MoveMacroblock(Int3 _Direction, Boolean _RelativeToCamera) {
	MoveMacroblock(_Direction, _RelativeToCamera, True);
}

// MoveMacroblock overload
Void MoveMacroblock(CMapEditorPluginEvent::EInput _Input) {
	switch (_Input) {
		case CMapEditorPluginEvent::EInput::CursorRaise	: MoveMacroblock(<0, 1, 0>, True);
		case CMapEditorPluginEvent::EInput::CursorLower	: MoveMacroblock(<0, -1, 0>, True);
		case CMapEditorPluginEvent::EInput::IconUp			: MoveMacroblock(<0, 0, 1>, True);
		case CMapEditorPluginEvent::EInput::IconRight		: MoveMacroblock(<-1, 0, 0>, True);
		case CMapEditorPluginEvent::EInput::IconDown		: MoveMacroblock(<0, 0, -1>, True);
		case CMapEditorPluginEvent::EInput::IconLeft		: MoveMacroblock(<1, 0, 0>, True);
		case CMapEditorPluginEvent::EInput::CursorUp		: MoveMacroblock(<0, 0, 1>, True);
		case CMapEditorPluginEvent::EInput::CursorRight	: MoveMacroblock(<-1, 0, 0>, True);
		case CMapEditorPluginEvent::EInput::CursorDown		: MoveMacroblock(<0, 0, -1>, True);
		case CMapEditorPluginEvent::EInput::CursorLeft		: MoveMacroblock(<1, 0, 0>, True);
	}
	
	if (IsEditor(C_Editor_Expert) && UI_Tuto::IsEnabled(UI_Tuto::Tuto_MoveBlock())) {
		UI_Tuto::ValidateTuto(UI_Tuto::Tuto_MoveBlock());
		CheckTuto();
	}
}

// MoveMacroblock overload
Void MoveMacroblock(CMapEditorPlugin::CardinalDirections _Dir) {
	switch (_Dir) {
		case C_North	: MoveMacroblock(<0, 0, 1>, False);
		case C_West	: MoveMacroblock(<-1, 0, 0>, False);
		case C_South	: MoveMacroblock(<0, 0, -1>, False);
		case C_East	: MoveMacroblock(<1, 0, 0>, False);
	}
}

// Select a random macroblock model in the available ones
CMacroblockModel GetRandomMacroblock() {
	declare AvailableMacroblocksIds = UI_MacroblockSelection::GetAllMacroblocksIds();
	if (AvailableMacroblocksIds.count <= 0) return Null;
	
	declare RandomMacroblockId = AvailableMacroblocksIds[Random::Rand(0, AvailableMacroblocksIds.count - 1)];
	if (MacroblockModels.existskey(RandomMacroblockId)) return MacroblockModels[RandomMacroblockId];
	
	return Null;
}

// Preview the selected macroblock
Void PreviewMacroblock(Ident _MacroblockModelId, Integer _MacroblockPlacement, Boolean _ForceDir) {
	tuningmark("PreviewMacroblock");
	// Get the macroblock model to use	
	declare CMacroblockModel MacroblockModel;
	if (_MacroblockModelId == NullId) {
		MacroblockModel <=> GetRandomMacroblock();
		if (MacroblockModel != Null) UI_MacroblockSelection::FindMacroblock(MacroblockModel.Id); 
	} else {
		MacroblockModel <=> Macroblock::GetMacroblockModelFromId(_MacroblockModelId);
	}
	
	if (MacroblockModel != Null) {
		// Don't preview a macroblock if we're skinning it
		if (G_IsSkinning || G_IsEditing) SetCursorMacroblockModel(Null, MacroblockModel);
		else SetCursorMacroblockModel(MacroblockModel);
		
		if (IsFreeMode() || IsPlacingStart() || IsEditingDecoration()) {
			if (C_Expert_AutoDir && !CustomCanPlaceMacroblock(MacroblockModel, Cursor.Coord, Cursor.Dir, False)) {
				declare Coord = Placement::GetCoord(MacroblockModel);
				declare Dir = Placement::GetDir(MacroblockModel);
				if (CustomCanPlaceMacroblock(MacroblockModel, Coord, Dir, False)) {
					SetCursorDir(Placement::GetDir(MacroblockModel));
				}
			}
		} else {
			// Keep block dir
			if (_ForceDir && Placement::Exists(MacroblockModel, Cursor.Dir)) {
				declare BlockDirs = Placement::GetDirs(MacroblockModel);
				Placement::Select(MacroblockModel, BlockDirs.keyof(Cursor.Dir));
			}
			// Use forced macroblock placement
			else if (_MacroblockPlacement >= 0) {
				Placement::Select(MacroblockModel, _MacroblockPlacement);
			}
			
			if (Placement::Exists(MacroblockModel)) {
				declare MacroblockCoord = Placement::GetCoord(MacroblockModel);
				declare MacroblockDir = Placement::GetDir(MacroblockModel);
				declare BlockUnitsCoords = Macroblock::GetCoords(MacroblockModel, MacroblockCoord, MacroblockDir);
				declare BlockUnitCoord = MacroblockCoord;
				if (BlockUnitsCoords.count > 0) BlockUnitCoord = BlockUnitsCoords[0];
				SetCursorCoord(MacroblockCoord, BlockUnitCoord);
				SetCursorDir(MacroblockDir);
			}
		}
		
		SetUndergroundMode(G_CursorMacroblockModel);
	} else {
		SetCursorMacroblockModel(Null);
	}
	
	SetCursorStyle();
}

/// Overload of PreviewMacroblock
Void PreviewMacroblock(Ident _MacroblockModelId, Boolean _ForceDir) {
	PreviewMacroblock(_MacroblockModelId, -1, _ForceDir);
}

/// Overload of PreviewMacroblock
Void PreviewMacroblock(Ident _MacroblockModelId) {
	PreviewMacroblock(_MacroblockModelId, False);
}

// Initialize the start block position
//	@param	_Position			The start block position to try
//	@param	_GetDefault		Return any existing macroblock model if none is valid at the given position
// 	@return								The selected start macroblocks
CMacroblockModel InitStartMacroblocks(Int3 _Position, Boolean _GetDefault) {
	SetCursorCoord(_Position);
	declare CMacroblockModel DefaultStartMacroblockModel;
	
	for (Y, 0, Map.Size.Y-1) {
		declare PosY = (_Position.Y + Y) % Map.Size.Y;
		foreach (MacroblockModel in MacroblockModels) {
			if (!MacroblockModel.HasStart && !MacroblockModel.HasMultilap) continue;
			if (!Macroblock::GetValidity(MacroblockModel)) continue;
			if (Macroblock::IsTerrain(MacroblockModel)) continue;
			if (Macroblock::IsDeco(MacroblockModel)) continue;
			if (!ThemePack::IsListed(MacroblockModel)) continue;
			
			DefaultStartMacroblockModel <=> MacroblockModel;
			
			if (!G_RandomMapGeneration && ThemePack::IsRandomOnly(MacroblockModel)) continue;
			
			if (TL::Find("Water",MacroblockModel.Id^"", True, True)) continue; // Avoid using water as first start.
			
			for (I, 0, 3) {
				if (CustomCanPlaceMacroblock(MacroblockModel, <Cursor.Coord.X, PosY, Cursor.Coord.Z>, Utils::IntToDir(I), False)) {
					SetCursorMacroblockModel(MacroblockModel);
					SetCursorCoord(<_Position.X, PosY, _Position.Z>);
					MoveMacroblock(<0, 0, 0>, False);
					return MacroblockModel;
				}
			}
		}
	}
	
	if (_GetDefault) {
		return DefaultStartMacroblockModel;
	}
	
	return Null;
}

// The coordinates of a spawn point in a given spawn block
Int3 GetSpawnCoord(CBlock _Block) {
	foreach (BlockUnit in _Block.BlockUnits) {
		return _Block.Coord + BlockUnit.AbsoluteOffset;
	}
	
	return _Block.Coord;
}

/// Generate the list of available spawns in the track
Void FindSpawns2() {
	tuningmark("FindSpawns2");
	declare Integer[Integer] ToSort;
	foreach (BlockKey => Block in ClassicBlocks) {
		if (Block == Null) continue;
		if (
			Block.BlockModel.WaypointType != CBlockModel::EWayPointType::Start &&
			Block.BlockModel.WaypointType != CBlockModel::EWayPointType::StartFinish &&
			Block.BlockModel.WaypointType != CBlockModel::EWayPointType::Checkpoint
		) continue;
		// Skip not respawnable checkpoints
		if (
			Block.BlockModel.WaypointType == CBlockModel::EWayPointType::Checkpoint &&
			Block.BlockModel.NoRespawn
		) continue;
		
		ToSort[BlockKey] = MapContent::GetMacroblockOrder(Block.Coord);
	}
	
	ToSort = ToSort.sort();
	declare Integer[] Spawns;
	foreach (Block => Order in ToSort) {
		Spawns.add(Block);
	}
	
	UI_SpawnSelection::SetSpawns(Spawns);
}

// Select the spawn to use for the test
//	@param	_Shift 					Select next (1) or previous (-1) spawn
Void SelectSpawn(Integer _Shift) {
	if (_Shift > 0) UI_SpawnSelection::NextSpawn();
	else if (_Shift < 0) UI_SpawnSelection::PrevSpawn();
	
	declare Spawn = UI_SpawnSelection::GetSpawn();
	if (Spawn != Null) {
		declare SpawnCoord = GetSpawnCoord(Spawn);
		declare SpawnMocroblockModel <=> MapContent::GetMacroblockModel(SpawnCoord);
		SetUndergroundMode(SpawnMocroblockModel);
		SetCursorCoord(SpawnCoord);
		SetCursorDir(Spawn.Dir);
	}
}

// ---------------------------------- //
Void GoToSpawn(Integer _Key) {
	UI_SpawnSelection::SelectSpawn(_Key, 0);
	SelectSpawn(0);
}

/// Update the landscape choice UI buttons
Void UpdateLandscapeChoice() {
	declare metadata Text GamepadEditor_TerrainId for Map;
	if (GamepadEditor_TerrainId == "" || Macroblock::GetId(ThemePack::GetTerrain()) != GamepadEditor_TerrainId) {
		if(!IsEditor(C_Editor_Expert)){
			UI_StyleSelection::ShowLandscapeButtons(True, False, False);
		}else{
			UI_StyleSelection::ShowLandscapeButtons(True, False, True); // when/how does this happen? > need to code what happens when clicking on cancel
		}
	} else {
		UI_StyleSelection::ShowLandscapeButtons(True, True, False);
	}
}

// Select the simplest macroblock among the given ones
CMacroblockModel SelectSimplestMacroblock(CMacroblockModel[] _MacroblockModels) {
	declare CMacroblockModel ThemePackSimpleMacroblock;
	declare CMacroblockModel SimplestMacroblock;
	declare CMacroblockModel ReallySimpleMacroblock;
	declare CMacroblockModel SimpleMacroblock;
	
	foreach (MacroblockModel in _MacroblockModels) {
		if (MacroblockModel.HasFinish || MacroblockModel.HasStart || MacroblockModel.HasMultilap || MacroblockModel.HasCheckpoint) continue;
		declare Variant <=> Macroblock::GetBlockModelVariant(MacroblockModel);
		
		if (ThemePack::IsSimple(MacroblockModel)) {
			ThemePackSimpleMacroblock = MacroblockModel;
			break;
		} else if (
			!Variant.IsPartUnderground &&
			!Variant.IsAllUnderground &&
			(!Macroblock::IsShifting(MacroblockModel) &&
			!Macroblock::IsTurning(MacroblockModel) &&
			!Macroblock::IsRising(MacroblockModel) &&
			Macroblock::GetName(MacroblockModel) == "Straight") ||
			Macroblock::GetFullName(MacroblockModel) == "Arena\\Bases\\Simple"
		) {
			SimplestMacroblock = MacroblockModel;
		} else if (
			!Macroblock::IsShifting(MacroblockModel) &&
			!Macroblock::IsTurning(MacroblockModel) &&
			!Macroblock::IsRising(MacroblockModel)
		) {
			ReallySimpleMacroblock = MacroblockModel;
		} else if (
			!Macroblock::IsTurning(MacroblockModel) &&
			!Macroblock::IsTransfert(MacroblockModel)
		) {
			SimpleMacroblock = MacroblockModel;
		} else if (SimpleMacroblock == Null) {
			SimpleMacroblock = MacroblockModel;
		}
	}
	
	if (ThemePackSimpleMacroblock != Null) return ThemePackSimpleMacroblock;
	else if (SimplestMacroblock != Null) return SimplestMacroblock;
	else if (ReallySimpleMacroblock != Null) return ReallySimpleMacroblock;
	return SimpleMacroblock;
}

/// Select the simplest macroblock among the available ones
Void SelectSimplestMacroblock() {
	declare CMacroblockModel[] AvailableMacroblockModels;
	declare AvailableMacroblocksIds = UI_MacroblockSelection::GetAllMacroblocksIds();
	foreach (MacroblockId in AvailableMacroblocksIds) {
		if (!MacroblockModels.existskey(MacroblockId)) continue;
		declare MacroblockModel <=> MacroblockModels[MacroblockId];
		AvailableMacroblockModels.add(MacroblockModel);
	}
	declare SimplestMacroblockModel = SelectSimplestMacroblock(AvailableMacroblockModels);
	if (SimplestMacroblockModel != Null) UI_MacroblockSelection::FindMacroblock(SimplestMacroblockModel.Id);
}

/// Automatically select the right style based on the current clip
Void AutoSelectStyle() {
	// Find one open clip
	declare PrevMacroblockInstance = GetMacroblockInstanceFromUnitCoord(G_CursorCoord);
	declare PrevDisconnectedClips = MapContent::GetDisconnectedClips(PrevMacroblockInstance);
	if (PrevDisconnectedClips.count > 0) {
		// Find the track style associated with this clip
		declare ClipName = PrevMacroblockInstance.ClipList.Clips[PrevDisconnectedClips[0]].Name;
		declare TrackStyleId = ThemePack::GetClipTrackStyle(ClipName);
		
		if (TrackStyleId >= 0 && TrackStyleId != ThemePack::GetTrackStyle()) {
			declare TrackStyleName = ThemePack::GetTrackStyleNameFromId(TrackStyleId);
			ThemePack::Select(TrackStyleId, ThemePack::GetLandStyle(), ThemePack::GetDecoStyle());
			UI_StyleSelection::SelectStyle(TrackStyleName);
			UI_MacroblockSelection::SetStyle(TrackStyleName, ThemePack::GetTrackStylePage(), ThemePack::GetTrackStylesCount());
		}
	}
}
// Check if we must hide or show the block helpers
Void CheckBlockHelpers(Integer _Sequence) {
	HideBlockHelpers = !(
		_Sequence == C_Sequence_PlaceStart ||
		_Sequence == C_Sequence_FreeMode ||
		_Sequence == C_Sequence_TestMode ||
		_Sequence == C_Sequence_Simple_PlaceStart ||
		_Sequence == C_Sequence_Simple_BuildTrack ||
		_Sequence == C_Sequence_Simple_MoveCursor ||
		_Sequence == C_Sequence_Simple_Test
	);
}

// ---------------------------------- //
/** Check which mouse mode to use in the mouse control UI
 *
 *	@param	_Sequence				The current sequence
 */
Void CheckMouseMode(Integer _Sequence) {
	if (_Sequence == C_Sequence_EditTerrain) {
		UI_MouseControl::SetMouseMode(UI_MouseControl::MouseMode_Selection());
	} else if (
		_Sequence == C_Sequence_PlaceStart ||
		_Sequence == C_Sequence_FreeMode ||
		_Sequence == C_Sequence_EditDecoration
	) {
		UI_MouseControl::SetMouseMode(UI_MouseControl::MouseMode_Move());
	}else {
		UI_MouseControl::SetMouseMode(UI_MouseControl::MouseMode_Click());
	}
}

// Select a style containing the given macroblock model
Void SelectMacroblockStyle(Ident _MacroblockModelId, Integer _MacroblockMode) {
	if (_MacroblockModelId == NullId) return;
	
	declare MacroblockModel <=> MacroblockModels[_MacroblockModelId];
	declare MacroblockStyles = ThemePack::GetStyles(MacroblockModel);
	
	if (_MacroblockMode == C_Modes_ConstructTrack) {
		if (MacroblockStyles.count > 0 && !MacroblockStyles.exists(ThemePack::GetTrackStyle())) {
			declare MacroblockTrackStylesNames = ThemePack::GetStylesNames(MacroblockModel);
			
			ThemePack::Select(MacroblockStyles[0], ThemePack::GetLandStyle(), ThemePack::GetDecoStyle());
			UI_StyleSelection::SelectStyle(MacroblockTrackStylesNames[0]);
			UI_MacroblockSelection::SetStyle(MacroblockTrackStylesNames[0], ThemePack::GetTrackStylePage(), ThemePack::GetTrackStylesCount());
			BrowseMacroblocks2();
		}
	} else if(_MacroblockMode == C_Modes_ConstructDeco) {
		if (MacroblockStyles.count > 0 && !MacroblockStyles.exists(ThemePack::GetDecoStyle())) {
			declare MacroblockDecoStylesNames = ThemePack::GetStylesNames(MacroblockModel);
			
			ThemePack::Select(ThemePack::GetTrackStyle(), ThemePack::GetLandStyle(), MacroblockStyles[0]);
			UI_StyleSelection::SelectStyle(MacroblockDecoStylesNames[0]);
			UI_MacroblockSelection::SetStyle(MacroblockDecoStylesNames[0], ThemePack::GetDecoStylePage(), ThemePack::GetDecoStylesCount());
			BrowseMacroblocks2();
		}
	} // note: Land not handled
}

// Event : triggered when a sequence is started
Void OnSequenceStart(Integer _Sequence) {
	tuningmark("OnSequenceStart");
	//log(_Sequence);
	CheckUIPosition(_Sequence);
	CheckBlockHelpers(_Sequence);
	CheckMouseMode(_Sequence);
	Camera.FollowCursor(True);
	switch (_Sequence) {
		case C_Sequence_RandomMap: {
			ThemePack::SetMode(ThemePack::Mode_Track());
			UI_Manager::HideAll();
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Macroblock, CMapEditorPlugin::EditMode::FreeLook);
		}
		case C_Sequence_AutoFinish: {
			ThemePack::SetMode(ThemePack::Mode_Track());
			UI_Manager::HideAll();
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Macroblock, CMapEditorPlugin::EditMode::FreeLook);
		}
		case C_Sequence_RerollMap: {
			if (S_RandomMap_Validate) UI_Header::SetTitle(_("What do you want to do?"), True);
			else UI_Header::SetTitle(_("Do you want to generate another track or play this one?"), True);
			UI_Header::SetModes([]);
			
			if (ManiaPlanet != Null && ManiaPlanet.HMD_IsActive) {
				if (MapContent::HasFinish()) {
					UI_SimpleChoice::SetOptions([
						Buttons2::Editor_RandomPlay() => _("|Infinitive|Play"),
						Buttons2::Editor_RandomGenerate() => _("|Infinitive|Generate")
					], [
						C_SimpleChoice_RandomPlay,
						C_SimpleChoice_RandomGenerate
					]);
				} else {
					UI_SimpleChoice::SetOptions([
						Buttons2::Editor_RandomGenerate() => _("|Infinitive|Generate")
					], [
						C_SimpleChoice_RandomGenerate
					]);
				}
				UI_SimpleChoice::SetStyle(UI_SimpleChoice::Style_Compact());
				UI_Manager::ShowOnly(UI_Manager::C_File_SimpleChoice);
			} else if (S_RandomMap_Validate) {
				if (MapContent::HasFinish()) {
					if (ValidationStatus != CMapEditorPlugin::ValidationStatus::Validated) {
						UI_SimpleChoice::SetOptions([
							Buttons2::Editor_RandomValidate() => _("|Infinitive|Save and Validate"),
							Buttons2::Editor_RandomGenerate() => _("|Infinitive|Generate another track"),
							Buttons2::Editor_RandomQuit() => _("|Infinitive - Quit game mode|Leave editor")
						], [
							C_SimpleChoice_RandomPlay,
							C_SimpleChoice_RandomGenerate,
							C_SimpleChoice_RandomQuit
						]);
					}else{
						UI_SimpleChoice::SetOptions([
							Buttons2::Editor_RandomValidate() => _("|Infinitive|Improve record"),
							Buttons2::Editor_RandomGenerate() => _("|Infinitive|Generate another track"),
							Buttons2::Editor_RandomQuit() => _("|Infinitive - Quit game mode|Leave editor")
						], [
							C_SimpleChoice_RandomPlay,
							C_SimpleChoice_RandomGenerate,
							C_SimpleChoice_RandomQuit
						]);
					}
				} else {
					UI_SimpleChoice::SetOptions([
						Buttons2::Editor_RandomGenerate() => _("|Infinitive|Generate a track")
					], [
						C_SimpleChoice_RandomGenerate
					]);
				}
				UI_SimpleChoice::SetStyle(UI_SimpleChoice::Style_Default());
				UI_Manager::ShowOnly([UI_Manager::C_File_SimpleChoice, UI_Manager::C_File_Header]);
			} else {
				if (MapContent::HasFinish()) {
					UI_SimpleChoice::SetOptions([
						Buttons2::Editor_RandomPlay() => _("|Infinitive|Play"),
						Buttons2::Editor_RandomGenerate() => _("|Infinitive|Generate another track"),
						Buttons2::Editor_RandomSave() => _("|Infinitive|Save"),
						Buttons2::Editor_RandomQuit() => _("|Infinitive - Quit game mode|Leave editor")
					], [
						C_SimpleChoice_RandomPlay,
						C_SimpleChoice_RandomGenerate,
						C_SimpleChoice_RandomSave,
						C_SimpleChoice_RandomQuit
					]);
				} else {
					UI_SimpleChoice::SetOptions([
						Buttons2::Editor_RandomGenerate() => _("|Infinitive|Generate a track")
					], [
						C_SimpleChoice_RandomGenerate
					]);
				}
				UI_SimpleChoice::SetStyle(UI_SimpleChoice::Style_Default());
				UI_Manager::ShowOnly([UI_Manager::C_File_SimpleChoice, UI_Manager::C_File_Header]);
			}
			
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Unknown, CMapEditorPlugin::EditMode::FreeLook);
			UndergroundMode = False;
			Camera.FollowCursor(False);
			Camera.WatchMacroblocks(C_Modes_ConstructTrack);
			SetCursorMacroblockModel(Null);
			SetCursorStyle();
		}
		case C_Sequence_MainMenu: {
			CheckProgression();
			
			if (IsSimpleEditor()) 
				UI_Manager::ShowOnly(UI_Manager::C_File_SimpleMenu);
			else {
				UI_Menu::SetHasFinish(MapContent::HasFinish());
				UI_Manager::ShowOnly(UI_Manager::C_File_Menu);
			}
				
			UI_Manager::Show(UI_Manager::C_File_Progression);
			
			Sound::Play("EditorPopUp");
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Unknown, CMapEditorPlugin::EditMode::FreeLook);
		}
		/*case C_Sequence_MapStyle: { // TAG: MapStyleSelection
			CheckProgression();
			Camera.FollowCursor(False);
			UI_Manager::ShowOnly(UI_Manager::C_File_MapStyleSelection);
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Unknown, CMapEditorPlugin::EditMode::FreeLook);
		}*/
		case C_Sequence_PopUp: {
			Camera.FollowCursor(False);
			
			UI_Manager::HideAll();
				
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Unknown, CMapEditorPlugin::EditMode::FreeLook);
		} 
		case C_Sequence_Save: {
			Camera.FollowCursor(False);
			UI_Manager::ShowOnly(UI_Manager::C_File_Save);
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Unknown, CMapEditorPlugin::EditMode::FreeLook);		
		}
		case C_Sequence_SelectTerrain: {
			ThemePack::SetMode(ThemePack::Mode_Terrain());
			if(!IsEditor(C_Editor_Expert)){
				UI_BlockHelp::SetOptions([
					Buttons2::Editor_Valid() => _("|Infinitive|Select"),
					Buttons2::Editor_CameraMove() => _("|Move camera|Camera")
				]);
			}else{
				UI_BlockHelp::SetOptions([
					Buttons2::Editor_Valid() => _("|Infinitive|Select"),
					Buttons2::Editor_RemoveBlock() => _("|Infinitive|Cancel"),
					Buttons2::Editor_CameraMove() => _("|Move camera|Camera")
				]);
			}

			UI_Header::SetTitle(_("|Game mode - Edit Landscapes|Landscape editing"));
			UI_Header::SetModes([C_Modes[C_Modes_LandscapeRandom], C_Modes[C_Modes_LandscapePostcards]]);
			UI_Header::SelectMode(C_Modes[C_Modes_LandscapePostcards]);

			UI_Manager::ShowOnly([UI_Manager::C_File_BlockHelp, UI_Manager::C_File_Header]);
			
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Unknown, CMapEditorPlugin::EditMode::FreeLook);
			Transitions::ClearAllTransitions();
			SetCustomTerrain(False);
			UndergroundMode = False;
			SetCursorMacroblockModel(Null);
			G_StartingNewMap = True;
			
			Camera.Zoom(CMapEditorCamera::EZoomLevel::Far);
		}
		case C_Sequence_RandomTerrain: {
			Camera.FollowCursor(False);
			ThemePack::SetMode(ThemePack::Mode_Terrain());
			
			UI_BlockHelp::SetOptions([
				Buttons2::Editor_Valid() => _("|Infinitive|Select"),
				Buttons2::Editor_RandomLandscape() => _("|Infinitive|Random"),
				Buttons2::Editor_CameraMove() => _("|Move camera|Camera")
			]);

			UI_Header::SetTitle(_("|Game mode - Edit Landscapes|Landscape editing"));
			UI_Header::SetModes([C_Modes[C_Modes_LandscapeRandom], C_Modes[C_Modes_LandscapePostcards]]);
			UI_Header::SelectMode(C_Modes[C_Modes_LandscapeRandom]);
			
			UI_Manager::ShowOnly([UI_Manager::C_File_BlockHelp, UI_Manager::C_File_Header]);
			
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Unknown, CMapEditorPlugin::EditMode::FreeLook);
			Transitions::ClearAllTransitions();
			UndergroundMode = False;
			SetCursorMacroblockModel(Null);
			G_StartingNewMap = True;
			
			Camera.Zoom(CMapEditorCamera::EZoomLevel::Far);
		}
		case C_Sequence_AutoTerrain: {
			Camera.FollowCursor(False);
			ThemePack::SetMode(ThemePack::Mode_Terrain());
			UI_Manager::HideAll();
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Macroblock, CMapEditorPlugin::EditMode::Place);
		}
		case C_Sequence_PlaceStart: {
			ThemePack::SetMode(ThemePack::Mode_Track());
			
			UI_BlockHelp::SetOptions([
				Buttons2::Editor_PlaceBlock() => _("|Infinitive|Place"),
				Buttons2::Editor_TurnBlock() => _("|Infinitive|Rotate"),
				Buttons2::Editor_RaiseBlock() => _("|Infinitive - Elevate block cursor|Raise"),
				Buttons2::Editor_LowerBlock() => _("|Infinitive - Reduce block cursor height|Lower"),
				Buttons2::Editor_Redo() => _("|Infinitive - Ctrl Z System|Redo"),
				Buttons2::Editor_Undo() => _("|Infinitive - Ctrl Z System|Undo"),
				Buttons2::Editor_BrowseBlocks() => _("|Infinitive|Browse"),
				Buttons2::Editor_CameraMove() => _("|Move camera|Camera"),
				Buttons2::Editor_CameraZoom() => _("|Infinitive|Zoom")
			]);
			UI_Header::SetTitle(_("Select the location of the starting line"));
			if(!S_NoExpertTerraforming){
				UI_Header::SetModes([C_Modes[C_Modes_ConstructTerrain], C_Modes[C_Modes_ConstructTrack], C_Modes[C_Modes_ConstructDeco]]);
			}else{
				UI_Header::SetModes([C_Modes[C_Modes_ConstructTrack], C_Modes[C_Modes_ConstructDeco]]);
			}
			UI_Header::SelectMode(C_Modes[C_Modes_ConstructTrack]);
			
			UI_MacroblockSelection::SetStyle(ThemePack::GetTrackStyleName(), ThemePack::GetStartStylePage(), ThemePack::GetStartStylesCount());
			UI_MacroblockSelection::SetMode(UI_MacroblockSelection::Mode_Track());
			UI_Tuto::DisableAll();
			
			UI_Manager::ShowOnly([UI_Manager::C_File_BlockHelp, UI_Manager::C_File_Header, UI_Manager::C_File_MacroblockSelection, UI_Manager::C_File_Tuto]);
			
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Macroblock, CMapEditorPlugin::EditMode::Place);
			Transitions::ClearAllTransitions();
			SetCursorMacroblockModel(Null);
			
			declare StartingCursorCoord = G_CursorCoord;
			if (G_StartingNewMap) {
				StartingCursorCoord = <Map.Size.X/2, CollectionGroundY, Map.Size.Z/2>;
				Camera.Zoom(CMapEditorCamera::EZoomLevel::Medium);
			}
			
			declare StartMacroblockModel = InitStartMacroblocks(StartingCursorCoord, False);
			if (!G_StartingNewMap && StartMacroblockModel == Null) {
				StartMacroblockModel = InitStartMacroblocks(<Map.Size.X/2, CollectionGroundY, Map.Size.Z/2>, True);
			}
			if (StartMacroblockModel != Null) {
				SelectMacroblockStyle(StartMacroblockModel.Id, C_Modes_ConstructTrack);
				PreviewMacroblock(StartMacroblockModel.Id);
				MoveMacroblock(<0, 0, 0>, False);
				// Do it a second time if the start style changed
				UI_MacroblockSelection::SetStyle(ThemePack::GetTrackStyleName(), ThemePack::GetStartStylePage(), ThemePack::GetStartStylesCount());
			} else {
				PreviewMacroblock(NullId);
			}
			
			G_StartingNewMap = False;
			CheckTuto();
		}
		case C_Sequence_FreeMode: {
			ThemePack::SetMode(ThemePack::Mode_Track());
			//CheckHelper();
			UI_Header::SetTitle(_("|Game mode - Edit Track|Track editing"));
			if(!S_NoExpertTerraforming){
				UI_Header::SetModes([C_Modes[C_Modes_ConstructTerrain], C_Modes[C_Modes_ConstructTrack], C_Modes[C_Modes_ConstructDeco]]);
			}else{
				UI_Header::SetModes([C_Modes[C_Modes_ConstructTrack], C_Modes[C_Modes_ConstructDeco]]);
			}
			UI_Header::SelectMode(C_Modes[C_Modes_ConstructTrack]);
			
			UI_MacroblockSelection::SetStyle(ThemePack::GetTrackStyleName(), ThemePack::GetTrackStylePage(), ThemePack::GetTrackStylesCount());
			UI_MacroblockSelection::SetMode(UI_MacroblockSelection::Mode_Track());
			UI_Tuto::DisableAll();
			
			UI_Manager::ShowOnly([UI_Manager::C_File_BlockHelp, UI_Manager::C_File_Header, UI_Manager::C_File_MacroblockSelection, UI_Manager::C_File_Tuto]);

			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Macroblock, CMapEditorPlugin::EditMode::Place);
			BrowseMacroblocks2();
			declare GamepadEditor_NeedSimpleBlock for Map = False;
			if (GamepadEditor_NeedSimpleBlock) SelectSimplestMacroblock();
			GamepadEditor_NeedSimpleBlock = False;
			
			Yield();
			PreviewMacroblock(UI_MacroblockSelection::GetMacroblockId(), UI_MacroblockSelection::GetMacroblockPlacement(), False);
			MoveMacroblock(<0,0,0>, False);
		}
		case C_Sequence_TestMode: {
			UI_BlockHelp::SetOptions([
				Buttons2::Editor_StartTest() => _("|Infinitive - Try track|Test"),
				Buttons2::Editor_CancelTest() => _("|Cancel|Back")
			]);
			UI_Header::SetTitle(_("|Infinitive - Try track|Test track"));
			if(!S_NoExpertTerraforming){
				UI_Header::SetModes([C_Modes[C_Modes_ConstructTerrain], C_Modes[C_Modes_ConstructTrack], C_Modes[C_Modes_ConstructDeco]]);
			}else{
				UI_Header::SetModes([C_Modes[C_Modes_ConstructTrack], C_Modes[C_Modes_ConstructDeco]]);
			}
			//UI_Header::SelectMode(C_Modes[C_Modes_ConstructTrack]);
			
			UI_Manager::ShowOnly([UI_Manager::C_File_BlockHelp, UI_Manager::C_File_Header, UI_Manager::C_File_SpawnSelection]);
			
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Macroblock, CMapEditorPlugin::EditMode::Place);
			
			SetCursorMacroblockModel(Null);
			FindSpawns2();
			SelectSpawn(0);
		}
		case C_Sequence_EditTerrain: {
			ThemePack::SetMode(ThemePack::Mode_Terrain());
			
			declare BlockHelp = [
				Buttons2::Editor_AddTerrain() => _("|Infinitive|Add"),
				Buttons2::Editor_RemoveTerrain() => _("|Infinitive|Remove"),
				Buttons2::Editor_Redo() => _("|Infinitive - Ctrl Z System|Redo"),
				Buttons2::Editor_Undo() => _("|Infinitive - Ctrl Z System|Undo"),
				Buttons2::Editor_OpenTest() => _("Prebuilt Landscapes"),
				Buttons2::Editor_BrowseBlocks() => _("|Infinitive|Browse"),
				Buttons2::Editor_CameraMove() => _("|Move camera|Camera"),
				Buttons2::Editor_CameraZoom() => _("|Infinitive|Zoom")
			];

			UI_BlockHelp::SetOptions(BlockHelp);
			UI_Header::SetTitle(_("|Game mode - Edit Landscapes|Landscape editing"));
			UI_Header::SetModes([C_Modes[C_Modes_ConstructTerrain], C_Modes[C_Modes_ConstructTrack], C_Modes[C_Modes_ConstructDeco]]);
			UI_Header::SelectMode(C_Modes[C_Modes_ConstructTerrain]);
			
			UI_MacroblockSelection::SetStyle("terrain", 1, 1);
			UI_MacroblockSelection::SetMode(UI_MacroblockSelection::Mode_Terrain());
			UI_Tuto::DisableAll();

			UI_Manager::ShowOnly([UI_Manager::C_File_BlockHelp, UI_Manager::C_File_Header, UI_Manager::C_File_MacroblockSelection, UI_Manager::C_File_Tuto]);
			
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Terraform, CMapEditorPlugin::EditMode::Place);
			Transitions::ClearAllTransitions();
			if (G_SavedCursorCoord.existskey(C_Sequence_EditTerrain)) {
				SetCursorCoord(G_SavedCursorCoord[C_Sequence_EditTerrain]);
			} else {
				SetCursorCoord(<Map.Size.X/2, GetGroundHeight(Map.Size.X/2, Map.Size.Z/2), Map.Size.Z/2>);
			}
			MoveTerrain(<0, 0, 0>, True); ///< Move camera to the right position
			G_AvailableMacroblocks = SortMacroblocks(FilterTerrainMacroblocks(), True);
	
			SendMacroblockList(G_AvailableMacroblocks);
			
			CheckTuto();
		}
		case C_Sequence_AutoDecoration: {
			Camera.FollowCursor(False);
			ThemePack::SetMode(ThemePack::Mode_Decoration());
			
			UI_Manager::HideAll();
		}
		case C_Sequence_EditDecoration: {
			ThemePack::SetMode(ThemePack::Mode_Decoration());
			//CheckHelper();
			UI_Header::SetTitle(_("|Game mode - Edit Decoration|Decoration editing"));
			if(!S_NoExpertTerraforming){
				UI_Header::SetModes([C_Modes[C_Modes_ConstructTerrain], C_Modes[C_Modes_ConstructTrack], C_Modes[C_Modes_ConstructDeco]]);
			}else{
				UI_Header::SetModes([C_Modes[C_Modes_ConstructTrack], C_Modes[C_Modes_ConstructDeco]]);
			}
			UI_Header::SelectMode(C_Modes[C_Modes_ConstructDeco]);
			
			UI_MacroblockSelection::SetStyle(ThemePack::GetDecoStyleName(), ThemePack::GetDecoStylePage(), ThemePack::GetDecoStylesCount());
			UI_MacroblockSelection::SetMode(UI_MacroblockSelection::Mode_Decoration());
			UI_Tuto::DisableAll();
			
			UI_Manager::ShowOnly([UI_Manager::C_File_BlockHelp, UI_Manager::C_File_Header, UI_Manager::C_File_MacroblockSelection, UI_Manager::C_File_Tuto]);
			
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Macroblock, CMapEditorPlugin::EditMode::Place);
			Transitions::ClearAllTransitions();
			if (G_SavedCursorCoord.existskey(C_Sequence_EditDecoration)) {
				SetCursorCoord(G_SavedCursorCoord[C_Sequence_EditDecoration]);
			} else {
				SetCursorCoord(<Map.Size.X/2, GetGroundHeight(Map.Size.X/2, Map.Size.Z/2), Map.Size.Z/2>);
			}
			DisplaySkinSelection(Cursor.Coord);
			BrowseMacroblocks2();
			
			CheckTuto();
		}
		case C_Sequence_Simple_Terraforming: {
			ThemePack::SetMode(ThemePack::Mode_Terrain());
			UI_Header::SetTitle(_("|Game mode - Edit Landscapes|Select a landscape"), True);
			UI_Header::SetModes([]);
			declare Integer[] UIToShow = [UI_Manager::C_File_Header];
			
			if (!IsEditor(C_Editor_Beginner)) {
				declare LandStylesNames = ThemePack::GetLandStylesNames();
				UI_StyleSelection::SetStyles(LandStylesNames);
				UI_StyleSelection::SelectStyle(ThemePack::GetLandStyleName());
				foreach (LandStylesName in LandStylesNames) {
					UI_StyleSelection::Enable(LandStylesName);
				}
				UIToShow.add(UI_Manager::C_File_StyleSelection);
				
				declare metadata Text GamepadEditor_TerrainId for Map;
				G_PreviewTerrainId = GamepadEditor_TerrainId;
				
				if (!C_RandomLandscape) {
					declare Terrain <=> ThemePack::GetTerrain();
					declare TerrainName = Macroblock::GetName(Terrain);
					if (G_PreviewTerrainId == Macroblock::GetId(Terrain)) TerrainName = ""; ///< Don't display screenshot if the terrain is already placed
					UI_TerrainPreview::SetTerrains("", TerrainName, 0);
				}
				
				UI_Tuto::DisableAll();
				UIToShow.add(UI_Manager::C_File_Tuto);
				if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_Landscape())) {
					UI_Tuto::Enable(UI_Tuto::Tuto_Landscape());
				}
			}
			
			if (!C_RandomLandscape) UIToShow.add(UI_Manager::C_File_TerrainPreview);
			
			UpdateLandscapeChoice();
			UI_SimpleMenu::DisplayAutoFinish(False);
			UI_Manager::ShowOnly(UIToShow);
			
			G_Category = C_Categories_Landscape;
			G_Mode = C_Modes_LandscapePostcards;
			G_StartingNewMap = True;
			
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Unknown, CMapEditorPlugin::EditMode::FreeLook);
			UndergroundMode = False;
			SetCursorMacroblockModel(Null);
			
			Camera.FollowCursor(False);
			Camera.Look(C_North);
			Camera.SetVStep(CMapEditorCamera::ECameraVStep::MediumLow);
			Camera.WatchWholeMap();
		}
		case C_Sequence_Simple_AutoTerrain: {
			Camera.FollowCursor(False);
			ThemePack::SetMode(ThemePack::Mode_Terrain());
			
			UI_Manager::HideAll();
			
			G_Category = C_Categories_Landscape;
			G_Mode = C_Modes_LandscapePostcards;
			G_StartingNewMap = True;
			
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Macroblock, CMapEditorPlugin::EditMode::Place);
			UndergroundMode = False;
			SetCursorMacroblockModel(Null);
			
			Camera.FollowCursor(False);
			Camera.Look(C_North);
			Camera.SetVStep(CMapEditorCamera::ECameraVStep::MediumLow);
			Camera.WatchWholeMap();
		}
		case C_Sequence_Simple_PlaceStart: {
			ThemePack::SetMode(ThemePack::Mode_Track());
			UI_Header::SetTitle(_("Select the location of the starting line"), True);
			UI_Header::SetModes([]);
			declare Integer[] UIToShow = [UI_Manager::C_File_Header, UI_Manager::C_File_MacroblockSelection, UI_Manager::C_File_BlockHelp, UI_Manager::C_File_Tuto];
			
			if (!IsEditor(C_Editor_Beginner)) {
				declare TrackStyles = ThemePack::GetTrackStyles();
				declare StartStyles = ThemePack::GetStartStyles();
				// Select an existing start style
				declare NeedSelectStyle = (StartStyles.count > 0 && !StartStyles.existskey(ThemePack::GetTrackStyle()));
				UI_StyleSelection::SetStyles(ThemePack::GetTrackStylesNames());
				foreach (TrackStyleId => TrackStyleName in TrackStyles) {
					if (StartStyles.existskey(TrackStyleId)) {
						UI_StyleSelection::Enable(TrackStyleName);
						if (NeedSelectStyle) {
							ThemePack::Select(TrackStyleId, ThemePack::GetLandStyle(), ThemePack::GetDecoStyle());
							NeedSelectStyle = False;
						}
					} else {
						UI_StyleSelection::Disable(TrackStyleName);
					}
				}
				UI_StyleSelection::SelectStyle(ThemePack::GetTrackStyleName());
				UIToShow.add(UI_Manager::C_File_StyleSelection);
				
				if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_Landscape())) {
					UI_Tuto::ValidateTuto(UI_Tuto::Tuto_Landscape());
				}
			} else {
				// Bugfix because all Starts seem to be added in Category 0 (tech).
				// Feels a bit hacky (I don't exactly know why starts are like that) but it works.
				ThemePack::Select(0, 0, 0); 
				BrowseMacroblocks2();
				Yield();
			}
			
			UI_MacroblockSelection::SetFamilyVisibility(IsEditor(C_Editor_Advanced));
			UI_SimpleMenu::DisplayAutoFinish(False);
			UI_Tuto::DisableAll();
			
			UI_BlockHelp::SetOptions([
				Buttons2::Editor_PlaceBlock() => _("|Infinitive|Place"),
				Buttons2::Editor_TurnBlock() => _("|Infinitive|Rotate"),
				Buttons2::Editor_RaiseStart() => _("|Infinitive - Elevate block cursor|Raise"),
				Buttons2::Editor_LowerStart() => _("|Infinitive - Reduce block cursor height|Lower"),
				Buttons2::Editor_MoveBlock() => _("|Infinitive|Move"),
				Buttons2::Editor_CameraMove() => _("|Move camera|Camera"),
				Buttons2::Editor_CameraZoom() => _("|Infinitive|Zoom")
			]);

			UI_Manager::ShowOnly(UIToShow);

			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Macroblock, CMapEditorPlugin::EditMode::Place);
			SetCursorMacroblockModel(Null);
			
			declare StartingCursorCoord = Cursor.Coord;
			if (G_StartingNewMap) {
				declare metadata Text GamepadEditor_TerrainId for Map;
				declare metadata Integer GamepadEditor_TerrainDir for Map;
				declare TerrainName = Macroblock::GetName(Macroblock::GetMacroblockModelFromId(GamepadEditor_TerrainId));
				StartingCursorCoord = Terrain::GetTerrainSpawn(TerrainName, Utils::IntToDir(GamepadEditor_TerrainDir));
				if (StartingCursorCoord == Utils::NullCoord()) StartingCursorCoord = <Map.Size.X/2, CollectionGroundY, Map.Size.Z/2>;
			}
			
			declare StartMacroblockModel = InitStartMacroblocks(StartingCursorCoord, False);
			if (!G_StartingNewMap && StartMacroblockModel == Null) StartMacroblockModel = InitStartMacroblocks(<Map.Size.X/2, CollectionGroundY, Map.Size.Z/2>, False);
			if (StartMacroblockModel != Null) PreviewMacroblock(StartMacroblockModel.Id);
			else PreviewMacroblock(NullId);
			
			G_Category = C_Categories_Construct;
			G_Mode = C_Modes_ConstructTrack;
			G_StartingNewMap = False;
			
			Camera.Look(Cursor.Dir);
			Camera.Zoom(CMapEditorCamera::EZoomLevel::Medium);
			
			declare GamepadEditor_NeedSimpleBlock for Map = False;
			GamepadEditor_NeedSimpleBlock = True;
			
			CheckTuto();
		}
		case C_Sequence_Simple_BuildTrack: {
			ThemePack::SetMode(ThemePack::Mode_Track());
			
			UI_Header::SetModes([]);
			declare Integer[] UIToShow = [UI_Manager::C_File_Header, UI_Manager::C_File_MacroblockSelection, UI_Manager::C_File_BlockHelp, UI_Manager::C_File_Tuto];
			
			if (IsEditor(C_Editor_Beginner)) {
				if(CutPasteIsAllowed())
					UIToShow.add(UI_Manager::C_File_CutPaste);
			} else {
				declare TrackStylesNames = ThemePack::GetTrackStylesNames();
				UI_StyleSelection::SetStyles(TrackStylesNames);
				UI_StyleSelection::SelectStyle(ThemePack::GetTrackStyleName());
				foreach (TrackStyleName in TrackStylesNames) {
					UI_StyleSelection::Enable(TrackStyleName);
				}
				UIToShow.add(UI_Manager::C_File_StyleSelection);
				UIToShow.add(UI_Manager::C_File_CutPaste);
			}
			
			UI_MacroblockSelection::SetFamilyVisibility(IsEditor(C_Editor_Advanced));
			UI_SimpleMenu::DisplayAutoFinish(True);
			UI_Tuto::DisableAll();
			UI_Manager::ShowOnly(UIToShow);
			
			G_Category = C_Categories_Construct;
			G_Mode = C_Modes_ConstructTrack;
			G_AskForValidation = True;
			
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Macroblock, CMapEditorPlugin::EditMode::Place);
			Transitions::ClearAllTransitions();
			SetCursorCoord(MapContent::GetLatestMacroblockUnitCoord(C_Modes_ConstructTrack, False));
			AutoSelectStyle();
			BrowseMacroblocks2();
			
			declare GamepadEditor_NeedSimpleBlock for Map = False;
			if (GamepadEditor_NeedSimpleBlock) {
				SelectSimplestMacroblock();
			}
			// Check that we selected an available macroblock when switching from disconnected to connected mode
			else if (IsEditor(C_Editor_Advanced)) {
				if (UI_MacroblockSelection::IsAvailable(UI_MacroblockSelection::GetMacroblockId())) {
					UI_MacroblockSelection::FindMacroblock(UI_MacroblockSelection::GetMacroblockId());
				} else {
					SelectSimplestMacroblock();
				}
			}
			
			PreviewMacroblock(UI_MacroblockSelection::GetMacroblockId(), UI_MacroblockSelection::GetMacroblockPlacement(), False);
			GamepadEditor_NeedSimpleBlock = False;
			
			CheckAdvices();
			CheckTuto();
		}
		case C_Sequence_Simple_MoveCursor: {
			ThemePack::SetMode(ThemePack::Mode_Track());
			
			UI_Header::SetTitle(_("Move the block to a new location"), True);
			UI_Header::SetModes([]);			
			declare Integer[] UIToShow = [UI_Manager::C_File_Header, UI_Manager::C_File_StyleSelection, UI_Manager::C_File_MacroblockSelection, UI_Manager::C_File_BlockHelp, UI_Manager::C_File_Tuto];
			
			declare TrackStylesNames = ThemePack::GetTrackStylesNames();
			UI_StyleSelection::SetStyles(TrackStylesNames);
			UI_StyleSelection::SelectStyle(ThemePack::GetTrackStyleName());
			foreach (TrackStyleName in TrackStylesNames) {
				UI_StyleSelection::Enable(TrackStyleName);
			}
						
			UI_BlockHelp::SetOptions([
				Buttons2::Editor_PlaceBlock() => _("|Infinitive|Place"),
				Buttons2::Editor_CutBlock() => _("|Infinitive|Cut"),
				Buttons2::Editor_TurnBlock() => _("|Infinitive|Rotate"),
				//Buttons2::Editor_OpenTest() => _("|Infinitive - Try track|Test"),
				Buttons2::Editor_Disconnect() => _("|Infinitive|Connect"),
				Buttons2::Editor_RaiseStart() => _("|Infinitive - Elevate block cursor|Raise"),
				Buttons2::Editor_LowerStart() => _("|Infinitive - Reduce block cursor height|Lower"),
				Buttons2::Editor_MoveBlock() => _("|Infinitive|Move"),
				Buttons2::Editor_CameraMove() => _("|Move camera|Camera"),
				Buttons2::Editor_CameraZoom() => _("|Infinitive|Zoom")
			]);
			
			UI_MacroblockSelection::SetFamilyVisibility(IsEditor(C_Editor_Advanced));
			UI_SimpleMenu::DisplayAutoFinish(True);
			UI_Tuto::DisableAll();
			UI_Manager::ShowOnly(UIToShow);
			
			G_Category = C_Categories_Construct;
			G_Mode = C_Modes_ConstructTrack;
			G_AskForValidation = True;
			
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Macroblock, CMapEditorPlugin::EditMode::Place);
			Transitions::ClearAllTransitions();
			AutoSelectStyle();
			BrowseMacroblocks2();
			
			if (G_CursorMacroblockModel != Null && UI_MacroblockSelection::IsAvailable(G_CursorMacroblockModel.Id)) {
				UI_MacroblockSelection::FindMacroblock(G_CursorMacroblockModel.Id);
			} else {
				SelectSimplestMacroblock();
			}
			
			PreviewMacroblock(UI_MacroblockSelection::GetMacroblockId(), UI_MacroblockSelection::GetMacroblockPlacement(), False);
			
			CheckTuto();
		}
		case C_Sequence_Simple_Test: {
			declare Integer[] UIToShow = [UI_Manager::C_File_SpawnSelection, UI_Manager::C_File_BlockHelp];
			
			UI_BlockHelp::SetOptions([
				Buttons2::Editor_StartTest() => _("|Infinitive - Try track|Test"),
				Buttons2::Editor_CancelTest() => _("|Infinitive|Cancel")
			]);
			UI_SimpleMenu::DisplayAutoFinish(False);
			UI_Manager::ShowOnly(UIToShow);
			
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Unknown, CMapEditorPlugin::EditMode::FreeLook);
			UndergroundMode = False;
			SetCursorMacroblockModel(Null);
			FindSpawns2();
			SelectSpawn(0);
		}
		case C_Sequence_Simple_Deco: {
			ThemePack::SetMode(ThemePack::Mode_Decoration());
			UI_Header::SetTitle(_("|Game mode - Edit Decoration|Decoration editing"), True);
			UI_Header::SetModes([]);
			declare Integer[] UIToShow = [UI_Manager::C_File_Header, UI_Manager::C_File_SimpleChoice];
			
			if (!IsEditor(C_Editor_Beginner)) {
				UIToShow.add(UI_Manager::C_File_DecoSelection);
				
				UI_Tuto::DisableAll();
				UIToShow.add(UI_Manager::C_File_Tuto);
				if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_Decoration())) {
					UI_Tuto::Enable(UI_Tuto::Tuto_Decoration());
				}
			}
						
			if (IsDecorated()) {
				UI_SimpleChoice::SetOptions([
					Buttons2::Editor_DecoGenerate() => _("|Infinitive|Generate decoration"),
					Buttons2::Editor_DecoValid() => _("|Infinitive|Validate track"),
					Buttons2::Editor_DecoCancel() => _("|Infinitive|Edit track"),
					Buttons2::Editor_DecoDefault() => _("|Reset to default button|Default settings")
				], [
					C_SimpleChoice_DecoGenerate,
					C_SimpleChoise_DecoValid,
					C_SimpleChoice_DecoCancel,
					C_SimpleChoice_DecoDefault
				]);
			} else {
				UI_SimpleChoice::SetOptions([
					Buttons2::Editor_DecoGenerate() => _("|Infinitive|Generate decoration"),
					Buttons2::Editor_DecoCancel() => _("|Infinitive|Edit track"),
					Buttons2::Editor_DecoDefault() => _("|Reset to default button|Default settings")
				], [
					C_SimpleChoice_DecoGenerate,
					C_SimpleChoice_DecoCancel,
					C_SimpleChoice_DecoDefault
				]);
			}
			UI_SimpleChoice::SetStyle(UI_SimpleChoice::Style_Default());
			UI_SimpleMenu::DisplayAutoFinish(False);
			UI_Manager::ShowOnly(UIToShow);
			
			G_Category = C_Categories_Construct;
			G_Mode = C_Modes_ConstructDeco;
			G_AskForValidation = True;
			
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Unknown, CMapEditorPlugin::EditMode::FreeLook);
			UndergroundMode = False;
			SetCursorMacroblockModel(Null);
			SetCursorStyle();
			
			Camera.FollowCursor(False);
			Camera.Look(C_SouthEast);
			Camera.SetVStep(CMapEditorCamera::ECameraVStep::MediumLow);
			Camera.WatchMacroblocks(C_Modes_ConstructDeco);
		}
		case C_Sequence_Simple_Outro: {
			if (ValidationStatus == CMapEditorPlugin::ValidationStatus::Validated) {
				UI_Header::SetTitle(
					TL::Compose(
						// "%1: %2 | %3: %4", // TAG: MapStyleSelection
						"%1: %2",
						"Author time", 
						TL::TimeToText(Map.TMObjective_AuthorTime, True)
						/*//L16N [MapEditor] The track style (fullspeed, tech, mini, lol, ...)
						_("Track style"), 
						UI_MapStyleSelection::GetStyleName()*/ // TAG: MapStyleSelection
					), 
					True, UI_Header::Status_AuthorTime()
				);
			} else {
				UI_Header::SetTitle(_("|Information - window title|Track not validated"), True, UI_Header::Status_Message());
			}
			
			UI_Header::SetModes([]);
						
			CheckProgression();
			UI_SimpleMenu::DisplayAutoFinish(False);
			UI_Manager::ShowOnly([UI_Manager::C_File_Header, UI_Manager::C_File_MenuOutro]);
			UI_Header::SetVisibility(False, True, True);
			UI_Manager::Show(UI_Manager::C_File_Progression);
			
			SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Unknown, CMapEditorPlugin::EditMode::FreeLook);
			UndergroundMode = False;
			SetCursorMacroblockModel(Null);
			
			Camera.FollowCursor(False);
			Camera.Look(C_SouthEast);
			Camera.SetVStep(CMapEditorCamera::ECameraVStep::MediumLow);
			Camera.WatchMacroblocks(C_Modes_ConstructTrack);
		}
		case C_Sequence_None: {
			UI_Manager::HideAll();
		}
	}
}

/// Select the current building sequence
Void SelectSequence() {
	if (UI_PopUp::IsOpen() || UI_ShadowMenu::LayerIsVisible()) 	G_CurrentSequence = C_Sequence_PopUp;
	else if (UI_Save::LayerIsVisible()) 	G_CurrentSequence = C_Sequence_Save;
	else if (G_RandomMapGeneration) {
		if (G_WaitingRerollAnswer) 		G_CurrentSequence = C_Sequence_RerollMap;
		else							G_CurrentSequence = C_Sequence_RandomMap;
	}
	// else if (G_MapStyleSelection) 		G_CurrentSequence = C_Sequence_MapStyle; // TAG: MapStyleSelection
	else if (G_MainMenu) 				G_CurrentSequence = C_Sequence_MainMenu;
	else if (IsGeneratingDecoration()) 	G_CurrentSequence = C_Sequence_AutoDecoration;
	else if (IsGeneratingTerrain()) 	G_CurrentSequence = C_Sequence_AutoTerrain;
	else if (IsAutoFinishing()) 		G_CurrentSequence = C_Sequence_AutoFinish;
	// Beginner or advanced
	else if (IsSimpleEditor()) {
		if (!IsTerraformed() && !S_NoTerraforming) {
			if (IsEditor(C_Editor_Advanced)) 	G_CurrentSequence = C_Sequence_Simple_Terraforming;
			else 								G_CurrentSequence = C_Sequence_Simple_AutoTerrain;
		}
		else if (!MapContent::HasStart()) 		G_CurrentSequence = C_Sequence_Simple_PlaceStart;
		else if (G_TestMode) 					G_CurrentSequence = C_Sequence_Simple_Test;
		else if (!MapContent::HasFinish()) {
			if (G_MoveCursor) 					G_CurrentSequence = C_Sequence_Simple_MoveCursor;
			else 								G_CurrentSequence = C_Sequence_Simple_BuildTrack;
		}
		else if (IsEditor(C_Editor_Advanced) && !DecoConfirmed() && !S_NoDecoration) 	G_CurrentSequence = C_Sequence_Simple_Deco;
		else							G_CurrentSequence = C_Sequence_Simple_Outro;
	}
	// Expert
	else {
		if (!IsTerraformed()) {
			if (G_Mode == C_Modes_LandscapeRandom) 			G_CurrentSequence = C_Sequence_RandomTerrain;
			else if (G_Mode == C_Modes_LandscapePostcards)	G_CurrentSequence = C_Sequence_SelectTerrain;
		}
		else {
			if (G_TestMode) 								G_CurrentSequence = C_Sequence_TestMode;
			else if (G_Mode == C_Modes_ConstructTerrain)	G_CurrentSequence = C_Sequence_EditTerrain;
			else if (G_Mode == C_Modes_ConstructTrack) {
				if (!MapContent::HasStart()) 				G_CurrentSequence = C_Sequence_PlaceStart; 
				else /*if (IsFreeMode())*/ 					G_CurrentSequence = C_Sequence_FreeMode; // If we're here we're ALWAYS in free mode
			}
			else if (G_Mode == C_Modes_ConstructDeco) 		G_CurrentSequence = C_Sequence_EditDecoration;
		}
	}
	
	if (G_CurrentSequence != G_PrevSequence) {	
		G_SavedCursorCoord = [
			C_Sequence_EditTerrain => G_CursorCoord,
			C_Sequence_EditDecoration => G_CursorCoord
		];
		OnSequenceStart(G_CurrentSequence);
		G_PrevSequence = G_CurrentSequence;
	}
}

/** Open a confirm pop up with a question and the choice to accept or refuse
 *
 *	@param	_Title					The title of the pop up
 *	@param	_Question				The question to ask
 *	@param	_Yes						The "valid" answer
 *	@param	_No							The "Cancel" answer
 *	@param	_PlaySound			Play a sound when displaying the pop up
 *
 *	@return							The answer to the question
 */
Boolean Confirm(Text _Title, Text _Question, Text _Yes, Text _No, Boolean _PlaySound) {
	if (_Title == "" && _Yes == "" && _No == "") UI_PopUp::Confirm(_Question);
	else UI_PopUp::Confirm(_Title, _Question, _Yes, _No);
	
	if (_PlaySound) Sound::Play("EditorPopUp");
	SelectSequence();
	
	while (UI_PopUp::Wait()) Yield();
	
	// Clear input buffer
	ClearInputBuffer();
	G_TerrainCanPress = False;
	
	SelectSequence();
	return UI_PopUp::Answer();
}

// Confirm overload
Boolean Confirm(Text _Title, Text _Question, Text _Yes, Text _No) {
	return Confirm(_Title, _Question, _Yes, _No, True);
}

// Confirm overload
Boolean Confirm(Text _Question) {
	return Confirm("", _Question, "", "", True);
}

/** Open an alert pop up with a message
 *
 *	@param	_Title				The title of the pop-up
 *	@param	_Message			The message to display
 *	@param	_Answer				The answer to display
 *	@param	_PlaySound			Play a sound when displaying the pop up
 */
Void Alert(Text _Title, Text _Message, Text _Answer, Boolean _PlaySound) {
	if (_Title == "" && _Answer == "") UI_PopUp::Alert(_Message);
	else UI_PopUp::Alert(_Title, _Message, _Answer);
	
	if (_PlaySound) Sound::Play("EditorPopUp");
	SelectSequence();
	
	while (UI_PopUp::Wait()) Yield();
	
	// Clear input buffer
	ClearInputBuffer();
	G_TerrainCanPress = False;
	
	SelectSequence();
}

// Alert overload
Void Alert(Text _Title, Text _Message, Text _Answer) {
	Alert(_Title, _Message, _Answer, True);
}

// Alert overload
Void Alert(Text _Message) {
	Alert("", _Message, "");
}

// Display or hide the loading screen
Void Loading(Boolean _IsLoading, Text _Message, Boolean _SequencePopUp) {
	if(HoldLoadingScreen) return;
	UI_PopUp::Loading(_IsLoading, _Message, _SequencePopUp);
	SelectSequence();
	Sleep(250);
}

Text GetLoadingText() {
	declare Integer Rand = ML::Rand(0, 100);
	declare LoadingText = "";
	if (Rand <= 30)				LoadingText = _("|Gamepad Track Editor Loading screen|Preparing Track Editor...");
	else if (Rand <= 50)	LoadingText = _("|Gamepad Track Editor Loading screen|Fetching the blocks...");
	else if (Rand <= 70)	LoadingText = _("|Gamepad Track Editor Loading screen|Getting ready...");
	else if (Rand <= 80)	LoadingText = _("|Gamepad Track Editor Loading screen|Just a moment...");
	else if (Rand <= 89)	LoadingText = _("|Gamepad Track Editor Loading screen|Almost there...");
	else if (Rand <= 90)	LoadingText = _("|Gamepad Track Editor Loading screen|Rebuilding the track...");
	else if (Rand <= 91)	LoadingText = _("|Gamepad Track Editor Loading screen|Cleaning the pools...");
	else if (Rand <= 92)	LoadingText = _("|Gamepad Track Editor Loading screen|Watering the trees...");
	else if (Rand <= 93)	LoadingText = _("|Gamepad Track Editor Loading screen|Refilling the sparklers...");
	else if (Rand <= 94)	LoadingText = _("|Gamepad Track Editor Loading screen|Freezing the ice...");
	else if (Rand <= 95)	LoadingText = _("|Gamepad Track Editor Loading screen|Assembling blocks...");
	else if (Rand <= 96)	LoadingText = _("|Gamepad Track Editor Loading screen|Buying more cacti...");
	else if (Rand <= 97)	LoadingText = _("|Gamepad Track Editor Loading screen|Bringing the llamas...");
	else if (Rand <= 98)	LoadingText = _("|Gamepad Track Editor Loading screen|Charging the cars...");
	else if (Rand <= 99)	LoadingText = _("|Gamepad Track Editor Loading screen|Building the stadium...");
	else if (Rand <= 100)	LoadingText = _("|Gamepad Track Editor Loading screen|Tracking the Manias...");
		
	return LoadingText;
}

// Loading overload
Void Loading(Boolean _IsLoading) {
	Loading(_IsLoading, GetLoadingText(), True);
}

// Place a macroblock on the track
Boolean CustomPlaceMacroblock(CMacroblockModel _MacroblockModel, Int3 _Coord, CMapEditorPlugin::CardinalDirections _Dir) {	
	declare Placed = False;
	if (!G_RandomMapGeneration && ThemePack::CanPlaceTerrain(_MacroblockModel)) Placed = PlaceMacroblock(_MacroblockModel, _Coord, _Dir);
	//else if(G_AirModeMapping && G_GhostModeMapping) Placed = PlaceMacroblock_AirAndGhostMode(_MacroblockModel, _Coord, _Dir);
	//else if(G_GhostModeMapping) Placed = PlaceMacroblock_GhostMode(_MacroblockModel, _Coord, _Dir);
	else if(G_AirModeMapping) 	Placed = PlaceMacroblock_AirMode(_MacroblockModel, _Coord, _Dir);
	else 												Placed = PlaceMacroblock_NoTerrain(_MacroblockModel, _Coord, _Dir);
	
	// Yield to place blocks
	if (Placed) Yield();
	
	return Placed;
}

// Find and select a macroblock in the currently available ones
Void SelectMacroblock(Ident _MacroblockModelId, Int3 _MacroblockCoord, CMapEditorPlugin::CardinalDirections _MacroblockDir) {
	// Search in the other families too
	if ((IsEditor(C_Editor_Advanced) || IsEditor(C_Editor_Expert))) {
		declare MacroblockMode = MapContent::GetMacroblockType(_MacroblockCoord);
		if (!MapContent::Exists(Cursor.Coord))
			MacroblockMode = G_Mode; // i guess?
		SelectMacroblockStyle(_MacroblockModelId, MacroblockMode);
	}
	
	if (IsSimpleEditor()) {
		foreach (Family => Macroblocks in G_AvailableMacroblocks) {
			foreach (MacroblockModel in Macroblocks) {
				if (MacroblockModel.Id != _MacroblockModelId) continue;
				
				declare MacroblockCoords = Placement::GetCoords(MacroblockModel);
				declare MacroblockDirs = Placement::GetDirs(MacroblockModel);
				foreach (Placement => MacroblockCoord in MacroblockCoords) {
					if (MacroblockCoord == _MacroblockCoord && MacroblockDirs[Placement] == _MacroblockDir) {
						declare ConnectedTo = Placement::GetConnectedToClip(MacroblockModel, Placement);
						if (G_AvailableConnectors.exists(ConnectedTo)) {
							G_CursorConnectedTo = ConnectedTo;
							//SendMacroblockList(G_AvailableMacroblocks);
						}
						UI_MacroblockSelection::FindMacroblock(_MacroblockModelId, Placement);
						return;
					}
				}
			}
		}
	} else {
		if (MacroblockModels.existskey(_MacroblockModelId)) {
			declare MacroblockModelName = Macroblock::GetFullName(MacroblockModels[_MacroblockModelId]);
			
			foreach (Family => Macroblocks in G_AvailableMacroblocks) {
				foreach (MacroblockModel in Macroblocks) {
					if (Macroblock::GetFullName(MacroblockModel) != MacroblockModelName) continue;
					
					UI_MacroblockSelection::FindMacroblock(MacroblockModel.Id);
					return;
				}
			}
		}
	}
}

//	Select a style
//	@param	_Shift					Animation direction in the UI for terrains
Void SelectStyle(Integer _StyleIndex, Text _StyleName, Integer _Shift) {
	UI_StyleSelection::SelectStyle(_StyleName);
	
	if (!C_RandomLandscape && G_CurrentSequence == C_Sequence_Simple_Terraforming) {
		declare OldTerrain <=> ThemePack::GetTerrain();
		declare OldTerrainName = Macroblock::GetName(OldTerrain);
		if (G_PreviewTerrainId == Macroblock::GetId(OldTerrain)) OldTerrainName = "";
		
		ThemePack::Select(ThemePack::GetTrackStyle(), _StyleIndex, ThemePack::GetDecoStyle());
		
		declare NewTerrain <=> ThemePack::GetTerrain();
		declare NewTerrainName = Macroblock::GetName(NewTerrain);
		if (G_PreviewTerrainId == Macroblock::GetId(NewTerrain)) NewTerrainName = "";
		
		UI_TerrainPreview::SetTerrains(OldTerrainName, NewTerrainName, _Shift);
	} else if (G_CurrentSequence == C_Sequence_Simple_Terraforming || G_CurrentSequence == C_Sequence_Simple_Deco) {
		ThemePack::Select(ThemePack::GetTrackStyle(), _StyleIndex, ThemePack::GetDecoStyle());
	} else if (
		G_CurrentSequence == C_Sequence_Simple_PlaceStart ||
		G_CurrentSequence == C_Sequence_Simple_MoveCursor ||
		G_CurrentSequence == C_Sequence_PlaceStart ||
		G_CurrentSequence == C_Sequence_FreeMode ||
		G_CurrentSequence == C_Sequence_EditDecoration
	) {
		if (G_CurrentSequence == C_Sequence_EditDecoration)
			ThemePack::Select(ThemePack::GetTrackStyle(), ThemePack::GetLandStyle(), _StyleIndex);
		
		else
			ThemePack::Select(_StyleIndex, ThemePack::GetLandStyle(), ThemePack::GetDecoStyle());
		BrowseMacroblocks2();
		Yield();
		
		PreviewMacroblock(UI_MacroblockSelection::GetMacroblockId(), UI_MacroblockSelection::GetMacroblockPlacement(), False);
		MoveMacroblock(<0, 0, 0>, False);
		
		if (G_CurrentSequence == C_Sequence_PlaceStart) {
			UI_MacroblockSelection::SetStyle(_StyleName, ThemePack::GetStartStylePage(), ThemePack::GetStartStylesCount());
		} else if(G_CurrentSequence == C_Sequence_EditDecoration) {
			UI_MacroblockSelection::SetStyle(_StyleName, ThemePack::GetDecoStylePage(), ThemePack::GetDecoStylesCount());
		} else {
			UI_MacroblockSelection::SetStyle(_StyleName, ThemePack::GetTrackStylePage(), ThemePack::GetTrackStylesCount());
		}
	} else if (G_CurrentSequence == C_Sequence_Simple_BuildTrack) {
		ThemePack::Select(_StyleIndex, ThemePack::GetLandStyle(), ThemePack::GetDecoStyle());
		SetCursorCoord(MapContent::GetLatestMacroblockUnitCoord(C_Modes_ConstructTrack, False));
		BrowseMacroblocks2();
		CheckAdvices();
	}
	
	SetCursorStyle();
}

// ---------------------------------- //
/// Select a style in the theme pack
Void SelectStyle(Text _StyleName) {
	if (UI_StyleSelection::IsDisabled(_StyleName)) return;
	
	declare Text[Integer] Styles;
	declare Style = 0;
	if (G_CurrentSequence == C_Sequence_EditDecoration) {
		Styles = ThemePack::GetDecoStyles();
		Style = ThemePack::GetDecoStyle();		
	} else if (G_CurrentSequence == C_Sequence_Simple_Terraforming || G_CurrentSequence == C_Sequence_Simple_Deco) {
		Styles = ThemePack::GetLandStyles();
		Style = ThemePack::GetLandStyle();
	} else if (
		G_CurrentSequence == C_Sequence_Simple_BuildTrack ||
		G_CurrentSequence == C_Sequence_Simple_MoveCursor ||
		G_CurrentSequence == C_Sequence_FreeMode
	) {
		Styles = ThemePack::GetTrackStyles();
		Style = ThemePack::GetTrackStyle();
	} else if (
		G_CurrentSequence == C_Sequence_Simple_PlaceStart ||
		G_CurrentSequence == C_Sequence_PlaceStart
	) {
		Styles = ThemePack::GetStartStyles();
		Style = ThemePack::GetTrackStyle();
	}
	
	if (Styles.count == 0) return;
	
	declare NewStyleIndex = -1;
	declare NewStyleName = "";
	declare Shift = -1;
	foreach (StyleIndex => StyleName in Styles) {
		if (UI_StyleSelection::IsDisabled(StyleName)) continue;
		
		if (StyleIndex == Style) {
			Shift = 0;
		} else if (Shift == 0) {
			Shift = 1;
		}
		
		if (StyleName == _StyleName) {
			if (StyleIndex != Style) {
				NewStyleIndex = StyleIndex;
				NewStyleName = StyleName;
			}
			break;
		}
	}
	
	// Don't select the style that is already selected
	if (NewStyleIndex < 0) return;
	
	SelectStyle(NewStyleIndex, NewStyleName, Shift);
	Sound::Play("EditorSimpleSelectMacroblock");
}

/// Select the next style in the theme pack
Void NextStyle() {
	declare Text[Integer] Styles;
	declare Style = 0;
	if (G_CurrentSequence == C_Sequence_EditDecoration) {
		Styles = ThemePack::GetDecoStyles();
		Style = ThemePack::GetDecoStyle();		
	} else if (G_CurrentSequence == C_Sequence_Simple_Terraforming || G_CurrentSequence == C_Sequence_Simple_Deco) {
		Styles = ThemePack::GetLandStyles();
		Style = ThemePack::GetLandStyle();
	} else if (
		G_CurrentSequence == C_Sequence_Simple_BuildTrack ||
		G_CurrentSequence == C_Sequence_Simple_MoveCursor ||
		G_CurrentSequence == C_Sequence_FreeMode
	) {
		Styles = ThemePack::GetTrackStyles();
		Style = ThemePack::GetTrackStyle();
	} else if (
		G_CurrentSequence == C_Sequence_Simple_PlaceStart ||
		G_CurrentSequence == C_Sequence_PlaceStart
	) {
		Styles = ThemePack::GetStartStyles();
		Style = ThemePack::GetTrackStyle();
	}
	
	if (Styles.count == 0) return;
	
	declare NewStyleIndex = -1;
	declare NewStyleName = "";
	declare IsNext = False;
	foreach (StyleIndex => StyleName in Styles) {
		if (UI_StyleSelection::IsDisabled(StyleName)) continue;
		
		if (IsNext) {
			NewStyleIndex = StyleIndex;
			NewStyleName = StyleName;
			break;
		}
		if (NewStyleIndex < 0) {
			NewStyleIndex = StyleIndex;
			NewStyleName = StyleName;
		}
		if (StyleIndex == Style) {
			IsNext = True;
		}
	}
	
	SelectStyle(NewStyleIndex, NewStyleName, 1);
	Sound::Play("EditorSimpleSelectMacroblock");
}

/// Select the previous style in the theme pack
Void PrevStyle() {
	declare Text[Integer] Styles;
	declare Style = 0;
	if (G_CurrentSequence == C_Sequence_EditDecoration) {
		Styles = ThemePack::GetDecoStyles();
		Style = ThemePack::GetDecoStyle();		
	} else if (G_CurrentSequence == C_Sequence_Simple_Terraforming || G_CurrentSequence == C_Sequence_Simple_Deco) {
		Styles = ThemePack::GetLandStyles();
		Style = ThemePack::GetLandStyle();
	} else if (
		G_CurrentSequence == C_Sequence_Simple_BuildTrack ||
		G_CurrentSequence == C_Sequence_Simple_MoveCursor ||
		G_CurrentSequence == C_Sequence_FreeMode
	) {
		Styles = ThemePack::GetTrackStyles();
		Style = ThemePack::GetTrackStyle();
	} else if (
		G_CurrentSequence == C_Sequence_Simple_PlaceStart || 
		G_CurrentSequence == C_Sequence_PlaceStart
	) {
		Styles = ThemePack::GetStartStyles();
		Style = ThemePack::GetTrackStyle();
	}
	
	if (Styles.count == 0) return;
	
	declare NewStyleIndex = -1;
	declare NewStyleName = "";
	foreach (StyleIndex => StyleName in Styles) {
		if (UI_StyleSelection::IsDisabled(StyleName)) continue;
		
		if (StyleIndex == Style && NewStyleIndex >= 0) {
			break;
		}
		NewStyleIndex = StyleIndex;
		NewStyleName = StyleName;
	}
	
	SelectStyle(NewStyleIndex, NewStyleName, -1);
	Sound::Play("EditorSimpleSelectMacroblock");
}

Void PrevStyleFilter() {
	if(G_CurrentSequence != C_Sequence_FreeMode) {
		return;
	}
	ThemePack::ShiftTrackStyleFilter(-1);
	NextStyle(); // select first style of new filter
}


Void NextStyleFilter() {
	if(G_CurrentSequence != C_Sequence_FreeMode) { // note: Then the UI should be hidden in start/deco if it doesn't work?
		return;
	}
	ThemePack::ShiftTrackStyleFilter(1);
	NextStyle(); // select first style of new filter
}

Void PrevMacroblocksPage() {
	UI_MacroblockSelection::ShiftRightPage(-1);
}

Void NextMacroblocksPage() {
	UI_MacroblockSelection::ShiftRightPage(1);
}

// Select a mode
Void SelectMode(Integer _Category, Integer _Mode) {
	// Switch to postcard mode after creating a random terrain
	declare Change = True;
	if (_Mode == C_Modes_LandscapePostcards && G_Mode == C_Modes_LandscapeRandom && IsCustomTerrain() && !IsSimpleEditor()) {
		Change = Confirm(ComposeMultilines([
			_("Any modification done on this terrain will be lost."),
			_("Are you sure you want to select another terrain?")
		]));
	}
	if (!Change) return;
	
	G_Category = _Category;
	G_Mode = _Mode;
}

Void SelectMode(Text _Mode) {
	declare Mode = C_Modes_ConstructTrack;
	if (_Mode == C_Modes[C_Modes_ConstructTerrain]) Mode = C_Modes_ConstructTerrain;
	else if (_Mode == C_Modes[C_Modes_ConstructTrack]) Mode = C_Modes_ConstructTrack;
	else if (_Mode == C_Modes[C_Modes_ConstructDeco]) Mode = C_Modes_ConstructDeco;
	SelectMode(C_Categories_Construct, Mode);
}

// Switch between the modes of a category
Void SwitchMode(Integer _Category) {
	if (_Category == C_Categories_Landscape) {
		switch (G_Mode) {
			case C_Modes_LandscapeRandom	: SelectMode(C_Categories_Landscape, C_Modes_LandscapePostcards);
			case C_Modes_LandscapePostcards	: SelectMode(C_Categories_Landscape, C_Modes_LandscapeRandom);
			default							: SelectMode(C_Categories_Landscape, C_Modes_LandscapePostcards);
		}
	} else if (_Category == C_Categories_Construct) {
		switch (G_Mode) {
			case C_Modes_ConstructTerrain	: SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
			case C_Modes_ConstructTrack		: SelectMode(C_Categories_Construct, C_Modes_ConstructDeco);
			case C_Modes_ConstructDeco		: {
																				if(!S_NoExpertTerraforming) 
																					SelectMode(C_Categories_Construct, C_Modes_ConstructTerrain);
																				else 
																					SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
																			}
			default							: SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
		}
		Sound::Play("EditorSimpleSelectMacroblock");
	}
	
	if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_ChangeMode())) {
		UI_Tuto::ValidateTuto(UI_Tuto::Tuto_ChangeMode());
		CheckTuto();
	}
}

// Apply a skin on a block
Void CustomSetBlockSkins(CBlock _Block, Text _SkinNameBg, Text _SkinNameFg) {
	if (_Block == Null) return;
	
	G_CacheBlocksSkinsBg[_Block.BlockModel.Id] = _SkinNameBg;
	G_CacheBlocksSkinsFg[_Block.BlockModel.Id] = _SkinNameFg;

	SetBlockSkins(_Block, _SkinNameBg, _SkinNameFg);
	MapModified();
}

Void SetMacroblockMultiSkin_Blocks(CMacroblockInstance _MacroblockInstance, Integer _MultiSkinIndex, Int3[] _SkinnableBlockCoords) {
	declare AcceptableSkinNames = UI_SkinSelection::GetAcceptableSkinsForMultiSkin(_MultiSkinIndex);
	
	declare IsSkinFg = False;
	declare SkinBg = "";
	declare SkinFg = "";
	declare SkinName = "";

	foreach (SkinnableBlockCoord in _SkinnableBlockCoords) {
		declare SkinBlock <=> GetBlock(SkinnableBlockCoord);
		if (SkinBlock == Null) continue;
		
		SkinBg = "";
		SkinFg = "";
		
		declare IndexMax = GetNbBlockModelSkins(SkinBlock.BlockModel) - 1;
		for (Index, 0, IndexMax) {
			SkinName = GetBlockModelSkin(SkinBlock.BlockModel, Index);
			
			foreach (AcceptableSkinName in AcceptableSkinNames) {
				if (TL::Find(AcceptableSkinName, SkinName, False, True)) {
					IsSkinFg = IsSkinForeground(SkinBlock.BlockModel, SkinName);
					if (IsSkinFg && SkinFg == "") {
						SkinFg = SkinName;
					} else if (!IsSkinFg && SkinBg == "") {
						SkinBg = SkinName;
					}
				}
				if (SkinFg != "" && SkinBg != "")	break;
			}
			
			if (SkinFg != "" && SkinBg != "")	break;
		}
		
		CustomSetBlockSkins(SkinBlock, SkinBg, SkinFg);
	}
}

Void SetMacroblockMultiSkin_Items(CMacroblockInstance _MacroblockInstance, Integer _MultiSkinIndex) {
	declare AcceptableSkinNames = UI_SkinSelection::GetAcceptableSkinsForMultiSkin(_MultiSkinIndex);
	
	declare IsSkinFg = False;
	declare SkinBg = "";
	declare SkinFg = "";
	declare SkinName = "";
	
	ComputeItemsForMacroblockInstance(_MacroblockInstance);
	
	foreach (ResultItem in MacroblockInstanceItemsResults) {
		SkinBg = "";
		SkinFg = "";
		declare ItemModel <=> ResultItem.ItemModel;
		declare IndexMax = GetNbItemModelSkins(ItemModel) - 1;
		for (Index, 0, IndexMax) {
			SkinName = GetItemModelSkin(ItemModel, Index);
			
			foreach (AcceptableSkinName in AcceptableSkinNames) {
				if (TL::Find(AcceptableSkinName, SkinName, False, True)) {
					IsSkinFg = IsSkinForeground(ItemModel, SkinName);
					if (IsSkinFg && SkinFg == "") {
						SkinFg = SkinName;
					} else if (!IsSkinFg && SkinBg == "") {
						SkinBg = SkinName;
					}
				}
				if (SkinFg != "" && SkinBg != "")	break;
			}
			
			if (SkinFg != "" && SkinBg != "")	break;
		}
		
		SetItemSkins(ResultItem, SkinBg, SkinFg);
	}
}

// Set a skin on a block
Void SetSkins(Text _SkinNameBg, Text _SkinNameFg) {
	declare SkinnableBlockCoords = UI_SkinSelection::GetBlockCoords();
	declare HasSkinnableItems = UI_SkinSelection::HasSkinnableItems();
	declare SkinnableMacroblockInstance = UI_SkinSelection::GetSkinnedMacroblockInstance();
	
	if (SkinnableMacroblockInstance == Null)
		return;
	
	if (SkinnableBlockCoords.count > 1 || HasSkinnableItems) {
		declare MultiSkinIndex = UI_SkinSelection::GetMultiSkinIndex(_SkinNameBg);
		MapContent::SetMultiSkinIndex(SkinnableMacroblockInstance, MultiSkinIndex);
		
		SetMacroblockMultiSkin_Blocks(SkinnableMacroblockInstance, MultiSkinIndex, SkinnableBlockCoords);
		SetMacroblockMultiSkin_Items(SkinnableMacroblockInstance, MultiSkinIndex);
	}
	else if (SkinnableBlockCoords.count == 1) {
		declare SkinBlock <=> GetBlock(SkinnableBlockCoords[0]);
		if (SkinBlock == Null) return;
		
		CustomSetBlockSkins(SkinBlock, _SkinNameBg, _SkinNameFg);
	} 
}

// Copy or apply the previously selected skin of this macroblock model
Void RestoreOrCopySkin(Boolean _OnlyCopy,CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CMapEditorPlugin::CardinalDirections _MacroblockDir) {
	tuningmark("RestoreOrCopySkin");
	if (_MacroblockModel == Null) return;
	if (!RandomStyles::CanSkin(_MacroblockModel) || !ThemePack::CanSkin(_MacroblockModel)) return;
	
	declare Coords = Macroblock::GetCoords(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
	if (Coords.count <= 0) return;
	
	declare Int3[] Skinned;
	declare AlreadySkinnedInflatable = False;
	foreach (Coord in Coords) {
		if (Skinned.exists(Coord)) continue;
		
		declare Block <=> GetBlock(Coord);
		if (Block == Null) continue;
		
		declare SkinNb = GetNbBlockModelSkins(Block.BlockModel);
		if (SkinNb <= 1) continue;
		
		// Not perfect, but this is the only solution to avoid reskinning several time the same inflatable
		declare IsInflatable = Collection::IsInflatable(Block.BlockModel.Name);
		if (AlreadySkinnedInflatable && IsInflatable) continue;
		
		if (_OnlyCopy) {
			G_CacheBlocksSkinsBg[Block.BlockModel.Id] = "";
			G_CacheBlocksSkinsFg[Block.BlockModel.Id] = "";
		} else {
			declare SkinBg = "";
			declare SkinFg = "";
			
			if (G_CacheBlocksSkinsBg.existskey(Block.BlockModel.Id))
				SkinBg = G_CacheBlocksSkinsBg[Block.BlockModel.Id];
				
			if (G_CacheBlocksSkinsFg.existskey(Block.BlockModel.Id))
				SkinFg = G_CacheBlocksSkinsFg[Block.BlockModel.Id];
			
			CustomSetBlockSkins(Block, SkinBg, SkinFg);
		}
		
		if (IsInflatable && !AlreadySkinnedInflatable) AlreadySkinnedInflatable = True;
		if (Block.BlockUnits.count > 1) {
			foreach (BlockUnit in Block.BlockUnits) {
				Skinned.add(Block.Coord + BlockUnit.AbsoluteOffset);
			}
		}
	}
}

// RestoreOrCopySkin overload
Void CopySkin(CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CMapEditorPlugin::CardinalDirections _MacroblockDir) {
	RestoreOrCopySkin(True, _MacroblockModel, _MacroblockCoord, _MacroblockDir);
}

// RestoreOrCopySkin overload
Void RestoreSkin(CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CMapEditorPlugin::CardinalDirections _MacroblockDir) {
	RestoreOrCopySkin(False, _MacroblockModel, _MacroblockCoord, _MacroblockDir);
}

// Apply a random skin to a block
Void RandomSkin(CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CMapEditorPlugin::CardinalDirections _MacroblockDir) {
	tuningmark("RandomSkin");
	if (_MacroblockModel == Null) return;
	
	if (!RandomStyles::CanSkin(_MacroblockModel) || !ThemePack::CanSkin(_MacroblockModel)) return;
	
	declare Coords = Macroblock::GetCoords(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
	if (Coords.count <= 0) return;
	
	declare Int3[] Skinned;
	declare AlreadySkinnedInflatable = False;
	foreach (Coord in Coords) {
		if (Skinned.exists(Coord)) continue;
		
		declare Block <=> GetBlock(Coord);
		if (Block == Null) continue;
		
		declare SkinNb = GetNbBlockModelSkins(Block.BlockModel);
		if (SkinNb <= 1) continue;
		
		// Not perfect, but this is the only solution to avoid reskinning several time the same inflatable
		declare IsInflatable = Collection::IsInflatable(Block.BlockModel.Name);
		if (AlreadySkinnedInflatable && IsInflatable) continue;
		
		declare SkinIndex = 0;
		declare SkinName = "";
		declare Found = False;
		
		// Find a skin allowed on this macroblock model
		declare AllowedSkins = RandomStyles::GetSkins(_MacroblockModel);
		if (AllowedSkins.count <= 0) {
			if (Collection::GetSkinType(Block) == Collection::SkinType_Billboard()) {
				AllowedSkins = Collection::GetEnviroSkins(Map.CollectionName, True, False);
			} else if (Collection::GetSkinType(Block) == Collection::SkinType_RoadPaint()) {
				AllowedSkins = Collection::GetEnviroSkins(Map.CollectionName, False, True);
			}
		}
		if (AllowedSkins.count > 0) {
			SkinName = AllowedSkins[Random::Rand(0, AllowedSkins.count-1)];
			for (I, 0, SkinNb-1) {
				if (SkinName == "") {
					SkinIndex = I;
					Found = True;
					break;
				}
			}
		}
		// Find a skin not disabled
		else {
			declare Count = 0;
			while (Count < 20) {
				SkinIndex = Random::Rand(0, SkinNb-1);
				SkinName = "";
				Found = !Collection::RandomDisabled(SkinName);
				if (Found) break;
				Count += 1;
			}
		}
		
		if (Found) CustomSetBlockSkins(Block, SkinName, "");
		else CustomSetBlockSkins(Block, "", "");
		
		if (IsInflatable && !AlreadySkinnedInflatable) AlreadySkinnedInflatable = True;
		if (Block.BlockUnits.count > 1) {
			foreach (BlockUnit in Block.BlockUnits) {
				Skinned.add(Block.Coord + BlockUnit.AbsoluteOffset);
			}
		}
	}
}

//	Convert a shadow quality into an Integer.	The higher the value, the better the quality
Integer ShadowsQualityToInt(CMapEditorPlugin::ShadowsQuality _ShadowQuality) {
	switch (_ShadowQuality) {
		case CMapEditorPlugin::ShadowsQuality::NotComputed	: return 0;
		case CMapEditorPlugin::ShadowsQuality::VeryFast		: return 1;
		case CMapEditorPlugin::ShadowsQuality::Fast				: return 2;
		case CMapEditorPlugin::ShadowsQuality::Default			: return 3;
		case CMapEditorPlugin::ShadowsQuality::High				: return 4;
		case CMapEditorPlugin::ShadowsQuality::Ultra				: return 5;
	}
	
	return -1;
}

Void CustomComputeShadows(CMapEditorPlugin::ShadowsQuality _ShadowQuality) {
	if (G_RandomMapGeneration && ShadowsQualityToInt(_ShadowQuality) <= ShadowsQualityToInt(CurrentShadowsQuality)) return;
	
	WaitReady();
	if (C_Debug) {
		ComputeShadows(CMapEditorPlugin::ShadowsQuality::Fast);
	} else {
		ComputeShadows(_ShadowQuality);
	}
	WaitReady();
	
	MapModified();
}

// Ask the player to select shadows quality and compute
Void CustomComputeShadows() {
	// Forced shadow quality
	if (S_ShadowQuality == C_Shadow_Fast) {
		CustomComputeShadows(CMapEditorPlugin::ShadowsQuality::Fast);
		return;
	} else if (S_ShadowQuality == C_Shadow_Nice) {
		CustomComputeShadows(CMapEditorPlugin::ShadowsQuality::Default);
		return;
	}
	
	// If the shadows are already computed in default quality, skip question
	if (CurrentShadowsQuality == CMapEditorPlugin::ShadowsQuality::Default) return;
	
	// Select shadow quality
	declare Wait = True;
	declare Answer = UI_ShadowMenu::Selection_Null();
	
	UI_Manager::Show(UI_Manager::C_File_ShadowMenu);
	Sound::Play("EditorPopUp");
	SelectSequence();
	
	while (Wait) {
		yield; ///< Yield before events to remove first menu button press
		foreach (Event in PendingEvents) {
			if (Event.Type == CMapEditorPluginEvent::Type::EditorInput) {
				switch (Inputs::GetEventInput(Event.Input, Input.JapanStylePadButtons)) {
					case CMapEditorPluginEvent::EInput::CursorPlace	: {
						Answer = UI_ShadowMenu::Valid();
						Wait = False;
					}
					case CMapEditorPluginEvent::EInput::CursorUp		: UI_ShadowMenu::Prev();
					case CMapEditorPluginEvent::EInput::CursorDown		: UI_ShadowMenu::Next();
					case CMapEditorPluginEvent::EInput::IconUp			: UI_ShadowMenu::Prev();
					case CMapEditorPluginEvent::EInput::IconDown		: UI_ShadowMenu::Next();
				}
			} else if (Event.Type == CMapEditorPluginEvent::Type::LayerCustomEvent) {
				switch (Event.CustomEventType) {
					case UI_ShadowMenu::Event_Hover(): UI_ShadowMenu::Select(TL::ToInteger(Event.CustomEventData[0]), True);
					case UI_ShadowMenu::Event_Click(): {
						UI_ShadowMenu::Select(TL::ToInteger(Event.CustomEventData[0]));
						Answer = UI_ShadowMenu::Valid();
						Wait = False;
					}
					case UI_ShadowMenu::Event_Confirm(): {
						Answer = UI_ShadowMenu::Valid();
						Wait = False;
					}
				}
			}
		}
	}
	
	UI_Manager::Hide(UI_Manager::C_File_ShadowMenu);
	SelectSequence();
	
	// Clear input buffer
	ClearInputBuffer();
	G_TerrainCanPress = False;
	
	switch (Answer) {
		case UI_ShadowMenu::Selection_Fast()			: CustomComputeShadows(CMapEditorPlugin::ShadowsQuality::Fast);
		case UI_ShadowMenu::Selection_Nice()			: CustomComputeShadows(CMapEditorPlugin::ShadowsQuality::Default);
		case UI_ShadowMenu::Selection_VeryFast()	: CustomComputeShadows(CMapEditorPlugin::ShadowsQuality::VeryFast);
		case UI_ShadowMenu::Selection_VeryNice()	: CustomComputeShadows(CMapEditorPlugin::ShadowsQuality::High);
		case UI_ShadowMenu::Selection_None()			: {/* Do not compute shadows */}
		default																		: CustomComputeShadows(CMapEditorPlugin::ShadowsQuality::Fast);
	}
}

Void PreviewTerrainBlock(Ident _TerrainBlockId) {
	if (_TerrainBlockId == NullId) return;
	declare TerrainMacroblock <=> Macroblock::GetMacroblockModelFromId(_TerrainBlockId);
	if (TerrainMacroblock == Null) return;
	
	declare TerrainName = Macroblock::GetName(TerrainMacroblock);
	declare TerrainBlock = GetTerrainBlockModelFromName(TerrainName);
	if (TerrainBlock == Null) return;
	
	Cursor.TerrainBlockModel = TerrainBlock;
}

//	Generate a random terrain
Void RandomTerrain(Boolean _RandomMap) {
	LogRandomMap("=================");
	LogRandomMap("Start random terrain");
	
	if (IsEditor(C_Editor_Advanced) && !UI_Tuto::IsValidated(UI_Tuto::Tuto_Landscape())) {
		UI_Tuto::ValidateTuto(UI_Tuto::Tuto_Landscape());
		CheckTuto();
	}
	
	SelectMode(C_Categories_Landscape, C_Modes_LandscapeRandom);
	SelectSequence();
	SetCustomTerrain(True);
	
	// ---------------------------------- //
	// Update sequence
	declare Real DecorationProgress;
	declare Text DecorationMessage;
	G_GeneratingTerrain = True;
	SelectSequence();
	SetCursorCoord(<0, 0, 0>);
	
	Sleep(250);
	Sound::Play("EditorRemoveBlock");
	Sleep(250);
	
	DecorationMessage = _("Terraforming in progress");
	DecorationProgress = 0.;
	RemoveAllTerrain();
	
	declare PrevPlaceMode = PlaceMode;
	declare PrevEditMode = EditMode;
	if (C_DemoSony) SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Terraform, CMapEditorPlugin::EditMode::Place);
	
	declare Count = 0;
	
	if (IsSimpleEditor()) {
		declare LayersCount = ThemePack::GetLayersCount();
		for (Layer, 0, LayersCount-1) {
			Terrain::Random_Start(
				ThemePack::GetType(Layer), 
				ThemePack::GetFrequency(Layer), 
				ThemePack::GetOctaves(Layer), 
				ThemePack::GetTerrainsIntervals(Layer), 
				Layer
			);
			while (!Terrain::Random_Finished()) {
				DecorationProgress = Terrain::Random_Loop();
				Count += 1;
				if (Count % Map.Size.X == 0) {
					if (_RandomMap) Sound::Play("EditorPlaceBlockCommon");
					if (C_FastTerraforming) Yield();
				}
				if (!C_FastTerraforming) Yield();
			}
		}
	} else {
		// Run the generator two times on canyon and stadium
		if (Map.CollectionName == "Canyon" || Map.CollectionName == "Stadium") {
			Terrain::Random_Start();
			while (!Terrain::Random_Finished()) {
				DecorationProgress = Terrain::Random_Loop() * 0.5;
				Count += 1;
				if (Count % Map.Size.X == 0) {
					if (C_FastTerraforming) Yield();
				}
				if (!C_FastTerraforming) Yield();
			}
			
			Terrain::Random_Start();
			while (!Terrain::Random_Finished()) {
				DecorationProgress = 0.5 + (Terrain::Random_Loop() * 0.5);
				Count += 1;
				if (Count % Map.Size.X == 0) {
					if (C_FastTerraforming) Yield();
				}
				if (!C_FastTerraforming) Yield();
			}
		} else if (Map.CollectionName == "Lagoon") {
			if (C_FastLagoon) {
				Terrain::Random_Start(0.15, 2., 2);
				while (!Terrain::Random_Finished()) {
					DecorationProgress = Terrain::Random_Loop();
					Count += 1;
					if (Count % Map.Size.X == 0) {
						if (C_FastTerraforming) Yield();
					}
					if (!C_FastTerraforming) Yield();
				}
			} else {
				Terrain::Random_Start(0.15, 1., 1);
				while (!Terrain::Random_Finished()) {
					DecorationProgress = Terrain::Random_Loop() * 0.5;
					Count += 1;
					if (Count % Map.Size.X == 0) {
						if (C_FastTerraforming) Yield();
					}
					if (!C_FastTerraforming) Yield();
				}
				
				Terrain::Random_Start();
				while (!Terrain::Random_Finished()) {
					DecorationProgress = 0.5 + (Terrain::Random_Loop() * 0.5);
					Count += 1;
					if (Count % Map.Size.X == 0) {
						if (C_FastTerraforming) Yield();
					}
					if (!C_FastTerraforming) Yield();
				}
			}
		} else {
			Terrain::Random_Start();
			while (!Terrain::Random_Finished()) {
				DecorationProgress = Terrain::Random_Loop();
				Count += 1;
				if (Count % Map.Size.X == 0) {
					if (C_FastTerraforming) Yield();
				}
				if (!C_FastTerraforming) Yield();
			}
		}
	}
	
	if (C_DemoSony) SetPlaceAndEditModes(PrevPlaceMode, PrevEditMode);
	
	// Clear input buffer
	ClearInputBuffer();
	G_TerrainCanPress = False;
	
	Yield(); //< Wait for the block to be placed before computing shadows
		
	DecorationProgress = 0.;
	DecorationMessage = "";	
	Sleep(250);
	
	declare metadata Text GamepadEditor_TerrainId for Map;
	declare metadata Integer GamepadEditor_TerrainDir for Map;
	declare metadata Boolean GamepadEditor_IsTerraformed for Map;
	GamepadEditor_TerrainId = C_RandomTerrainId;
	GamepadEditor_TerrainDir = 0;
	G_PreviewTerrainId = C_RandomTerrainId;
	GamepadEditor_IsTerraformed = True;
	
	G_GeneratingTerrain = False;		
	SelectSequence();
	MapModified();
	
	LogRandomMap("=================");
	LogRandomMap("Stop random terrain");
	LogRandomMap("#################");
}

/// Use an existing terrain (currently selected) as the base for the track
Void PlaceTerrain() {
	declare metadata Text GamepadEditor_TerrainId for Map;
	declare metadata Integer GamepadEditor_TerrainDir for Map;
	
	if (GamepadEditor_TerrainId == "" && G_PreviewTerrainId == "") return;
	
	Sound::Play("EditorMenuValid");
	
	if (GamepadEditor_TerrainId != G_PreviewTerrainId) {
		declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(G_PreviewTerrainId);
		if (!Macroblock::IsTerrain(MacroblockModel)) return;
		
		if (MacroblockModel != Null) {
			RemoveAllTerrain();
			
			// Don't place the custom terrain macroblock
			if (Macroblock::GetName(MacroblockModel) != "Empty") {
				// Get the macroblock data
				declare Int3 Coord;
				declare CMapEditorPlugin::CardinalDirections Dir;
				if (Placement::Exists(MacroblockModel)) {
					Coord = Placement::GetCoord(MacroblockModel);
					Dir = Placement::GetDir(MacroblockModel);
				}
				
				declare Placed = PlaceMacroblock_AirMode(MacroblockModel, Coord, Dir);
				if (Placed) {
					GamepadEditor_TerrainId = G_PreviewTerrainId;
					GamepadEditor_TerrainDir = Utils::DirToInt(Dir);
				}
			}
			// ... but save it as the current terrain id
			else {
				GamepadEditor_TerrainId = G_PreviewTerrainId;
				GamepadEditor_TerrainDir = 0;
			}
			
			Yield(); //< Wait for the block to be placed before computing shadows
		}
	} else {
		Yield();
	}
	
	declare metadata Boolean GamepadEditor_IsTerraformed for Map;
	GamepadEditor_IsTerraformed = True;
	Camera.Zoom(CMapEditorCamera::EZoomLevel::Medium);
	
	AutoSave();
	Yield(); // Autosave is heavy, Yield to make the script feel smoother
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	MapModified();
}

// Preview the selected terrain // note 20/10/2020: currently unused apparently. PreviewTerrain2 is used.
Void PreviewTerrain(Ident _MacroblockModelId) {
	declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(_MacroblockModelId);
	if (MacroblockModel == Null) return;
	if (!Macroblock::IsTerrain(MacroblockModel)) return;
	
	// Change terrain
	if (G_PreviewTerrainId != Macroblock::GetId(MacroblockModel)) {
		G_PreviewTerrainTime = Now + C_TerrainPreviewThreshold;
		G_PreviewTerrainId = Macroblock::GetId(MacroblockModel);
	}
	
	if (G_PreviewTerrainTime > 0 && Now >= G_PreviewTerrainTime) {
		declare metadata Text GamepadEditor_TerrainId for Map;
		declare metadata Integer GamepadEditor_TerrainDir for Map;
		
		G_PreviewTerrainTime = -1;
		
		if (GamepadEditor_TerrainId != G_PreviewTerrainId) {
			declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(G_PreviewTerrainId);
			if (MacroblockModel != Null) {
				RemoveAllTerrain();			
				// Don't place the custom terrain macroblock ...
				if (Macroblock::GetName(MacroblockModel) != "Empty") {
					// Get the macroblock data
					declare Int3 Coord;
					declare CMapEditorPlugin::CardinalDirections Dir;
					if (Placement::Exists(MacroblockModel)) {
						Coord = Placement::GetCoord(MacroblockModel);
						Dir = Placement::GetDir(MacroblockModel);
					}
					
					declare Placed = PlaceMacroblock_AirMode(MacroblockModel, Coord, Dir);
					if (Placed) {
						GamepadEditor_TerrainId = G_PreviewTerrainId;
						GamepadEditor_TerrainDir = Utils::DirToInt(Dir);
					}
				} 
				// ... but save it as the current terrain id
				else {
					GamepadEditor_TerrainId = G_PreviewTerrainId;
					GamepadEditor_TerrainDir = 0;
				}
				
				Yield(); //< Wait for the block to be placed before computing shadows
			}
		}
	}
}

// Remove all blocks progressively
Void CustomRemoveAll() {
	RemoveAllBlocks();
	
	declare UnitSize = 15;
	for (X, 0, Map.Size.X/UnitSize) {
		for (Y, 0, Map.Size.Y/UnitSize) {
			declare Position = <X*UnitSize, 0, Y*UnitSize>;
			declare Size = Position + <UnitSize, 0, UnitSize>;
			declare Removed = RemoveTerrainBlocks(Position, Size);
			Yield();
		}
	}
	
	RemoveAll();
}

// Preview the selected terrain
Void PreviewTerrain2(CMacroblockModel _MacroblockModel, CMapEditorPlugin::CardinalDirections _Dir) {
	if (_MacroblockModel == Null) return;
	if (!Macroblock::IsTerrain(_MacroblockModel)) return;
	
	declare metadata Text GamepadEditor_TerrainId for Map;
	declare metadata Integer GamepadEditor_TerrainDir for Map;
	G_PreviewTerrainId = Macroblock::GetId(_MacroblockModel);
		
	if (GamepadEditor_TerrainId != G_PreviewTerrainId) {
		Sound::Play("EditorPlaceBlockCommon");
		UI_TerrainPreview::Loading(True);
		Sleep(500); //< Let the sound and the animation play
		
		CustomRemoveAll();
		
		declare TerrainName = Macroblock::GetName(_MacroblockModel);
		if (TerrainName != "Empty") {
			declare PartsCount = Terrain::GetPartsCount(TerrainName);
			for (Part, 0, PartsCount-1) {
				declare Placed = Terrain::PlacePart(TerrainName, Part, _Dir);
				Sleep(1000);
			}
			GamepadEditor_TerrainId = G_PreviewTerrainId;
			GamepadEditor_TerrainDir = Utils::DirToInt(_Dir);
		} else {
			GamepadEditor_TerrainId = G_PreviewTerrainId;
			GamepadEditor_TerrainDir = 0;
		}
		
		Yield(); //< Wait for the block to be placed before computing shadows
		
		UI_TerrainPreview::SetTerrains(TerrainName, "", 0);
		UI_TerrainPreview::Loading(False);
	}
	
	UpdateLandscapeChoice();
	MapModified();
}

/// Place and confirm a terrain in the menu
Void SelectTerrain() {
	declare metadata Text GamepadEditor_TerrainId for Map;
	MapContent::RemoveAllContent();
	if (GamepadEditor_TerrainId == "" || Macroblock::GetId(ThemePack::GetTerrain()) != GamepadEditor_TerrainId) {
		if (C_RandomLandscape) RandomTerrain(False); ///< Generate random terrain
		else PreviewTerrain2(ThemePack::GetTerrain(), C_North);
	} else {
		PlaceTerrain();
	}
}

/// Remove the terrain base from the track
Void RemoveTerrain() {
	declare metadata Boolean GamepadEditor_IsTerraformed for Map;
	declare metadata Text GamepadEditor_TerrainId for Map;
	declare metadata Integer GamepadEditor_TerrainDir for Map;
	GamepadEditor_IsTerraformed = False;
	GamepadEditor_TerrainId = "";
	GamepadEditor_TerrainDir = 0;
	G_PreviewTerrainTime = -1;
	G_PreviewTerrainId = "";
}

// Automatically switch between connected/disconnected mode
Void AutoConnectedMode(Int3 _Coord) {
	if (!IsEditor(C_Editor_Advanced)) {
		G_MoveCursor = False;
		return;
	}
	
	declare MBInstance = GetMacroblockInstanceFromUnitCoord(_Coord);
	
	if(MBInstance == Null)
		MBInstance = MapContent::GetLatestTypedMacroblockInstance(C_Modes_ConstructTrack, True);

	declare DisconnectedClips = MapContent::GetDisconnectedClips(MBInstance);
	if(DisconnectedClips.count < 1){	
		G_MoveCursor = True;
	}
	else { 
		G_MoveCursor = False;
	}
}

//	Place the cursor at the right position	to continue with the connection of the following macroblock
//	if no connection is available, switch to free mode
Void SetTrackCursorCoord(Boolean _Add, CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CMapEditorPlugin::CardinalDirections _MacroblockDir) {
	tuningmark("SetTrackCursorCoord");
	// Select the macroblock coord as the default coord
	declare Coord = _MacroblockCoord;
	declare NoMoreConnectedBlocks = False; // If we delete a block in advanced mode and there's no blocks attached, go into simple_movecursor mode
	// Adding a macroblock
	if (_Add) {
		// We want to select any block unit of this macroblock
		declare Coords = Macroblock::GetCoords(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
		if (Coords.count > 0) Coord = Coords[0];
	}
	// Removing a macroblock // Handled before calling the function now?
	else {
		// We want to select any block unit of a macroblock placed chronogically before this macroblock
		declare ConnectedCoords = MapContent::GetTheoricalConnectedMacroblockUnitCoords(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
		declare MaxOrder = -1;
		if(ConnectedCoords.count == 0 && IsEditor(C_Editor_Advanced)) NoMoreConnectedBlocks = True;
		foreach (ConnectedCoord in ConnectedCoords) {
			declare Order = MapContent::GetMacroblockOrder(ConnectedCoord);
			if (MaxOrder < 0 || Order > MaxOrder) {
				MaxOrder = Order;
				Coord = ConnectedCoord;
			}
		}
	}
	if(!NoMoreConnectedBlocks)
		AutoConnectedMode(Coord);
	else
		G_MoveCursor = True;
	
	SetCursorMacroblockModel(_MacroblockModel);
	SetCursorCoord(_MacroblockCoord, Coord);
	SetCursorDir(_MacroblockDir);
	
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
}

/// Overload of SetTrackCursorCoord
Void SetTrackCursorCoord(Boolean _Add, CMacroblockInstance _MacroblockInstance) {
	SetTrackCursorCoord(_Add, _MacroblockInstance.MacroblockModel, _MacroblockInstance.Coord, _MacroblockInstance.Dir);
}

// Place the cursor at the right position
Void AutoCursorCoord(Boolean _Add, CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CMapEditorPlugin::CardinalDirections _MacroblockDir) {
	tuningmark("AutoCursorCoord");
	if (G_Mode == C_Modes_ConstructTrack) {
		SetTrackCursorCoord(_Add, _MacroblockModel, _MacroblockCoord, _MacroblockDir);
	} else if (G_Mode == C_Modes_ConstructDeco) {
		SetCursorMacroblockModel(_MacroblockModel);
		SetCursorCoord(_MacroblockCoord);
		SetCursorDir(_MacroblockDir);
		if (_MacroblockModel != Null) UI_MacroblockSelection::FindMacroblock(_MacroblockModel.Id);
	} else {
		SetCursorCoord(_MacroblockCoord);
		Camera.CenterOnCursor();
	}
}

// Remove content from the mapcontent
Void RemoveContent(CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CMapEditorPlugin::CardinalDirections _MacroblockDir, Integer _MacroblockType) {
	if (_MacroblockType == C_Modes_ConstructTrack || _MacroblockType == C_Modes_ConstructDeco) {
		MapContent::Remove(_MacroblockModel, _MacroblockCoord, _MacroblockDir, _MacroblockType);
		MapModified();
	}
	
	AutoCursorCoord(False, _MacroblockModel, _MacroblockCoord, _MacroblockDir);
}

// Add content to the mapcontent
Void AddContent(CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CMapEditorPlugin::CardinalDirections _MacroblockDir, Integer _MacroblockType) {
	if (_MacroblockType == C_Modes_ConstructTrack || _MacroblockType == C_Modes_ConstructDeco) {
		MapContent::Add(_MacroblockModel, _MacroblockCoord, _MacroblockDir, _MacroblockType);
		MapModified();
	}
	
	AutoCursorCoord(True, _MacroblockModel, _MacroblockCoord, _MacroblockDir);
}


// Save a new state in the history
Void SaveHistory2(Integer _Action, Integer _Mode, Ident[] _MacroblockModelsIds, Int3[] _MacroblocksCoords, CMapEditorPlugin::CardinalDirections[] _MacroblocksDirs) {
	// Save content of the track if we added or removed a macroblock
	tuningmark("SaveHistory2 Add");
	if (_Mode == C_Modes_ConstructTrack || _Mode == C_Modes_ConstructDeco) {
		foreach (Key => MacroblockModelId in _MacroblockModelsIds) {
			declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(MacroblockModelId);
			declare MacroblockCoord = _MacroblocksCoords[Key];
			declare MacroblockDir = _MacroblocksDirs[Key];
			
			if (_Action == History2::Action_Add()) {
				MapContent::Add(MacroblockModel, MacroblockCoord, MacroblockDir, _Mode);
				MapModified();
			} else if (_Action == History2::Action_Remove()) {
				MapContent::Remove(MacroblockModel, MacroblockCoord, MacroblockDir, _Mode);
				MapModified();
			} else if (_Action == History2::Action_EditSkin()) {
				MapModified();
			}
		}
	}
	
	// It looks like we're doing exactly the same in both expert and cutpaste, and we no longer used an old function called Bind...
	if (!CutPasteIsAllowed() || _Mode == C_Modes_ConstructTrack) {
		History2::Insert(_Action, _Mode, _MacroblockModelsIds, _MacroblocksCoords, _MacroblocksDirs);
		AutoSave();
		Yield();// Autosave is heavy, Yield to make the script feel smoother
	}
}

// SaveHistory overload
Void SaveHistory2(Integer _Action, Integer _Mode, Ident _MacroblockModelId, Int3 _MacroblockCoord, CMapEditorPlugin::CardinalDirections _MacroblockDir) {
	SaveHistory2(_Action, _Mode, [_MacroblockModelId], [_MacroblockCoord], [_MacroblockDir]);
}


// Undo history
Void UndoHistory2(Boolean _Cut) {
	tuningmark("UndoHistory2");
	declare Action = History2::GetAction();
	declare Mode = History2::GetMode();
	
	declare MacroblockModelsIds = History2::GetMacroblockModelsIds();
	declare MacroblocksCoords = History2::GetMacroblocksCoords();
	declare MacroblocksDirs = History2::GetMacroblocksDirs();

	declare Undone = History2::UndoAction();
	if (Undone) {
		SelectMode(C_Categories_Construct, Mode);
		if(!Undo()){
			History2::RedoAction();
			return;
		}
		Yield();
		
		SelectSequence(); //< We have to be sure we are in the right sequence mode
		
		declare FindMacroblockModelId = NullId;
		declare FindMacroblockCoord = Utils::NullCoord();
		declare FindMacroblockDir = C_North;
		
		if (Action == History2::Action_EditSkin()) {
			SetCursorCoord(MacroblocksCoords[0]);
		} else if (Action == History2::Action_Add()) {
			declare Integer Key = MacroblockModelsIds.count;
			while(Key > 0){
				Key -= 1;
				if(Key < 0) break;
				
				declare MBInstance = MapContent::GetMacroblockInstance(Macroblock::GetMacroblockModelFromId(MacroblockModelsIds[Key]), MacroblocksCoords[Key], MacroblocksDirs[Key]);
				
				if (MBInstance != Null){
					declare MacroblockModel = MBInstance.MacroblockModel;
					if(MacroblockModel != Null){
						FindMacroblockModelId = MacroblockModel.Id;
						FindMacroblockCoord = MBInstance.Coord;
						FindMacroblockDir = MBInstance.Dir;	
					}

					if (G_Mode == C_Modes_ConstructTrack && (!IsFreeMode() || CutPasteIsAllowed())) {
						declare ClipList = MBInstance.ClipList;
						declare ConnectionToPrevious = MapContent::GetConnectionToPrevious(MBInstance);
						
						declare CBlockClip ConnectedClip;
						if(ConnectionToPrevious[1] != -1){
							ConnectedClip <=> MBInstance.ClipList.Clips[ConnectionToPrevious[1]];
						}
						declare CMacroblockInstance PrevMacroblockInstance = Null;
						declare PrevMacroblockModelId = NullId;
						
						if(ConnectedClip != Null)
							PrevMacroblockInstance = GetMacroblockInstanceConnectedToClip(ConnectedClip);

						if (PrevMacroblockInstance != Null && PrevMacroblockInstance.MacroblockModel != Null)
							PrevMacroblockModelId = PrevMacroblockInstance.MacroblockModel.Id;

						if(_Cut){
							// Can't cut the start
							if (MacroblockModel != Null && !MacroblockModel.HasStart && !MacroblockModel.HasMultilap) {
								// Save cutted macroblock
								CutPaste::Cut(PrevMacroblockModelId, ConnectionToPrevious[0], FindMacroblockModelId, ConnectionToPrevious[1]);
							}
						}

						RemoveContent(MacroblockModel, FindMacroblockCoord, FindMacroblockDir, Mode);

						if (MapContent::GetDisconnectedClips(PrevMacroblockInstance).count > 0) 
							SetTrackCursorCoord(False, MacroblockModel, FindMacroblockCoord, FindMacroblockDir);
													
					}else{
						RemoveContent(MacroblockModel, FindMacroblockCoord, FindMacroblockDir, Mode);
					}
				}				
				if(IsEditor(C_Editor_Beginner)) AutoSelectStyle(); // Avoid Track in dead end situation. Autoselectstyle is handled differently in Advanced
				BrowseMacroblocks2();
			}
		} else if (Action == History2::Action_Remove()) {
			foreach (Key => MacroblockModelId in MacroblockModelsIds) {
				declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(MacroblockModelId);
				FindMacroblockModelId = MacroblockModelId;
				FindMacroblockCoord = MacroblocksCoords[Key];
				FindMacroblockDir = MacroblocksDirs[Key];
				
				AddContent(MacroblockModel, FindMacroblockCoord, FindMacroblockDir, Mode);
			}
			
			if (G_Mode == C_Modes_ConstructTrack && (!IsFreeMode() || CutPasteIsAllowed())) {
				// If there are several macroblocks, find where to connect the next macroblock
				if (MacroblockModelsIds.count > 0) {
					foreach (Key => MacroblockModelId in MacroblockModelsIds) {
						declare MBInstance = GetMacroblockInstanceFromUnitCoord(MacroblocksCoords[Key]);
						declare CMacroblockModel MacroblockModel = Null;
						if (MBInstance != Null){
							if (MapContent::GetConnectedClips(MBInstance).count > 0) {
								SetTrackCursorCoord(True, MBInstance);
								FindMacroblockModelId = MBInstance.MacroblockModel.Id;
								FindMacroblockCoord = MBInstance.Coord;
								FindMacroblockDir = MBInstance.Dir;
							}
						}
					}
				}
				BrowseMacroblocks2();
			}
			
			declare NextMacroblockModelsIds = History2::GetMacroblockModelsIds();
			if (NextMacroblockModelsIds.count > 0) FindMacroblockModelId = NextMacroblockModelsIds[0];
			declare NextMacroblockCoords = History2::GetMacroblocksCoords();
			if (NextMacroblockCoords.count > 0) FindMacroblockCoord = NextMacroblockCoords[0];
			declare NextMacroblockDirs = History2::GetMacroblocksDirs();
			if (NextMacroblockDirs.count > 0) FindMacroblockDir = NextMacroblockDirs[0];
		}
		
		if (FindMacroblockModelId != NullId) {
			SelectMacroblock(FindMacroblockModelId, FindMacroblockCoord, FindMacroblockDir);
			if(!_Cut) // Move doesn't seem necessary when cutting ?
				MoveMacroblock(<0, 0, 0>, False);
		}
		if (CanNotify()) {
			if (_Cut) UI_BlockHelp::Notify(_("|Infinitive|Cut"));
			else UI_BlockHelp::Notify(_("|Infinitive - Ctrl Z System|Undo"));
		}
	}
}

/// Undo history overload
Void UndoHistory2() {
	UndoHistory2(False);
}

/// Redo history
Void RedoHistory2() {
	tuningmark("RedoHistory2");
	declare Redone = History2::RedoAction();
	
	if (Redone) {
		declare Action = History2::GetAction();
		declare Mode = History2::GetMode();
		declare MacroblockModelsIds = History2::GetMacroblockModelsIds();
		declare MacroblocksCoords = History2::GetMacroblocksCoords();
		declare MacroblocksDirs = History2::GetMacroblocksDirs();
		
		SelectMode(C_Categories_Construct, Mode);
	
		if(!Redo()){
			History2::UndoAction();
			return;
		}
		
		Yield();
		SelectSequence(); //< We have to be sure we are in the right sequence mode
		
		declare FindMacroblockModelId = NullId;
		declare FindMacroblockCoord = Utils::NullCoord();
		declare FindMacroblockDir = C_North;
		if (Action == History2::Action_EditSkin()) {
			SetCursorCoord(MacroblocksCoords[0]);
		} else if (Action == History2::Action_Add()) {
			foreach (Key => MacroblockModelId in MacroblockModelsIds) {
				declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(MacroblockModelId);
				declare MacroblockCoord = MacroblocksCoords[Key];
				declare MacroblockDir = MacroblocksDirs[Key];
				FindMacroblockModelId = MacroblockModelId;
				FindMacroblockCoord = MacroblockCoord;
				FindMacroblockDir = MacroblockDir;
				
				AddContent(MacroblockModel, MacroblockCoord, MacroblockDir, Mode);
			}
		}
		
		if (G_Mode == C_Modes_ConstructTrack && (!IsFreeMode() || CutPasteIsAllowed())) {
			// If there are several macroblocks, find where to connect the next macroblock
			if (MacroblockModelsIds.count > 0) {
				foreach (Key => MacroblockModelId in MacroblockModelsIds) {
					declare MBInstance = GetMacroblockInstanceFromUnitCoord(MacroblocksCoords[Key]);

					
					if(MBInstance != Null){					
						declare MacroblockModel = MBInstance.MacroblockModel;
						declare MacroblockCoord = MBInstance.Coord;
						declare MacroblockDir = MBInstance.Dir;
						if (Action == History2::Action_Add()) {
							if (MapContent::GetDisconnectedClips(MBInstance).count > 0) {
								SetTrackCursorCoord(True, MBInstance);
								FindMacroblockModelId = MacroblockModelId;
								FindMacroblockCoord = MacroblockCoord;
								FindMacroblockDir = MacroblockDir;
								break;
							}
						} else if (Action == History2::Action_Remove()) {
							if (MapContent::GetConnectedClips(MBInstance).count > 0) {
								SetTrackCursorCoord(False, MBInstance);
								FindMacroblockModelId = MacroblockModelId;
								FindMacroblockCoord = MacroblockCoord;
								FindMacroblockDir = MacroblockDir;
								break;
							}
						}
						
					}
					
				}
			}
			BrowseMacroblocks2();
		}
		
		if (Action == History2::Action_Remove()) {
			foreach (Key => MacroblockModelId in MacroblockModelsIds) {
				declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(MacroblockModelId);
				declare MacroblockCoord = MacroblocksCoords[Key];
				declare MacroblockDir = MacroblocksDirs[Key];
				
				RemoveContent(MacroblockModel, MacroblockCoord, MacroblockDir, Mode);
			}
		}
		
		// Select the next macroblock in the history by default
		if (Action == History2::Action_Add()) {
			declare NextMacroblockModelsIds = History2::GetMacroblockModelsIds(History2::GetCursor()+1);
			if (NextMacroblockModelsIds.count > 0) FindMacroblockModelId = NextMacroblockModelsIds[0];
			declare NextMacroblockCoords = History2::GetMacroblocksCoords(History2::GetCursor()+1);
			if (NextMacroblockCoords.count > 0) FindMacroblockCoord = NextMacroblockCoords[0];
			declare NextMacroblockDirs = History2::GetMacroblocksDirs(History2::GetCursor()+1);
			if (NextMacroblockDirs.count > 0) FindMacroblockDir = NextMacroblockDirs[0];
		}
		if (FindMacroblockModelId != NullId) {
			SelectMacroblock(FindMacroblockModelId, FindMacroblockCoord, FindMacroblockDir);
			MoveMacroblock(<0, 0, 0>, False);
		}
		if (CanNotify()) UI_BlockHelp::Notify(_("|Infinitive - Ctrl Z System|Redo"));
	}
}

Boolean AddMacroblock2(
	CMacroblockModel _MacroblockModel, 
	Int3 _MacroblockCoord, 
	CMapEditorPlugin::CardinalDirections _MacroblockDir,
	Boolean _Browse,
	Boolean _Notify
) {
	tuningmark("AddMacroblock2 1");

	// Check copper limit if the macroblock is not a finish line
	if (MustCheckCoppersLimit() && Map.CopperPrice >= C_CopperLimit_Hard && (MapContent::HasFinish() || !_MacroblockModel.HasFinish)) {
		Alert(
			_("|Alert window title|Warning"), 
			_("The track contains too many blocks! Do not exceed the limit of the top left indicator."), // copied from C++
			_("|Infinitive|Confirm")
		);
		return False;
	}
	
	if (_MacroblockModel == Null) return False;
	if (!CustomCanPlaceMacroblock(_MacroblockModel, _MacroblockCoord, _MacroblockDir, True)) {
		if (!G_RandomMapGeneration) Sound::Play("EditorWrongAction");
		if (_Notify && CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("|Infinitive|Place")));
		return False;
	}
	declare MacroblockPlaced = False;
	declare TransitionPlaced = False;
	declare CMacroblockModel TransitionMacroblockModel;
	declare Int3 TransitionCoord;
	declare CMapEditorPlugin::CardinalDirections TransitionDir;
	
	// Try to place the macroblock without transition
	if (CustomCanPlaceMacroblock(_MacroblockModel, _MacroblockCoord, _MacroblockDir, False)) {
		MacroblockPlaced = CustomPlaceMacroblock(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
	}
	// Can't place the macroblock, does it need a transition?
	else if (Transitions::HasTransitions(_MacroblockModel)) {		
		// This is the only place where we want a disconnected cliplist of a non placed macroblock, so we cannot use MacroblockInstance
		declare CBlockClipList MacroblockClipList = CreateFrameClipList(); 
		MacroblockClipList.SetFromClipList(Macroblock::GetCreatedClipList(_MacroblockModel), _MacroblockCoord, _MacroblockDir);
		declare Integer[] TheoricallyDisconnectedClips;
		
		// Don't directly loop on the ClipList.Clips on the second foreach : a Yield in Place or Remove will erase our FrameClipList during the foreach.
		foreach(Clip in MacroblockClipList.Clips){
			if(!MapContent::IsClipConnected(Clip)) TheoricallyDisconnectedClips.add(Clip.ClipId);
		}
			
		foreach(ClipId in TheoricallyDisconnectedClips){
			declare Transitions = Transitions::GetTransitions(_MacroblockModel, _MacroblockCoord, _MacroblockDir, ClipId);
			foreach (Transition in Transitions) {
				TransitionMacroblockModel <=> Transitions::GetTransitionMacroblockModel(_MacroblockModel, Transition);
				TransitionCoord = Transitions::GetTransitionCoord(_MacroblockModel, Transition);
				TransitionDir = Transitions::GetTransitionDir(_MacroblockModel, Transition);
				
				// Place transition
				TransitionPlaced = CustomPlaceMacroblock(TransitionMacroblockModel, TransitionCoord, TransitionDir);
				// Place the macroblock
				if (TransitionPlaced && CustomCanPlaceMacroblock(_MacroblockModel, _MacroblockCoord, _MacroblockDir, False)) {
					MacroblockPlaced = CustomPlaceMacroblock(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
				}
				
				// Remove transition if we couldn't place the macroblock
				if (TransitionPlaced && !MacroblockPlaced) {
					TransitionPlaced = False;
					declare Removed = Macroblock::Remove(TransitionMacroblockModel, TransitionCoord, TransitionDir);
				}
				
				if (MacroblockPlaced) break;
			}
		}
	}
	// Transition place success
	if (TransitionPlaced) {
		if (IsEditor(C_Editor_Expert) && !G_RandomMapGeneration) RestoreSkin(TransitionMacroblockModel, TransitionCoord, TransitionDir);
		else RandomSkin(TransitionMacroblockModel, TransitionCoord, TransitionDir);
	}
	
	// Macroblock place success
	if (MacroblockPlaced) {
		if (!G_RandomMapGeneration) {
			if (G_Mode == C_Modes_ConstructDeco) {
				Sound::Play("EditorPlaceBlockDeco");
			} else if (_MacroblockModel.HasCheckpoint) {
				Sound::Play("EditorPlaceBlockCheckpoint");
			} else if (_MacroblockModel.HasFinish) {
				Sound::Play("EditorPlaceBlockFinish");
			} else if (_MacroblockModel.HasStart || _MacroblockModel.HasMultilap) {
				Sound::Play("EditorPlaceBlockStart");
			} else {
				Sound::Play("EditorPlaceBlockCommon");
			}
		}	
		
		if (TransitionPlaced) {
			SaveHistory2(History2::Action_Add(), G_Mode, [_MacroblockModel.Id, TransitionMacroblockModel.Id], [_MacroblockCoord, TransitionCoord], [_MacroblockDir, TransitionDir]);
		} else {
			SaveHistory2(History2::Action_Add(), G_Mode, _MacroblockModel.Id, _MacroblockCoord, _MacroblockDir);
		}
		
		if (IsEditor(C_Editor_Expert) && !G_RandomMapGeneration) RestoreSkin(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
		else RandomSkin(_MacroblockModel, _MacroblockCoord, _MacroblockDir);
		
		if (!TransitionPlaced) {
			AutoCursorCoord(True, _MacroblockModel, _MacroblockCoord, _MacroblockDir);
		}else{
			AutoCursorCoord(True, TransitionMacroblockModel, TransitionCoord, TransitionDir);
		}
		
		if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_Multilaps()) && _MacroblockModel.HasMultilap) {
			UI_Tuto::ValidateTuto(UI_Tuto::Tuto_Multilaps());
			CheckTuto();
		}
		
		G_CanAskCheckpoint = True;
		
		if (_Notify && CanNotify()) UI_BlockHelp::Notify(_("|Infinitive|Place"));
	} else {
		if (_Notify && CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("|Infinitive|Place")));
		if (!G_RandomMapGeneration) Sound::Play("EditorWrongAction");
	}
	
	// Find the right style to continue
	if (IsSimpleEditor()) AutoSelectStyle();
	
	// Show a selection of compatible blocks to connect
	if (_Browse) BrowseMacroblocks2();
	
	if (IsEditor(C_Editor_Expert)) {
		DisplaySkinSelection(Cursor.Coord);
		SetCursorStyle();
	}
	
	CheckAdvices();
	CheckTuto();
	
	return MacroblockPlaced;
}

// Connect the given macroblock to the previous one
Boolean AddMacroblock2(Ident _MacroblockModelId, Boolean _Browse) {
	// Get the macroblock model to use
	declare CMacroblockModel MacroblockModel;
	if (_MacroblockModelId == NullId) {
		MacroblockModel <=> GetRandomMacroblock();
	} else {
		MacroblockModel <=> Macroblock::GetMacroblockModelFromId(_MacroblockModelId);
	}
	if (MacroblockModel == Null) return False;
	
	// Get the macroblock coordinates and direction
	declare Int3 BlockCoord; 
	declare CMapEditorPlugin::CardinalDirections BlockDir;
	if (IsFreeMode() || !MapContent::HasStart()) {
		BlockCoord = Cursor.Coord;
		BlockDir = Cursor.Dir;
	} else {
		if (Placement::Exists(MacroblockModel)) {
			BlockCoord = Placement::GetCoord(MacroblockModel);
			BlockDir = Placement::GetDir(MacroblockModel);
		}
	}
	
	return AddMacroblock2(MacroblockModel, BlockCoord, BlockDir, _Browse, True);
}

/// Overload AddMacroblock2
Boolean AddMacroblock2(Ident _MacroblockModelId) {
	if (CutPasteIsAllowed() && UI_Tuto::IsEnabled(UI_Tuto::Tuto_CutPaste())) {
		UI_Tuto::Disable(UI_Tuto::Tuto_CutPaste());
	}
	return AddMacroblock2(_MacroblockModelId, True);
}

/// Add a random macroblock
Void AddRandomMacroblock2() {
	if (G_LastRandomPlace > 0 && Now - G_LastRandomPlace < C_RandomDecorationDelay) return;
	G_LastRandomPlace = Now;
	
	AddMacroblock2(NullId);
}

/// Start a new track
Void AddStartMacroblock2() {
	if (G_CursorMacroblockModel == Null) return;
	if (!G_CursorMacroblockModel.HasStart && !G_CursorMacroblockModel.HasMultilap) return;
	
	AddMacroblock2(G_CursorMacroblockModel.Id);
	
	if (IsEditor(C_Editor_Expert) && !G_RandomMapGeneration) {
		switch (Cursor.Dir) {
			case C_North	: MoveMacroblock(<0, 0, 1>, False);
			case C_West	: MoveMacroblock(<1, 0, 0>, False);
			case C_South	: MoveMacroblock(<0, 0, -1>, False);
			case C_East	: MoveMacroblock(<-1, 0, 0>, False);
		}
	}
}

// Add a decoration macroblock
Boolean AddDecoMacroblock2(Ident _MacroblockModelId) {
	// Get the macroblock model to use
	declare CMacroblockModel MacroblockModel;
	if (_MacroblockModelId != NullId) {
		MacroblockModel <=> Macroblock::GetMacroblockModelFromId(_MacroblockModelId);
	}
	if (MacroblockModel == Null) return False;
	
	// Get the macroblock coordinates and direction
	if (Placement::Exists(MacroblockModel, Cursor.Dir)) {
		declare BlockDirs = Placement::GetDirs(MacroblockModel);
		Placement::Select(MacroblockModel, BlockDirs.keyof(Cursor.Dir));
	}
	
	declare MacroblockPlaced = AddMacroblock2(_MacroblockModelId);
	DisplaySkinSelection(Cursor.Coord);
	CheckTuto();
	
	return MacroblockPlaced;
}

// Add a terrain block
Void AddTerrain2(CBlockModel _Terrain, Int3 _StartCoord, Int3 _EndCoord) {
	declare Placed = PlaceTerrainBlocks/*_NoDestruction*/(_Terrain, _StartCoord, _EndCoord);
	if (Placed) {
		if (!G_RandomMapGeneration) Sound::Play("EditorPlaceBlockCommon");
		if (CanNotify()) UI_BlockHelp::Notify(_("|Infinitive|Add"));
		SaveHistory2(History2::Action_Add(), C_Modes_ConstructTerrain, NullId, _StartCoord, C_North);
		
		if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_EditTerrain())) {
			UI_Tuto::ValidateTuto(UI_Tuto::Tuto_EditTerrain());
			CheckTuto();
		}
	} else {
		if (!G_RandomMapGeneration) Sound::Play("EditorWrongAction");
		if (CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("|Infinitive|Add")));
	}
	
	// Undo the terrain modification if it exceeds the copper limit
	Yield(); ///< yield to update track copper price
	if (Placed && MustCheckCoppersLimit() && Map.CopperPrice >= C_CopperLimit_Hard) {
		UndoHistory2();
		Alert(
			_("|Alert window title|Warning"), 
			_("You reached the maximum number of blocks. You cannot add more."),
			_("|Infinitive|Confirm")
		);
	}
}

// Remove a macroblock
Void RemoveMacroblock2(Int3 _Coord, Integer _Type, Boolean _Cut, Boolean _MoveCameraTo) {
	tuningmark("RemoveMacroblock2 1");
	if (_Cut && IsSimpleEditor()) {
		UndoHistory2(True);
		return;
	}
	
	declare MacroblockType = MapContent::GetMacroblockType(_Coord);
	declare CannotRemoveOtherType = G_RandomMapGeneration || !IsEditor(C_Editor_Expert);
	if (!MapContent::Exists(_Coord) || (CannotRemoveOtherType && _Type != MapContent::GetMacroblockType(_Coord))) {
		if (!G_RandomMapGeneration) Sound::Play("EditorWrongAction");
		if (CanNotify()) {
			if (_Cut) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("|Infinitive|Cut")));
			else UI_BlockHelp::Notify(TL::Compose("$f00%1", _("|Infinitive|Remove")));
		}
		return;
	}
	
	declare MacroblockModel = MapContent::GetMacroblockModel(_Coord);
	declare MacroblockCoord = MapContent::GetMacroblockCoord(_Coord);
	declare MacroblockDir = MapContent::GetMacroblockDir(_Coord);
	
	if (MacroblockModel == Null) return;
	
	// Save block connected to the transition
	declare CBlock[Int3] ConnectedBlocks;
	if (Transitions::IsTransition(MacroblockModel)) {
		declare ConnectedCoords = MapContent::GetTheoricalConnectedMacroblockUnitCoords(MacroblockModel, MacroblockCoord, MacroblockDir);
		foreach (ConnectedCoord in ConnectedCoords) {
			ConnectedBlocks[ConnectedCoord] = GetBlock(ConnectedCoord);
		}
	}
	
	declare Removed = Macroblock::Remove(MacroblockModel, MacroblockCoord, MacroblockDir);
	if (Removed) {
		if (!G_RandomMapGeneration) Sound::Play("EditorRemoveBlock");

		declare RemovedCoord = _Coord;
		declare RemovedMacroblockModelsIds = [MacroblockModel.Id];
		declare RemovedMacroblocksCoords = [MacroblockCoord];
		declare RemovedMacroblocksDirs = [MacroblockDir];
		
		// Detect any block connected to a transition that was automatically removed by the editor
		foreach (ConnectedCoord => ConnectedBlock in ConnectedBlocks) {
			if (ConnectedBlock != GetBlock(ConnectedCoord)) {
				declare RemovedMacroblockModel <=> MapContent::GetMacroblockModel(ConnectedCoord);
				if (RemovedMacroblockModel == Null) continue;
				
				declare RemovedMacroblockCoord = MapContent::GetMacroblockCoord(ConnectedCoord);
				declare RemovedMacroblockDir = MapContent::GetMacroblockDir(ConnectedCoord);
				RemovedMacroblockModelsIds.add(RemovedMacroblockModel.Id);
				RemovedMacroblocksCoords.add(RemovedMacroblockCoord);
				RemovedMacroblocksDirs.add(RemovedMacroblockDir);
				
				// This block was removed automatically, so we must connect the next macroblock here and not where the transition was
				if (MapContent::GetTheoricalConnectedMacroblockUnitCoords(RemovedMacroblockModel, RemovedMacroblockCoord, RemovedMacroblockDir).count > 1) {
					MacroblockModel = RemovedMacroblockModel;
					MacroblockCoord = RemovedMacroblockCoord;
					MacroblockDir = RemovedMacroblockDir;
				}
				
				// Be sure that the macroblock was removed
				declare RemovedForSure = Macroblock::Remove(RemovedMacroblockModel, RemovedMacroblockCoord, RemovedMacroblockDir);
			}
		}
		
		SaveHistory2(History2::Action_Remove(), MacroblockType, RemovedMacroblockModelsIds, RemovedMacroblocksCoords, RemovedMacroblocksDirs);
		if (G_Mode == C_Modes_ConstructTrack) {
			if (IsSimpleEditor()) {
				declare MBInstance = MapContent::GetLatestTypedMacroblockInstance(C_Modes_ConstructTrack, True);
				if(MBInstance != Null)
					AutoCursorCoord(False, MBInstance.MacroblockModel, MBInstance.Coord, MBInstance.Dir);
				AutoSelectStyle();
			}
			BrowseMacroblocks2();
			// Check again if we can place a block in place of the removed one
			if (!IsSimpleEditor()) {
				SetCursorCoord(Cursor.Coord);
				MoveMacroblock(<0,0,0>, False);
			}
			if (MacroblockModel != Null) {
				if (IsSimpleEditor()) SelectMacroblock(MacroblockModel.Id, MacroblockCoord, MacroblockDir);
				
				// Can't cut the start
				// Save cutted macroblock
				if (_Cut && !MacroblockModel.HasStart && !MacroblockModel.HasMultilap) {
					declare ConnectionToPrevious = MapContent::GetConnectionToPrevious(MacroblockModel, MacroblockCoord, MacroblockDir);
					declare PrevMacroblockModel <=> MapContent::GetMacroblockModel(G_CursorCoord);
					declare PrevMacroblockModelId = NullId;
					if (PrevMacroblockModel != Null) PrevMacroblockModelId = PrevMacroblockModel.Id;
					CutPaste::Cut(PrevMacroblockModelId, ConnectionToPrevious[0], MacroblockModel.Id, ConnectionToPrevious[1]);
				}
			}
		} else if (G_Mode == C_Modes_ConstructDeco) {
			// Check again if we can place a block in place of the removed one
			if (!IsSimpleEditor()) {
				SetCursorCoord(Cursor.Coord);
				BrowseMacroblocks2();
				MoveMacroblock(<0,0,0>, False);
			}
			
			if (MacroblockModel != Null) {
				if (IsSimpleEditor()) SelectMacroblock(MacroblockModel.Id, MacroblockCoord, MacroblockDir);
			}
		}
		
		DisplaySkinSelection(RemovedCoord);
		SetCursorStyle();
		CheckAdvices();
		CheckTuto();
		
		if (CanNotify()) {
			if (_Cut) UI_BlockHelp::Notify(_("|Infinitive|Cut"));
			else UI_BlockHelp::Notify(_("|Infinitive|Remove"));
		}
	} else {
		if (!G_RandomMapGeneration) Sound::Play("EditorWrongAction");
		if (CanNotify()) {
			if (_Cut) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("|Infinitive|Cut")));
			else UI_BlockHelp::Notify(TL::Compose("$f00%1", _("|Infinitive|Remove")));
		}
	}
}

//	Remove a macroblock
Void RemoveMacroblock2(Int3 _Coord, Boolean _MoveCameraTo) {
	// Switch to the right building mode if necessary
	if (C_RemoveAutoSwitchMode && !G_RandomMapGeneration && IsEditor(C_Editor_Expert)) {
		declare MacroblockMode = MapContent::GetMacroblockType(_Coord);
		if (MapContent::Exists(Cursor.Coord) && (MacroblockMode == C_Modes_ConstructTrack || MacroblockMode == C_Modes_ConstructDeco)) {
			if (G_Mode != MacroblockMode) {
				declare PrevCursorCoord = Cursor.Coord;
				SelectMode(C_Categories_Construct, MacroblockMode);
				SelectSequence();
				SetCursorCoord(PrevCursorCoord);
			}
		}
	}
	
	RemoveMacroblock2(_Coord, G_Mode, False, _MoveCameraTo);
}

// Remove a macroblock from just a coord
Void ExpertRemoveMacroblock2(Int3 _Coord) {
	if (!G_IsEditing && !G_IsSkinning) return;
	
	declare Coord = _Coord;
	declare MBInstance = GetMacroblockInstanceFromUnitCoord(Cursor.Coord);
	if (MBInstance != Null && MBInstance.UnitCoords.count > 0) {
		// On supprime le bloc qui est sous notre curseur directement, qui est celui qui est en cours d'édition
		Coord = MBInstance.UnitCoords[0];
	}else{
		// Il n'y a pas de bloc sous notre curseur directement, on est peut être dans le cas particulier où on édite un bloc qui n'occupe pas sa coordonnée (ex: grand virage direction est), mais où on est exactement dans la même position avec le meme bloc selectionné
		declare CursorMBInstance = MapContent::GetMacroblockInstance(G_CursorMacroblockModel, Cursor.Coord, Cursor.Dir);
		if (CursorMBInstance != Null && CursorMBInstance.UnitCoords.count > 0) {
			Coord = CursorMBInstance.UnitCoords[0];
		}
	}
	
	RemoveMacroblock2(Coord, False);
}


// Safer remove a macroblock
Void RemoveMacroblock2(CMacroblockModel _MacroblockModel, Int3 _Coord, CMapEditorPlugin::CardinalDirections _Dir, Integer _Type, Boolean _MoveCameraTo) {
	if (_MacroblockModel == Null) return;
	
	// Save block connected to the transition
	declare CBlock[Int3] ConnectedBlocks;
	if (Transitions::IsTransition(_MacroblockModel)) {
		declare ConnectedCoords = MapContent::GetTheoricalConnectedMacroblockUnitCoords(_MacroblockModel, _Coord, _Dir);
		foreach (ConnectedCoord in ConnectedCoords) {
			ConnectedBlocks[ConnectedCoord] = GetBlock(ConnectedCoord);
		}
	}
	
	declare Removed = Macroblock::Remove(_MacroblockModel, _Coord, _Dir);
	if (Removed) {
		if (!G_RandomMapGeneration) Sound::Play("EditorRemoveBlock");
		
		declare MacroblockModel <=> _MacroblockModel;
		declare MacroblockCoord = _Coord;
		declare MacroblockDir = _Dir;
		
		declare RemovedMacroblockModelsIds = [MacroblockModel.Id];
		declare RemovedMacroblocksCoords = [MacroblockCoord];
		declare RemovedMacroblocksDirs = [MacroblockDir];
		
		// Detect any block connected to a transition that was automatically removed by the editor
		foreach (ConnectedCoord => ConnectedBlock in ConnectedBlocks) {
			if (ConnectedBlock != GetBlock(ConnectedCoord)) {
				declare RemovedMacroblockModel <=> MapContent::GetMacroblockModel(ConnectedCoord);
				if (RemovedMacroblockModel == Null) continue;
				
				declare RemovedMacroblockCoord = MapContent::GetMacroblockCoord(ConnectedCoord);
				declare RemovedMacroblockDir = MapContent::GetMacroblockDir(ConnectedCoord);
				RemovedMacroblockModelsIds.add(RemovedMacroblockModel.Id);
				RemovedMacroblocksCoords.add(RemovedMacroblockCoord);
				RemovedMacroblocksDirs.add(RemovedMacroblockDir);
				
				// This block was removed automatically, so we must connect the next macroblock here and not where the transition was
				if (MapContent::GetTheoricalConnectedMacroblockUnitCoords(RemovedMacroblockModel, RemovedMacroblockCoord, RemovedMacroblockDir).count > 1) {
					MacroblockModel <=> RemovedMacroblockModel;
					MacroblockCoord = RemovedMacroblockCoord;
					MacroblockDir = RemovedMacroblockDir;
				}
				
				// Be sure that the macroblock was removed
				declare RemovedForSure = Macroblock::Remove(RemovedMacroblockModel, RemovedMacroblockCoord, RemovedMacroblockDir);
			}
		}
		
		SaveHistory2(History2::Action_Remove(), _Type, RemovedMacroblockModelsIds, RemovedMacroblocksCoords, RemovedMacroblocksDirs);
		
		AutoCursorCoord(False, MacroblockModel, MacroblockCoord, MacroblockDir);
	} else {
		if (!G_RandomMapGeneration) Sound::Play("EditorWrongAction");
	}
}

// Remove all finishes blocks from the track
Void RemoveAllFinishes(Boolean _Cut) {
	declare FinishesCoords = MapContent::GetFinishesUnitCoord(C_Modes_ConstructTrack);
	
	foreach (FinishCoord in FinishesCoords) {
		RemoveMacroblock2(FinishCoord, C_Modes_ConstructTrack, _Cut, True);
	}
}

// Remove a terrain block
Void RemoveTerrain2(Int3 _StartCoord, Int3 _EndCoord) {
	declare Removed = RemoveTerrainBlocks(_StartCoord, _EndCoord);
	if (Removed) {
		if (!G_RandomMapGeneration) Sound::Play("EditorRemoveBlock");
		if (CanNotify()) UI_BlockHelp::Notify(_("|Infinitive|Remove"));
		SaveHistory2(History2::Action_Remove(), C_Modes_ConstructTerrain, NullId, _StartCoord, C_North);
		
		if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_EditTerrain())) {
			UI_Tuto::ValidateTuto(UI_Tuto::Tuto_EditTerrain());
			CheckTuto();
		}
	} else {
		if (!G_RandomMapGeneration) Sound::Play("EditorWrongAction");
		if (CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("|Infinitive|Remove")));
	}
	
	// Undo the terrain modification if it exceeds the copper limit
	Yield(); ///< yield to update track copper price
	if (Removed && MustCheckCoppersLimit() && Map.CopperPrice >= C_CopperLimit_Hard) {
		UndoHistory2();
		Alert(
			_("|Alert window title|Warning"), 
			_("You reached the maximum number of blocks. You cannot add more."),
			_("|Infinitive|Confirm")
		);
	}
}

// Note Regilio: Just copied this from the old Turbo code bc it looks interesting and mouse related
// But MapContent changed a lot since then, maybe it doesn't work anymore. Find out how it's supposed to work.

// Note 2 : It looks very interesting, but I believe that I've cleared the whole ClipExists, GetClipDir etc from the track content script
// that's no longer how it works, maybe I have ways to replace it now, but I'm not totally sure. For now I'm commenting it

// Note 3: This func used to allow you to click on a disconnected clip, and would try to connect your current block to it
// This could be useful but is a pretty hidden feature, and you can always just double click on the block you want to connect to now.
// The issue is that clips changed with tm2020, and MapContent as well, we don't have any list of clips anymore.
// All we could do is check for all coords around it and then get each block, check if it has any open clips at this coord...
// But it doesn't seem like a priority, may be handled later.
Void ExpertCursorConnect(Ident _MacroblockModelId, Int3 _Coord) {
	//log("Should've done ExpertCursorConnect here");
	/*if (!MacroblockModels.existskey(_MacroblockModelId)) return;
	declare MacroblockModel <=> MacroblockModels[_MacroblockModelId];
	declare Variant <=> Macroblock::GetBlockModelVariant(MacroblockModel);
	if (MacroblockModel == Null || Variant == Null) return;
	
	if (IsEditor(C_Editor_Expert) && UI_Tuto::IsEnabledAndVisible(UI_Tuto::Tuto_MoveBlock_Mouse())) {
		UI_Tuto::ValidateTuto(UI_Tuto::Tuto_MoveBlock_Mouse());
		CheckTuto();
	}
	
	declare Connected = False;
	declare Int3[] Directions = [<1,0,0>, <0,0,1>, <-1,0,0>, <0,0,-1>];
	
	if (MapContent::ClipExists(_Coord)) {
		// The properties of the clip we want to connect to
		declare ClipCoord = _Coord;
		declare ClipDir = MapContent::GetClipDir(_Coord);
		declare ClipName = MapContent::GetClipName(_Coord);
		
		// The properties of the clip that can be connected
		declare ValidClipDir = MU::GetOpposedDir(ClipDir);
		declare ValidClipCoord = MU::GetNeighbourCoord(ClipCoord, ValidClipDir);
		declare ValidClipNames = Macroblock::GetConnectableClips(ClipName);
		
		// The clips available on the macroblock to connect
		declare NextClipNames = Macroblock::GetClipNames(MacroblockModel);
		declare NextClipOffsets = Macroblock::GetClipOffsets(MacroblockModel);
		declare NextClipDirs = Macroblock::GetClipDirs(MacroblockModel);
		
		// The best block placement
		declare BestDir = CMapEditorPlugin::CardinalDirections::North;
		declare BestCoord = Utils::NullCoord();
		declare DirDiff = -1;
		
		foreach (NextClipId => NextClipName in NextClipNames) {
			// Skip -out clip, we can't use them to connect the next macroblock
			if (Macroblock::IsOutClip(NextClipName)) continue;
			
			// Skip clips that can't be connected
			if (!ValidClipNames.exists(NextClipName)) continue;
			
			// Determine next block coord and dir
			if (!NextClipOffsets.existskey(NextClipId) || !NextClipDirs.existskey(NextClipId)) continue;
			declare NextBlockDir = MU::SubDirs(ValidClipDir, NextClipDirs[NextClipId]);
			declare NextBlockCoord = ValidClipCoord - MU::GetRotatedOffsetPositive(NextClipOffsets[NextClipId], NextBlockDir, Variant.Size);
			
			if (CustomCanPlaceMacroblock(MacroblockModel, NextBlockCoord, NextBlockDir, True)) {
				declare Diff = ML::Abs(Utils::DirToInt(NextBlockDir) - Utils::DirToInt(Cursor.Dir));
				if (DirDiff == -1 || Diff < DirDiff) {
					DirDiff = Diff;
					BestCoord = NextBlockCoord;
					BestDir = NextBlockDir;
				}
			}
		}
		
		// Set the cursor to the best placement
		if (BestCoord != Utils::NullCoord()) {
			SetCursorCoord(BestCoord);
			SetCursorDir(BestDir);
			Connected = True;
		}
	}
	
	if (!Connected && !CustomCanPlaceMacroblock(MacroblockModel, Cursor.Coord, Cursor.Dir, True)) {
		for (Dir, 0, 3) {
			declare ShiftDir = (Utils::DirToInt(Cursor.Dir) + Dir) % 4;
			if (CustomCanPlaceMacroblock(MacroblockModel, Cursor.Coord, Utils::IntToDir(ShiftDir), True)) {
				SetCursorDir(Utils::IntToDir(ShiftDir));
				break;
			}
		}
	}*/
}

//	Try to place the given macroblock, if it can't be placed then check why and do what's best
Boolean ExpertCursorPlace(Ident _MacroblockModelId) {
	declare MacroblockPlaced = False;

	tuningmark("ExpertCursorPlace");
	if (G_CurrentSequence == C_Sequence_EditDecoration) {
		MacroblockPlaced = AddDecoMacroblock2(_MacroblockModelId); ///< Place deco macroblock
	} else {
		MacroblockPlaced = AddMacroblock2(_MacroblockModelId); ///< Place macroblock
	}
	if (!MacroblockPlaced) {
		declare Coord = Cursor.Coord;
		declare OriginalCoord = Cursor.Coord;
		
		declare MBInstance = GetMacroblockInstanceFromUnitCoord(Cursor.Coord);
		if (MBInstance != Null && MBInstance.UnitCoords.count > 0) 
			Coord = MBInstance.UnitCoords[0];

		// Cursor is on a macroblock, find a macroblock that can be connected
		if ((G_IsEditing || G_IsSkinning) && MapContent::Exists(Coord)) {
			if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_Edit())) {
				UI_Tuto::ValidateTuto(UI_Tuto::Tuto_Edit());
				CheckTuto();
			}
			
			// Select the right building mode
			declare MacroblockMode = MapContent::GetMacroblockType(Coord);
			if ((MacroblockMode == C_Modes_ConstructTrack || MacroblockMode == C_Modes_ConstructDeco)) {
				if (G_Mode != MacroblockMode) {
					declare PrevCursorCoord = Coord;
					SelectMode(C_Categories_Construct, MacroblockMode);
					SelectSequence();
					SetCursorCoord(PrevCursorCoord);
				}
			}
			
			// Select the right style
			if (MacroblockMode == C_Modes_ConstructTrack || MacroblockMode == C_Modes_ConstructDeco) {
				declare EditedMacroblockModel = MapContent::GetMacroblockModel(Coord);
				if (EditedMacroblockModel != Null) SelectMacroblockStyle(EditedMacroblockModel.Id, MacroblockMode);
			}
			
			SetCursorCoord(Coord);
			declare ValidMacroblockModels = FilterMacroblocks2(True);
			if (ValidMacroblockModels.count > 0) {
				declare MacroblockModel <=> MapContent::GetMacroblockModel(Coord);
				if (MacroblockModel == Null || !ValidMacroblockModels.exists(MacroblockModel)) 
					MacroblockModel = SelectSimplestMacroblock(ValidMacroblockModels);
				
				SetCursorDir(Placement::GetDir(MacroblockModel));
				SetCursorCoord(Placement::GetCoord(MacroblockModel));
				SetCursorMacroblockModel(MacroblockModel);
				
				MoveMacroblock(<0, 0, 0>, False);
				if (CanNotify()) UI_BlockHelp::Notify(_("|Infinitive|Connect"));
			} else {
				SetCursorCoord(OriginalCoord);
				MoveMacroblock(<0, 0, 0>, False);
			}
		} 
		// Cursor in on an empty space, try to find a valid placement for the cursor macroblock
		else {
			if (MacroblockModels.existskey(_MacroblockModelId)) {
				declare MacroblockModel <=> MacroblockModels[_MacroblockModelId];
				declare PlacementCoords = Placement::GetCoords(MacroblockModel);
				declare PlacementDirs = Placement::GetDirs(MacroblockModel);
				foreach (Placement => Coord in PlacementCoords) {
					if (CustomCanPlaceMacroblock(MacroblockModel, Coord, PlacementDirs[Placement], True)) {
						if (Cursor.Dir != PlacementDirs[Placement] || Coord != Cursor.Coord) {
							SetCursorDir(PlacementDirs[Placement]);
							SetCursorCoord(Coord);
							
							if (CanNotify()) UI_BlockHelp::Notify(_("|Infinitive|Rotate"));
						}
						break;
					}
				}
			}
		}
	}
	
	return MacroblockPlaced;
}

// Try to turn the current macroblock if we are in an open block, pick the select macroblock if we are on an occupied block
Void ExpertCursorTurn() {
	if (G_IsEditing || G_IsSkinning) {
		declare MacroblockMode = MapContent::GetMacroblockType(Cursor.Coord);
		if (MapContent::Exists(Cursor.Coord) && (MacroblockMode == C_Modes_ConstructTrack || MacroblockMode == C_Modes_ConstructDeco)) {
			if (G_Mode != MacroblockMode) {
				declare PrevCursorCoord = Cursor.Coord;
				SelectMode(C_Categories_Construct, MacroblockMode);
				SelectSequence();
				SetCursorCoord(PrevCursorCoord);
			}
			
			declare MacroblockModel = MapContent::GetMacroblockModel(Cursor.Coord);
			if (MacroblockModel != Null && !MacroblockModel.HasStart && !MacroblockModel.HasMultilap) {
				if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_Edit())) {
					UI_Tuto::ValidateTuto(UI_Tuto::Tuto_Edit());
					CheckTuto();
				}
				
				declare MacroblockCoord = MapContent::GetMacroblockCoord(Cursor.Coord);
				declare MacroblockDir = MapContent::GetMacroblockDir(Cursor.Coord);
				SelectMacroblock(MacroblockModel.Id, MacroblockCoord, MacroblockDir);
				
				SetCursorMacroblockModel(Null, MacroblockModel);

				SetCursorDir(MacroblockDir);
				CopySkin(MacroblockModel, MacroblockCoord, MacroblockDir);
				
				if (CanNotify()) UI_BlockHelp::Notify(_("|Infinitive|Copy"));
				Sound::Play("EditorBlockSelection");
			} else {
				if (CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("|Infinitive|Copy"))); 
				Sound::Play("EditorWrongAction");
			}
		}
	} else {
		RotateMacroblock(1);
	}
}

/// Skip a macroblock from the paste stack
Void SkipMacroblock() {
	// Cut and paste tuto
	if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_CutPaste())) {
		UI_Tuto::ValidateTuto(UI_Tuto::Tuto_CutPaste());
		CheckTuto();
	}
	
	if (CutPaste::Count() > 0) {
		if (CanNotify()) UI_BlockHelp::Notify(_("|Infinitive - throw out|Discard"));
	} else {
		if (!G_RandomMapGeneration) Sound::Play("EditorWrongAction");
	}
	CutPaste::Skip();
}

/// Cut the latest macroblock
Void CutMacroblock() {
	// Cut and paste tuto
	if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_CutPaste())) {
		UI_Tuto::Enable(UI_Tuto::Tuto_CutPaste());
	}
	RemoveMacroblock2(MapContent::GetLatestMacroblockUnitCoord(G_Mode, False), G_Mode, True, False);
	if (!G_RandomMapGeneration) Sound::Play("EditorRemoveBlock");
}

/// Find the informations about the next paste
Void FindNextPaste() {
	tuningmark("FindNextPaste");
	declare CMacroblockModel GamepadEditor_NextPasteMacroblockModel for This;
	declare Int3 GamepadEditor_NextPasteCoord for This;
	declare CMapEditorPlugin::CardinalDirections GamepadEditor_NextPasteDir for This;
	GamepadEditor_NextPasteMacroblockModel = Null;
	GamepadEditor_NextPasteCoord = Utils::NullCoord();
	GamepadEditor_NextPasteDir = C_North;
		
	declare CutNextMacroblockModelId = CutPaste::GetNextMacroblockModelId();
	if (CutNextMacroblockModelId != NullId && MacroblockModels.existskey(CutNextMacroblockModelId)) {
		
		// Get the macroblock at the current cursor coordinates
		declare PrevMacroblockInstance = GetMacroblockInstanceFromUnitCoord(G_FilteringCoord);
		declare PrevDisconnectedClips = MapContent::GetDisconnectedClips(PrevMacroblockInstance);
		
		declare CutNextMacroblockModel <=> MacroblockModels[CutNextMacroblockModelId];
		declare CutNextConnectedBy = CutPaste::GetNextMacroblockConnectedBy();
		declare CutPrevMacroblockModelId = CutPaste::GetPrevMacroblockModelId();
		declare CutPrevConnectedBy = CutPaste::GetPrevMacroblockConnectedBy();
		
		declare FoundConnection = False;
	
		if (PrevDisconnectedClips.count > 0) {
			// Valid data for the next macroblock
			declare PrevClipList = PrevMacroblockInstance.ClipList;
			foreach (PrevClipId in PrevDisconnectedClips) {
				if ( PrevClipId >= PrevClipList.Clips.count ) continue;
				declare Clip <=> PrevClipList.Clips[PrevClipId];
				
				declare ValidClipDir = MU::GetOpposedDir(Clip.Dir);
				declare ValidClipCoord = Clip.GetConnectableCoord();
				declare ValidClipName = Macroblock::GetConnectableClips(Clip.Name);
				
				// Test all variants
				declare MacroblockVariants = Macroblock::GetVariants(CutNextMacroblockModel);
				foreach (VariantId in MacroblockVariants) {
					declare VariantModel <=> Macroblock::GetMacroblockModelFromId(VariantId);
					
					// Get variant
					declare NextVariant <=> Macroblock::GetBlockModelVariant(VariantModel);
					if (NextVariant == Null) continue;
			
					// Data of the next macroblock
					declare NextClipNames = Macroblock::GetClipNames(VariantModel);
					declare NextClipOffsets = Macroblock::GetClipOffsets(VariantModel);
					declare NextClipDirs = Macroblock::GetClipDirs(VariantModel);
					
					foreach (NextClipId => NextClipName in NextClipNames) {
						// Skip clips that can't be connected
						if (!ValidClipName.exists(NextClipName)) continue;
						
						// Determine next block coord and dir
						if (!NextClipOffsets.existskey(NextClipId) || !NextClipDirs.existskey(NextClipId)) continue;
						declare NextBlockDir = MU::SubDirs(ValidClipDir, NextClipDirs[NextClipId]);
						declare NextBlockCoord = ValidClipCoord - MU::GetRotatedOffsetPositive(NextClipOffsets[NextClipId], NextBlockDir, NextVariant.Size);
					
						// Skip macroblock that can't be placed and have no transition
						if (!CustomCanPlaceMacroblock(VariantModel, NextBlockCoord, NextBlockDir, True)) continue;
						
						declare IsConnectedTo = (PrevMacroblockInstance.MacroblockModel.Id == CutPrevMacroblockModelId && PrevClipId == CutPrevConnectedBy);
						declare IsConnectedBy = (NextClipId == CutNextConnectedBy);
						
						if (IsConnectedTo && IsConnectedBy) FoundConnection = True;
						
						if (GamepadEditor_NextPasteMacroblockModel == Null || IsConnectedBy || FoundConnection) {
							GamepadEditor_NextPasteMacroblockModel <=> VariantModel;
							GamepadEditor_NextPasteCoord = NextBlockCoord;
							GamepadEditor_NextPasteDir = NextBlockDir;
						}
						
						if (FoundConnection) break;
					}
					if (FoundConnection) break;
				}
				if (FoundConnection) break;
			}
		}
	}
}

/// Try to select the next paste in the macroblocks list
Void SelectNextPaste() {
	FindNextPaste();
	
	declare CMacroblockModel GamepadEditor_NextPasteMacroblockModel for This;
	declare Int3 GamepadEditor_NextPasteCoord for This;
	declare CMapEditorPlugin::CardinalDirections GamepadEditor_NextPasteDir for This;
	
	if (GamepadEditor_NextPasteMacroblockModel == Null) return;
	
	SelectMacroblock(GamepadEditor_NextPasteMacroblockModel.Id, GamepadEditor_NextPasteCoord, GamepadEditor_NextPasteDir);
}

/// Paste the newest macroblock
Void PasteMacroblock() {
	FindNextPaste();
	
	declare CMacroblockModel GamepadEditor_NextPasteMacroblockModel for This;
	declare Int3 GamepadEditor_NextPasteCoord for This;
	declare CMapEditorPlugin::CardinalDirections GamepadEditor_NextPasteDir for This;
		
	if (GamepadEditor_NextPasteMacroblockModel != Null) {
		declare MacroblockPlaced = AddMacroblock2(GamepadEditor_NextPasteMacroblockModel, GamepadEditor_NextPasteCoord, GamepadEditor_NextPasteDir, True, False);
		if (MacroblockPlaced) {
			CutPaste::Paste();
			SelectNextPaste();
			if (CanNotify()) UI_BlockHelp::Notify(_("Paste"));
		}else{
			CutPaste::WarnNoPaste();
		}
	} else {
		if (!G_RandomMapGeneration){
			CutPaste::WarnNoPaste();
			Sound::Play("EditorWrongAction");
		}
	}
	
	// Cut and paste tuto
	if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_CutPaste())) {
		UI_Tuto::ValidateTuto(UI_Tuto::Tuto_CutPaste());
	}
	
	CheckAdvices();
	CheckTuto();
}

// Add a random prefab landscape
Void RandomLandscape(Boolean _Beginner, Boolean _Random) {
	if (!_Beginner) RemoveAllTerrain();
	
	declare CMacroblockModel Terrain;
	declare TerrainName = "";
	declare Terrains = Terrain::GetTerrains(/*_Beginner,*/ _Random);
	if(Terrains.count == 0) return;
	declare TerrainIndex = Random::Rand(0, Terrains.count-1);
	declare Count = 0;
	foreach (Name => MacroblockModel in Terrains) {
		if (Count == TerrainIndex) {
			TerrainName = Name;
			Terrain <=> MacroblockModel;
			break;
		}
		Count += 1;
	}
	
	declare Directions = Terrain::GetTerrainDirs(TerrainName);
	declare Dir = Directions[Random::Rand(0, Directions.count-1)];
	
	declare PartsCount = Terrain::GetPartsCount(TerrainName);
	for (Part, 0, PartsCount-1) {
		declare Placed = Terrain::PlacePart(TerrainName, Part, Dir);
		Yield();
	}
	
	declare metadata Text GamepadEditor_TerrainId for Map;
	declare metadata Integer GamepadEditor_TerrainDir for Map;
	GamepadEditor_TerrainId = Macroblock::GetId(Terrain);
	GamepadEditor_TerrainDir = Utils::DirToInt(Dir);
	
	AutoSave();
	Yield();// Autosave is heavy, Yield to make the script feel smoother
	
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	MapModified();
}


//	Select the connection clip to use
Void SelectConnectedTo(Ident _MacroblockModelId, Integer _ConnectedTo) {
	if (G_AvailableConnectors.exists(_ConnectedTo)) G_CursorConnectedTo = _ConnectedTo;
	else G_CursorConnectedTo = -1;
	SendMacroblockList(G_AvailableMacroblocks);
		
	if (G_CursorConnectedTo >= 0) {
		// Get the macroblock model variant to use
		declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(_MacroblockModelId);
		
		declare MacroblockConnectedByClips = Placement::GetConnectedByClips(MacroblockModel);
		declare MacroblockConnectedByClip = Placement::GetConnectedByClip(MacroblockModel);
		foreach (Placement => ConnectedBy in MacroblockConnectedByClips) {
			if (ConnectedBy != MacroblockConnectedByClip) continue;
			if (Placement::GetConnectedToClip(MacroblockModel, Placement) == G_CursorConnectedTo) {
				Placement::Select(MacroblockModel, Placement);
				if (MacroblockModel != Null) UI_MacroblockSelection::FindMacroblock(MacroblockModel.Id, Placement);
				break;
			}
		}
	}
}

// Switch between the clips of the next block
Void SwitchMacroblockPlacement(Ident _MacroblockModelId, Boolean _SwitchOnlyConnection) {
	// Get the macroblock model variant to use
	declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(_MacroblockModelId);
	
	if (_SwitchOnlyConnection) {
		declare ConnectedTo = G_CursorConnectedTo;
		declare Key = G_AvailableConnectors.keyof(ConnectedTo) + 1;
		if (!G_AvailableConnectors.existskey(Key)) {
			if (G_AvailableConnectors.count > 0) ConnectedTo = G_AvailableConnectors[0];
			else ConnectedTo = -1;
		} else {
			ConnectedTo = G_AvailableConnectors[Key];
		}
		SelectConnectedTo(_MacroblockModelId, ConnectedTo);
		
		if (!G_RandomMapGeneration) {
			if (G_AvailableConnectors.count > 1) {
				Sound::Play("EditorBlockRotate");
				if (CanNotify()) UI_BlockHelp::Notify(_("|Infinitive - Change choice|Switch"));
			}
			else {
				Sound::Play("EditorWrongAction");
				if (CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("|Infinitive - Change choice|Switch")));
			}
		}
	} else {
		if (!G_RandomMapGeneration) Sound::Play("EditorBlockRotate");
		if (CanNotify()) UI_BlockHelp::Notify(_("|Infinitive - Change choice|Switch"));
	}
	
	// Next placement
	
	PreviewMacroblock(_MacroblockModelId, Placement::GetPlacement(MacroblockModel), False);
	
	// Update tuto
	if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_Switch())) {
		UI_Tuto::Trigger(UI_Tuto::Tuto_Switch());
		CheckTuto();
	}
}

/// Select the right state when switching to the construct mode
Void InitConstructMode() {
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	
	// Try to find an open clip
	declare Coord = MapContent::GetLatestMacroblockUnitCoord(C_Modes_ConstructTrack, True);
	if (Coord != Utils::NullCoord()) {
		SetCursorCoord(Coord);
	} else {
		Coord = MapContent::GetLatestMacroblockUnitCoord(C_Modes_ConstructTrack, False);
		if (Coord != Utils::NullCoord()) {
			SetCursorCoord(Coord);
		}
	}
}

// Turn on/off the test mode
Void SetTestMode(Boolean _Status) {
	// Can't start test if there's no start and checkpoint
	if (!MapContent::HasStart() && !MapContent::HasCheckpoint()) {
		G_TestMode = False;
		Sound::Play("EditorWrongAction");
		if (CanNotify()) UI_BlockHelp::Notify(TL::Compose("$f00%1", _("|Infinitive - Try track|Test")));
		return;
	}
	
	G_TestMode = _Status;
	
	if (_Status) {
		if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_Test())) {
			UI_Tuto::ValidateTuto(UI_Tuto::Tuto_Test());
			CheckTuto();
		}
	} else {
		// Return to the right macroblock
		if (G_Mode == C_Modes_ConstructTrack) {
			InitConstructMode();
		}
	}
	
	if (CanNotify() && _Status) {
		UI_BlockHelp::Notify(_("|Infinitive - Try track|Test"));
	}
	
	if (_Status) {
		Sound::Play("EditorTestStart");
	} else {
		Sound::Play("EditorMenuCancel");
	}
	
	SelectSequence();
	CheckHelper();
}

/// Update the Uid of the track
Void UpdateUid() {
	declare MacroblockModel <=> Macroblock::GetUpdateUidBlock();
	if (MacroblockModel == Null) return;
	declare Stop = False;
	
	for (RevertY, 0, Map.Size.Y-1) {
		declare Y = Map.Size.Y - 1 - RevertY;
		for (X, 0, Map.Size.X-1) {
			for (Z, 0, Map.Size.Z-1) {
				declare Placed = False;
				if (CanPlaceMacroblock_NoTerrain(MacroblockModel, <X, Y, Z>, C_North)) {
					Placed = PlaceMacroblock_NoTerrain(MacroblockModel, <X, Y, Z>, C_North);
				}
				if (Placed) {
					yield; ///< Let the track type unvalidate the track
					declare Removed = RemoveMacroblock_NoTerrain(MacroblockModel, <X, Y, Z>, C_North);
					Stop = True;
				}
				
				if (Stop) break;
			}
			if (Stop) break;
		}
		yield;
		if (Stop) break;
	}
	
	MapModified();
}

/// Confirm before exiting the editor
Boolean ConfirmQuit() {
	if ( Utils::GetSaveStatus() != Utils::SaveStatus_Saved()) {
		return Confirm(
			_("|Infinitive - Quit game mode|Leave editor"),
			ComposeMultilines([
				_("Any unsaved modification done on this track will be lost."),
				_("Are you sure you want to leave the editor?")
			]),
			_("|Infinitive|Confirm"),
			_("|Infinitive|Cancel")
		);
	}else if(S_RandomMap_Generate){
		return Confirm(
			_("|Infinitive - Quit game mode|Leave editor"),
			ComposeMultilines([
				_("Are you sure you want to leave the editor?")
			]),
			_("|Infinitive|Confirm"),
			_("|Infinitive|Cancel")
		);
	}
	return True;
}

/// Quit the editor
Void CustomQuitNoConfirm() {
		QuickQuit();
}

/// Confirm before exiting the editor
Void CustomQuit() {
	if (ConfirmQuit()) {
		CustomQuitNoConfirm();
	}
}

// Confirm before exiting the editor and return an event
Void CustomQuit(Text _Type, Text[] _Data) {
	if (ConfirmQuit()) {
		QuickQuitAndSetResult(_Type, _Data);
	}
}


// Custom save track function, make sure track gets saved correctly (no save interruptions)
Boolean SaveMapAndCheckIfSaved(Text _MapName){
	SaveMapGamepadEditor(_MapName);
	
	while(True){
		foreach (Event in PendingEvents) {
			if (Event.Type == CMapEditorPluginEvent::Type::MapSavedOrSaveCancelled) {
				return Event.MapSavedOrSaveCancelled;
			}
		}
		Yield();
	}
	return False;
}

Boolean CustomSavePrompt() {
	declare Text PrefillSaveEntry = GetMapName();
	if (PrefillSaveEntry == "" && S_AutoName)
		PrefillSaveEntry = GetAvailableMapName();
	
	declare Text[] Splitted;
	Splitted = TL::Split("\\", PrefillSaveEntry);
	PrefillSaveEntry = Splitted[Splitted.count - 1];
		
	UI_Save::PrefillEntry(PrefillSaveEntry);
	
	Loading(False); 
	
	declare Boolean Saved = False;
	declare Boolean Cancelled = False;
	
	while (!Saved && !Cancelled) {
		UI_Manager::ShowOnly(UI_Manager::C_File_Save);
		SelectSequence();
		
		while (UI_Save::Wait()) Yield();
		
		Yield(); // Allow GetMapName/Answer update if pressed Enter
		
		if (UI_Save::Answer()) { // The player pressed "yes"/enter
			declare Text NewMapName = UI_Save::GetMapName();
			if (NewMapName == "" && S_AutoName)
				NewMapName = GetAvailableMapName();
				
			Splitted = TL::Split("\\", NewMapName);
			NewMapName = Splitted[Splitted.count - 1];
			
			if (IsMapFileNameAvailable(NewMapName)) {
				if (!TL::EndsWith(".Map.Gbx", NewMapName))
					NewMapName = NewMapName^".Map.Gbx";
				
				declare NewMapNameWithPath = "My Maps\\"^NewMapName;
				if (Confirm(
					_("|Action|Save"),
					ComposeMultilines([
						_("Do you want to save your track using the following name?"),
						FilterProfanities(NewMapName)
					]),
					_("|Validation choice|Save"),
					_("|Validation choice|Cancel")
				)){
					SetMapName(NewMapNameWithPath);
					Saved = True; // normal save
				}
			} else {
				if (!TL::EndsWith(".Map.Gbx", NewMapName))
					NewMapName = NewMapName^".Map.Gbx";
					
				declare NewMapNameWithPath = "My Maps\\"^NewMapName;
					
				if (Confirm(
					_("|Alert window title|Warning"),
					ComposeMultilines([
						_("The following track already exists, overwrite it?"),
						FilterProfanities(NewMapName)
					]),
					_("|Validation choice|Overwrite"),
					_("|Validation choice|Cancel")
				)){
					SetMapName(NewMapNameWithPath);
					Saved = True; // overwrite
				}
			}
		} else { // the player pressed "no"/back/esc.
			Cancelled = True; // go back to start menu
		}
			
		Yield(); // avoid keeping inputs when going back to UI_Save::Wait() or any other UI frame afterwards
	}
	
	assert (Saved != Cancelled); // xor
	
	if(Saved) return True;
	/*else if(Cancelled)*/ return False;
}

//	Custom save track as function
Boolean CustomSaveMap(Boolean _SaveAs) {
	if (_SaveAs) {
		// This doesn't seem true, I don't know if anything changed...
		/*if (ValidationStatus == CMapEditorPlugin::ValidationStatus::Validated) {
			declare ConfirmSave = Confirm(
				_("|Infinitive|Save as new"),
				_("You will have to validate the track again."),
				_("|Infinitive|Confirm"),
				_("|Infinitive|Cancel")
			);
			if (!ConfirmSave) return False;
		}*/
		UpdateUid();
	}
	
	MapContent::SaveMapContent();
	
	// TAG: MapStyleSelection
	// Select style on first save after validation
	/*declare metadata GamepadEditor_MapStyleSelected for Map = False;
	if (!G_RandomMapGeneration && !GamepadEditor_MapStyleSelected && ValidationStatus == CMapEditorPlugin::ValidationStatus::Validated) {
		declare metadata GamepadEditor_MapStyle for Map = UI_MapStyleSelection::Style_Race();
		declare Canceled = False;
		G_MapStyleSelection = True;
		SelectSequence();
		ClearInputBuffer();
		G_TerrainCanPress = False;
		
		while (G_MapStyleSelection) {
			Yield();
			
			foreach (Input in G_InputBuffer) {
				switch (Input) {
					case CMapEditorPluginEvent::EInput::CursorPlace	: { ///< Valid track style selection
						GamepadEditor_MapStyle = UI_MapStyleSelection::Valid();
						GamepadEditor_MapStyleSelected = True;
						G_MapStyleSelection = False;
					}
					case CMapEditorPluginEvent::EInput::CursorDelete	: { ///< Cancel track style selection
							UI_MapStyleSelection::Select(GamepadEditor_MapStyle);
							G_MapStyleSelection = False;
							Canceled = True;
							Sound::Play("EditorMenuCancel");
						}
					case CMapEditorPluginEvent::EInput::IconUp			: UI_MapStyleSelection::Prev(); ///< Previous selection in the menu
					case CMapEditorPluginEvent::EInput::IconDown		: UI_MapStyleSelection::Next(); ///< Next selection in the menu
					case CMapEditorPluginEvent::EInput::CursorUp		: UI_MapStyleSelection::Prev(); ///< Previous selection in the menu
					case CMapEditorPluginEvent::EInput::CursorDown		: UI_MapStyleSelection::Next(); ///< Next selection in the menu
				}
			}
			ClearInputBuffer();
			G_TerrainCanPress = False;
		}
		SelectSequence();
		if (Canceled) return False;
	}*/
	
	declare CurMapName = "";
	if (!_SaveAs) CurMapName = GetMapName();
	
	// TAG: MapStyleSelection
	/*if (G_RandomMapGeneration) SetMapStyle(UI_MapStyleSelection::GetStyleRawName(UI_MapStyleSelection::Style_Random()));
	else SetMapStyle(UI_MapStyleSelection::GetStyleRawName());*/

	if (S_CustomSavePrompt && CurMapName == "") {
		declare SaveSuccess = CustomSavePrompt();
		UI_Manager::Hide(UI_Manager::C_File_Save);
		if (SaveSuccess) {
			CurMapName = GetMapName();
		} else {
			return False;
		}
	}
	else if(S_AutoName && CurMapName == ""){
		declare Text AvailableMapName = GetAvailableMapName();
		if(Confirm(
			_("|Action|Quick save"),
				ComposeMultilines([
					_("Do you want to save your track using the following name?"),
					FilterProfanities(AvailableMapName)
				]),
				_("|Validation choice|Yes"),
				_("|Validation choice|No")
			)){
				SetMapName(AvailableMapName);
				CurMapName = GetMapName();
			}
	}
	
	declare metadata GamepadEditor_TrackbuilderVersion_Created for Map = "";
	declare metadata GamepadEditor_TrackbuilderVersion_Modified for Map = "";
	if (GamepadEditor_TrackbuilderVersion_Created == "")
		GamepadEditor_TrackbuilderVersion_Created = C_EditorVersion;
	if (GamepadEditor_TrackbuilderVersion_Modified != C_EditorVersion)
		GamepadEditor_TrackbuilderVersion_Modified = C_EditorVersion;
	
	SetMapName(CurMapName);

	Yield();
	// Compute shadows
	if ((G_RandomMapGeneration && !S_RandomMap_Validate) || ValidationStatus == CMapEditorPlugin::ValidationStatus::Validated)
		CustomComputeShadows();
	
	Loading(True, SystemText::GetSavingMessage(), True);
	
	// Save track again once shadows are computed
	if(!SaveMapAndCheckIfSaved(CurMapName)){ 
		Loading(False); 
		return False;
	}
	// For PC : SaveMap with an empty name gives the save prompt where the user types a name. We afterwards need to get that name, set it as the metadata mapname, and save the track again to save the metadata
	if	(CurMapName == ""){
		CurMapName = MapFileName;
		SetMapName(CurMapName);
		if(!SaveMapAndCheckIfSaved(CurMapName)){ 
			Loading(False); 
			return False;
		}
	}

	Share::SetLastMapCreated(GetMapName()^".Map.Gbx", Map.MapInfo.MapUid);
	Utils::SetSaveStatus(Utils::SaveStatus_Saved());
	
	// Update progression
	CheckProgression();
	
	Loading(False);
	return True;
}

/// Create a copy of the track
Void CopyMap() {
	// Wait a bit for the editor to be ready, otherwise it crashes...
	while (!IsEditorReadyForRequest) yield;
	declare TimeLimit = Now + 1000;
	while (Now < TimeLimit) yield;

	UpdateUid();
	
	declare CurMapName = "";
	CurMapName = MapFileName;

	if (CurMapName == "") return;
	
	// Save the version of the editor used to create the track
	declare metadata GamepadEditor_TrackbuilderVersion_Created for Map = "";
	declare metadata GamepadEditor_TrackbuilderVersion_Modified for Map = "";
	if (GamepadEditor_TrackbuilderVersion_Created == "") GamepadEditor_TrackbuilderVersion_Created = C_EditorVersion;
	GamepadEditor_TrackbuilderVersion_Modified = C_EditorVersion;
	
	SetMapName(CurMapName);
	
	while (!IsEditorReadyForRequest) yield;
	if(!SaveMapAndCheckIfSaved(CurMapName)) return;
	while (!IsEditorReadyForRequest) yield;
}

//	Check if the track contains at least one respawnable checkpoint
Boolean HasRespawnableCheckpoint() {
	tuningmark("HasRespawnableCheckpoint");
	foreach (Block in ClassicBlocks) {
		if (Block == Null) continue;
		if (Block.BlockModel.WaypointType == CBlockModel::EWayPointType::Checkpoint && !Block.BlockModel.NoRespawn) return True;
	}
	
	return False;
}

// Ask the player to confirm the validation
Boolean ConfirmValidate() {	
	
	if (IsEditor(C_Editor_Beginner)) {
		return Confirm(
			_("|Infinitive|Validate track"),
			ComposeMultilines([
				_("To play this track outside of the editor you need to validate it."),
				_("To do so you have to complete one race, from start to finish, passing through all checkpoints.")
			]),
			_("|Infinitive|Validate"),
			_("|Infinitive|Cancel"),
			False
		);
	}
		
	return Confirm(
		_("|Infinitive|Validate track"),
		ComposeMultilines([
			_("To play this track outside of the editor you need to validate it."),
			_("Do you want to validate the track now?")
		]),
		_("Yes"),
		_("No")
	);
}

Void SetPodiumMacroblock() {
	if(!IsEditor(C_Editor_Expert))
		return;
	
	SelectMode(C_Categories_Construct, C_Modes_ConstructDeco);
	SelectSequence();
	Yield();
	
	declare PodiumMacroblockModel = Macroblock::GetPodiumMacroblockModel();
	
	if(PodiumMacroblockModel != Null) {
		declare PodiumFamily = Macroblock::GetFamily(PodiumMacroblockModel);
		declare DecoStyles = ThemePack::GetDecoStyles();
		declare DecoStyleIndex = -1;
		
		foreach(Key => DecoStyle in DecoStyles) {
			declare TranslatedValueSplit = TL::Split("|", DecoStyle);
			declare DecoWithoutLegend = TranslatedValueSplit[TranslatedValueSplit.count-1];
			if (DecoWithoutLegend == PodiumFamily) {
				DecoStyleIndex = Key;
				break;
			}
		}

		if (DecoStyleIndex != -1) {
			ThemePack::Select(ThemePack::GetTrackStyle(), ThemePack::GetLandStyle(), DecoStyleIndex);
			
			BrowseMacroblocks2();
		
			UI_MacroblockSelection::FindMacroblock(PodiumMacroblockModel.Id);
			SetCursorMacroblockModel(PodiumMacroblockModel);
		}
	}
}

// Validate the track
Void CustomValidate() {
	declare PodiumNb = MapContent::GetPodiumCount();
	declare PlayerWantsToPlacePodium = False;
	
	if (!MapContent::HasStart() || GetStartLineBlock() == Null) {
		Alert(_("You need to place a starting point!"));
	} else if (GetStartLineBlock().BlockModel.WaypointType == CBlockModel::EWayPointType::StartFinish && (!MapContent::HasCheckpoint() || !HasRespawnableCheckpoint())) {
		Alert(_("You must place at least one respawnable checkpoint!"));
	} else if (GetStartLineBlock().BlockModel.WaypointType != CBlockModel::EWayPointType::StartFinish && !MapContent::HasFinish()) {
		Alert(_("You must place at least one finish line!"));
	} else {
		if (IsEditor(C_Editor_Expert) && PodiumNb < 1) {
			PlayerWantsToPlacePodium = Confirm(
				_("|Gamepad Editor Pop-up header|No podium found"),
				ComposeMultilines([
					_("You haven't placed any podium in your track."),
					_("Do you want to place one before validating?")
				]),
				_("|Infinitive|Place podium"), 
				_("|Infinitive|Validate")
			);
		}
		
		declare LaunchValidation = !PlayerWantsToPlacePodium;
		if (LaunchValidation && !G_RandomMapGeneration && ValidationStatus == CMapEditorPlugin::ValidationStatus::Validated) {
			LaunchValidation = Confirm(
				_("|Infinitive|Improve validation time"),
				ComposeMultilines([
					_("This track is already validated."),
					_("Do you want to improve the validation time?")
				]),
				_("|Infinitive|Confirm"), 
				_("|Infinitive|Cancel")
			);
		}
		
		if (LaunchValidation) {
			declare PreviousLapsNb = Map.TMObjective_NbLaps;
			declare MenuWasVisible = UI_Menu::LayerIsVisible();
			declare MenuOutroWasVisible = UI_MenuOutro::LayerIsVisible();
			declare ProgressionWasVisible = UI_Progression::LayerIsVisible();
			declare HeaderWasVisible = UI_Header::LayerIsVisible();
			declare SimpleChoiceWasVisible = UI_SimpleChoice::LayerIsVisible();
			if (MenuWasVisible) UI_Manager::Hide(UI_Manager::C_File_Menu);
			if (MenuOutroWasVisible) UI_Manager::Hide(UI_Manager::C_File_MenuOutro);
			if (ProgressionWasVisible) UI_Manager::Hide(UI_Manager::C_File_Progression);
			if (HeaderWasVisible) UI_Manager::Hide(UI_Manager::C_File_Header);
			if (SimpleChoiceWasVisible) UI_Manager::Hide(UI_Manager::C_File_SimpleChoice);
			Sleep(250);
			
			// Set the number of laps
			if (GetStartLineBlock().BlockModel.WaypointType == CBlockModel::EWayPointType::StartFinish) {
				UI_Manager::Show(UI_Manager::C_File_Multilaps);
				
				while (!UI_Multilaps::Confirmed() && !UI_Multilaps::Canceled()) {
					Yield();
					UI_Multilaps::Loop();
				}
				
				UI_Manager::Hide(UI_Manager::C_File_Multilaps);
				LaunchValidation = UI_Multilaps::Confirmed();
			}
			
			if (LaunchValidation) {
				CustomComputeShadows();
				Yield();
				Validate();
				Sleep(250);
				
				while (IsValidating) Yield(); 
				
				if (!G_RandomMapGeneration) Sound::Play("EditorValidationStop");
			}
				
			if (MenuWasVisible) UI_Manager::Show(UI_Manager::C_File_Menu);
			
			Sleep(250);
			
			if (ProgressionWasVisible) UI_Manager::Show(UI_Manager::C_File_Progression);
			if (HeaderWasVisible) {
				if (ManiaPlanet != Null && ManiaPlanet.HMD_IsActive) UI_Header::SetVisibility(True, False, False);
				else UI_Manager::Show(UI_Manager::C_File_Header);
			}
			
			if (SimpleChoiceWasVisible) {
				UI_Manager::Show(UI_Manager::C_File_SimpleChoice);
			}
			
			if (MenuOutroWasVisible) {
				UI_Manager::Show(UI_Manager::C_File_MenuOutro);
				OnSequenceStart(G_CurrentSequence);
			}
			
			CheckProgression();
		}
	}
	
	Yield();
	if (PlayerWantsToPlacePodium) {
		G_MainMenu = False;
		SetPodiumMacroblock();
	} else {
		UI_Menu::Select(UI_Menu::Selection_Validate());
		SelectSequence();
	}
}


/// Custom save track function with auto shadows, requires validation, and auto quit
Void CustomSaveAndQuit() {
	while(ValidationStatus != CMapEditorPlugin::ValidationStatus::Validated) {
		if(ConfirmValidate()){
			CustomValidate();
		}else{
			return;
		}
	}
		
	if(!CustomSaveMap(False)) return;
	CustomQuitNoConfirm();
}


// Start the track with a mode script
Void CustomPlay(Boolean _Validated) {
	if (_Validated && ValidationStatus != CMapEditorPlugin::ValidationStatus::Validated) {
		Alert(_("To play this track outside of the editor you need to validate it."));
		return;
	}
}

// Start to test the track on the selected spawn
Void StartTest() {
	declare Block <=> UI_SpawnSelection::GetSpawn();
	if (Block == Null) Block <=> GetStartLineBlock();
	if (Block == Null) return;
	
	Yield();
	
	declare PrevUndergroundMode = UndergroundMode;
	UndergroundMode = False;
	
	TestMapFromCoord(GetSpawnCoord(Block), Block.Dir);
	Yield(); // TestMap will start a test at the end of the frame, and the script will stop being executed until the end of the test
	
	UndergroundMode = PrevUndergroundMode;
	
	SetTestMode(False);
}

Void RemoveTrack() {
	declare MacroblocksCoords = MapContent::GetMacroblocksUnitCoords(C_Modes_ConstructTrack);
	foreach (MacroblockCoord in MacroblocksCoords) {
		RemoveMacroblock2(MacroblockCoord, C_Modes_ConstructTrack, False, False);
	}
}

Void RemoveDecoration() {
	declare MacroblocksCoords = MapContent::GetMacroblocksUnitCoords(C_Modes_ConstructDeco);
	foreach (MacroblockCoord in MacroblocksCoords) {
		RemoveMacroblock2(MacroblockCoord, C_Modes_ConstructDeco, False, False);
	}
	
	declare metadata Boolean GamepadEditor_IsDecorated for Map;
	declare metadata Boolean GamepadEditor_DecoConfirmed for Map;
	GamepadEditor_IsDecorated = False;
	GamepadEditor_DecoConfirmed = False;
}


Void ConfirmDecoration() {
	if (!IsDecorated()) return;
	
	declare metadata Boolean GamepadEditor_DecoConfirmed for Map;
	GamepadEditor_DecoConfirmed = True;
}

/// Set decoration ratios to their default values
Void DefaultDecoration() {
	declare metadata Real[Text] GamepadEditor_DecoRatios for Map;
	UI_DecoSelection::SetRatios(ThemePack::GetDecoRatios());
}

/*Void ResetMapStyle() { // TAG: MapStyleSelection
	declare metadata GamepadEditor_MapStyle for Map = UI_MapStyleSelection::Style_Race();
	declare metadata GamepadEditor_MapStyleSelected for Map = False;
	GamepadEditor_MapStyle = UI_MapStyleSelection::Style_Race();
	UI_MapStyleSelection::Select(GamepadEditor_MapStyle);
	GamepadEditor_MapStyleSelected = False;
}*/

/// Reset the plugin
Void Reset(Boolean _Soft) {
	Loading(True);
	
	// Test
	if (_Soft && ManiaPlanet != Null && ManiaPlanet.HMD_IsActive) {
		declare MacroblocksCoords = MapContent::GetMacroblocksUnitCoords(C_Modes_ConstructTrack);
		foreach (MacroblockCoord in MacroblocksCoords) {
			RemoveMacroblock2(MacroblockCoord, C_Modes_ConstructTrack, False, False);
			Yield();
		}
		
		MacroblocksCoords = MapContent::GetMacroblocksUnitCoords(C_Modes_ConstructDeco);
		foreach (MacroblockCoord in MacroblocksCoords) {
			RemoveMacroblock2(MacroblockCoord, C_Modes_ConstructDeco, False, False);
			Yield();
		}
		
		RemoveAllBlocks();
		
		declare UnitSize = 5;
		for (X, 0, Map.Size.X/UnitSize) {
			for (Y, 0, Map.Size.Y/UnitSize) {
				declare Position = <X*UnitSize, 0, Y*UnitSize>;
				declare Size = Position + <UnitSize, 0, UnitSize>;
				declare Removed = RemoveTerrainBlocks(Position, Size);
				Yield();
			}
		}
	}
	
	SetMapName("");
	MapContent::RemoveAllContent();
	RemoveDecoration();
	DefaultDecoration();
	History2::Clear();
	UI_Header::ResetColor();
	
	RemoveAll();
	WaitReady();
	RemoveTerrain();
	WaitReady();
	
	Utils::SetSaveStatus(Utils::SaveStatus_NotSaved());
	SetCustomTerrain(False);
	if (IsSimpleEditor()) SelectMode(C_Categories_Landscape, C_Modes_LandscapePostcards);
	else SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	UI_Tuto::DisableAll();
	ThemePack::Select(0, 0, 0);
	UI_MacroblockSelection::SetStyle(ThemePack::GetTrackStyleName(), ThemePack::GetTrackStylePage(), ThemePack::GetTrackStylesCount());
	//ResetMapStyle(); // TAG: MapStyleSelection
	Loading(False);
}

/// Overload Reset()
Void Reset() {
	Reset(False);
}

// Check if you can place a finish at current position
Boolean AutoFinish_CanPlaceFinish(Int3 _Coord) {
	declare CMacroblockModel[] AutoFinish_Finishes for This;
	foreach (MacroblockModel in AutoFinish_Finishes) {
		for (I, 0, 3) {
			if (CustomCanPlaceMacroblock(MacroblockModel, _Coord, Utils::IntToDir(I), False)) {
				return True;
			}
		}
	}
	
	return False;
}

// Find the nearest block where a finish can be placed
Int3 AutoFinish_GetFinishCoord_BFS(Int3 _Start) {
	// Can place finish at start point, exit
	if (AutoFinish_CanPlaceFinish(_Start)) return _Start;
	
	foreach (MacroblockModel in MacroblockModels) {
		if (!Macroblock::GetValidity(MacroblockModel)) continue;
		if (!ThemePack::IsListed(MacroblockModel)) continue;
		
		declare AutoFinish_Visited for MacroblockModel = False;
		AutoFinish_Visited = False;
	}
	
	declare Int3[] Frontier;
	Frontier.add(_Start);
	declare Int3[] Visited;
	Visited.add(_Start);
	declare NextYield = C_Tick_GetFinishCoordBFS;
	
	while (Frontier.count > 0) {
		declare Current = Frontier[0];
		declare Removed = Frontier.removekey(0);
		declare Neighbors = Utils::GetNeighbors(Current);
		foreach (Neighbor in Neighbors) {
			if (Collection::IsObstacle(Neighbor, True)) continue;
			if (Visited.exists(Neighbor)) continue;
			Frontier.add(Neighbor);
			Visited.add(Neighbor);
			//CustomSelectionCoords.add(Neighbor);
			if (AutoFinish_CanPlaceFinish(Neighbor)) return Neighbor;
			if (G_CancelGeneration) break;
		}
		NextYield -= 1;
		if (NextYield <= 0) {
			NextYield = C_Tick_GetFinishCoordBFS;
			Yield();
		}
		if (G_CancelGeneration) break;
	}
	
	return _Start;
}

// Find the path to the from a block to another block
Int3[] AutoFinish_GetFinishPath_GBFS(Int3 _Start, Int3 _End) {
	declare Integer[Int3] Frontier;
	Frontier[_Start] = 0;
	declare Int3[Int3] CameFrom;
	CameFrom[_Start] = _Start;
	
	declare NextYield = C_Tick_GetFinishCoordGBFS;
	
	while (Frontier.count > 0) {
		declare Int3 Current;
		foreach (Coord => Priority in Frontier) {
			Current = Coord;
			break;
		}
		declare Removed = Frontier.removekey(Current);
		declare Neighbors = Utils::GetNeighbors(Current);
		
		foreach (Neighbor in Neighbors) {
			if (Collection::IsObstacle(Neighbor, True)) continue;
			
			if (!CameFrom.existskey(Neighbor)) {
				Frontier[Neighbor] = Utils::ManhattanDistance(Neighbor, _End);
				CameFrom[Neighbor] = Current;
				Frontier = Frontier.sort();
				
				if (AutoFinish_CanPlaceFinish(Neighbor)) {
					declare PrevCoord = Neighbor;
					declare Path = [Neighbor];
					declare Limit = CameFrom.count;
					while (True) {
						if (PrevCoord == CameFrom[PrevCoord]) break;
						PrevCoord = CameFrom[PrevCoord];
						
						Path.add(PrevCoord);
						
						Limit -= 1;
						if (Limit <= 0) break;
					}
					
					return Path;
				}
			}
			if (G_CancelGeneration) break;
		}
		NextYield -= CameFrom.count / 5000 + 1;
		if (NextYield <= 0) {
			NextYield = C_Tick_GetFinishCoordGBFS;
			Yield();
		}
		if (G_CancelGeneration) break;
	}
	
	return [_Start];
}

// Find the first finish block in the list
CMacroblockModel AutoFinish_GetFinishMacroblock(CMacroblockModel[] _MacroblockModels) {
	foreach (MacroblockModel in _MacroblockModels) {
		if (MacroblockModel.HasFinish && Macroblock::GetClipCount(MacroblockModel) > 0) return MacroblockModel;
	}
	return Null;
}

//	Find a path and place a finish
Boolean AutoFinish_FindFinish(Integer _MaxSteps) {
	LogRandomMap("----------------");
	LogRandomMap("_MaxSteps : "^_MaxSteps);
	if (_MaxSteps <= 0) return False;
	declare AutoFinish_MaxIterations for This = 0;
	if (AutoFinish_MaxIterations <= 0) return False;
	tuningmark("AutoFinish_FindFinish");
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	declare CompatibleMacroblocks = FilterMacroblocks2(False);
	declare Finish <=> AutoFinish_GetFinishMacroblock(CompatibleMacroblocks);
	
	// Skip search if there's no compatible block
	LogRandomMap("CompatibleMacroblocks : "^CompatibleMacroblocks.count);
	if (CompatibleMacroblocks.count <= 0) return False;
	
	// Stop auto-finish if cancel
	if (G_CancelGeneration) return False;
	
	// If the block is a finish stop
	if (Finish != Null) {
		AddMacroblock2(Finish.Id, False);
		LogRandomMap("Found a finish : "^Finish);
		return True;
	} 
	// Sort the available blocks
	else if (_MaxSteps > 1) {
		declare Int3[Integer] FinishesCoords;
		declare PrevMacroblockInstance = GetMacroblockInstanceFromUnitCoord(G_CursorCoord);
		declare PrevDisconnectedClips = MapContent::GetDisconnectedClips(PrevMacroblockInstance);
		declare PrevClipList = PrevMacroblockInstance.ClipList;
		
		foreach (PrevDisconnectedClip in PrevDisconnectedClips) {
			declare ClipCoord = PrevClipList.Clips[PrevDisconnectedClip].Coord;
			// Find the nearest placable finish
			FinishesCoords[PrevDisconnectedClip] = AutoFinish_GetFinishCoord_BFS(ClipCoord);
		}
		
		declare Integer[Text] MacroblockModelsSorting;
		declare Text[] MacroblockModelsSorted;
		declare Integer[Ident][Text] MacroblockModelsToTest;
		declare Int3[Text] MacroblocksCoords;
		declare CMapEditorPlugin::CardinalDirections[Text] MacroblocksDirs;
		declare Text[] AutoFinish_FinishesClips for This;
		
		foreach (PrevClip => FinishCoord in FinishesCoords) {
			declare PrevClipCoord = PrevClipList.Clips[PrevClip].Coord;
			declare PrevClipName =	PrevClipList.Clips[PrevClip].Name;
			
			// Walk the path to the finish and stop at the first crossable obstacle
			// Then determine what are the possible height at which the obstacle can be crossed from a tunnel
			
			// Note RBVDZ: I suspect this to be unused/useless in TM2020 as of 2023/02/13 (and since release)
			// The Collection things aren't filled correctly, but I don't even know if this (crossable) concept still exists.
			// Maybe Rafik would know, however he's not here this week. 
			declare PathToFinish = AutoFinish_GetFinishPath_GBFS(PrevClipCoord, FinishCoord);
			declare Integer[] HeightTargets;
			for (Step, 0, PathToFinish.count - 1) {
				declare PathReversedStepCoord = PathToFinish[PathToFinish.count - Step - 1];
				declare Block <=> GetBlock(PathReversedStepCoord);
				if (Block != Null) {
					if (Collection::CrossableExists(Block.BlockModel)) {
						HeightTargets.clear();
						declare CrossableHeights = Collection::GetCrossableHeights(Block.BlockModel);
						foreach (CrossableHeight in CrossableHeights) {
							HeightTargets.add(Block.Coord.Y + CrossableHeight);
						}
					}
				}
			}
			// Compute the smallest height difference between the current clip and the targets
			declare HeightDifference = -1;
			declare HeightTarget = -1;
			foreach (Height in HeightTargets) {
				declare TmpHeightDifference = ML::Abs(Height - PrevClipCoord.Y);
				if (HeightDifference < 0 || TmpHeightDifference < HeightDifference) {
					HeightDifference = TmpHeightDifference;
					HeightTarget = Height;
				}
			}
			// Reset the height target if we're already at the right height
			if (HeightDifference == 0) {
				HeightDifference = -1;
				HeightTarget = -1;
			}
			// Single tunnels have a height step of 4, double tunnels have a height step of 1
			// If the height target is a multiple of 4 we will prioritize "Tunnel" clips, otherwise we'll prioritize "TunnelDouble" clips
			declare Integer[Text] PenalizedClips;
			
			if (Map.CollectionName == "Canyon") {
				if (HeightDifference < 0 || HeightDifference % 4 == 0) PenalizedClips["RoadCaveDoubleFreeClip"] = 1000;
				else PenalizedClips["RoadCaveClip"] = 1000;
				
				// When on cliff roads, privilege first "RoadMain", then "Cliff12RoadHigh" and finaly all the others
				declare CliffClips = ["Cliff12RoadHighClipLeft", "Cliff12RoadHighClipRight", "Cliff12RoadMedClipLeft", "Cliff12RoadMedClipRight"];
				if (CliffClips.exists(PrevClipName)) {
					PenalizedClips["Cliff12RoadHighClipLeft"] = 1000;
					PenalizedClips["Cliff12RoadHighClipRight"] = 1000;
					PenalizedClips["Cliff12RoadMedClipLeft"] = 2000;
					PenalizedClips["Cliff12RoadMedClipRight"] = 2000;
				}
			}
		
			foreach (Count => MacroblockModel in CompatibleMacroblocks) {
				yield(2);
				// Skip block disabled for random generation
				if (ThemePack::IsRandomDisabled(MacroblockModel)) continue;
				// Skip blocks that have less than 2 clips
				declare MacroblockModelClips = Macroblock::GetClipNames(MacroblockModel);
				if (MacroblockModelClips.count < 2) continue;
				
				declare BlockDirs = Placement::GetDirs(MacroblockModel);
				declare BlockCoords = Placement::GetCoords(MacroblockModel);
				
				LogRandomMap("MacroblockModel : "^MacroblockModel^" | ClipsNames : "^MacroblockModelClips^" | BlockDirs : "^BlockDirs);
				foreach (Placement => BlockDir in BlockDirs) {
					MacroblockModelsSorting[MacroblockModel.Id^Placement] = 0;
					MacroblockModelsToTest[MacroblockModel.Id^Placement] = [MacroblockModel.Id => Placement];
					MacroblocksCoords[MacroblockModel.Id^Placement] = BlockCoords[Placement];
					MacroblocksDirs[MacroblockModel.Id^Placement] = BlockDir;
					
					declare Total = 0;
					declare TotalWeight = 0;
						
					declare BlockCoord = Placement::GetCoord(MacroblockModel, Placement);
					// Finding disconnected clips consume too mush resources, it's better to use brute force and try all clips
					/*declare DisconnectedClips = MapContent::GetDisconnectedClips(MacroblockModel, BlockCoord, BlockDir);
					foreach (Clip in DisconnectedClips) {*/
					declare BlockClips = Macroblock::GetClipDirs(MacroblockModel);
					foreach (Clip => ClipDir in BlockClips) {
						declare ClipCoord = Macroblock::GetClipCoord(MacroblockModel, BlockCoord, BlockDir, Clip);
						// Weight computation :
						// Good : blocks with 2 clips only
						// Good : blocks that lead faster to the nearest finish
						// Bad : blocks with a clip that end into an obstacle
						// Bad : blocks with a penalized clip
						// Bad : blocks with a turbo
						// Bad : not the auto oriented placement
						// Bad : clip too close of the top of the track
						
						// Compute the clip penalty
						declare ClipPenalty = 0;
						declare ClipName = MacroblockModelClips[Clip];
						if (PenalizedClips.existskey(ClipName)) ClipPenalty += PenalizedClips[ClipName];
						// Penalize clips if it can't be connected to a finish clip
						ClipPenalty += AutoFinish::GetClipPenalty(ClipName, PrevClipCoord) * 1000;
						
						declare HeightPenalty = 0;
						if (HeightTarget < 0) HeightPenalty = ML::Abs(ClipCoord.Y - FinishCoord.Y) * Map.Size.Y;
						else HeightPenalty = ML::Abs(ClipCoord.Y - HeightTarget) * Map.Size.Y;
						declare DistanceToFinish = Utils::ManhattanDistance(ClipCoord, FinishCoord);
						declare Weight = HeightPenalty + DistanceToFinish + ClipPenalty;
						
						if (Collection::IsObstacle(ClipCoord, True)) Weight += Map.Size.Y * Map.Size.Y;
						if (Macroblock::GetType(MacroblockModel) == "Turbos") Weight += 1;
						if (Placement != Placement::GetPlacement(MacroblockModel)) Weight += 1;
						if (Map.Size.Y - 1 - ClipCoord.Y < C_AutoFinish_PaddingTop) Weight += ClipCoord.Y * 1000; ///< Clip is near the top limit, we can't place a finish block that uses 2 blocks
						
						Total += 1;
						TotalWeight += Weight;
					}
					
					MacroblockModelsSorting[MacroblockModel.Id^Placement] = TotalWeight / Total;
					
					LogRandomMap("MacroblockModel.Id^Placement > Weight : "^MacroblockModelsSorting[MacroblockModel.Id^Placement]);
				}
			}
		}
		
		// Sort the macroblocks by weight, but randomize the position of the macroblocks with the same weight
		MacroblockModelsSorting = MacroblockModelsSorting.sort();
		declare LastWeight = -1;
		declare Integer[Text] TmpSorting;
		foreach (MacroblockSortId => Weight in MacroblockModelsSorting) {
			if (LastWeight == -1 || LastWeight == Weight) {
				TmpSorting[MacroblockSortId] = Random::Rand(0, 100);
			} else {
				TmpSorting = TmpSorting.sort();
				foreach (TmpId => TmpWeight in TmpSorting) {
					MacroblockModelsSorted.add(TmpId);
				}
				TmpSorting.clear();
				TmpSorting[MacroblockSortId] = Random::Rand(0, 100);
			}
			LastWeight = Weight;
		}
		if (TmpSorting.count > 0) {
			TmpSorting = TmpSorting.sort();
			foreach (TmpId => TmpWeight in TmpSorting) {
				MacroblockModelsSorted.add(TmpId);
			}
			TmpSorting.clear();
		}
		
		LogRandomMap("__________________");
		LogRandomMap("Sorting list : "^MacroblockModelsSorting);
		LogRandomMap("Sorted list : "^MacroblockModelsSorted);
		
		// Loop through the sorted blocks and try to build a path to the finish
		declare Integer[] InvalidSignaturesKey;
		foreach (MacroblockSortId in MacroblockModelsSorted) {
			declare MacroblockModelToTest = MacroblockModelsToTest[MacroblockSortId];
			foreach (MacroblockModelId => Placement in MacroblockModelToTest) {
				declare MacroblockModel <=> MacroblockModels[MacroblockModelId];
				
				// Skip macroblocks that was already tested with the same signature
				declare MacroblockSignature = Macroblock::GetSignatureKey(MacroblockModel);
				if (InvalidSignaturesKey.exists(MacroblockSignature)) continue;
				
				AutoFinish_MaxIterations -= 1;
				
				declare BlockCoord = MacroblocksCoords[MacroblockSortId];
				declare BlockDir = MacroblocksDirs[MacroblockSortId];
				declare MacroblockPlaced = AddMacroblock2(MacroblockModel, BlockCoord, BlockDir, False, True);
				
				SetUndergroundMode(MacroblockModel);
				
				// Slow mode
				if (ManiaPlanet != Null && ManiaPlanet.HMD_IsActive) Sleep(100);
				
				LogRandomMap("Connect macroblock > Placed : "^MacroblockPlaced^" | Coord : "^BlockCoord^" | Dir : "^BlockDir^" | Id : "^MacroblockModelId);
				
				if (MacroblockPlaced) {
					LogRandomMap("Forward from step : "^_MaxSteps);
					declare FinishPlaced = AutoFinish_FindFinish(_MaxSteps - 1);
					LogRandomMap("Backward to step : "^_MaxSteps);
					if (FinishPlaced) {
						return True;
					} else {
						if (CutPasteIsAllowed()) {
							CutMacroblock(); ///< Cut the previous macroblock
							SkipMacroblock();
						} else {
							RemoveMacroblock2(MacroblockModel, BlockCoord, BlockDir, G_Mode, False); ///< Remove the previous macroblock
						}
						LogRandomMap("Removed macroblock : "^MacroblockModel);
						
						if (!InvalidSignaturesKey.exists(MacroblockSignature)) InvalidSignaturesKey.add(MacroblockSignature);
					}
				}
				
				if (AutoFinish_MaxIterations <= 0) break;
				
				// Stop auto-finish if cancel
				if (G_CancelGeneration) return False;
			}
			if (AutoFinish_MaxIterations <= 0) break;
			
			// Stop auto-finish if cancel
			if (G_CancelGeneration) return False;
		}
		
		return False;
	}
	
	return False;
}

/// Initialize the auto-finish process
Void AutoFinish_Start() {
	CustomSelectionCoords.clear();
	Cursor.Brightness = C_CursorVisibility;
	
	declare AutoFinish_MaxIterations for This = 0;
	AutoFinish_MaxIterations = C_AutoFinish_MaxIterations;
	
	declare CMacroblockModel[] AutoFinish_Finishes for This;
	declare Text[] AutoFinish_FinishesClips for This;
	AutoFinish_Finishes.clear();
	AutoFinish_FinishesClips.clear();
	foreach (MacroblockModel in MacroblockModels) {
		if (!Macroblock::GetValidity(MacroblockModel)) continue;
		if (!ThemePack::IsListed(MacroblockModel)) continue;
		
		if (MacroblockModel.HasFinish && Macroblock::GetClipCount(MacroblockModel) > 0) {
			AutoFinish_Finishes.add(MacroblockModel);
			declare ClipNames = Macroblock::GetClipNames(MacroblockModel);
			foreach (ClipName in ClipNames) {
				if (!AutoFinish_FinishesClips.exists(ClipName)) AutoFinish_FinishesClips.add(ClipName);
			}
		}
	}

	G_CancelGeneration = False;
}

/// Clean the auto-finish process
Void AutoFinish_End() {
	CustomSelectionCoords.clear();
	Cursor.Brightness = C_CursorVisibility;
}

// Try to place a finish a build a track to it automatically
Void AutoFinish(Boolean _Alert) {
	LogRandomMap("Start Auto finish");
	LogRandomMap("==================");
	
	// Update sequence
	G_AutoFinishing = True;
	G_MoveCursor = False;
	declare PrevCategory = G_Category;
	declare PrevMode = G_Mode;
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	SelectSequence();
	Yield();
	// Find the coordinates of a macroblock with an open clip
	declare PrevMacroblockInstance = MapContent::GetLatestTypedMacroblockInstance(C_Modes_ConstructTrack, True);
	declare PrevDisconnectedClips = MapContent::GetDisconnectedClips(PrevMacroblockInstance);
	
	// We found on open block
	if (PrevDisconnectedClips.count > 0) {
		declare StartingCoord = PrevMacroblockInstance.Coord;
		declare PrevClipList = PrevMacroblockInstance.ClipList;
		SetCursorCoord(StartingCoord, StartingCoord);
		declare Finished = False;
		if (G_RandomMapGeneration) {
			// Try until we can't remove the latest placed block
			declare Count = 0;
			while (!Finished && Count <= 10) {
				LogRandomMap(".............");
				LogRandomMap("AutoFinish > Count : "^Count);
				AutoFinish_Start();
				Finished = AutoFinish_FindFinish(C_AutoFinish_MaxSteps);
				AutoFinish_End();
				
				LogRandomMap("AutoFinish > Finished : "^Finished);
				if (!Finished) {
					declare RemoveCoord = MapContent::GetLatestMacroblockUnitCoord(C_Modes_ConstructTrack, True);
					if (RemoveCoord == Utils::NullCoord()) break;
					LogRandomMap("Try to remove : "^RemoveCoord^" | Macroblock : "^MapContent::GetMacroblockModel(RemoveCoord));
					RemoveMacroblock2(RemoveCoord, True);
					StartingCoord = MapContent::GetLatestMacroblockUnitCoord(C_Modes_ConstructTrack, True);
					if (StartingCoord == Utils::NullCoord()) break;
					
					PrevMacroblockInstance = GetMacroblockInstanceFromUnitCoord(StartingCoord);
					if(PrevMacroblockInstance != Null){
						PrevDisconnectedClips = MapContent::GetDisconnectedClips(PrevMacroblockInstance);
						PrevClipList = PrevMacroblockInstance.ClipList;
						LogRandomMap("New starting coord : "^StartingCoord^" | Macroblock : "^PrevMacroblockInstance.MacroblockModel.Id);
					
						SetCursorCoord(PrevMacroblockInstance.Coord, StartingCoord);
					}else{
						LogRandomMap("New starting coord : "^StartingCoord^" | Macroblock : Null");
						PrevDisconnectedClips.clear();
						PrevClipList = Null;
						SetCursorCoord(StartingCoord, StartingCoord);
					}
					
					
					if (PrevDisconnectedClips.count <= 0) break;
				}
				
				Count += 1;
			}
		} else {
			Sound::Play("EditorAutoFinish");
			AutoFinish_Start();
			Finished = AutoFinish_FindFinish(C_AutoFinish_MaxSteps);
			AutoFinish_End();
		}
		
		if (Finished) {
			G_MainMenu = False;
			LogRandomMap("Auto-finish succeed");
		} else {
			if (_Alert) Alert(_("The track could not be auto-finished. Remove a few blocks before retrying."));
			LogRandomMap("Auto-finish failed : The track could not be auto-finished.");
		}
	} 
	// We didn't find an open block, cancel autofinish
	else {
		if (_Alert) Alert(_("The track must have an open connector to be auto-finished."));
		LogRandomMap("Auto-finish failed : The track must have an open connector to be auto-finished.");
	}
	
	G_AutoFinishing = False;
	SelectMode(PrevCategory, PrevMode);
	SelectSequence();
	
	LogRandomMap("=================");
	LogRandomMap("Stop auto-finish");
	LogRandomMap("#################");
}

// Place a random start
Boolean RandomStart() {
	LogRandomMap("=================");
	LogRandomMap("Start random start");
	
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	SelectSequence();
	
	// Find random start with at least one clip
	declare TriesNb = 50;
	declare StartPlaced = False;
	declare CMacroblockModel[] StartBlocks;
	declare ClipsPriority = RandomStyles::GetClipsPriority();
	// Space to test around the start (3x2 blocks)
	declare Int3[] SpaceToTest;
	for (PosX, -1, 1) {
		for (PosY, 1, 2) {
			SpaceToTest.add(<PosX, 0, PosY>);
		}
	}
	
	List::Clear();
	declare PrimaryList = List::Push();
	declare SecondaryList = List::Push();
	
	for (I, 1, TriesNb) {
		Yield();
		
		// Find start blocks
		foreach (MacroblockModel in MacroblockModels) {
			if (!Macroblock::GetValidity(MacroblockModel)) continue;
			if (MacroblockModel.HasStart && Macroblock::GetClipCount(MacroblockModel) > 0) {
				if (!ThemePack::IsListed(MacroblockModel)) continue;
				if (ThemePack::IsRandomDisabled(MacroblockModel)) continue;
				
				StartBlocks.add(MacroblockModel);
				declare Probability = ML::NearestInteger(RandomStyles::GetMultiplier(MacroblockModel) * 100);
				if (Probability < 0) Probability = 1;
				
				// If the macroblock contained some prioritized clips, add it to the priority list ...
				if (ClipsPriority.count == 0 || Macroblock::GetClipNames(MacroblockModel).containsonly(ClipsPriority)) {
					List::Add(PrimaryList, MacroblockModel, Probability);
				} 
				// ... else add it to the secondary list
				else {
					List::Add(SecondaryList, MacroblockModel, Probability);
				}
			}
		}
		
		// Select random coord
		declare RandomCoord = <0, 0, 0>;
		// Start by searching near the center of the track
		declare Padding = ML::NearestInteger(Map.Size.X * 0.25);
		if (I <= TriesNb - 30) RandomCoord = <Random::Rand(Padding, Map.Size.X-1-Padding), 0, Random::Rand(Padding, Map.Size.Z-1-Padding)>;
		else RandomCoord = <Random::Rand(0, Map.Size.X-1), 0, Random::Rand(0, Map.Size.Z-1)>;
		
		// Try to place a start block
		while (List::Count(PrimaryList) > 0 || List::Count(SecondaryList) > 0) {
			// Get a random start
			declare CMacroblockModel Start;
			declare Boolean Removed;
			if (List::Count(PrimaryList) > 0) {
				declare Found = List::SelectRandom(PrimaryList);
				Start <=> List::GetMacroblockModelFromRandom();
				Removed = List::Remove(PrimaryList, Start);
			} else {
				declare Found = List::SelectRandom(SecondaryList);
				Start <=> List::GetMacroblockModelFromRandom();
				Removed = List::Remove(SecondaryList, Start);
			}
			
			// Try each direction
			declare StartJ = Random::Rand(0, 3);
			declare EndJ = StartJ + 3;
			for (J, StartJ, EndJ) {
				// Try to place the block
				declare Dir = Utils::IntToDir(J % 4);
				
				// Try to place the start on ground at first, then randomly
				// Note RVZ 2022/07/06: With our current deco macroblocks, we don't want to start on the ground
				/*if (I < TriesNb - 10) {
					RandomCoord.Y = GetBlockGroundHeight(Start.GeneratedBlockModel, RandomCoord.X, RandomCoord.Z, Dir);
				} else {*/
					RandomCoord.Y = Random::Rand(0, Map.Size.Y-1);
				//}
				
				LogRandomMap("Try to place start > Id : "^Start.Id^" | Coord : "^RandomCoord^" | Dir : "^Dir);
				
				if (CustomCanPlaceMacroblock(Start, RandomCoord, Dir, False)) {
					// Check if there's enough space in front of the start
					declare EnoughSpace = True;
					if (I < TriesNb - 20) {
						foreach (SpaceCoord in SpaceToTest) {
							declare RotatedSpaceCoord = RandomCoord + MU::GetRotatedOffset(SpaceCoord, Dir);
							if (!CustomCanPlaceMacroblock(Start, RotatedSpaceCoord, Dir, False)) {
								EnoughSpace = False;
								break;
							}
						}
					}
					
					if (EnoughSpace) {
						StartPlaced = AddMacroblock2(Start, RandomCoord, Dir, True, True);
						LogRandomMap("Start placed");
					}
				}
			}
			if (StartPlaced || !Removed) break;
		}
		if (StartPlaced) break;
	}
	
	List::Clear();
	
	LogRandomMap("Random start placed : "^StartPlaced);
	
	LogRandomMap("=================");
	LogRandomMap("Stop random start");
	LogRandomMap("#################");
	
	return StartPlaced;
}

// Create a random track
Void Private_RandomTrack(Real _Distance) {
	declare StepsNb = 0;
	declare Depth = 0;
	declare Distance = 0.;
	declare MinTurboDistance = 300.;
	declare LastTurboDistance = -MinTurboDistance;
	declare LastCheckpointDistance = 0.;
	declare CMacroblockModel PrevMacroblockModel;
	declare ClipsPriority = RandomStyles::GetClipsPriority();
	
	List::Clear();
	
	LogRandomMap("Start random track");
	LogRandomMap("==================");
	
	// Stop if we reached the maximum number of iterations
	while (StepsNb < C_RandomMap_MaxIterations) {
		tuningmark("Private_RandomTrack");
		LogRandomMap("------------------");
		LogRandomMap("Step : "^StepsNb^" | Depth : "^Depth^" | Distance : "^Distance);
		
		StepsNb += 1;
		
		// Stop if we reach the right distance
		if (Distance > _Distance) break;
		
		// Create or load list
		declare PrimaryListId = 2*Depth;
		declare SecondaryListId = (2*Depth)+1;
		declare CMacroblockModel[] FilteredMacroblocks;
		declare CMacroblockModel[] CheckpointMacroblocks;
		if (!List::Exists(PrimaryListId)) {
			PrimaryListId = List::Push();
			SecondaryListId = List::Push();
			
			declare Integer[Ident] PrimaryTransferts;
			declare Integer[Ident] SecondaryTransferts;
			declare MacroblockModelFollowUp = ThemePack::GetFollowUp(PrevMacroblockModel);
		
			// Find compatible macroblocks
			FilteredMacroblocks = FilterMacroblocks2(False);
			
			foreach (MacroblockModel in FilteredMacroblocks) {
				// Skip finish blocks
				if (MacroblockModel.HasFinish) continue;
				// Skip disabled blocks
				if (ThemePack::IsRandomDisabled(MacroblockModel)) continue;
				// Skip blocks that have less than 2 clips
				if (Macroblock::GetClipCount(MacroblockModel) < 2) continue;
				// Save and skip checkpoint blocks
				if (MacroblockModel.HasCheckpoint) {
					CheckpointMacroblocks.add(MacroblockModel);
					continue;
				}
				
				declare Ratio = 1000. * RandomStyles::GetMultiplier(MacroblockModel);
				
				// After a turbo reduce probability of selecting a turn or another turbo
				if (Distance - LastTurboDistance < MinTurboDistance) {
					if (Macroblock::GetType(MacroblockModel) == "Turbos") Ratio *= 0.05;
					else if (Macroblock::IsTurning(MacroblockModel)) Ratio *= 0.1;
					else if (Macroblock::IsShifting(MacroblockModel)) Ratio *= 0.5;
				} else {
					if (Map.CollectionName == "Lagoon") {
						// Increase the probability to select a turbo every 300 meters on lagoon rollercoaster
						if (Macroblock::GetFamily(PrevMacroblockModel) == "RoadThemePark" && Macroblock::GetType(MacroblockModel) == "Turbos") {
							Ratio *= 10.; 
						}
					}
				}
				
				declare Probability = ML::NearestInteger(Ratio);
				if (Probability < 0) Probability = 0; //< Allow the possibility to completely disable a block at your own risk
				
				declare SelectedListId = -1;
				
				// No clips priority, custom constraints
				if (ClipsPriority.count <= 0) {
					// Check follow up
					if (MacroblockModelFollowUp != "" && Macroblock::GetFullName(MacroblockModel) == MacroblockModelFollowUp) {
						SelectedListId = PrimaryListId;
					}
					// Prefer ground blocks
					else if (Macroblock::GetVariant(MacroblockModel) == Macroblock::VariantGround()) {
						if (Map.CollectionName == "Lagoon") {
							// Prefer freeway on ground
							if (Macroblock::GetFamily(MacroblockModel) == "Freeway") {
								SelectedListId = PrimaryListId;
							} 
							// Try to leave tunnel
							else if (Macroblock::GetFamily(PrevMacroblockModel) == "Tunnel") {
								SelectedListId = PrimaryListId;
							} else {
								SelectedListId = SecondaryListId;
							}
						} else {
							SelectedListId = PrimaryListId;
						}
					} else {
						SelectedListId = SecondaryListId;
					}
				} 
				// Follow clips priority
				else {
					declare ClipNames = Macroblock::GetClipNames(MacroblockModel);
					declare ClipsExists = ClipNames.containsonly(ClipsPriority);
					if (ClipsExists) {
						SelectedListId = PrimaryListId;
					} 
					// ... else add it to the secondary list
					else {
						SelectedListId = SecondaryListId;
					}
					
					// Save transfert macroblocks leading to the prioritized clips
					if (ClipsPriority.count > 0 && Macroblock::IsTransfert(MacroblockModel)) {
						if (ClipNames.containsoneof(ClipsPriority)) {
							PrimaryTransferts[MacroblockModel.Id] = Probability;
						} else {
							SecondaryTransferts[MacroblockModel.Id] = Probability;
						}
					}
				}
				
				declare PlacementCoords = Placement::GetCoords(MacroblockModel);
				declare PlacementDirs = Placement::GetDirs(MacroblockModel);
				for (PlacementKey, 0, PlacementCoords.count-1) {
					List::Add(
						SelectedListId, 
						MacroblockModel, 
						PlacementKey, 
						PlacementCoords[PlacementKey], 
						Utils::DirToInt(PlacementDirs[PlacementKey]), 
						Probability
					);
				}
			}
			
			// If there's no primary macroblocks, then it's probably because the last available clip isn't a prioritized one
			// We'll add the right transfert block to the primary list to fix that
			if (List::Count(PrimaryListId) <= 0) {
				if (PrimaryTransferts.count > 0) {
					foreach (MacroblockModelId => Probability in PrimaryTransferts) {
						declare MacroblockModel = MacroblockModels[MacroblockModelId];
						declare PlacementCoords = Placement::GetCoords(MacroblockModel);
						declare PlacementDirs = Placement::GetDirs(MacroblockModel);
						for (PlacementKey, 0, PlacementCoords.count-1) {
							List::Add(
								PrimaryListId, 
								MacroblockModel, 
								PlacementKey, 
								PlacementCoords[PlacementKey], 
								Utils::DirToInt(PlacementDirs[PlacementKey]), 
								Probability
							);
						}
					}	
				} else {
					foreach (MacroblockModelId => Probability in SecondaryTransferts) {
						declare MacroblockModel = MacroblockModels[MacroblockModelId];
						declare PlacementCoords = Placement::GetCoords(MacroblockModel);
						declare PlacementDirs = Placement::GetDirs(MacroblockModel);
						for (PlacementKey, 0, PlacementCoords.count-1) {
							List::Add(
								PrimaryListId, 
								MacroblockModel, 
								PlacementKey, 
								PlacementCoords[PlacementKey], 
								Utils::DirToInt(PlacementDirs[PlacementKey]), 
								Probability
							);
						}
					}
				}
			}
		}
		
		LogRandomMap("__________________");
		if (C_LogRandom) {
			declare DebugPrimaryList = List::GetAllWithWeight(PrimaryListId);
			declare DebugSecondaryList = List::GetAllWithWeight(SecondaryListId);
			LogRandomMap("Primary list : "^DebugPrimaryList);
			LogRandomMap("Secondary list : "^DebugSecondaryList);
		}
		
		declare MacroblockConnected = False;
		
		// If there's no compatible macroblock, decrease depth
		declare FoundMacroblocks = List::Count(PrimaryListId) <= 0 && List::Count(SecondaryListId) <= 0;
		if (FoundMacroblocks) {
			List::Pop();
			List::Pop();
			
			LogRandomMap("******************");
			LogRandomMap("No compatible macroblock");
		} 
		// If there are some compatible macroblocks
		else {
			LogRandomMap("******************");
			LogRandomMap("Some compatible macroblocks");
			
			// Select the macroblock to connect
			declare Ident MacroblockId;
			declare Int3 RandomCoord;
			declare CMapEditorPlugin::CardinalDirections RandomDir;
			// Try to find a checkpoint
			// if the last checkpoint is at more than MaxCheckpointDistance meters
			// if the finish is at more than 350 meters
			if (CheckpointMacroblocks.count > 0 && Distance - LastCheckpointDistance > RandomStyles::GetCheckpointsSpacing()) {
				declare Checkpoint <=> CheckpointMacroblocks[Random::Rand(0, CheckpointMacroblocks.count-1)];
				MacroblockId = Checkpoint.Id;
				Placement::Select(Checkpoint, 0);
				RandomCoord = Placement::GetCoord(Checkpoint);
				RandomDir = Placement::GetDir(Checkpoint);
				declare Removed = CheckpointMacroblocks.remove(Checkpoint);
				
				LogRandomMap("Select a checkpoint");
				LogRandomMap("Selected : "^Checkpoint);
				
				if (!Removed) break;
			}
			// Try to find a simple block
			if (MacroblockId == NullId) {
				declare CMacroblockModel Macroblock;
				declare Integer Placement;
				declare Int3 Coord;
				declare CMapEditorPlugin::CardinalDirections Dir;
				
				if (List::Count(PrimaryListId) > 0) {
					declare Found = List::SelectRandom(PrimaryListId);
					Macroblock <=> List::GetMacroblockModelFromRandom();
					Placement = List::GetPlacementFromRandom();
					Coord = List::GetCoordFromRandom();
					Dir = List::GetDirFromRandom();
					declare Removed = List::Remove(PrimaryListId, Macroblock, Placement);
					
					LogRandomMap("Select a macroblock in primary list");
					LogRandomMap("Selected : "^Macroblock);
				} else {
					declare Found = List::SelectRandom(SecondaryListId);
					Macroblock <=> List::GetMacroblockModelFromRandom();
					Placement = List::GetPlacementFromRandom();
					Coord = List::GetCoordFromRandom();
					Dir = List::GetDirFromRandom();
					declare Removed = List::Remove(SecondaryListId, Macroblock, Placement);
					
					LogRandomMap("Select a macroblock in secondary list");
					LogRandomMap("Selected : "^Macroblock);
				}
				if (Macroblock != Null) {
					MacroblockId = Macroblock.Id;
					RandomCoord = Coord;
					RandomDir = Dir;
				}
			}
			
			// Try to connect the macroblock
			if (MacroblockId != NullId) {
				// Check if the macroblock is a checkpoint or a turbo
				declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(MacroblockId);
				if (MacroblockModel.HasCheckpoint || Macroblock::GetType(MacroblockModel) == "Checkpoints") {
					LastCheckpointDistance = Distance;
					LogRandomMap("It's a checkpoint");
				}
				if (Macroblock::GetType(MacroblockModel) == "Turbos") {
					LastTurboDistance = Distance;
					LogRandomMap("It's a turbo");
				}
				
				// Connect macroblock
				declare MacroblockPlaced = AddMacroblock2(MacroblockModel, RandomCoord, RandomDir, False, True);
				LogRandomMap("Placed : "^MacroblockPlaced^" | Coord : "^RandomCoord^" | Dir : "^RandomDir^" | MacroblockModel : "^MacroblockModel);
				
				// Slow mode
				if (ManiaPlanet != Null && ManiaPlanet.HMD_IsActive) Sleep(100);
				
				PrevMacroblockModel = MacroblockModel;
				MacroblockConnected = True;
				SetUndergroundMode(MacroblockModel);
				
				// Add the length of the macroblock to the 
				declare Length = Macroblock::GetLength(MacroblockModel);
				if (Length <= 0.) Length = 64.;
				Distance += Length;
			}
		}
		
		// Macroblock connected, increase depth
		if (MacroblockConnected) {
			Camera.FollowCursor(True); // au cas où on l'aurait désactivé dans une suppresion
			Depth += 1;
			
			LogRandomMap("++++++++++++++++++");
			LogRandomMap("Macroblock connected with success > Depth : "^Depth);
		} 
		// Couldn't connect a macroblock, disconnect the last one and decrease depth
		else {
			Depth -= 1;
			
			LogRandomMap("++++++++++++++++++");
			LogRandomMap("Can't connect macroblock > Depth : "^Depth);
			
			// Get the macroblock models that we will disconnect
			declare CMacroblockModel[] DisconnectedMacroblockModels;
			declare MacroblockModelsIds = History2::GetMacroblockModelsIds();
			foreach (MacroblockModelId in MacroblockModelsIds) {
				declare MacroblockModel <=> Macroblock::GetMacroblockModelFromId(MacroblockModelId);
				if (MacroblockModel != Null) DisconnectedMacroblockModels.add(MacroblockModel);
			}
			
			if (Depth >= 0) {
				Camera.FollowCursor(False); // C'est moche de suivre le curseur qui revient sur un bloc qu'on supprime... et mange des ressources pour rien
				UndoHistory2();
				
				foreach (MacroblockModel in DisconnectedMacroblockModels) {
					LogRandomMap("Disconnect previous macroblock : "^MacroblockModel.Id);
					
					if (MacroblockModel.HasCheckpoint || Macroblock::GetType(MacroblockModel) == "Checkpoints") {
						LastCheckpointDistance = 0.;
						LogRandomMap("It was a checkpoint");
					}
					if (Macroblock::GetType(MacroblockModel) == "Turbos") {
						LastTurboDistance = 0.;
						LogRandomMap("It was a turbo");
					}
				
					declare Length = Macroblock::GetLength(MacroblockModel);
					if (Length <= 0.) Length = 64.;
					Distance -= Length;
				}
				
				// Remove all macroblocks with the same signature from the list
				declare Integer[] SignaturesKeys;
				foreach (MacroblockModel in DisconnectedMacroblockModels) {
					SignaturesKeys.add(Macroblock::GetSignatureKey(MacroblockModel));
				}
				
				LogRandomMap("Search and remove macroblocks with signature key : "^SignaturesKeys);
				
				for (I, 1, 2) {
					declare PrevListId = 0;
					if (I == 1) PrevListId = 2*Depth; ///< Primary list
					else PrevListId = (2*Depth)+1; ///< Secondary list
				
					declare CompatibleMacroblocks = List::GetAll(PrevListId);
					foreach (Macroblock in CompatibleMacroblocks) {
						if (SignaturesKeys.exists(Macroblock::GetSignatureKey(Macroblock))) {
							declare Removed = List::Remove(PrevListId, Macroblock);
							LogRandomMap("Removed block with same signature from list "^I^" > "^Macroblock.Id);
						}
					}
					
					if (C_LogRandom) {
						declare DebugList = List::GetAll(PrevListId);
						declare Text[] DebugNames;
						foreach (DebugMacroblockModel in DebugList) {
							DebugNames.add(""^DebugMacroblockModel.Id);
						}
						LogRandomMap(""^I^" list : "^DebugNames);
					}
				}
			}
		}
		
		if (!MacroblockConnected) Yield();
		
		// If the user want to stop
		if (G_CancelGeneration) break;
		
		// If there's no compatible block at all, stop
		if (Depth < 0) break;
		
		LogRandomMap("");
		LogRandomMap("");
	}
	
	// Clean history and weighted lists
	List::Clear();
	
	LogRandomMap("=================");
	LogRandomMap("Stop random track");
	LogRandomMap("#################");
}

// Generate a random track
Void RandomTrack(Real _Length) {
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	SelectSequence();
	
	declare RandomMap_MaxIterations for This = 0;
	RandomMap_MaxIterations = C_RandomMap_MaxIterations;
	
	Private_RandomTrack(_Length);
}

// Get the probability of use for each decoration category
Real[Text] GetDecoProbabilities(Real[Text] _DecoRatios) {
	declare Max = 0.;
	declare Total = 0.;
	declare EmptyRatio = 1.;
	foreach (Family => Ratio in _DecoRatios) {
		if (Ratio <= 0.) continue;
		if (Ratio > Max) Max = Ratio;
		Total += Ratio;
	}
	if (Total > 1.) EmptyRatio = 1. / Total;
	
	declare Real[Text] NormalizedRatios;
	foreach (Family => Ratio in _DecoRatios) {
		NormalizedRatios[Family] = Ratio * Max * EmptyRatio;
	}
	
	declare Real[Text] Probabilities;
	declare ProbabilitiesTotal = 0.;
	foreach (Family => Ratio in NormalizedRatios) {
		ProbabilitiesTotal += Ratio;
		Probabilities[Family] = ProbabilitiesTotal;
	}
	
	return Probabilities;
}

// Add decoration to the track
Void RandomDecorate2(Boolean _RandomMap) {
	if(S_NoDecoration) return;
	if(IsDecorated() && IsEditor(C_Editor_Beginner)) return;
	LogRandomMap("Start random decorate");
	LogRandomMap("=================");
	
	// Update sequence
	G_GeneratingDecoration = True;
	SelectMode(C_Categories_Construct, C_Modes_ConstructDeco);
	SelectSequence();
	
	// Move camera
	if (_RandomMap) {
		if (ManiaPlanet == Null || !ManiaPlanet.HMD_IsActive){
			Camera.FollowCursor(False);
			Camera.WatchMacroblocks(C_Modes_ConstructTrack);
		}
	} else {
		RemoveDecoration();
		Camera.FollowCursor(False);
		Camera.WatchMacroblocks(C_Modes_ConstructTrack);
	}
	
	Sleep(250);
	
	// Get list of available deco macroblocks
	declare DecorationTypeAndModels = GetDecorationMacroblocks(True);
	declare Integer[Ident] DecorationMaxCount;
	
	// Create deco type source
	declare Real[Text] DecoRatios;
	declare Real[Text] AdvancedRatios = UI_DecoSelection::GetRatios();
	declare UsePodium = False;
	
	foreach (DecorationType => DecorationMacroblockModels in DecorationTypeAndModels) {
		if (DecorationType == "|Decoration|Podium") { // TODO random generator: this is no longer how to check for podiums
			declare Amount = C_DefaultPodiumAmount;
				if (MapContent::GetPodiumCount() <= 0) {
					Amount = 1.;
				}
			if (Amount > 0.) UsePodium = True;
			continue;
		}
		
		declare Amount = C_DefaultDecoAmount;
		if (IsEditor(C_Editor_Advanced) || IsEditor(C_Editor_Beginner)) {
			if (AdvancedRatios.existskey(DecorationType)) Amount = AdvancedRatios[DecorationType];
		} else {
			if (RandomStyles::ExistsMultiplier(DecorationType)) Amount = RandomStyles::GetMultiplier(DecorationType);
		}
		
		DecoRatios[DecorationType] = Amount;
		
		LogRandomMap(DecorationType^" > Exists : "^RandomStyles::ExistsMultiplier(DecorationType)^" | Amount : "^RandomStyles::GetMultiplier(DecorationType));
	}
	
	// Save deco ratios
	declare metadata Real[Text] GamepadEditor_DecoRatios for Map;
	GamepadEditor_DecoRatios = DecoRatios;
	
	declare DecoProbabilities = GetDecoProbabilities(DecoRatios);
	LogRandomMap("DecoProbabilities : "^DecoProbabilities);
	
	// Place podium
	if (UsePodium) {
		// Select a random podium macroblock
		declare PodiumMacroblockModel <=> DecorationTypeAndModels["|Decoration|Podium"][Random::Rand(0, DecorationTypeAndModels["|Decoration|Podium"].count-1)];
		declare IsAir = False;
		declare IsUnderground = False;
		declare IsGround = False;
		if (PodiumMacroblockModel.GeneratedBlockModel.VariantGround != Null) {
			IsGround = True;
		} else if (PodiumMacroblockModel.GeneratedBlockModel.VariantAir != Null) {
			if (
				PodiumMacroblockModel.GeneratedBlockModel.VariantAir.IsAllUnderground
				|| PodiumMacroblockModel.GeneratedBlockModel.VariantAir.IsPartUnderground
			) {
				IsUnderground = True;
			} else {
				IsAir = True;
				
				// Try to select a ground variant when possible
				declare MacroblockVariants = Macroblock::GetVariants(PodiumMacroblockModel);
				foreach (VariantId => VariantModelId in MacroblockVariants) {
					if (VariantId != Macroblock::VariantGround()) continue;
					PodiumMacroblockModel <=> Macroblock::GetMacroblockModelFromId(VariantModelId);
					IsGround = True;
					IsAir = False;
					break;
				}
			}
		}
		
		// Select a random points around the finish and spiral around it
		declare Int3 Coord;
		if (MapContent::HasFinish()) Coord = MapContent::GetFinishUnitCoord();
		Coord = <Random::Rand(Coord.X-2, Coord.X+2), Coord.Y, Random::Rand(Coord.Z-2, Coord.Z+2)>;
		if (Coord.X < 0) Coord.X = 0;
		if (Coord.X > Map.Size.X - 1) Coord.X = Map.Size.X - 1;
		if (Coord.Z < 0) Coord.Z = 0;
		if (Coord.Z > Map.Size.Z - 1) Coord.Z = Map.Size.Z - 1;
		declare Vecs = [
			<0, 0, 1>, 
			<-1, 0, 0>, 
			<0, 0, -1>, 
			<1, 0, 0>
		];
		declare I = 0;
		declare J = 0;
		declare N = 0;
		declare Vec = <0, 0, 0>;
		declare Max = Map.Size.X * Map.Size.Z;
		declare Stop = False;
		while (I <= Max) {
			J = (N / 2) + 1;
			Vec = Vecs[N%4];
			N += 1;
			for (K, 1, J) {
				Coord += Vec;
				I += 1;
				
				// Try to place in all direction
				declare StartDir = Random::Rand(0, 3);
				for (L, StartDir, StartDir+3) {
					declare IntDir = L % 4;
					declare Dir = Utils::IntToDir(IntDir);
					declare GroundHeight = GetBlockGroundHeight(PodiumMacroblockModel.GeneratedBlockModel, Coord.X, Coord.Z, Dir);
					declare Coord = <Coord.X % Map.Size.X, GroundHeight, Coord.Z % Map.Size.Z>;
					
					if (IsAir) {
						for (Y, GroundHeight + 1, Map.Size.Y - 1) {
							Coord.Y = Y;
							if (CustomCanPlaceMacroblock(PodiumMacroblockModel, Coord, Dir, False)) {
								declare Placed = AddMacroblock2(PodiumMacroblockModel, Coord, Dir, False, True);
								Stop = True;
								break;
							}
						}
					} else if (IsUnderground) {
						for (RevY, 1, GroundHeight) {
							Coord.Y = GroundHeight - RevY;
								for (Y, GroundHeight + 1, Map.Size.Y - 1) {
								Coord.Y = Y;
								if (CustomCanPlaceMacroblock(PodiumMacroblockModel, Coord, Dir, False)) {
									declare Placed = AddMacroblock2(PodiumMacroblockModel, Coord, Dir, False, True);
									Stop = True;
									break;
								}
							}
						}
					} else if (IsGround) {
						if (CustomCanPlaceMacroblock(PodiumMacroblockModel, Coord, Dir, False)) {
							Coord.Y = GroundHeight;
							declare Placed = AddMacroblock2(PodiumMacroblockModel, Coord, Dir, False, True);
							Stop = True;
						}
					}
					
					if (Max != 0 && I % C_Tick_RandomDecorate == 0) {
						Yield();
					}
					if (Stop) break;
				}
				if (Stop) break;
			}
			if (Stop) break;
		}
	}
	
	// Run the track and try to add deco around it
	declare TrackCoords = MapContent::GetMacroblocksUnitCoords(C_Modes_ConstructTrack);
	LogRandomMap("DecorationTypeAndModels : "^DecorationTypeAndModels);
	LogRandomMap("TrackCoords : "^TrackCoords.count);
	
	declare ProgressMessage = _("|Gamepad progress step|Decoration");
	declare MinBlocksCount = 10;
	if (!G_RandomMapGeneration && TrackCoords.count > MinBlocksCount) UI_PopUp::SetProgress(ProgressMessage, 0);
	
	foreach (Key => TrackCoord in TrackCoords) {
		if (!G_RandomMapGeneration && TrackCoords.count > MinBlocksCount) UI_PopUp::SetProgress(ProgressMessage, ML::FloorInteger((Key / (TrackCoords.count*1.)) * 100));
		
		declare CubeStart = <TrackCoord.X-2, CollectionGroundY, TrackCoord.Z-2>;
		declare CubeEnd = <TrackCoord.X+2, CollectionGroundY, TrackCoord.Z+2>;
		declare Placed = False;
		
		// Check each block around the track
		for (X, CubeStart.X, CubeEnd.X) {
			if (X < 0 || X > Map.Size.X - 1) continue;
			for (Z, CubeStart.Z, CubeEnd.Z) {
				if (Z < 0 || Z > Map.Size.Z - 1) continue;
				
				// Dynamically adjust decoration amount
				declare CopperLimitRatio = 1.;
				if (Map.CopperPrice > C_CopperLimit_Deco) {
					CopperLimitRatio = 1. - ((Map.CopperPrice - C_CopperLimit_Deco) / ((C_CopperLimit_Hard - C_CopperLimit_Deco) * 1.));
					if (CopperLimitRatio < 0.01) CopperLimitRatio = 0.01;
				}
				declare CanPlaceMax = C_DecoLimiter * CopperLimitRatio;
				if (Random::Rand(0., 1., X*Z*1.) > CanPlaceMax) continue;
				
				// Select a random deco macroblock
				declare DecoType = "";
				declare DecoTypeRand = Random::Rand(0., 1., X*Z*1.);
				foreach (Family => Probability in DecoProbabilities) {
					if (DecoTypeRand <= Probability) {
						DecoType = Family;
						break;
					}
				}
				if (DecoType == "") continue;
				declare DecoMacroblockModel <=> DecorationTypeAndModels[DecoType][Random::Rand(0, DecorationTypeAndModels[DecoType].count-1)];
				
				// Try to spread limited blocks on all the track
				declare DecoMacroblockModelLimit = RandomStyles::GetDecoMaxCount(DecoMacroblockModel);
				if (DecoMacroblockModelLimit >= 0) {
					declare SkipLimited = DecoMacroblockModelLimit * (1. / DecorationTypeAndModels[DecoType].count);
					if (Random::Rand(0., 1., X*Z*1.) > SkipLimited) {
						continue;
					}
				}
				
				// Some block have a limited rate
				declare DecoRate = RandomStyles::GetDecoRate(DecoMacroblockModel);
				if (DecoRate < 1.) {
					if (Random::Rand(0., 1., X*Z*1.) > DecoRate) {
						continue;
					}
				}
				
				declare DecoCountUpdate = False;
				declare IsAir = Macroblock::GetVariant(DecoMacroblockModel) == Macroblock::VariantAir();
				
				// Try to place it in all direction
				declare StartDir = Random::Rand(0, 3);
				for (I, StartDir, StartDir+3) {
					declare IntDir = I % 4;
					declare Dir = Utils::IntToDir(IntDir);
					declare Int3 Coord;
					if (IsAir) {
						Coord = <X, TrackCoord.Y+1, Z>;
					} else {
						declare GroundHeight = GetBlockGroundHeight(DecoMacroblockModel.GeneratedBlockModel, X, Z, Dir);
						Coord = <X, GroundHeight, Z>;
					}
					
					if (CustomCanPlaceMacroblock(DecoMacroblockModel, Coord, Dir, False)) {
						// Check that the deco macroblock doesn't obstruct the track
						// It's especially true for arena blocks
						declare MacroblockCoords = Macroblock::GetCoords(DecoMacroblockModel, Coord, Dir);
						declare Int3[] ShiftedMacroblockCoords;
						foreach (MacroblockCoord in MacroblockCoords) ShiftedMacroblockCoords.add(MacroblockCoord - <0, 1, 0>);
						if (!TrackCoords.containsoneof(ShiftedMacroblockCoords)) {
							SetCursorMacroblockModel(DecoMacroblockModel);
							Placed = AddMacroblock2(DecoMacroblockModel, Coord, Dir, False, True);
							if (Placed) DecoCountUpdate = True;
							
							// Slow mode
							if (ManiaPlanet != Null && ManiaPlanet.HMD_IsActive) Sleep(100);
							
							break;
						}
					}
					if (G_CancelGeneration) break;
				}
				
				// Check decoration count limitation
				if (DecoMacroblockModel != Null && DecoCountUpdate) {
					if (!DecorationMaxCount.existskey(DecoMacroblockModel.Id)) {
						DecorationMaxCount[DecoMacroblockModel.Id] = RandomStyles::GetDecoMaxCount(DecoMacroblockModel);
					}
					declare Count = DecorationMaxCount[DecoMacroblockModel.Id];
					if (Count > 0) {
						Count -= 1;
						DecorationMaxCount[DecoMacroblockModel.Id] = Count;
					}
					if (Count == 0) {
						declare Removed = DecorationTypeAndModels[DecoType].remove(DecoMacroblockModel);
					}
				}
				
				if (G_CancelGeneration) break;
			}
			if (G_CancelGeneration) break;
		}
		if (!Placed) Yield();
	}
	
	if (!G_RandomMapGeneration && TrackCoords.count > MinBlocksCount) UI_PopUp::SetProgress(ProgressMessage, 100);
	
	// Clear input buffer
	ClearInputBuffer();
	G_TerrainCanPress = False;
	
	declare metadata Boolean GamepadEditor_IsDecorated for Map;
	GamepadEditor_IsDecorated = True;
	G_GeneratingDecoration = False;
	
	if (IsEditor(C_Editor_Advanced)) {
		if (!UI_Tuto::IsValidated(UI_Tuto::Tuto_Decoration())) {
			UI_Tuto::ValidateTuto(UI_Tuto::Tuto_Decoration());
			CheckTuto();
		}
	}
	
	UI_PopUp::SetProgress("", -1);
	
	SelectSequence();
	
	LogRandomMap("=================");
	LogRandomMap("Stop random decorate");
	LogRandomMap("#################");
}

//	Generate a full random track
Boolean Private_RandomMap(Boolean _Full) {
	Camera.Zoom(CMapEditorCamera::EZoomLevel::Medium);
	Camera.Look(C_SouthWest);
	Camera.SetVStep(CMapEditorCamera::ECameraVStep::Medium);
	// Initialization
	G_CancelGeneration = False;
	UndergroundMode = False;
	
	// Reset track
	Reset(C_DemoSony);
	
	// Generate a random terrain
	if (_Full) {
		RandomLandscape(False, True);
	}
	
	// Save terrain
	declare metadata Boolean GamepadEditor_IsTerraformed for Map;
	declare metadata Text GamepadEditor_TerrainId for Map;
	declare metadata Integer GamepadEditor_TerrainDir for Map;
	GamepadEditor_IsTerraformed = True;
	GamepadEditor_TerrainId = "FullRandom";
	GamepadEditor_TerrainDir = 0;
	G_PreviewTerrainTime = -1;
	G_PreviewTerrainId = "FullRandom";
	
	// Try to place a start
	declare StartPlaced = RandomStart();
	if (!StartPlaced || G_CancelGeneration) return False;
	
	// Slow mode
	if (ManiaPlanet != Null && ManiaPlanet.HMD_IsActive) Sleep(1000);
	
	// Randomly place blocks
	if (_Full) RandomTrack(RandomStyles::GetLength());
	if (G_CancelGeneration) return False;
	
	// Autofinish track
	AutoFinish(False);
	if (G_CancelGeneration) return False;
	
	// Failed to place a finish
	if (!MapContent::HasFinish()) return False;
	
	// Decorate track
	UndergroundMode = False;
	RandomDecorate2(True);
	if (G_CancelGeneration) return False;
	
	// We completed the track for sure
	Sound::Play("EditorRandomGenerationFinished");
	
	if (ManiaPlanet == Null || !ManiaPlanet.HMD_IsActive) {
		Yield(); //< Wait for the block to be placed before computing shadows
		//CustomComputeShadows(CMapEditorPlugin::ShadowsQuality::Default);
		Yield();
	}
	
	return True;
}

/// Choose to reroll the track or not
Void RerollRandomMap() {
	if (!G_CancelGeneration && Utils::GetSaveStatus() != Utils::SaveStatus_Saved() || (S_RandomMap_Validate && !G_TestedRandomMap)) {
		declare ConfirmReroll = Confirm(_("Are you sure you want to generate another track?"));
		if (!ConfirmReroll) {
			// If no, go back to menu
			G_WaitingRerollAnswer = True;
			G_RerollRandomMap = False;
			return;
		}
	}
	
	// If we need to reroll (user said yes or we have the track saved (and tested if needs validation))
	G_WaitingRerollAnswer = False;
	G_RerollRandomMap = True;
}

/// Rebuild track from metadata
Void RebuildMap() {
	G_RebuildMap = True;
	Loading(True, GetLoadingText(), False);
		
	// Save
	declare metadata Text GamepadEditor_TerrainId for Map;
	declare metadata Integer GamepadEditor_TerrainDir for Map;
	declare metadata Boolean GamepadEditor_IsDecorated for Map;
	declare metadata Boolean GamepadEditor_DecoConfirmed for Map;
	
	declare metadata MapContent::K_MacroblockInstanceSave[Integer] KMBInstances for Map;
	declare metadata Text[] MacroblockModelNumIds for Map;
	declare Boolean MapContentExists = False;
	if(KMBInstances.count > 0)
		MapContentExists = True;
	declare BackUp_TerrainId = GamepadEditor_TerrainId;
	declare BackUp_TerrainDir = GamepadEditor_TerrainDir;
	declare BackUp_IsCustomTerrain = IsCustomTerrain();
	declare BackUp_IsDecorated = GamepadEditor_IsDecorated;
	declare BackUp_DecoConfirmed = GamepadEditor_DecoConfirmed;
	// Init loading progress
	declare BasePercentage = 30;
	declare TrackPercentage = (100 - BasePercentage) / 2;
	declare DecoPercentage = (100 - BasePercentage) / 2;
	if (MapContentExists && !BackUp_IsDecorated) {
		TrackPercentage = 100 - BasePercentage;
		DecoPercentage = 0;
	} else if (!MapContentExists && BackUp_IsDecorated) {
		TrackPercentage = 0;
		DecoPercentage = 100 - BasePercentage;
	} else if (!MapContentExists && !BackUp_IsDecorated) {
		BasePercentage = 100;
		TrackPercentage = 0;
		DecoPercentage = 0;
	}
	declare TrackCount = 0;
	declare DecoCount = 0;
	foreach (MBInstance in KMBInstances) {
		if (MBInstance.Type == C_Modes_ConstructTrack) TrackCount += 1;
		else if (MBInstance.Type == C_Modes_ConstructDeco) DecoCount += 1;
	}
	UI_PopUp::SetLoadingProgress(0);
	
	// Reset
	MapContent::RemoveAllContent();
	RemoveDecoration();
	RemoveAll();
	WaitReady();
	RemoveTerrain();
	WaitReady();
	SetCustomTerrain(False);
	History2::Clear();
	
	AutoSave();
	Yield();
	
	UI_PopUp::SetLoadingProgress(BasePercentage/2);
	
	Utils::SetSaveStatus(Utils::SaveStatus_NotSaved());
	if (IsSimpleEditor()) SelectMode(C_Categories_Landscape, C_Modes_LandscapePostcards);
	else SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	UI_Tuto::DisableAll();
	ThemePack::Select(0, 0, 0);
	UI_MacroblockSelection::SetStyle(ThemePack::GetTrackStyleName(), ThemePack::GetTrackStylePage(), ThemePack::GetTrackStylesCount());
	
	// Restore
	// Terrain
	Yield();
	PreviewTerrain2(Macroblock::GetMacroblockModelFromId(BackUp_TerrainId), Utils::IntToDir(BackUp_TerrainDir));
	Yield();
	PlaceTerrain();
	Yield();
	SetCustomTerrain(BackUp_IsCustomTerrain);
	
	UI_PopUp::SetLoadingProgress(BasePercentage);
	
	Yield();
	SelectSequence();
	Yield();
	
	// Track
	if (MapContentExists) {
		SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
		declare StartPlaced = False;
		declare Count = 0;
		foreach (MBInstance in KMBInstances) {
			declare Type = MBInstance.Type;
			if (Type != C_Modes_ConstructTrack) continue;
			
			declare MacroblockModel = GetMacroblockModelFromFilePath(MacroblockModelNumIds[MBInstance.MacroblockModelNumId]);
			declare Coord = MBInstance.Coord;
			declare Dir = Utils::IntToDir(MBInstance.Dir);
			
			if (TrackCount > 0) {
				UI_PopUp::SetLoadingProgress(
					BasePercentage + ML::FloorInteger(TrackPercentage * (Count / (TrackCount*1.)))
				);
				Count += 1;
			}
			
			declare Placed = AddMacroblock2(MacroblockModel, Coord, Dir, False, False);
			
			if (!StartPlaced && (MacroblockModel.HasStart || MacroblockModel.HasMultilap)) {
				StartPlaced = True;
				
				Yield();
				SelectSequence();
				Yield();
			}
		}
	}
	
	Yield();
	SelectSequence();
	Yield();
	
	// Decoration
	if (BackUp_IsDecorated) {
		declare Count = 0;
		SelectMode(C_Categories_Construct, C_Modes_ConstructDeco);
		foreach (MBInstance in KMBInstances) {
			declare Type = MBInstance.Type;
			if (Type != C_Modes_ConstructDeco) continue;
			
			declare MacroblockModel = GetMacroblockModelFromFilePath(MacroblockModelNumIds[MBInstance.MacroblockModelNumId]);
			declare Coord = MBInstance.Coord;
			declare Dir = Utils::IntToDir(MBInstance.Dir);
			
			if (DecoCount > 0) {
				UI_PopUp::SetLoadingProgress(
					BasePercentage + TrackPercentage + ML::FloorInteger(DecoPercentage * (Count / (DecoCount*1.)))
				);
				Count += 1;
			}
				
			declare Placed = AddMacroblock2(MacroblockModel, Coord, Dir, False, False);
		}
		GamepadEditor_IsDecorated = BackUp_IsDecorated;
		GamepadEditor_DecoConfirmed = BackUp_DecoConfirmed;
	}
	
	G_AskForValidation = !BackUp_DecoConfirmed;
	
	G_NeedRebuild = False;
	
	// Force sequence refresh
	G_CurrentSequence = C_Sequence_None;
	G_PrevSequence = C_Sequence_None;
	Yield();
	SelectSequence();
	Yield();
	
	Loading(False, "", False);
	G_RebuildMap = False;
	CheckAdvices();
}

/// Validate a selection in the main menu
Void MainMenuValid() {
	if (IsSimpleEditor()) {
		declare Selection = UI_SimpleMenu::Valid();
		
		switch (Selection) {
			case UI_SimpleMenu::Selection_AutoFinish()	: {
				G_MainMenu = False;
				AutoFinish(True);
			}
			case UI_Menu::Selection_Test()			: {
				G_MainMenu = False;
				SetTestMode(True);
			}
			case UI_SimpleMenu::Selection_Save()		: CustomSaveMap(False);
			case UI_SimpleMenu::Selection_SaveAs()		: CustomSaveMap(True);
			case UI_SimpleMenu::Selection_Shadows()		: CustomComputeShadows();
			case UI_SimpleMenu::Selection_New() 		: {
				declare ResetMap = Confirm(
					_("|Window title - creating a new track|New track"),
					ComposeMultilines([
						_("Any unsaved modification done on this track will be lost."),
						_("Are you sure you want to create a new track?")
					]),
					_("|Infinitive|Confirm"),
					_("|Infinitive|Cancel")
				);
				if (ResetMap) {
					G_MainMenu = False;
					Reset();
				}
			}
			case UI_SimpleMenu::Selection_Tuto()		: {
				UI_Tuto::Reset();
				G_MainMenu = False;
			}
			case UI_SimpleMenu::Selection_Quit()		: CustomQuit();
			case UI_SimpleMenu::Selection_Back()		: G_MainMenu = False;
		}
		
		UI_SimpleMenu::Select(Selection);
	} else {
		declare Selection = UI_Menu::Valid();
		
		switch (Selection) {
			case UI_Menu::Selection_Validate()		: CustomValidate();
			//case UI_Menu::Selection_Style()			: G_MapStyleSelection = True; // TAG: MapStyleSelection
			case UI_Menu::Selection_Test()			: {
				G_MainMenu = False;
				SetTestMode(True);
			}
			case UI_Menu::Selection_Save()			: CustomSaveMap(False);
			case UI_Menu::Selection_SaveAs()		: CustomSaveMap(True);
			case UI_Menu::Selection_Shadows()		: CustomComputeShadows();
			case UI_Menu::Selection_New() 		: {
				declare ResetMap = Confirm(
					_("|Window title - creating a new track|New track"),
					ComposeMultilines([
						_("Any unsaved modification done on this track will be lost."),
						_("Are you sure you want to create a new track?")
					]),
					_("|Infinitive|Confirm"),
					_("|Infinitive|Cancel")
				);
				if (ResetMap) {
					G_MainMenu = False;
					Reset();
				}
			}
			case UI_Menu::Selection_Tuto()		: {
				UI_Tuto::Reset();
				G_MainMenu = False;
			}
			case UI_Menu::Selection_Quit()			: CustomQuit();
			case UI_Menu::Selection_Back()			: G_MainMenu = False;
		}
		
		UI_Menu::Select(Selection);
	}
	
	ClearInputBuffer();
	G_TerrainCanPress = False;
}

/// Validate a selection in the outro menu
Void OutroMenuValid() {
	declare Selection = UI_MenuOutro::Valid();
	
	switch (Selection) {
		case UI_MenuOutro::Selection_Validate()		: CustomValidate();
		case UI_MenuOutro::Selection_Test()			: SetTestMode(True);
		// case UI_MenuOutro::Selection_Style()		: G_MapStyleSelection = True; // TAG: MapStyleSelection
		case UI_MenuOutro::Selection_Play() 		: CustomPlay(True);
		case UI_MenuOutro::Selection_Save()			: CustomSaveMap(False);
		case UI_MenuOutro::Selection_SaveAs()		: CustomSaveMap(True);
		case UI_MenuOutro::Selection_SaveAndQuit() : CustomSaveAndQuit();
		case UI_MenuOutro::Selection_EditTrack()	: {
			declare Message = "";
			if (IsEditor(C_Editor_Advanced) && !S_NoDecoration) {
				if (ValidationStatus == CMapEditorPlugin::ValidationStatus::Validated) {
					Message = ComposeMultilines([
						_("The decoration will be removed and you will have to validate the track again."),
						_("Are you sure you want to edit this track?")
					]);
				} else {
					Message = ComposeMultilines([
						_("The decoration will be removed."),
						_("Are you sure you want to edit this track?")
					]);
				}
			} else {
				if (ValidationStatus == CMapEditorPlugin::ValidationStatus::Validated) {
					Message = ComposeMultilines([
						_("You will have to validate the track again."),
						_("Are you sure you want to edit this track?")
					]);
				} else {
					Message = _("Are you sure you want to edit this track?");
				}
			}
			declare EditMap = Confirm(
				_("|Window title - editing a track|Edit track"),
				Message,
				_("|Infinitive|Confirm"),
				_("|Infinitive|Cancel")
			);
			if (EditMap) {
				if (G_NeedRebuild) RebuildMap();
				SelectMode(C_Categories_Construct, C_Modes_ConstructDeco);
				RemoveDecoration();
				SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
				RemoveAllFinishes(CutPasteIsAllowed());
			}
		}
		case UI_MenuOutro::Selection_EditDeco()		: {
			declare Message = "";
			if (ValidationStatus == CMapEditorPlugin::ValidationStatus::Validated) {
				Message = ComposeMultilines([
					_("You will have to validate the track again."),
					_("Are you sure you want to edit the decoration?")
				]);
			} else {
				Message = _("Are you sure you want to edit the decoration?");
			}
			declare EditDeco = Confirm(
				_("|Infinitive|Edit decoration"),
				Message,
				_("|Infinitive|Confirm"),
				_("|Infinitive|Cancel")
			);
			if (EditDeco) {
				if (G_NeedRebuild) RebuildMap();
				SelectMode(C_Categories_Construct, C_Modes_ConstructDeco);
				RemoveDecoration();
			}
		}
		case UI_MenuOutro::Selection_Quit()			: CustomQuit();
	}
	
	UI_MenuOutro::Select(Selection);
	ClearInputBuffer();
	G_TerrainCanPress = False;
}

// TAG: MapStyleSelection
/// Valid a selection in the track style menu
/*Void MapStyleValid() {
	declare metadata GamepadEditor_MapStyle for Map = UI_MapStyleSelection::Style_Race();
	declare metadata GamepadEditor_MapStyleSelected for Map = False;
	GamepadEditor_MapStyle = UI_MapStyleSelection::Valid();
	GamepadEditor_MapStyleSelected = True;
	
	ClearInputBuffer();
	G_TerrainCanPress = False;
	G_MapStyleSelection = False;
	
	MapModified();
}

/// Close the track style menu
Void MapStyleCancel() {
	declare metadata GamepadEditor_MapStyle for Map = UI_MapStyleSelection::Style_Race();
	UI_MapStyleSelection::Select(GamepadEditor_MapStyle);
	G_MapStyleSelection = False;
	Sound::Play("EditorMenuCancel");
}*/

/// Cancel the decoration step and go back to track building
Void CancelDecoration() {
	SelectMode(C_Categories_Construct, C_Modes_ConstructDeco);
	RemoveDecoration();
	SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	RemoveAllFinishes(CutPasteIsAllowed());
}

// Select a skin for the macroblock
Void SelectSkin(CMapEditorPluginEvent::EInput _Input, Boolean _IsPreview) {
	if (!G_IsSkinning) return;
	
	if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_Skin())) {
		UI_Tuto::ValidateTuto(UI_Tuto::Tuto_Skin());
		CheckTuto();
	}
	
	switch (_Input) {
		case CMapEditorPluginEvent::EInput::CursorRight	: UI_SkinSelection::NextSkin(_IsPreview); ///< Select next skin
		case CMapEditorPluginEvent::EInput::CursorLeft	: UI_SkinSelection::PrevSkin(_IsPreview); ///< Select previous skin
		case CMapEditorPluginEvent::EInput::IconRight		: UI_SkinSelection::NextSkin(_IsPreview); ///< Select next skin
		case CMapEditorPluginEvent::EInput::IconLeft		: UI_SkinSelection::PrevSkin(_IsPreview); ///< Select previous skin
		case CMapEditorPluginEvent::EInput::CursorPick	: UI_SkinSelection::ToggleBgFg();
	}
}

// Check if we can move the macroblock
Void CursorHeight(CMapEditorPluginEvent::EInput _Input) {
	if (UI_MacroblockSelection::IsSelecting()) return;
	MoveMacroblock(_Input);
}

// ---------------------------------- //
/** Check if the player clicked on the block in the cursor
 *
 *	@return														True if the player clicked on the block, False otherwise
 */
Boolean ClickedOnBlock() {
	declare MacroblockModel = G_CursorMacroblockModel;
	declare Coord = Cursor.Coord;
	declare Dir = Cursor.Dir;
	if ((G_IsEditing || G_IsSkinning) && MapContent::Exists(Coord)) {
		MacroblockModel = MapContent::GetMacroblockModel(Coord);
		Coord = MapContent::GetMacroblockCoord(Coord);
		Dir = MapContent::GetMacroblockDir(Coord);
	}
	
	declare Variant <=> Macroblock::GetBlockModelVariant(MacroblockModel);
	if (Variant != Null) {
		declare MacroblockCoords = Macroblock::GetCoords(MacroblockModel, Coord, Dir, False);
		declare Start = Coord.Y;
		declare End = Coord.Y + Variant.Size.Y - 1;
		for (Y, Start, End) {
			declare ClickedOnBlock = MacroblockCoords.exists(GetMouseCoordAtHeight(Y));
			if (ClickedOnBlock) return True;
		}
	}
	
	return False;
}


/// Leave the random editor
Void LeaveRandomEditor() {
	if (Confirm(
		_("Leave random track generator"),
		ComposeMultilines([
			_("Do you want to leave the random track generator?")
		]),
		_("|Infinitive|Confirm"),
		_("|Infinitive|Cancel")
	)) CustomQuit();
}

// Validate the rosaces tutorial when pressing the right button
Void ValidateTutoRosaces(CMapEditorPluginEvent::EInput _Input) {
	if (
		_Input == CMapEditorPluginEvent::EInput::CursorUp ||
		_Input == CMapEditorPluginEvent::EInput::CursorRight ||
		_Input == CMapEditorPluginEvent::EInput::CursorDown ||
		_Input == CMapEditorPluginEvent::EInput::CursorLeft ||
		_Input == CMapEditorPluginEvent::EInput::CursorPick ||
		_Input == CMapEditorPluginEvent::EInput::CameraUp ||
		_Input == CMapEditorPluginEvent::EInput::CameraRight ||
		_Input == CMapEditorPluginEvent::EInput::CameraDown ||
		_Input == CMapEditorPluginEvent::EInput::CameraLeft
	) {	
		if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_Rosaces())) {
			UI_Tuto::ValidateTuto(UI_Tuto::Tuto_Rosaces());
			CheckTuto();
		}
	}
}

Void ValidateTutoRosaces(Text _Input) {
	if (_Input == UI_MacroblockSelection::Event_MacroblockClick()) {	
		if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_Rosaces())) {
			UI_Tuto::ValidateTuto(UI_Tuto::Tuto_Rosaces());
			CheckTuto();
		}
	}
}

// Save the different parameters you need to save in RandomGen + a normal save
Void RandomGeneratorSave(){
	if (MapContent::HasFinish()) {			
		CustomSaveMap(False);
		if(S_RandomMap_Validate && ValidationStatus != CMapEditorPlugin::ValidationStatus::Validated) {
				Alert(_("To play this track outside of the editor you need to validate it."));
			}	
	}
}

/// Calculate shadows, save if needed and play
Void RandomGeneratorPlay(){
	if (MapContent::HasFinish()) {
		if(CurrentShadowsQuality == CMapEditorPlugin::ShadowsQuality::NotComputed) 
			CustomComputeShadows();
		if (C_DemoSony) CustomValidate(); ///< Test the track
		else if (S_RandomMap_Validate) {
			if(ValidationStatus != CMapEditorPlugin::ValidationStatus::Validated)
				RandomGeneratorSave();
			CustomValidate();
			G_TestedRandomMap = True;
			SaveMapGamepadEditor(GetMapName()); // Resave for record
			OnSequenceStart(C_Sequence_RerollMap); // force UI refresh for validation button
		} else{
			// Try the track
			G_WaitingRerollAnswer = False;
			CustomValidate();
			G_WaitingRerollAnswer = True;
			SelectSequence();
		}
	}
}

/// Choose a predefined landscape even in expert mode
Void ExpertChooseLandscape(){
	if(!IsEditor(C_Editor_Expert)) return;
	if(C_RandomLandscape){
		Alert(
			_("|Alert window title|Warning"),
			_("Random Landscape is not available in Expert Mode. Please turn off Random Landscape and try again."),
			_("|Infinitive|Cancel")
		);
		return;
	}
	if(MapContent::Count() > 0){
		if(!Confirm(
				_("|Alert window title|Warning"),
				ComposeMultilines([
					_("If you choose a landscape, you might lose all of your progress."),
					_("To avoid this you can create your own landscapes. Continue anyways?")
				]),
				_("|Infinitive|Continue"), 
				_("|Infinitive|Cancel")
		)) return;
	}
	G_CurrentSequence = C_Sequence_Simple_Terraforming; 
	OnSequenceStart(C_Sequence_Simple_Terraforming);
}

Void TriggerInput(CMapEditorPluginEvent::EInput _Input, Integer _Device) {
	//log(_Input);
	// Cancel input if a selection is ongoing
	if (Selection::IsSelecting() && !Selection::IsMoveInput(_Input)) return;
	
	if(IsSimpleEditor() || !UI_MacroblockSelection::IsSelecting()){
		if (G_AllowCameraRotation.exists(G_CurrentSequence)){
			switch (_Input) {
				case CMapEditorPluginEvent::EInput::CameraUp			: { Camera.TurnV(True);					return; }
				case CMapEditorPluginEvent::EInput::CameraRight		: { Camera.TurnH(False, True);	return; }
				case CMapEditorPluginEvent::EInput::CameraDown		: { Camera.TurnV(False);					return; }
				case CMapEditorPluginEvent::EInput::CameraLeft		: { Camera.TurnH(True, True);		return; }
			}
		}
		
		if (_Input == CMapEditorPluginEvent::EInput::CameraZoomNext){
			if(G_AllowCameraZoom.exists(G_CurrentSequence)){
				Camera.ZoomIn(True);
				return;
			}
		}
	}
	
	if (!UI_MacroblockSelection::IsSelecting() && _Device == Buttons2::Device_Mouse() && G_AllowCameraRotation.exists(G_CurrentSequence)) {
		switch (_Input) {
			case CMapEditorPluginEvent::EInput::CursorRaise		: { Camera.ZoomIn(False);		return; }
			case CMapEditorPluginEvent::EInput::CursorLower		: { Camera.ZoomOut(False);	return; }
		}
	}
	
	switch (G_CurrentSequence) {
		case C_Sequence_RerollMap: { // 14
			switch (_Input) {
				case CMapEditorPluginEvent::EInput::Menu					: RandomMenu(); //LeaveRandomEditor(); ///< Leave editor
				//case CMapEditorPluginEvent::EInput::Undo				:
				//case CMapEditorPluginEvent::EInput::Redo				:
				//case CMapEditorPluginEvent::EInput::CursorRaise	:
				//case CMapEditorPluginEvent::EInput::CursorLower	:
				case CMapEditorPluginEvent::EInput::CursorTurn		: if(!S_RandomMap_Validate) RandomGeneratorSave();
				case CMapEditorPluginEvent::EInput::CursorPlace 	: RandomGeneratorPlay();
				case CMapEditorPluginEvent::EInput::CursorDelete 	: CustomQuit();
				case CMapEditorPluginEvent::EInput::SwitchToRace	: RerollRandomMap(); ///< Reroll the track
				//case CMapEditorPluginEvent::EInput::IconUp			:
				//case CMapEditorPluginEvent::EInput::IconRight		:
				//case CMapEditorPluginEvent::EInput::IconDown		:
				//case CMapEditorPluginEvent::EInput::IconLeft		:
				//case CMapEditorPluginEvent::EInput::CursorUp		:
				//case CMapEditorPluginEvent::EInput::CursorRight	:
				//case CMapEditorPluginEvent::EInput::CursorDown	:
				//case CMapEditorPluginEvent::EInput::CursorLeft	:
				//case CMapEditorPluginEvent::EInput::CursorPick	:
			}
		}
		case C_Sequence_MainMenu: { // 0
			switch (_Input) {
				case CMapEditorPluginEvent::EInput::Menu			: {
					G_MainMenu = False; ///< Close main menu
					Sound::Play("EditorMenuCancel");
				}
				//case CMapEditorPluginEvent::EInput::Undo				:
				//case CMapEditorPluginEvent::EInput::Redo				:
				//case CMapEditorPluginEvent::EInput::CursorRaise	:
				//case CMapEditorPluginEvent::EInput::CursorLower	:
				//case CMapEditorPluginEvent::EInput::CursorTurn	:
				case CMapEditorPluginEvent::EInput::CursorPlace		: MainMenuValid(); ///< Valid menu selection
				case CMapEditorPluginEvent::EInput::CursorDelete	: {
					G_MainMenu = False; ///< Close main menu
					Sound::Play("EditorMenuCancel");
				}
				//case CMapEditorPluginEvent::EInput::SwitchToRace	:
				case CMapEditorPluginEvent::EInput::IconUp			: {
					if (IsSimpleEditor()) UI_SimpleMenu::Prev();
					else UI_Menu::Prev();
				} ///< Previous selection in the menu
				//case CMapEditorPluginEvent::EInput::IconRight	:
				case CMapEditorPluginEvent::EInput::IconDown		: {
					if (IsSimpleEditor()) UI_SimpleMenu::Next();
					else UI_Menu::Next();
				} ///< Next selection in the menu
				//case CMapEditorPluginEvent::EInput::IconLeft		:
				case CMapEditorPluginEvent::EInput::CursorUp		: {
					if (IsSimpleEditor()) UI_SimpleMenu::Prev();
					else UI_Menu::Prev();
				} ///< Previous selection in the menu
				//case CMapEditorPluginEvent::EInput::CursorRight	:
				case CMapEditorPluginEvent::EInput::CursorDown	: {
					if (IsSimpleEditor()) UI_SimpleMenu::Next();
					else UI_Menu::Next();
				} ///< Next selection in the menu
				//case CMapEditorPluginEvent::EInput::CursorLeft	:
				//case CMapEditorPluginEvent::EInput::CursorPick	:
			}
			if (_Device == Buttons2::Device_Pad()) {
				switch (_Input) {
					//case CMapEditorPluginEvent::EInput::RemoveAll	:
					case CMapEditorPluginEvent::EInput::CursorDelete	: {
						G_MainMenu = False; ///< Close main menu
						Sound::Play("EditorMenuCancel");
					}
				}
			} else {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::RemoveAll		: {
						G_MainMenu = False; ///< Close main menu
						Sound::Play("EditorMenuCancel");
					}
					//case CMapEditorPluginEvent::EInput::CursorDelete	:
				}
			}
		}
		/*case C_Sequence_MapStyle: { // 15 // TAG: MapStyleSelection
			switch (_Input) {
				//case CMapEditorPluginEvent::EInput::Menu				:
				//case CMapEditorPluginEvent::EInput::Undo				:
				//case CMapEditorPluginEvent::EInput::Redo				:
				//case CMapEditorPluginEvent::EInput::CursorRaise	:
				//case CMapEditorPluginEvent::EInput::CursorLower	:
				//case CMapEditorPluginEvent::EInput::CursorTurn	:
				case CMapEditorPluginEvent::EInput::CursorPlace		: MapStyleValid(); ///< Valid track style selection
				case CMapEditorPluginEvent::EInput::CursorDelete	: MapStyleCancel(); ///< Cancel track style selection
				//case CMapEditorPluginEvent::EInput::SwitchToRace:
				case CMapEditorPluginEvent::EInput::IconUp				: UI_MapStyleSelection::Prev(); ///< Previous selection in the menu
				//case CMapEditorPluginEvent::EInput::IconRight		:
				case CMapEditorPluginEvent::EInput::IconDown			: UI_MapStyleSelection::Next(); ///< Next selection in the menu
				//case CMapEditorPluginEvent::EInput::IconLeft		:
				case CMapEditorPluginEvent::EInput::CursorUp			: UI_MapStyleSelection::Prev(); ///< Previous selection in the menu
				//case CMapEditorPluginEvent::EInput::CursorRight	:
				case CMapEditorPluginEvent::EInput::CursorDown		: UI_MapStyleSelection::Next(); ///< Next selection in the menu
				//case CMapEditorPluginEvent::EInput::CursorLeft	:
				//case CMapEditorPluginEvent::EInput::CursorPick	:
			}
			if (_Device == Buttons2::Device_Pad()) {
				switch (_Input) {
					//case CMapEditorPluginEvent::EInput::RemoveAll	:
					case CMapEditorPluginEvent::EInput::CursorDelete	: MapStyleCancel(); ///< Cancel track style selection
				}
			} else {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::RemoveAll		: MapStyleCancel(); ///< Cancel track style selection
					//case CMapEditorPluginEvent::EInput::CursorDelete	:
				}
			}
		}*/
		case C_Sequence_SelectTerrain: { // 2
			switch (_Input) {
				case CMapEditorPluginEvent::EInput::Menu					: G_MainMenu = True; ///< Open main menu
				//case CMapEditorPluginEvent::EInput::Undo				:
				//case CMapEditorPluginEvent::EInput::Redo				:
				//case CMapEditorPluginEvent::EInput::CursorRaise	:
				//case CMapEditorPluginEvent::EInput::CursorLower	:
				//case CMapEditorPluginEvent::EInput::CursorTurn	:
				case CMapEditorPluginEvent::EInput::CursorPlace		: PlaceTerrain(); ///< Place the current terrain
				//case CMapEditorPluginEvent::EInput::CursorDelete: 
				//case CMapEditorPluginEvent::EInput::SwitchToRace:
				//case CMapEditorPluginEvent::EInput::IconUp			:
				//case CMapEditorPluginEvent::EInput::IconRight		:
				//case CMapEditorPluginEvent::EInput::IconDown		:
				//case CMapEditorPluginEvent::EInput::IconLeft		:
				//case CMapEditorPluginEvent::EInput::CursorUp		:
				//case CMapEditorPluginEvent::EInput::CursorRight	:
				//case CMapEditorPluginEvent::EInput::CursorDown	:
				//case CMapEditorPluginEvent::EInput::CursorLeft	:
				case CMapEditorPluginEvent::EInput::CursorPick		: SwitchMode(C_Categories_Landscape); ///< Switch mode
			}
		}
		case C_Sequence_RandomTerrain: { // 3
			switch (_Input) {
				case CMapEditorPluginEvent::EInput::Menu					: G_MainMenu = True; ///< Open main menu
				//case CMapEditorPluginEvent::EInput::Undo				:
				//case CMapEditorPluginEvent::EInput::Redo				:
				//case CMapEditorPluginEvent::EInput::CursorRaise	:
				//case CMapEditorPluginEvent::EInput::CursorLower	:
				case CMapEditorPluginEvent::EInput::CursorTurn		: RandomTerrain(False); ///< Generate random terrain
				case CMapEditorPluginEvent::EInput::CursorPlace		: PlaceTerrain(); ///< Place the current terrain
				//case CMapEditorPluginEvent::EInput::CursorDelete:
				//case CMapEditorPluginEvent::EInput::SwitchToRace: 
				//case CMapEditorPluginEvent::EInput::IconUp			:
				//case CMapEditorPluginEvent::EInput::IconRight		:
				//case CMapEditorPluginEvent::EInput::IconDown		:
				//case CMapEditorPluginEvent::EInput::IconLeft		:
				//case CMapEditorPluginEvent::EInput::CursorUp		:
				//case CMapEditorPluginEvent::EInput::CursorRight	:
				//case CMapEditorPluginEvent::EInput::CursorDown	:
				//case CMapEditorPluginEvent::EInput::CursorLeft	:
				case CMapEditorPluginEvent::EInput::CursorPick		: SwitchMode(C_Categories_Landscape); ///< Switch mode
			}
		}
		case C_Sequence_PlaceStart: { // 5 
			if (UI_MacroblockSelection::IsSelecting()) {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::CursorPlace		: ToggleAirMode();
					case CMapEditorPluginEvent::EInput::CursorPick		: SwitchMode(C_Categories_Construct); ///< Switch mode
					//case CMapEditorPluginEvent::EInput::CursorDelete	: ToggleGhostMode();
				}
				if (_Device == Buttons2::Device_Keyboard()) {
					switch (_Input) {
						case CMapEditorPluginEvent::EInput::CursorTiltLeft	: PrevStyle();
						case CMapEditorPluginEvent::EInput::CursorTiltRight	: NextStyle();
						//case CMapEditorPluginEvent::EInput::CursorRaise			: PrevStyleFilter();  // there is currently no filter in deco mode
						//case CMapEditorPluginEvent::EInput::CursorLower			: NextStyleFilter();
						case CMapEditorPluginEvent::EInput::CursorUp				: PrevMacroblocksPage(); // we show L/R but may as well allow Up/Down
						case CMapEditorPluginEvent::EInput::CursorLeft			: PrevMacroblocksPage();
						case CMapEditorPluginEvent::EInput::CursorRight			: NextMacroblocksPage();
						case CMapEditorPluginEvent::EInput::CursorDown			: NextMacroblocksPage();
					}
				} else {
					switch (_Input) {
						case CMapEditorPluginEvent::EInput::SwitchToRace	: PrevMacroblocksPage();
						case CMapEditorPluginEvent::EInput::CursorTurn		: NextMacroblocksPage();
						//case CMapEditorPluginEvent::EInput::Undo					: PrevStyleFilter();
						//case CMapEditorPluginEvent::EInput::Redo					: NextStyleFilter();
						case CMapEditorPluginEvent::EInput::CursorLower		: PrevStyle();
						case CMapEditorPluginEvent::EInput::CursorRaise		: NextStyle();
					}
				}
			} else if (G_IsSkinning) {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::CursorPick		:	SelectSkin(_Input, False); // Switch Fg/Bg
					case CMapEditorPluginEvent::EInput::Menu					:	G_MainMenu = True; ///< Open main menu
					case CMapEditorPluginEvent::EInput::CursorRaise		: CursorHeight(_Input); ///< Move macroblock
					case CMapEditorPluginEvent::EInput::CursorLower		: CursorHeight(_Input); ///< Move macroblock
					case CMapEditorPluginEvent::EInput::CursorDelete	: ExpertRemoveMacroblock2(Cursor.Coord); ///< Remove the macroblock
					//case CMapEditorPluginEvent::EInput::SwitchToRace	: SetTestMode(True);
				}				
				if (_Device == Buttons2::Device_Keyboard()) {
					switch (_Input) {
						// TAG:ICONONKB The IconU/R/D/L inputs aren't binded on keyboard, so we don't have any available buttons here to select skins.
						// However, it's still usable with mouse
						//case CMapEditorPluginEvent::EInput::IconRight		: SelectSkin(_Input, False); ///< Select next skin
						//case CMapEditorPluginEvent::EInput::IconLeft		: SelectSkin(_Input, False); ///< Select previous skin
						case CMapEditorPluginEvent::EInput::CursorUp			: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::CursorRight		: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::CursorDown		: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::CursorLeft		: MoveMacroblock(_Input); ///< Move macroblock
					}
				} else {
					switch (_Input) {
						//case CMapEditorPluginEvent::EInput::CursorUp	: 
						case CMapEditorPluginEvent::EInput::CursorRight	: SelectSkin(_Input, False); ///< Select next skin
						//case CMapEditorPluginEvent::EInput::CursorDown: 
						case CMapEditorPluginEvent::EInput::CursorLeft	: SelectSkin(_Input, False); ///< Select previous skin
						case CMapEditorPluginEvent::EInput::IconUp			: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::IconRight		: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::IconDown		: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::IconLeft		: MoveMacroblock(_Input); ///< Move macroblock
					}
				}
			} else {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::Menu					: G_MainMenu = True; ///< Open main menu
					case CMapEditorPluginEvent::EInput::CursorRaise		: CursorHeight(_Input); ///< Move start macroblock up
					case CMapEditorPluginEvent::EInput::CursorLower		: CursorHeight(_Input); ///< Move start macroblock down
					case CMapEditorPluginEvent::EInput::CursorTurn		: RotateMacroblock(1); ///< Rotate start macroblock
					case CMapEditorPluginEvent::EInput::CursorPlace		: AddStartMacroblock2(); ///< Place start macroblock
					//case CMapEditorPluginEvent::EInput::CursorDelete:
					//case CMapEditorPluginEvent::EInput::SwitchToRace: ExpertChooseLandscape(); // should we re-enable this at some point?
					case CMapEditorPluginEvent::EInput::SwitchToRace	: ToggleColor();
					case CMapEditorPluginEvent::EInput::CursorPick		: SwitchMode(C_Categories_Construct); ///< Switch mode
				}
				if (_Device == Buttons2::Device_Keyboard()) {
					switch (_Input) {
						case CMapEditorPluginEvent::EInput::CursorUp			: MoveMacroblock(_Input); ///< Move start macroblock
						case CMapEditorPluginEvent::EInput::CursorRight		: MoveMacroblock(_Input); ///< Move start macroblock
						case CMapEditorPluginEvent::EInput::CursorDown		: MoveMacroblock(_Input); ///< Move start macroblock
						case CMapEditorPluginEvent::EInput::CursorLeft		: MoveMacroblock(_Input); ///< Move start macroblock
						case CMapEditorPluginEvent::EInput::CursorTiltLeft : UndoHistory2(); ///< Undo or previous style
						case CMapEditorPluginEvent::EInput::CursorTiltRight: RedoHistory2(); ///< Redo history
					}
				} else {
					switch (_Input) {
						case CMapEditorPluginEvent::EInput::IconUp			: MoveMacroblock(_Input); ///< Move start macroblock
						case CMapEditorPluginEvent::EInput::IconRight		: MoveMacroblock(_Input); ///< Move start macroblock
						case CMapEditorPluginEvent::EInput::IconDown		: MoveMacroblock(_Input); ///< Move start macroblock
						case CMapEditorPluginEvent::EInput::IconLeft		: MoveMacroblock(_Input); ///< Move start macroblock
						case CMapEditorPluginEvent::EInput::Undo				: UndoHistory2(); ///< Undo or previous style
						case CMapEditorPluginEvent::EInput::Redo				: RedoHistory2(); ///< Redo history
					}
				}
			}
		}
		case C_Sequence_FreeMode: { // 7
			if (UI_MacroblockSelection::IsSelecting()) {
				ValidateTutoRosaces(_Input);
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::CursorPlace		: ToggleAirMode();
					case CMapEditorPluginEvent::EInput::CursorPick		:	SwitchMode(C_Categories_Construct);
					//case CMapEditorPluginEvent::EInput::CursorDelete	: ToggleGhostMode();
				}
				if (_Device == Buttons2::Device_Keyboard()) {
					switch (_Input) {
						case CMapEditorPluginEvent::EInput::CursorTiltLeft	: PrevStyle();
						case CMapEditorPluginEvent::EInput::CursorTiltRight	: NextStyle();
						case CMapEditorPluginEvent::EInput::CursorRaise			: PrevStyleFilter();
						case CMapEditorPluginEvent::EInput::CursorLower			: NextStyleFilter();
						case CMapEditorPluginEvent::EInput::CursorUp				: PrevMacroblocksPage(); // we show L/R but may as well allow Up/Down
						case CMapEditorPluginEvent::EInput::CursorLeft			: PrevMacroblocksPage();
						case CMapEditorPluginEvent::EInput::CursorRight			: NextMacroblocksPage();
						case CMapEditorPluginEvent::EInput::CursorDown			: NextMacroblocksPage();
					}
				} else {
					switch (_Input) {
						case CMapEditorPluginEvent::EInput::SwitchToRace	: PrevMacroblocksPage();
						case CMapEditorPluginEvent::EInput::CursorTurn		: NextMacroblocksPage();
						case CMapEditorPluginEvent::EInput::Undo					: PrevStyleFilter();
						case CMapEditorPluginEvent::EInput::Redo					: NextStyleFilter();
						case CMapEditorPluginEvent::EInput::CursorLower		: PrevStyle();
						case CMapEditorPluginEvent::EInput::CursorRaise		: NextStyle();
					}
				}
			} else {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::CursorPick		:	{
						if (G_IsSkinning)
							SelectSkin(_Input, False); // Switch Fg/Bg
						else
							SwitchMode(C_Categories_Construct);
					}
					case CMapEditorPluginEvent::EInput::Menu					:	G_MainMenu = True; ///< Open main menu
					case CMapEditorPluginEvent::EInput::CursorRaise		: CursorHeight(_Input); ///< Move macroblock
					case CMapEditorPluginEvent::EInput::CursorLower		: CursorHeight(_Input); ///< Move macroblock
					case CMapEditorPluginEvent::EInput::CursorDelete	: ExpertRemoveMacroblock2(Cursor.Coord); ///< Remove the macroblock
					case CMapEditorPluginEvent::EInput::SwitchToRace	: ToggleColor();
					case CMapEditorPluginEvent::EInput::CursorTurn		: ExpertCursorTurn(); ///< Rotate macroblock or copy
					case CMapEditorPluginEvent::EInput::CursorPlace		: {
						if (!G_IsSkinning)
							ExpertCursorPlace(UI_MacroblockSelection::GetMacroblockId()); ///< Place macroblock
					}
				}				
				if (_Device == Buttons2::Device_Keyboard()) {
					switch (_Input) {
						// TAG:ICONONKB The IconU/R/D/L inputs aren't binded on keyboard, so we don't have any available buttons here to select skins.
						// However, it's still usable with mouse
						//case CMapEditorPluginEvent::EInput::IconRight		: SelectSkin(_Input, False); ///< Select next skin
						//case CMapEditorPluginEvent::EInput::IconLeft		: SelectSkin(_Input, False); ///< Select previous skin
						case CMapEditorPluginEvent::EInput::CursorUp			: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::CursorRight		: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::CursorDown		: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::CursorLeft		: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::CursorTiltLeft	: UndoHistory2(); ///< Undo or previous style
						case CMapEditorPluginEvent::EInput::CursorTiltRight	: RedoHistory2(); ///< Redo history
					}
				} else {
					switch (_Input) {
						//case CMapEditorPluginEvent::EInput::CursorUp	: 
						case CMapEditorPluginEvent::EInput::CursorRight	: SelectSkin(_Input, False); ///< Select next skin
						//case CMapEditorPluginEvent::EInput::CursorDown: 
						case CMapEditorPluginEvent::EInput::CursorLeft	: SelectSkin(_Input, False); ///< Select previous skin
						case CMapEditorPluginEvent::EInput::IconUp			: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::IconRight		: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::IconDown		: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::IconLeft		: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::Undo				: UndoHistory2(); ///< Undo or previous style
						case CMapEditorPluginEvent::EInput::Redo				: RedoHistory2(); ///< Redo history
					}
				}
			}
		}
		case C_Sequence_TestMode: { // 8
			switch (_Input) {
				case CMapEditorPluginEvent::EInput::Menu					: SetTestMode(False);
				//case CMapEditorPluginEvent::EInput::Undo				:
				//case CMapEditorPluginEvent::EInput::Redo				:
				//case CMapEditorPluginEvent::EInput::CursorRaise	:
				//case CMapEditorPluginEvent::EInput::CursorLower	:
				//case CMapEditorPluginEvent::EInput::CursorTurn	:
				case CMapEditorPluginEvent::EInput::CursorPlace		: StartTest(); ///< Spawn the player
				case CMapEditorPluginEvent::EInput::CursorDelete	: SetTestMode(False); ///< Leave test mode
				//case CMapEditorPluginEvent::EInput::SwitchToRace	:
				//case CMapEditorPluginEvent::EInput::IconUp			:
				case CMapEditorPluginEvent::EInput::IconRight			: SelectSpawn(1); ///< Next checkpoint
				//case CMapEditorPluginEvent::EInput::IconDown		:
				case CMapEditorPluginEvent::EInput::IconLeft			: SelectSpawn(-1); ///< Previous checkpoint
				//case CMapEditorPluginEvent::EInput::CursorUp		: 
				case CMapEditorPluginEvent::EInput::CursorRight		: SelectSpawn(1); ///< Next checkpoint
				//case CMapEditorPluginEvent::EInput::CursorDown	: 
				case CMapEditorPluginEvent::EInput::CursorLeft		: SelectSpawn(-1); ///< Previous checkpoint
				case CMapEditorPluginEvent::EInput::CursorPick		: { SetTestMode(False); SwitchMode(C_Categories_Construct); } ///< Switch mode
			}			
			if (_Device == Buttons2::Device_Pad()) {
				switch (_Input) {
					//case CMapEditorPluginEvent::EInput::RemoveAll	:
					case CMapEditorPluginEvent::EInput::CursorDelete	: SetTestMode(False); ///< Leave test mode
				}
			} else {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::RemoveAll		: SetTestMode(False); ///< Leave test mode
					//case CMapEditorPluginEvent::EInput::CursorDelete	:
				}
			}
		}
		case C_Sequence_EditTerrain: { // 10
			if (!UI_MacroblockSelection::IsSelecting()) {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::Menu					: G_MainMenu = True; ///< Open main menu
					//case CMapEditorPluginEvent::EInput::CursorRaise	:
					//case CMapEditorPluginEvent::EInput::CursorLower	:
					//case CMapEditorPluginEvent::EInput::CursorTurn	:
					//case CMapEditorPluginEvent::EInput::CursorPlace	:
					//case CMapEditorPluginEvent::EInput::CursorDelete:
					case CMapEditorPluginEvent::EInput::SwitchToRace	: ExpertChooseLandscape(); //SetTestMode(True); ///< Switch to test mode
					case CMapEditorPluginEvent::EInput::CursorPick		: SwitchMode(C_Categories_Construct); ///< Switch mode
				}
			}
			if (_Device == Buttons2::Device_Keyboard()) {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::CursorUp		: MoveTerrain(_Input); ///< Move terrain block
					case CMapEditorPluginEvent::EInput::CursorRight	: MoveTerrain(_Input); ///< Move terrain block
					case CMapEditorPluginEvent::EInput::CursorDown	: MoveTerrain(_Input); ///< Move terrain block
					case CMapEditorPluginEvent::EInput::CursorLeft	: MoveTerrain(_Input); ///< Move terrain block
					case CMapEditorPluginEvent::EInput::CursorTiltLeft	: UndoHistory2(); ///< Undo history
					case CMapEditorPluginEvent::EInput::CursorTiltRight	: RedoHistory2(); ///< Redo history
				}
			} else {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::IconUp			: MoveTerrain(_Input); ///< Move terrain block
					case CMapEditorPluginEvent::EInput::IconRight		: MoveTerrain(_Input); ///< Move terrain block
					case CMapEditorPluginEvent::EInput::IconDown		: MoveTerrain(_Input); ///< Move terrain block
					case CMapEditorPluginEvent::EInput::IconLeft		: MoveTerrain(_Input); ///< Move terrain block
					case CMapEditorPluginEvent::EInput::Undo				: UndoHistory2(); ///< Undo history
					case CMapEditorPluginEvent::EInput::Redo				: RedoHistory2(); ///< Redo history
				}
			}
		}
		case C_Sequence_EditDecoration: { // 12
			if (UI_MacroblockSelection::IsSelecting()) {
				ValidateTutoRosaces(_Input);
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::CursorPlace		: ToggleAirMode();
					case CMapEditorPluginEvent::EInput::CursorPick		:	SwitchMode(C_Categories_Construct);
					//case CMapEditorPluginEvent::EInput::CursorDelete	: ToggleGhostMode();
				}
				if (_Device == Buttons2::Device_Keyboard()) {
					switch (_Input) {
						case CMapEditorPluginEvent::EInput::CursorTiltLeft	: PrevStyle();
						case CMapEditorPluginEvent::EInput::CursorTiltRight	: NextStyle();
						//case CMapEditorPluginEvent::EInput::CursorRaise		: PrevStyleFilter(); // there is currently no filter in deco mode
						//case CMapEditorPluginEvent::EInput::CursorLower		: NextStyleFilter();
						case CMapEditorPluginEvent::EInput::CursorUp				: PrevMacroblocksPage(); // we show L/R but may as well allow Up/Down
						case CMapEditorPluginEvent::EInput::CursorLeft			: PrevMacroblocksPage();
						case CMapEditorPluginEvent::EInput::CursorRight			: NextMacroblocksPage();
						case CMapEditorPluginEvent::EInput::CursorDown			: NextMacroblocksPage();
					}
				} else {
					switch (_Input) {
						case CMapEditorPluginEvent::EInput::SwitchToRace	: PrevMacroblocksPage();
						case CMapEditorPluginEvent::EInput::CursorTurn		: NextMacroblocksPage();
						//case CMapEditorPluginEvent::EInput::Undo				: PrevStyleFilter();  // there is currently no filter in deco mode
						//case CMapEditorPluginEvent::EInput::Redo				: NextStyleFilter();
						case CMapEditorPluginEvent::EInput::CursorLower	: PrevStyle();
						case CMapEditorPluginEvent::EInput::CursorRaise	: NextStyle();
					}
				}
			} else {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::CursorPick		:	{
						if (G_IsSkinning)
							SelectSkin(_Input, False); // Switch Fg/Bg
						else
							SwitchMode(C_Categories_Construct);
					}
					case CMapEditorPluginEvent::EInput::Menu					:	G_MainMenu = True; ///< Open main menu
					case CMapEditorPluginEvent::EInput::CursorRaise		: CursorHeight(_Input); ///< Move macroblock
					case CMapEditorPluginEvent::EInput::CursorLower		: CursorHeight(_Input); ///< Move macroblock
					case CMapEditorPluginEvent::EInput::CursorDelete	: ExpertRemoveMacroblock2(Cursor.Coord); ///< Remove the macroblock
					case CMapEditorPluginEvent::EInput::SwitchToRace	: ToggleColor();
					case CMapEditorPluginEvent::EInput::CursorTurn		: ExpertCursorTurn(); ///< Rotate macroblock or copy
					case CMapEditorPluginEvent::EInput::CursorPlace		: {
						if (!G_IsSkinning)
							ExpertCursorPlace(UI_MacroblockSelection::GetMacroblockId()); ///< Place macroblock
					}
				}				
				if (_Device == Buttons2::Device_Keyboard()) {
					switch (_Input) {
						// TAG:ICONONKB The IconU/R/D/L inputs aren't binded on keyboard, so we don't have any available buttons here to select skins.
						// However, it's still usable with mouse
						//case CMapEditorPluginEvent::EInput::IconRight		: SelectSkin(_Input, False); ///< Select next skin
						//case CMapEditorPluginEvent::EInput::IconLeft		: SelectSkin(_Input, False); ///< Select previous skin
						case CMapEditorPluginEvent::EInput::CursorUp			: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::CursorRight		: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::CursorDown		: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::CursorLeft		: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::CursorTiltLeft	: UndoHistory2(); ///< Undo or previous style
						case CMapEditorPluginEvent::EInput::CursorTiltRight	: RedoHistory2(); ///< Redo history
					}
				} else {
					switch (_Input) {
						//case CMapEditorPluginEvent::EInput::CursorUp	: 
						case CMapEditorPluginEvent::EInput::CursorRight	: SelectSkin(_Input, False); ///< Select next skin
						//case CMapEditorPluginEvent::EInput::CursorDown: 
						case CMapEditorPluginEvent::EInput::CursorLeft	: SelectSkin(_Input, False); ///< Select previous skin
						case CMapEditorPluginEvent::EInput::IconUp			: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::IconRight		: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::IconDown		: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::IconLeft		: MoveMacroblock(_Input); ///< Move macroblock
						case CMapEditorPluginEvent::EInput::Undo				: UndoHistory2(); ///< Undo or previous style
						case CMapEditorPluginEvent::EInput::Redo				: RedoHistory2(); ///< Redo history
					}
				}
			}
		}
		case C_Sequence_Simple_Terraforming: { // 16
			switch (_Input) {
				case CMapEditorPluginEvent::EInput::Menu					: G_MainMenu = True; ///< Open main menu
				//case CMapEditorPluginEvent::EInput::CursorRaise	:
				//case CMapEditorPluginEvent::EInput::CursorLower	:
				//case CMapEditorPluginEvent::EInput::CursorTurn	: 
				case CMapEditorPluginEvent::EInput::CursorPlace		: SelectTerrain();
				case CMapEditorPluginEvent::EInput::CursorDelete	: if(IsEditor(C_Editor_Expert)) SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
				case CMapEditorPluginEvent::EInput::SwitchToRace	: ToggleColor();
				//case CMapEditorPluginEvent::EInput::IconUp		:
				//case CMapEditorPluginEvent::EInput::IconRight		:
				//case CMapEditorPluginEvent::EInput::IconDown		:
				//case CMapEditorPluginEvent::EInput::IconLeft		:
				//case CMapEditorPluginEvent::EInput::CursorUp		:
				//case CMapEditorPluginEvent::EInput::CursorDown	:
				//case CMapEditorPluginEvent::EInput::CursorPick	:
			}
			if (_Device == Buttons2::Device_Keyboard()) {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::CursorLeft	: if (IsEditor(C_Editor_Advanced)) { PrevStyle(); UpdateLandscapeChoice(); }
					case CMapEditorPluginEvent::EInput::CursorRight	: if (IsEditor(C_Editor_Advanced)) { NextStyle(); UpdateLandscapeChoice(); }
				}
			} else {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::Undo				: if (IsEditor(C_Editor_Advanced)) { PrevStyle(); UpdateLandscapeChoice(); }
					case CMapEditorPluginEvent::EInput::Redo				: if (IsEditor(C_Editor_Advanced)) { NextStyle(); UpdateLandscapeChoice(); }
				}
			}
		}
		case C_Sequence_Simple_PlaceStart: { // 18
			switch (_Input) {
				case CMapEditorPluginEvent::EInput::Menu					: G_MainMenu = True; ///< Open main menu
				case CMapEditorPluginEvent::EInput::CursorTurn		: RotateMacroblock(1); ///< Rotate start macroblock
				case CMapEditorPluginEvent::EInput::CursorPlace		: AddStartMacroblock2(); ///< Place start macroblock
				case CMapEditorPluginEvent::EInput::SwitchToRace	: ToggleColor();
				//case CMapEditorPluginEvent::EInput::CursorDelete	:
				//case CMapEditorPluginEvent::EInput::CursorPick	: 
			}
			if (_Device == Buttons2::Device_Keyboard()) {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::CursorRaise	: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorLower	: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorUp		: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorRight	: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorDown	: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorLeft	: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorTiltLeft	: {
						if (IsEditor(C_Editor_Advanced)) PrevStyle();
						else UI_MacroblockSelection::PrevMacroblock();
					}
					case CMapEditorPluginEvent::EInput::CursorTiltRight	:{
						if (IsEditor(C_Editor_Advanced)) NextStyle();
						else UI_MacroblockSelection::NextMacroblock();
					}
				}
			} else {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::IconUp			: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::IconRight		: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::IconDown		: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::IconLeft		: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorUp		: MoveMacroblock(CMapEditorPluginEvent::EInput::CursorRaise); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorRight	: UI_MacroblockSelection::NextMacroblock(); ///< Select next macroblock
					case CMapEditorPluginEvent::EInput::CursorDown	: MoveMacroblock(CMapEditorPluginEvent::EInput::CursorLower); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorLeft	: UI_MacroblockSelection::PrevMacroblock(); ///< Select previous macroblock
					case CMapEditorPluginEvent::EInput::Undo				: if (IsEditor(C_Editor_Advanced)) PrevStyle();
					case CMapEditorPluginEvent::EInput::Redo				: if (IsEditor(C_Editor_Advanced)) NextStyle();
				}
			}
		}
		case C_Sequence_Simple_BuildTrack: { // 19
			switch (_Input) {
				case CMapEditorPluginEvent::EInput::Menu					: G_MainMenu = True; ///< Open main menu
				case CMapEditorPluginEvent::EInput::CursorTurn		: if (IsEditor(C_Editor_Advanced)) SwitchMacroblockPlacement(UI_MacroblockSelection::GetMacroblockId(), True); ///< Switch placement
				case CMapEditorPluginEvent::EInput::CursorPlace		: {
					AddMacroblock2(UI_MacroblockSelection::GetMacroblockId()); ///< Connect macroblock
				}
				case CMapEditorPluginEvent::EInput::CursorDelete	: {
					if (CutPasteIsAllowed()) CutMacroblock(); ///< Cut the previous macroblock
					else RemoveMacroblock2(MapContent::GetLatestMacroblockUnitCoord(G_Mode, False), False); ///< Remove the previous macroblock
				}
				case CMapEditorPluginEvent::EInput::SwitchToRace	: ToggleColor();
				case CMapEditorPluginEvent::EInput::CursorUp			: if (CutPasteIsAllowed()) PasteMacroblock();
				case CMapEditorPluginEvent::EInput::CursorRight		: UI_MacroblockSelection::NextMacroblock(); ///< Select next macroblock
				case CMapEditorPluginEvent::EInput::CursorDown		: if (CutPasteIsAllowed()) SkipMacroblock();
				case CMapEditorPluginEvent::EInput::CursorLeft		: UI_MacroblockSelection::PrevMacroblock(); ///< Select previous macroblock
				case CMapEditorPluginEvent::EInput::CursorPick		: { if (IsEditor(C_Editor_Advanced)) G_MoveCursor = True; MoveMacroblock(<0,0,0>, False, False);}
			}
			if (_Device == Buttons2::Device_Keyboard()) {
				if (IsEditor(C_Editor_Advanced)) {
					switch (_Input) {
						case CMapEditorPluginEvent::EInput::CursorTiltLeft	: PrevStyle();
						case CMapEditorPluginEvent::EInput::CursorTiltRight	: NextStyle();
						case CMapEditorPluginEvent::EInput::CursorRaise			: UI_MacroblockSelection::PrevFamily(); 
						case CMapEditorPluginEvent::EInput::CursorLower			: UI_MacroblockSelection::NextFamily();
					}
				} else {
					switch (_Input) {
						case CMapEditorPluginEvent::EInput::CursorTiltLeft	:	UI_MacroblockSelection::PrevMacroblock();
						case CMapEditorPluginEvent::EInput::CursorTiltRight	: UI_MacroblockSelection::NextMacroblock();
						case CMapEditorPluginEvent::EInput::CursorRaise			: UI_MacroblockSelection::PrevMacroblock();
						case CMapEditorPluginEvent::EInput::CursorLower			: UI_MacroblockSelection::NextMacroblock(); 
					}
				}
			} else {
				if (IsEditor(C_Editor_Advanced)) {
					switch (_Input) {
						case CMapEditorPluginEvent::EInput::CursorLower	: UI_MacroblockSelection::PrevFamily(); 
						case CMapEditorPluginEvent::EInput::CursorRaise	: UI_MacroblockSelection::NextFamily();
						case CMapEditorPluginEvent::EInput::Undo				: PrevStyle();
						case CMapEditorPluginEvent::EInput::Redo				: NextStyle();
					}
				}
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::IconUp			: if (CutPasteIsAllowed()) PasteMacroblock(); // allow both Stick/Dpad
					case CMapEditorPluginEvent::EInput::IconRight		: UI_MacroblockSelection::NextMacroblock();
					case CMapEditorPluginEvent::EInput::IconDown		: if (CutPasteIsAllowed()) SkipMacroblock();
					case CMapEditorPluginEvent::EInput::IconLeft		: UI_MacroblockSelection::PrevMacroblock();
				}
			}
		}
		case C_Sequence_Simple_MoveCursor: { // 20
			switch (_Input) {
				case CMapEditorPluginEvent::EInput::Menu					: G_MainMenu = True; ///< Open main menu
				case CMapEditorPluginEvent::EInput::CursorTurn		: RotateMacroblock(1); ///< Rotate start macroblock
				case CMapEditorPluginEvent::EInput::CursorPlace		: {
					ExpertCursorPlace(UI_MacroblockSelection::GetMacroblockId()); ///< Place macroblock
				}
				case CMapEditorPluginEvent::EInput::CursorDelete	: { G_MoveCursor = False; CutMacroblock(); } ///< Cut the previous macroblock
				case CMapEditorPluginEvent::EInput::SwitchToRace	: ToggleColor();
				case CMapEditorPluginEvent::EInput::CursorPick		: {
					if (UI_Tuto::IsEnabled(UI_Tuto::Tuto_ConnectMode())) UI_Tuto::ValidateTuto(UI_Tuto::Tuto_ConnectMode());
					G_MoveCursor = False; ///< Disable move cursor move
				}
			}
			if (_Device == Buttons2::Device_Keyboard()) {
				switch (_Input) {
					// TAG:ICONONKB we don't have any button for families. Usually Raise/Lower are used, but needed here.
					//case CMapEditorPluginEvent::EInput::IconLeft	: if (IsEditor(C_Editor_Advanced))	UI_MacroblockSelection::PrevFamily();
					//case CMapEditorPluginEvent::EInput::IconRight	: if (IsEditor(C_Editor_Advanced))	UI_MacroblockSelection::NextFamily();
					case CMapEditorPluginEvent::EInput::CursorRaise	: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorLower	: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorUp		: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorRight	: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorDown	: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorLeft	: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorTiltLeft	: PrevStyle();
					case CMapEditorPluginEvent::EInput::CursorTiltRight	: NextStyle();
				}
			} else {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::CursorLower	: UI_MacroblockSelection::PrevFamily(); ///< Select previous family
					case CMapEditorPluginEvent::EInput::CursorRaise	: UI_MacroblockSelection::NextFamily(); ///< Select next family
					case CMapEditorPluginEvent::EInput::IconUp			: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::IconRight		: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::IconDown		: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::IconLeft		: MoveMacroblock(_Input); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorUp		: MoveMacroblock(CMapEditorPluginEvent::EInput::CursorRaise); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorRight	: UI_MacroblockSelection::NextMacroblock(); ///< Select next macroblock
					case CMapEditorPluginEvent::EInput::CursorDown	: MoveMacroblock(CMapEditorPluginEvent::EInput::CursorLower); ///< Move start macroblock
					case CMapEditorPluginEvent::EInput::CursorLeft	: UI_MacroblockSelection::PrevMacroblock(); ///< Select previous macroblock
					case CMapEditorPluginEvent::EInput::Undo				: PrevStyle();
					case CMapEditorPluginEvent::EInput::Redo				: NextStyle();
				}
			}
		}
		case C_Sequence_Simple_Test: { // 21
			switch (_Input) {
				case CMapEditorPluginEvent::EInput::Menu					: SetTestMode(False);
				//case CMapEditorPluginEvent::EInput::Undo				:
				//case CMapEditorPluginEvent::EInput::Redo				:
				//case CMapEditorPluginEvent::EInput::CursorRaise	:
				//case CMapEditorPluginEvent::EInput::CursorLower	:
				//case CMapEditorPluginEvent::EInput::CursorTurn	:
				case CMapEditorPluginEvent::EInput::CursorPlace		: StartTest(); ///< Spawn the player
				case CMapEditorPluginEvent::EInput::CursorDelete	: SetTestMode(False); ///< Leave test mode
				//case CMapEditorPluginEvent::EInput::SwitchToRace:
				//case CMapEditorPluginEvent::EInput::IconUp			:
				case CMapEditorPluginEvent::EInput::IconRight			: SelectSpawn(1); ///< Next checkpoint
				//case CMapEditorPluginEvent::EInput::IconDown		:
				case CMapEditorPluginEvent::EInput::IconLeft			: SelectSpawn(-1); ///< Previous checkpoint
				//case CMapEditorPluginEvent::EInput::CursorUp		: 
				case CMapEditorPluginEvent::EInput::CursorRight		: SelectSpawn(1); ///< Next checkpoint
				//case CMapEditorPluginEvent::EInput::CursorDown	: 
				case CMapEditorPluginEvent::EInput::CursorLeft		: SelectSpawn(-1); ///< Previous checkpoint
				//case CMapEditorPluginEvent::EInput::CursorPick	: 
			}
			if (_Device == Buttons2::Device_Pad()) {
				switch (_Input) {
					//case CMapEditorPluginEvent::EInput::RemoveAll	:
					case CMapEditorPluginEvent::EInput::CursorDelete: SetTestMode(False); ///< Leave test mode
				}
			} else {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::RemoveAll		: SetTestMode(False); ///< Leave test mode
					//case CMapEditorPluginEvent::EInput::CursorDelete	:
				}
			}
		}
		case C_Sequence_Simple_Deco: { // 22
			switch (_Input) {
				case CMapEditorPluginEvent::EInput::Menu					: G_MainMenu = True; ///< Open main menu
				case CMapEditorPluginEvent::EInput::CursorRaise		: if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::More();
				case CMapEditorPluginEvent::EInput::CursorLower		: if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::Less();
				case CMapEditorPluginEvent::EInput::CursorTurn		: DefaultDecoration(); ///< Use default decoration settings
				case CMapEditorPluginEvent::EInput::CursorPlace		: RandomDecorate2(False); ///< Generate random decoration
				case CMapEditorPluginEvent::EInput::CursorDelete	: CancelDecoration(); ///< Cancel decoration
				case CMapEditorPluginEvent::EInput::SwitchToRace	: ConfirmDecoration(); ///< Confirm the decoration
				//case CMapEditorPluginEvent::EInput::IconUp			:
				//case CMapEditorPluginEvent::EInput::IconRight		: 
				//case CMapEditorPluginEvent::EInput::IconDown		:
				//case CMapEditorPluginEvent::EInput::IconLeft		: 
				//case CMapEditorPluginEvent::EInput::CursorUp		:
				//case CMapEditorPluginEvent::EInput::CursorDown	:
				//case CMapEditorPluginEvent::EInput::CursorPick	:
			}
			if (_Device == Buttons2::Device_Keyboard()) {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::CursorLeft	: if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::PrevFamily();
					case CMapEditorPluginEvent::EInput::CursorRight	: if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::NextFamily();
				}
			} else {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::Undo				: if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::PrevFamily();
					case CMapEditorPluginEvent::EInput::Redo				: if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::NextFamily();
				}
			}
		}
		case C_Sequence_Simple_Outro: { // 23
			switch (_Input) {
				//case CMapEditorPluginEvent::EInput::Menu				:
				//case CMapEditorPluginEvent::EInput::Undo				:
				//case CMapEditorPluginEvent::EInput::Redo				:
				//case CMapEditorPluginEvent::EInput::CursorRaise	:
				//case CMapEditorPluginEvent::EInput::CursorLower	:
				//case CMapEditorPluginEvent::EInput::CursorTurn	:
				case CMapEditorPluginEvent::EInput::CursorPlace		: OutroMenuValid(); ///< Valid menu selection
				//case CMapEditorPluginEvent::EInput::CursorDelete:
				//case CMapEditorPluginEvent::EInput::SwitchToRace:
				//case CMapEditorPluginEvent::EInput::CursorPick	:
			}
			
			if (_Device == Buttons2::Device_Keyboard()) {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::CursorUp			: UI_MenuOutro::Prev(); ///< Previous selection in the menu
					case CMapEditorPluginEvent::EInput::CursorDown		: UI_MenuOutro::Next(); ///< Next selection in the menu
				}
			} else {
				switch (_Input) {
					case CMapEditorPluginEvent::EInput::CursorUp			: UI_MenuOutro::Prev(); ///< Previous selection in the menu
					case CMapEditorPluginEvent::EInput::IconUp				: UI_MenuOutro::Prev(); ///< Previous selection in the menu
					case CMapEditorPluginEvent::EInput::IconDown			: UI_MenuOutro::Next(); ///< Next selection in the menu
					case CMapEditorPluginEvent::EInput::CursorDown		: UI_MenuOutro::Next(); ///< Next selection in the menu
				}
			}
		}
	}
}
// ---------------------------------- //
/** Trigger inputs from the skin selection UI
 *
 *	@param	_EventType				The input to trigger
 *	@param	_EventData				The event data
 */
Void TriggerSkinInput(Text _EventType, Text[] _EventData) {
	switch (_EventType) {
		case UI_SkinSelection::Event_ToggleBgFg(): {
			UI_SkinSelection::ToggleBgFg();
		}
		case UI_SkinSelection::Event_SkinHover(): {
			UI_SkinSelection::SelectSkin(TL::ToInteger(_EventData[0]), True, True);
		}
		case UI_SkinSelection::Event_SkinClick(): {
			UI_SkinSelection::SelectSkin(TL::ToInteger(_EventData[0]), True, False);
		}
		case UI_SkinSelection::Event_SkinNext(): {
			SelectSkin(CMapEditorPluginEvent::EInput::CursorRight, False); ///< Select next skin
		}
		case UI_SkinSelection::Event_SkinPrev(): {
			SelectSkin(CMapEditorPluginEvent::EInput::CursorLeft, False); ///< Select next skin
		}
		case UI_SkinSelection::Event_SkinRestore(): {
			UI_SkinSelection::CancelPreview();
		}
	}
}

// ---------------------------------- //
/** Trigger an input
 *
 *	@param	_Input					The input to trigger
 */
Void TriggerInput(Text[][Text] _Input) {
	declare EventType = "";
	declare Text[] EventData;
	
	foreach (Type => Data in _Input) {
		EventType = Type;
		EventData = Data;
	}
	
	// Cancel input if a selection is ongoing
	if (Selection::IsSelecting() && !Selection::IsMoveEvent(EventType)) return;
	
	switch (G_CurrentSequence) {
		case C_Sequence_RerollMap: {
			switch (EventType) {
				case UI_SimpleChoice::Event_Click(): {
					declare Action = TL::ToInteger(EventData[0]);
					switch (Action) {						
						case C_SimpleChoice_RandomGenerate: RerollRandomMap(); ///< Reroll the track
						case C_SimpleChoice_RandomQuit		: CustomQuit();
						case C_SimpleChoice_RandomSave		: RandomGeneratorSave();
						case C_SimpleChoice_RandomPlay		: RandomGeneratorPlay();
					}
				}
			}
		}
		case C_Sequence_MainMenu: {
			if (IsSimpleEditor()) {
				switch (EventType) {
					case UI_SimpleMenu::Event_Hover(): UI_SimpleMenu::Select(TL::ToInteger(EventData[0]), True);
					case UI_SimpleMenu::Event_Click(): {
						UI_SimpleMenu::Select(TL::ToInteger(EventData[0]));
						MainMenuValid(); ///< Valid menu selection
					}
				}
			} else {
				switch (EventType) {
					case UI_Menu::Event_Hover(): UI_Menu::Select(TL::ToInteger(EventData[0]), True);
					case UI_Menu::Event_Click(): {
						UI_Menu::Select(TL::ToInteger(EventData[0]));
						MainMenuValid(); ///< Valid menu selection
					}
				}
			}
		}
		/*case C_Sequence_MapStyle: { // TAG: MapStyleSelection
			switch (EventType) {
				case UI_MapStyleSelection::Event_Hover(): UI_MapStyleSelection::Select(TL::ToInteger(EventData[0]), True);
				case UI_MapStyleSelection::Event_Click(): {
					UI_MapStyleSelection::Select(TL::ToInteger(EventData[0]));
					MapStyleValid(); ///< Valid track style selection
				}
				case UI_MapStyleSelection::Event_Confirm(): MapStyleValid(); ///< Valid track style selection
				case UI_MapStyleSelection::Event_Cancel():	MapStyleCancel(); ///< Cancel track style selection
			}
		}*/
		case C_Sequence_PlaceStart: {
			if (UI_MacroblockSelection::IsSelecting()) {
				switch (EventType) {
					case UI_MacroblockSelection::Event_FamilyPrev(): PrevStyle(); ///< Previous style
					case UI_MacroblockSelection::Event_FamilyNext(): NextStyle(); ///< Next style
					case UI_Header::Event_SelectMode(): {
						UI_MacroblockSelection::CloseRosaces();
						SelectMode(EventData[0]);
					}
					case UI_Header::Event_SwitchMode(): {
						SwitchMode(C_Categories_Construct); ///< Switch mode
					}
					case UI_Header::Event_ToggleAirMode(): ToggleAirMode();
					//case UI_Header::Event_ToggleGhostMode(): ToggleGhostMode();
					case UI_Header::Event_ToggleColor(): ToggleColor();
				}
			} else {
				TriggerSkinInput(EventType, EventData);
				switch (EventType) {
					case UI_Header::Event_SelectMode(): {
						SelectMode(EventData[0]);
					}
					case UI_Header::Event_SwitchMode(): {
						SwitchMode(C_Categories_Construct); ///< Switch mode
					}
					case UI_Header::Event_ToggleAirMode(): ToggleAirMode();
					//case UI_Header::Event_ToggleGhostMode(): ToggleGhostMode();
					case UI_Header::Event_ToggleColor(): ToggleColor();
					case UI_MouseControl::Event_GetCoordinates(): {
						declare ClickedCoord = GetMouseCoordAtHeight(Cursor.Coord.Y);
						if (ClickedCoord != <-1, -1, -1>) {
							if (ClickedOnBlock()) {
								AddStartMacroblock2(); ///< Place start macroblock
								if (IsEditor(C_Editor_Expert) && UI_Tuto::IsEnabledAndVisible(UI_Tuto::Tuto_PlaceBlock_Mouse())) {
									UI_Tuto::ValidateTuto(UI_Tuto::Tuto_PlaceBlock_Mouse());
									CheckTuto();
								}
							} else {
								MoveMacroblock(ClickedCoord - G_ForcedCursorCoord, False);
								ExpertCursorConnect(UI_MacroblockSelection::GetMacroblockId(), ClickedCoord); // note: is turned off
							}
						}
					}
				}
			}
		}
		/*case C_Sequence_ConnectMode: {
			switch (EventType) {
				case UI_Header::Event_SelectMode(): {
					SelectMode(EventData[0]);
				}
				case UI_Header::Event_SwitchMode(): {
					SwitchMode(C_Categories_Construct); ///< Switch mode
				}
			}
		}*/
		case C_Sequence_FreeMode: {
			ValidateTutoRosaces(EventType);
			if (UI_MacroblockSelection::IsSelecting()) {
				ValidateTutoRosaces(EventType);
				switch (EventType) {
					case UI_MacroblockSelection::Event_FamilyPrev(): PrevStyle();
					case UI_MacroblockSelection::Event_FamilyNext(): NextStyle();
					case UI_MacroblockSelection::Event_FilterPrev(): PrevStyleFilter();
					case UI_MacroblockSelection::Event_FilterNext(): NextStyleFilter();
					case UI_MacroblockSelection::Event_MacroblockPagePrev(): PrevMacroblocksPage();
					case UI_MacroblockSelection::Event_MacroblockPageNext(): NextMacroblocksPage();
					case UI_Header::Event_SelectMode(): {
						UI_MacroblockSelection::CloseRosaces();
						SelectMode(EventData[0]);
					}
					case UI_Header::Event_SwitchMode(): {
						SwitchMode(C_Categories_Construct); ///< Switch mode
					}
					case UI_Header::Event_ToggleAirMode(): ToggleAirMode();
					//case UI_Header::Event_ToggleGhostMode(): ToggleGhostMode();
					case UI_Header::Event_ToggleColor(): ToggleColor();
				}
			} else {
				TriggerSkinInput(EventType, EventData);
				switch (EventType) {
					case UI_Header::Event_SelectMode(): {
						SelectMode(EventData[0]);
					}
					case UI_Header::Event_SwitchMode(): {
						SwitchMode(C_Categories_Construct); ///< Switch mode
					}
					case UI_Header::Event_ToggleAirMode(): ToggleAirMode();
					//case UI_Header::Event_ToggleGhostMode(): ToggleGhostMode();
					case UI_Header::Event_ToggleColor(): ToggleColor();
					case UI_MouseControl::Event_GetCoordinates(): {
						declare ClickedCoord = GetMouseCoordAtHeight(Cursor.Coord.Y);
						if (ClickedCoord != <-1, -1, -1>) {
							if (ClickedOnBlock()) {
								ExpertCursorPlace(UI_MacroblockSelection::GetMacroblockId());
								if (IsEditor(C_Editor_Expert) && UI_Tuto::IsEnabledAndVisible(UI_Tuto::Tuto_PlaceBlock_Mouse())) {
									UI_Tuto::ValidateTuto(UI_Tuto::Tuto_PlaceBlock_Mouse());
									CheckTuto();
								}
							} else {
								MoveMacroblock(ClickedCoord - G_ForcedCursorCoord, False);
								ExpertCursorConnect(UI_MacroblockSelection::GetMacroblockId(), ClickedCoord); // note: is turned off
							}
						}
					}
				}
			}
		}
		case C_Sequence_TestMode: {
			switch (EventType) {
				case UI_SpawnSelection::Event_SpawnHover(): {
					GoToSpawn(TL::ToInteger(EventData[0]));
				}
				case UI_SpawnSelection::Event_SpawnClick(): {
					GoToSpawn(TL::ToInteger(EventData[0]));
					StartTest();
				}
				case UI_SpawnSelection::Event_SpawnNext(): {
					SelectSpawn(1); ///< Next checkpoint
				}
				case UI_SpawnSelection::Event_SpawnPrev(): {
					SelectSpawn(-1); ///< Previous checkpoint
				}
				case UI_Header::Event_SelectMode(): {
					SetTestMode(False);
					SelectMode(EventData[0]);
				}
				case UI_Header::Event_SwitchMode(): {
					SetTestMode(False);
					SwitchMode(C_Categories_Construct); ///< Switch mode
				}
				case UI_Header::Event_ToggleAirMode(): ToggleAirMode();
				//case UI_Header::Event_ToggleGhostMode(): ToggleGhostMode();
				case UI_Header::Event_ToggleColor(): ToggleColor();
			}
		}
		case C_Sequence_EditTerrain: {
			if (UI_MacroblockSelection::IsSelecting()) {
				switch (EventType) {
					case UI_Header::Event_SelectMode(): {
						UI_MacroblockSelection::CloseRosaces();
						SelectMode(EventData[0]);
					}
					case UI_Header::Event_SwitchMode(): {
						SwitchMode(C_Categories_Construct); ///< Switch mode
					}
					case UI_Header::Event_ToggleAirMode(): ToggleAirMode();
					//case UI_Header::Event_ToggleGhostMode(): ToggleGhostMode();
					case UI_Header::Event_ToggleColor(): ToggleColor();
				}
			} else {
				switch (EventType) {
					case UI_Header::Event_SelectMode(): {
						SelectMode(EventData[0]);
					}
					case UI_Header::Event_SwitchMode(): {
						SwitchMode(C_Categories_Construct); ///< Switch mode
					}
					case UI_Header::Event_ToggleAirMode(): ToggleAirMode();
					//case UI_Header::Event_ToggleGhostMode(): ToggleGhostMode();
					case UI_Header::Event_ToggleColor(): ToggleColor();
					default : {
						if (
							EventType == UI_MouseControl::Event_SelectionStart() ||
							EventType == UI_MouseControl::Event_SelectionUpdate() ||
							EventType == UI_MouseControl::Event_SelectionStop()
						) {
							declare ClickedCoord = GetMouseCoordOnGround();
							if (ClickedCoord != <-1, -1, -1>) {
								MoveTerrain(ClickedCoord - G_ForcedCursorCoord,	False);
							}
						}
					}
				}
			}
		}
		case C_Sequence_EditDecoration: {
			ValidateTutoRosaces(EventType);
			if (UI_MacroblockSelection::IsSelecting()) {
				ValidateTutoRosaces(EventType);
				switch (EventType) {
					case UI_Header::Event_SelectMode(): {
						UI_MacroblockSelection::CloseRosaces();
						SelectMode(EventData[0]);
					}
					case UI_Header::Event_SwitchMode(): {
						SwitchMode(C_Categories_Construct); ///< Switch mode
					}
					case UI_Header::Event_ToggleAirMode(): ToggleAirMode();
					//case UI_Header::Event_ToggleGhostMode(): ToggleGhostMode();
					case UI_Header::Event_ToggleColor(): ToggleColor();
				}
			} else {
				TriggerSkinInput(EventType, EventData);
				switch (EventType) {
					case UI_Header::Event_SelectMode(): {
						SelectMode(EventData[0]);
					}
					case UI_Header::Event_SwitchMode(): {
						SwitchMode(C_Categories_Construct); ///< Switch mode
					}
					case UI_Header::Event_ToggleAirMode(): ToggleAirMode();
					//case UI_Header::Event_ToggleGhostMode(): ToggleGhostMode();
					case UI_Header::Event_ToggleColor(): ToggleColor();
					case UI_MouseControl::Event_GetCoordinates(): {
						declare ClickedCoord = GetMouseCoordAtHeight(Cursor.Coord.Y);
						if (ClickedCoord != <-1, -1, -1>) {
							if (ClickedOnBlock()) {
								ExpertCursorPlace(UI_MacroblockSelection::GetMacroblockId());
								if (IsEditor(C_Editor_Expert) && UI_Tuto::IsEnabledAndVisible(UI_Tuto::Tuto_PlaceBlock_Mouse())) {
									UI_Tuto::ValidateTuto(UI_Tuto::Tuto_PlaceBlock_Mouse());
									CheckTuto();
								}
							} else {
								MoveMacroblock(ClickedCoord - G_ForcedCursorCoord, False);
								ExpertCursorConnect(UI_MacroblockSelection::GetMacroblockId(), ClickedCoord); // note: is turned off
							}
						}
					}
				}
			}
		}
		case C_Sequence_Simple_Terraforming: {
			switch (EventType) {
				case UI_StyleSelection::Event_StyleClick(): {
					if (IsEditor(C_Editor_Advanced)) { SelectStyle(EventData[0]); UpdateLandscapeChoice(); }
				}
				case UI_StyleSelection::Event_StylePrev(): {
					if (IsEditor(C_Editor_Advanced)) { PrevStyle(); UpdateLandscapeChoice(); }
				}
				case UI_StyleSelection::Event_StyleNext(): {
					if (IsEditor(C_Editor_Advanced)) { NextStyle(); UpdateLandscapeChoice(); }
				}
				case UI_StyleSelection::Event_StyleSelectLandscape(): {
					if (IsEditor(C_Editor_Advanced)) { SelectTerrain(); }
				}
				case UI_Header::Event_ToggleColor(): ToggleColor();
			}
		}
		case C_Sequence_Simple_PlaceStart: {
			switch (EventType) {
				case UI_MacroblockSelection::Event_MacroblockHover(): {
					UI_MacroblockSelection::Private_SelectMacroblock(TL::ToInteger(EventData[0]), True);
				}
				case UI_MacroblockSelection::Event_MacroblockClick(): {
					UI_MacroblockSelection::Private_SelectMacroblock(TL::ToInteger(EventData[0]));
					AddMacroblock2(UI_MacroblockSelection::GetMacroblockId());
				}
				case UI_StyleSelection::Event_StyleClick(): {
					if (IsEditor(C_Editor_Advanced)) SelectStyle(EventData[0]);
				}
				case UI_StyleSelection::Event_StylePrev(): {
					if (IsEditor(C_Editor_Advanced)) PrevStyle();
				}
				case UI_StyleSelection::Event_StyleNext(): {
					if (IsEditor(C_Editor_Advanced)) NextStyle();
				}
				case UI_MacroblockSelection::Event_FamilyClick(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::SelectFamily(EventData[0], True);
				}
				case UI_MacroblockSelection::Event_FamilyPrev(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::PrevFamily(); ///< Select previous family
				}
				case UI_MacroblockSelection::Event_FamilyNext(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::NextFamily(); ///< Select next family
				}
				case UI_MacroblockSelection::Event_MacroblockNext(): {
					UI_MacroblockSelection::NextMacroblock(); ///< Select next macroblock
				}
				case UI_MacroblockSelection::Event_MacroblockPrev(): {
					UI_MacroblockSelection::PrevMacroblock(); ///< Select previous macroblock
				}
				case UI_Header::Event_ToggleColor(): ToggleColor();
			}
		}
		case C_Sequence_Simple_BuildTrack: {
			switch (EventType) {
				case UI_MacroblockSelection::Event_MacroblockHover(): {
					UI_MacroblockSelection::Private_SelectMacroblock(TL::ToInteger(EventData[0]), True);
				}
				case UI_MacroblockSelection::Event_MacroblockClick(): {
					UI_MacroblockSelection::Private_SelectMacroblock(TL::ToInteger(EventData[0]));
					AddMacroblock2(UI_MacroblockSelection::GetMacroblockId());
				}
				case UI_StyleSelection::Event_StyleClick(): {
					if (IsEditor(C_Editor_Advanced)) SelectStyle(EventData[0]);
				}
				case UI_StyleSelection::Event_StylePrev(): {
					if (IsEditor(C_Editor_Advanced)) PrevStyle();
				}
				case UI_StyleSelection::Event_StyleNext(): {
					if (IsEditor(C_Editor_Advanced)) NextStyle();
				}
				case UI_MacroblockSelection::Event_FamilyClick(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::SelectFamily(EventData[0], True);
				}
				case UI_MacroblockSelection::Event_FamilyPrev(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::PrevFamily(); ///< Select previous family
				}
				case UI_MacroblockSelection::Event_FamilyNext(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::NextFamily(); ///< Select next family
				}
				case UI_MacroblockSelection::Event_MacroblockNext(): {
					UI_MacroblockSelection::NextMacroblock(); ///< Select next macroblock
				}
				case UI_MacroblockSelection::Event_MacroblockPrev(): {
					UI_MacroblockSelection::PrevMacroblock(); ///< Select previous macroblock
				}
				case CutPaste::Event_Paste(): {
					if (CutPasteIsAllowed()) PasteMacroblock();
				}
				case CutPaste::Event_Discard(): {
					if (CutPasteIsAllowed()) SkipMacroblock();
				}
				case UI_Header::Event_ToggleColor(): ToggleColor();
			}
		}
		case C_Sequence_Simple_MoveCursor: {
			switch (EventType) {
				case UI_MacroblockSelection::Event_MacroblockHover(): {
					UI_MacroblockSelection::Private_SelectMacroblock(TL::ToInteger(EventData[0]), True);
				}
				case UI_MacroblockSelection::Event_MacroblockClick(): {
					UI_MacroblockSelection::Private_SelectMacroblock(TL::ToInteger(EventData[0]));
					AddMacroblock2(UI_MacroblockSelection::GetMacroblockId());
				}
				case UI_StyleSelection::Event_StyleClick(): {
					if (IsEditor(C_Editor_Advanced)) SelectStyle(EventData[0]);
				}
				case UI_StyleSelection::Event_StylePrev(): {
					if (IsEditor(C_Editor_Advanced)) PrevStyle();
				}
				case UI_StyleSelection::Event_StyleNext(): {
					if (IsEditor(C_Editor_Advanced)) NextStyle();
				}
				case UI_MacroblockSelection::Event_FamilyClick(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::SelectFamily(EventData[0], True);
				}
				case UI_MacroblockSelection::Event_FamilyPrev(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::PrevFamily(); ///< Select previous family
				}
				case UI_MacroblockSelection::Event_FamilyNext(): {
					if (IsEditor(C_Editor_Advanced)) UI_MacroblockSelection::NextFamily(); ///< Select next family
				}
				case UI_MacroblockSelection::Event_MacroblockNext(): {
					UI_MacroblockSelection::NextMacroblock(); ///< Select next macroblock
				}
				case UI_MacroblockSelection::Event_MacroblockPrev(): {
					UI_MacroblockSelection::PrevMacroblock(); ///< Select previous macroblock
				}
				case UI_Header::Event_ToggleColor(): ToggleColor();
			}
		}
		case C_Sequence_Simple_Test: {
			switch (EventType) {
				case UI_SpawnSelection::Event_SpawnHover(): {
					GoToSpawn(TL::ToInteger(EventData[0]));
				}
				case UI_SpawnSelection::Event_SpawnClick(): {
					GoToSpawn(TL::ToInteger(EventData[0]));
					StartTest();
				}
				case UI_SpawnSelection::Event_SpawnNext(): {
					SelectSpawn(1); ///< Next checkpoint
				}
				case UI_SpawnSelection::Event_SpawnPrev(): {
					SelectSpawn(-1); ///< Previous checkpoint
				}
				case UI_Header::Event_ToggleColor(): ToggleColor();
			}
		}
		case C_Sequence_Simple_Deco: {
			switch (EventType) {
				case UI_DecoSelection::Event_DecoClick(): {
					UI_DecoSelection::SelectFamily(EventData[0], True);
				}
				case UI_DecoSelection::Event_DecoNext(): {
					if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::NextFamily();
				}
				case UI_DecoSelection::Event_DecoPrev(): {
					if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::PrevFamily();
				}
				case UI_DecoSelection::Event_DecoMore(): {
					if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::More();
				}
				case UI_DecoSelection::Event_DecoLess(): {
					if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::Less();
				}
				case UI_DecoSelection::Event_GaugeClick(): {
					if (IsEditor(C_Editor_Advanced)) UI_DecoSelection::SetRatio(EventData[0], TL::ToReal(EventData[1]));
				}
				case UI_SimpleChoice::Event_Click(): {
					declare Action = TL::ToInteger(EventData[0]);
					switch (Action) {
						case C_SimpleChoice_DecoGenerate: RandomDecorate2(False); ///< Generate random decoration
						case C_SimpleChoise_DecoValid	: ConfirmDecoration(); ///< Confirm the decoration
						case C_SimpleChoice_DecoCancel	: CancelDecoration(); ///< Cancel decoration
						case C_SimpleChoice_DecoDefault	: DefaultDecoration(); ///< Use default decoration settings
					}
				}
			}
		}
		case C_Sequence_Simple_Outro: {
			switch (EventType) {
				case UI_MenuOutro::Event_Hover(): UI_MenuOutro::Select(TL::ToInteger(EventData[0]), True);
				case UI_MenuOutro::Event_Click(): {
					UI_MenuOutro::Select(TL::ToInteger(EventData[0]));
					OutroMenuValid(); ///< Valid menu selection
				}
			}
		}
	}
}

/// Generate a full random track
Void RandomMap() {
	G_RandomMapGeneration = True;
	RandomStyles::ClearStyles();
	
	declare metadata GamepadEditor_RandomSeed for Map = -1;
	GamepadEditor_RandomSeed = -1;
	
	if (S_RandomMap_Config != "") {
		RandomStyles::ReadStyles(S_RandomMap_Config, True);
	} else {
		RandomStyles::ApplyStyles([S_RandomMap_Length, S_RandomMap_Speed, S_RandomMap_Style], True);
	}
	
	RandomStyles::LoadDefaultStyles();
	
	declare FirstRoll = True;
	G_RerollRandomMap = True;
	declare metadata Boolean GamepadEditor_RandomGenerationComplete for Map = False;
	declare MapCreated = GamepadEditor_RandomGenerationComplete;
	while (G_RerollRandomMap) {
		Camera.Zoom(CMapEditorCamera::EZoomLevel::Far);
		G_WaitingRerollAnswer = (!FirstRoll && MapContent::HasFinish()) || MapContent::HasFinish() || G_CancelGeneration || GamepadEditor_RandomGenerationComplete;
		SelectSequence();
		ClearInputBuffer();
		G_TerrainCanPress = False;
		while (G_WaitingRerollAnswer) {
			Yield();
			if (G_LeaveEditor) {
				CustomQuit();
				G_LeaveEditor = False;
			}
			
			if (G_RestartGeneration) {
				RerollRandomMap();
				G_RestartGeneration = False;
				break;
			}
			
			// Force sequence update when turning on/off HMD
			if (ManiaPlanet != Null && G_HMD_IsActive != ManiaPlanet.HMD_IsActive) {
				G_HMD_IsActive = ManiaPlanet.HMD_IsActive;
				OnSequenceStart(G_CurrentSequence);
			}
			
			foreach (Key => Input in G_InputBuffer) {
				TriggerInput(Input, G_DeviceBuffer[Key]);
			}
			foreach (Input in G_UIInputBuffer) {
				TriggerInput(Input);
			}
			ClearInputBuffer();
			G_TerrainCanPress = False;
		}
		SelectSequence();
		
		if (!G_RerollRandomMap) break;
		GamepadEditor_RandomGenerationComplete = False;
		G_TestedRandomMap = False;
		MapContent::RemoveAllContent();
		MapContent::SaveMapContent();
		
		// Init random seed
		if (FirstRoll && S_RandomMap_Seed != 0) {
			Random::Init(S_RandomMap_Seed);
		} else {
			Random::Init();
		}
		FirstRoll = False;
		
		// Get and save the seed used to create this track
		GamepadEditor_RandomSeed = Random::GetSeed();
		Utils::Log("[Random] Seed : "^GamepadEditor_RandomSeed);
		
		// Determine a length for the track
		// We have to do it event if it's already defined in the settings
		// This way the random seed will be valid with our without setting
		declare RandomLength = Random::Rand(0, 7);
		declare Length = "";
		if (RandomLength <= 3) Length = "short";
		else if (RandomLength <= 5) Length = "veryshort";
		else if (RandomLength <= 6) Length = "medium";
		else Length = "long";
		// Override length
		if (S_RandomMap_Length != "") Length = S_RandomMap_Length;
		RandomStyles::ApplyStyles([Length], False);
		
		G_CancelGeneration = False;
		
		Utils::LogToFile(C_LogToFile);
		Utils::ResetLogFile();
		LogRandomMap("[Random] Seed : "^GamepadEditor_RandomSeed);
		
		// Generate a complete track
		declare TriesNb = 1;
		while (TriesNb <= C_RandomMap_MaxTries && !G_CancelGeneration) {
			MapCreated = Private_RandomMap(True);
			if (MapCreated) break;
			TriesNb += 1;
		}
		
		// Generate a really simple track if all tries failed
		if (!MapCreated) {
			TriesNb = 1;
			while (TriesNb <= C_RandomMap_MaxTries && !G_CancelGeneration) {
				MapCreated = Private_RandomMap(False);
				if (MapCreated) break;
				TriesNb += 1;
			}
		}
		
		if (C_LogToFile) Utils::ViewLogFile();
		
		if(MapCreated){
			GamepadEditor_RandomGenerationComplete = True;
			MapContent::SaveMapContent();
		}
	}
	
	// Reset all and switch to manual mode if we failed to generate a track
	if (!MapCreated) {
		Reset();
	} 
	
	G_RandomMapGeneration = False;
}

// ---------------------------------- //
/// Initialize the deco families
Void InitDecoFamilies() {
	// Initialize deco selection UI
	declare DecoMacroblockModels = GetDecorationMacroblocks(False);
	declare Text[] DecoFamilies;
	foreach (Family => DecoMacroblocks in DecoMacroblockModels) {
		if (Family == "|Decoration|Podium" || Family == "|Decoration|Flying") continue;
		DecoFamilies.add(Family);
	}
	UI_DecoSelection::SetFamilies(DecoFamilies);
	//UI_DecoSelection::SetRatios(ThemePack::GetDecoRatios());
	UI_DecoSelection::SetColors(ThemePack::GetDecoColors());
	
	declare metadata Real[Text] GamepadEditor_DecoRatios for Map;
	declare DecoRatios = ThemePack::GetDecoRatios();
	foreach (Category => Ratio in GamepadEditor_DecoRatios) {
		if (DecoRatios.existskey(Category)) DecoRatios[Category] = Ratio;
	}
	UI_DecoSelection::SetRatios(DecoRatios);
}

/// Unload the plugin
Void Unload() {
	UI_Manager::Unload();	
	Collection::Unload();
	Transitions::Unload();
	ThemePack::Unload();
	RandomStyles::Unload();
	Terrain::Unload();
	Buttons::Unload();
	List::Unload();
	History2::Unload();
	CutPaste::Unload();
	MapContent::Unload();
	AutoFinish::Unload();
	Random::Unload();
	Sound::Unload();
	Layers::Unload();
	Macroblock::Unload();
}

// Load the plugin. The Load() functions of the libraries can call yield;
// Be careful because this results on lost events, etc ...
Void Load() {
	// Initialize default editor UI
	HideEditorInterface = !C_Debug;
	EnableEditorInputsCustomProcessing = True;
	Cursor.HideDirectionalArrow = True;
	Cursor.Brightness = C_CursorVisibility;
	HideBlockHelpers = C_HideBlockHelpers;
	ShowPlacementGrid = C_ShowPlacementGrid;
	EnableCursorShowingWhenInterfaceIsFocused = True;
	Utils::EnableLog(C_EnableLog);
	
	Unload();
	
	G_AllowCameraRotation = [C_Sequence_RerollMap, C_Sequence_SelectTerrain, C_Sequence_RandomTerrain, C_Sequence_PlaceStart, C_Sequence_FreeMode, C_Sequence_TestMode, C_Sequence_AutoFinish, C_Sequence_EditTerrain, C_Sequence_EditDecoration, C_Sequence_Simple_Terraforming, C_Sequence_Simple_PlaceStart, C_Sequence_Simple_BuildTrack, C_Sequence_Simple_MoveCursor, C_Sequence_Simple_Test, C_Sequence_Simple_Deco, C_Sequence_Simple_Outro];
	
	G_AllowCameraZoom = [C_Sequence_PlaceStart, C_Sequence_FreeMode, C_Sequence_TestMode, C_Sequence_AutoFinish, C_Sequence_EditTerrain, C_Sequence_EditDecoration, C_Sequence_Simple_PlaceStart, C_Sequence_Simple_BuildTrack, C_Sequence_Simple_MoveCursor, C_Sequence_Simple_Test, C_Sequence_Simple_Deco];

	if(GetMapType() != C_MapType)
		if(!SetMapType(C_MapType))
			Alert(
				_("|Warning|Caution"), 
				_("Race MapType has not been found or set. You might be unable to validate your track."),
				_("|Infinitive|Confirm")
			);
	
	// Load buttons before any other lib use them
	Buttons::Load();
	Buttons2::Load();

	// Display loading screen
	Layers::Load();
	UI_PopUp::Load();
	UI_PopUp::Loading(True, GetLoadingText(), True, False);
	
	tuningmark("macroblock::load");
	Macroblock::Load();	
	Yield();
	
	tuningmark("after::load");
	SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Unknown, CMapEditorPlugin::EditMode::FreeLook);
	G_RandomMapGeneration = S_RandomMap_Generate;
	
	declare Boolean IsNotAGamepadEditorMap = False;
	if (MapFileName != "" && GetMapName() == "") {
		IsNotAGamepadEditorMap = True;
	} else {
		declare metadata GamepadEditor_Setting_EditorLevel for Map = 0;
		// New track
		if (GetMapName() == "") {
			declare EditorLevel = S_EditorLevel;
			if (S_RandomMap_Generate) EditorLevel = C_Editor_Expert;
			G_Setting_EditorLevel = EditorLevel;
			GamepadEditor_Setting_EditorLevel = EditorLevel;
		} 
		// Load track
		else {
			G_Setting_EditorLevel = GamepadEditor_Setting_EditorLevel;
		}
	}
	Yield();
	
	// /!\ SYNCHRO OPERATION, EVENTS WILL BE LOST
	// Load theme pack
	ThemePack::Load(C_LogThemePack);
	ThemePack::UseRandomLandscapeGeneration(C_RandomLandscape);
	if (!G_RandomMapGeneration && IsEditor(C_Editor_Beginner)) {
		ThemePack::LoadConfig_Start(C_ThemePack_Beginner);
	} else if (!G_RandomMapGeneration && IsEditor(C_Editor_Advanced)) {
		ThemePack::LoadConfig_Start(C_ThemePack_Advanced);
	} else {
		ThemePack::LoadConfig_Start(C_ThemePack_Expert);
	}
	while (ThemePack::LoadConfig_IsLoading()) Yield();
	ThemePack::Sync_LoadConfig_End();
	ThemePack::Sync_GenerateMacroblockModelsList();
	
	if (C_LogThemePack && !ThemePack::LoadConfig_IsLoaded()) Utils::Log("Failed to load theme packs config file.");
	
	ThemePack::Select(0, 0, 0);
	
	Macroblock::SetDecoStyles(ThemePack::GetDecoStylesNames());
	Yield();
	
	SystemText::Load();
	Random::Load();
	MapContent::Load();
	CutPaste::Load();
	History2::Load();
	List::Load();
	Terrain::Load();
	RandomStyles::Load();
	Transitions::Load();
	// we currently never use autofinish in expert. Don't spend time loading it; it's heavy.
	if(S_RandomMap_Generate || !IsEditor(C_Editor_Expert)) AutoFinish::Load();
	Collection::Load();
	
	Yield(); ///< Yield before loading sounds because it takes a while
	Sound::Load(S_EnableSound);

	UI_Manager::Load(IsSimpleEditor(), IsEditor(C_Editor_Advanced));
	
	/*// Select track style
	declare metadata GamepadEditor_MapStyle for Map = UI_MapStyleSelection::Style_Race(); // TAG: MapStyleSelection
	UI_MapStyleSelection::Select(GamepadEditor_MapStyle);
	UI_MapStyleSelection::DisplayBackground(IsEditor(C_Editor_Expert));*/
	
	// Let the layers initialize their variables for Page
	Sleep(50);
	
	if (IsNotAGamepadEditorMap) {
		HoldLoadingScreen = False;
		Loading(False);
		Alert(_("This track has not been created with the Track Editor using a controller and is not supported. You will now return to the main menu."));
		CustomQuitNoConfirm();
	}
	
	if (GetMapName() == "") Utils::SetSaveStatus(Utils::SaveStatus_NotSaved());
	else Utils::SetSaveStatus(Utils::SaveStatus_Saved());
	
	UI_Header::SetLimit(C_CopperLimit_Hard);
	UI_Header::SetLimitVisibility(!S_RandomMap_Generate);
	CustomSelectionCoords.clear();
	Cursor.Brightness = C_CursorVisibility;
	SetFreeModeVariant(Macroblock::VariantNull());
	SetCursorCoord(<Map.Size.X/2, CollectionGroundY, Map.Size.Z/2>);
	
	G_RandomMacroblocks.clear();
	if (G_RandomMapGeneration) {
		foreach (MacroblockModel in MacroblockModels) {
			G_RandomMacroblocks.add(MacroblockModel); // why using this instead of MacroblockModels?
		}
	}
	Yield();
	
	G_CurrentSequence = C_Sequence_None;
	G_PrevSequence = C_Sequence_None;
	G_TestMode = False;
	G_PreviewTerrainTime = -1;
	G_PreviewTerrainId = "";
	G_AutoRepeatInput.clear();
	ClearInputBuffer();
	G_TerrainCanPress = False;
	G_CancelGeneration = False;
	G_LeaveEditor = False;
	G_StartingNewMap = !MapContent::HasStart();
	G_MainMenu = False;
	//G_MapStyleSelection = False; // TAG: MapStyleSelection
	G_IsSkinning = False;
	G_IsEditing = False;
	G_ForcedCursorCoord = Cursor.Coord;
	G_SavedCursorCoord.clear();
	G_LastRandomPlace = -1;
	G_InactivityStartTime = -1;
	G_AskForValidation = False;
	G_AvailableMacroblocks.clear();
	G_DiscardedMacroblocks.clear();
	G_AvailableConnectors.clear();
	G_CursorConnectedTo = -1;
	G_MacroblocksCount = 0;
	if (ManiaPlanet != Null) G_HMD_IsActive = ManiaPlanet.HMD_IsActive;
	G_NeedRebuild = IsSimpleEditor();
	G_MoveCursor = False;
	G_CanAskCheckpoint = False;
	G_TestedRandomMap = False;
	G_RebuildMap = False;
	G_CacheBlocksSkinsBg.clear();
	G_CacheBlocksSkinsFg.clear();
	G_Platform = Buttons2::System_PC();
	
	declare GamepadEditor_NeedSimpleBlock for Map = False;
	GamepadEditor_NeedSimpleBlock = True;
	
	Yield();
	if (IsTerraformed()) {
		InitConstructMode();
	} else {
		if (IsSimpleEditor()) SelectMode(C_Categories_Landscape, C_Modes_LandscapePostcards);
		else SelectMode(C_Categories_Construct, C_Modes_ConstructTrack);
	}
	
	Yield();
	SelectSequence();
	
	if (IsEditor(C_Editor_Advanced)) {
		InitDecoFamilies();
		UI_MacroblockSelection::DisplayNames(True);
		UI_Header::SetEditor(UI_Header::Editor_Advanced());
		UI_MacroblockSelection::SetEditor(UI_MacroblockSelection::Editor_Advanced());
	} else if (IsEditor(C_Editor_Beginner)) {
		InitDecoFamilies();
		UI_MacroblockSelection::DisplayNames(False);
		UI_Header::SetEditor(UI_Header::Editor_Beginner());
		UI_MacroblockSelection::SetEditor(UI_MacroblockSelection::Editor_Beginner());
	} else {
		if (G_RandomMapGeneration) UI_Header::SetEditor(UI_Header::Editor_Random());
		else UI_Header::SetEditor(UI_Header::Editor_Expert());
		UI_MacroblockSelection::SetEditor(UI_MacroblockSelection::Editor_Expert());
		UI_MacroblockSelection::SetStyle(ThemePack::GetTrackStyleName(), ThemePack::GetTrackStylePage(), ThemePack::GetTrackStylesCount());
	}
	G_FilterNextMacroblockClipList = CreateFixedClipList();

	Loading(False);
}

main() {
	// Force the default loading screen display until the plugin finish loading
	HoldLoadingScreen = True;
	// Hide the editor interface by default
	HideEditorInterface = True;
	
	// Don't use Yield() function before the librairies are loaded, because Yield() use these librairies (eg: gamepad disconnected window, TRAC-1751)
	yield; //< Script compilation complete, yield to go to next frame
	
	// Create a copy of the track
	if (S_CreateCopy) CopyMap();
	
	Load();
	
	declare PrevSelectedModelIdUpdate = UI_MacroblockSelection::GetMacroblockUpdate();
	declare PrevSelectedSkinUpdate = UI_SkinSelection::GetSkinUpdate();
	declare PrevAddTerrain = False;
	declare PrevRemoveTerrain = False;
	declare CursorPlaceStart = -1;
	declare CursorPlaceSequence = C_Sequence_None;
	declare PrevCopperPrice = 0;
	declare CanShowSoftLimit = True;
	declare AskCheckpoint = False;
	declare MustSaveMapContentTick = C_Tick_SaveMapContent;
	
	Camera.GetLock();
	Cursor.GetLock();
	
	Camera.ActivateScrollRotateMode(True);
	Camera.IgnoreCameraCollisions(True);
	
	HoldLoadingScreen = False;
	// If the track is already validated, don't rebuild because it'd unvalidate, reload it only when editing
	if (G_NeedRebuild && (ValidationStatus != CMapEditorPlugin::ValidationStatus::Validated)) {
		RebuildMap();
	}
	else{
		MapContent::ReloadMapContent();
		declare LatestMBInstance = MapContent::GetLatestTypedMacroblockInstance(C_Modes_ConstructTrack, True);
		if(LatestMBInstance != Null){
			Loading(True, GetLoadingText(), False);
			Yield();
			SetTrackCursorCoord(True, LatestMBInstance);
			G_CurrentSequence = C_Sequence_None;
			G_PrevSequence = C_Sequence_None;
			Yield();
			SelectSequence();
			Yield();	
		}
		Loading(False, "", False);
	}
	
	// Clear inputs done during loading
	ClearInputBuffer();
	
	declare Boolean QuitPlugin = False;
	if(MacroblockModels.count <= 0){
		QuitPlugin = Confirm(
				("No macroblocks found"),
				ComposeMultilines([
					_("There are no macroblocks available for this editor."),
					_("Do you want to quit the plugin or return to the editor?")
				]),
				_("Quit plugin"), 
				_("Quit editor")
			);
			
			if(!QuitPlugin)
				CustomQuitNoConfirm();
	}
	// Run a random generation
	while (!QuitPlugin && S_RandomMap_Generate) {
		RandomMap();
	}
	
	//AutoSave();
	Yield();
	
	G_AutoRepeatInput.clear();
	ClearInputBuffer();
	ResetAutoRepeat();
	
	if(!QuitPlugin)
	while (True) {
		Yield();
		
		if(MapContent::MustSaveMapContent() && !G_RebuildMap) // don't save while we're using medatata to rebuild
		{
			MustSaveMapContentTick -=1;
			if(MustSaveMapContentTick <= 0){
				MapContent::SaveMapContent();
				
				MustSaveMapContentTick = C_Tick_SaveMapContent;
			}
		}
		
		if (BackToMainMenuRequested) {
			CustomSaveMap(True);
			CustomQuitNoConfirm();
		}
		
		// Force sequence update when turning on/off HMD
		if (ManiaPlanet != Null && G_HMD_IsActive != ManiaPlanet.HMD_IsActive) {
			G_HMD_IsActive = ManiaPlanet.HMD_IsActive;
			OnSequenceStart(G_CurrentSequence);
		}
			
		// Select the sequence to use
		SelectSequence();
		
		// User input
		foreach (Key => Input in G_InputBuffer) {
			if (G_DeviceBuffer.existskey(Key)) { ///< The two arrays can be cleared during TriggerInput, so we must check they are not empty
				TriggerInput(Input, G_DeviceBuffer[Key]);
			}
		}
		foreach (Input in G_UIInputBuffer) {
			TriggerInput(Input);
		}
		ClearInputBuffer();
		
		if (G_CurrentSequence != C_Sequence_EditTerrain) G_TerrainCanPress = False;
		// Select the sequence to use
		SelectSequence();
		
		// Tell the Header UI on whether the Rosace is visible.
		if (IsEditor(C_Editor_Expert)) {
			UI_Header::SetRosaceIsVisible(UI_MacroblockSelection::IsSelecting());
		}
		
		// Check copper limit
		if (PrevCopperPrice != Map.CopperPrice && MustCheckCoppersLimit()) {
			PrevCopperPrice = Map.CopperPrice;
			
			if (!CanShowSoftLimit && Map.CopperPrice < C_CopperLimit_Soft - 250) CanShowSoftLimit = True;
			if (CanShowSoftLimit && Map.CopperPrice > C_CopperLimit_Soft) {
				CanShowSoftLimit = False;
				Alert(
					_("|Warning|Caution"), 
					_("Your track may cause performance issues when played with lower end systems. Pay attention to the top left indicator to help you increase the performance of your tracks."),  // copied from C++
					_("|Infinitive|Confirm")
				);
			}
		}
		// ---------------------------------- //
		// Free mode
		if (G_CurrentSequence == C_Sequence_FreeMode) {
			if (PrevSelectedModelIdUpdate != UI_MacroblockSelection::GetMacroblockUpdate()) {
				PrevSelectedModelIdUpdate = UI_MacroblockSelection::GetMacroblockUpdate();
				
				declare MacroblockId = UI_MacroblockSelection::GetMacroblockId();
				if (MacroblockId != NullId) PreviewMacroblock(MacroblockId, True);
			}
			
			if (PrevSelectedSkinUpdate != UI_SkinSelection::GetSkinUpdate()) {
				PrevSelectedSkinUpdate = UI_SkinSelection::GetSkinUpdate();
				SetSkins(UI_SkinSelection::GetSkinNameBg(), UI_SkinSelection::GetSkinNameFg());
			}
		}
		// ---------------------------------- //
		// Place a start block
		else if (IsPlacingStart()) {
			if (PrevSelectedModelIdUpdate != UI_MacroblockSelection::GetMacroblockUpdate()) {
				PrevSelectedModelIdUpdate = UI_MacroblockSelection::GetMacroblockUpdate();
				PreviewMacroblock(UI_MacroblockSelection::GetMacroblockId(), True);
				CheckTuto();
			}
			
			if (PrevSelectedSkinUpdate != UI_SkinSelection::GetSkinUpdate()) {
				PrevSelectedSkinUpdate = UI_SkinSelection::GetSkinUpdate();
				SetSkins(UI_SkinSelection::GetSkinNameBg(), UI_SkinSelection::GetSkinNameFg());
			}
		}
		// ---------------------------------- //
		// Place terrain
		else if (G_CurrentSequence == C_Sequence_SelectTerrain) {
			//PreviewTerrain(UI_LandscapeSelection::GetTerrainId());
		}
		// ---------------------------------- //
		// Edit terrain
		else if (G_CurrentSequence == C_Sequence_EditTerrain) {
			if (PrevSelectedModelIdUpdate != UI_MacroblockSelection::GetMacroblockUpdate()) {
				PrevSelectedModelIdUpdate = UI_MacroblockSelection::GetMacroblockUpdate();
				PreviewTerrainBlock(UI_MacroblockSelection::GetMacroblockId());
				SetCursorStyle();
			}
			
			declare MouseLeftButton = UI_MouseControl::MouseLeftButton();
			
			if (!G_TerrainCanPress) {
				G_TerrainCanPress = !MouseLeftButton && !EditorInputIsDown_CursorPlace && !EditorInputIsDown_CursorDelete;
			}
			
			declare CursorPlace = (
				G_TerrainCanPress &&
				(EditorInputIsDown_CursorPlace || MouseLeftButton) &&
				!EditorInputIsDown_CursorDelete
			);
			declare CursorDelete = (
				G_TerrainCanPress &&
				!EditorInputIsDown_CursorPlace &&
				(EditorInputIsDown_CursorDelete || MouseLeftButton)
			);
			if (CursorPlace && CursorDelete) {
				if (PrevAddTerrain) CursorDelete = False;
				else if (PrevRemoveTerrain) CursorPlace = False;
				else CursorDelete = False;
			}

			if (PrevAddTerrain != CursorPlace) {
				PrevAddTerrain = CursorPlace;
				
				/* Newer code would be this, but didn't add "AddTerrain2" and "RemoveTerrain2" because we don't have any terrain
					if (PrevAddTerrain != CursorPlace) {
						PrevAddTerrain = CursorPlace;
						AddTerrain2(CursorPlace);
					}
					
					if (PrevRemoveTerrain != CursorDelete) {
						PrevRemoveTerrain = CursorDelete;
						RemoveTerrain2(CursorDelete);
					}
				*/
				
				// Start selection
				if (CursorPlace) {
					Selection::Start(Cursor.Coord);
					Selection::SetColor(<0., 0., 0.3>);
					Selection::Show();
				} 
				// Stop selection
				else if (!CursorPlace) {
					if (Cursor.TerrainBlockModel != Null) {
						Selection::Stop(Cursor.Coord);
						AddTerrain2(Cursor.TerrainBlockModel, Selection::GetStart(), Selection::GetEnd());
					}
					Selection::Hide();
					Selection::Destroy();
					SetCursorStyle();
				}
			}
			
			if (PrevRemoveTerrain != CursorDelete) {
				PrevRemoveTerrain = CursorDelete;
				
				// Start selection
				if (CursorDelete) {
					SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Terraform, CMapEditorPlugin::EditMode::Erase);
					Selection::Start(Cursor.Coord);
					Selection::SetColor(<0.3, 0.3, 0.3>);
					Selection::Show();
				} 
				// Stop selection
				else if (!CursorDelete) {
					SetPlaceAndEditModes(CMapEditorPlugin::PlaceMode::Terraform, CMapEditorPlugin::EditMode::Place);
					Selection::Stop(Cursor.Coord);
					RemoveTerrain2(Selection::GetStart(), Selection::GetEnd());
					Selection::Hide();
					Selection::Destroy();
					SetCursorStyle();
				}
			}
		}
		// ---------------------------------- //
		// Edit decoration
		else if (G_CurrentSequence == C_Sequence_EditDecoration) {
			if (PrevSelectedModelIdUpdate != UI_MacroblockSelection::GetMacroblockUpdate()) {
				PrevSelectedModelIdUpdate = UI_MacroblockSelection::GetMacroblockUpdate();
				PreviewMacroblock(UI_MacroblockSelection::GetMacroblockId(), True);
			}
			
			if (PrevSelectedSkinUpdate != UI_SkinSelection::GetSkinUpdate()) {
				PrevSelectedSkinUpdate = UI_SkinSelection::GetSkinUpdate();
				SetSkins(UI_SkinSelection::GetSkinNameBg(), UI_SkinSelection::GetSkinNameFg());
			}
		}
		// ---------------------------------- //
		// Simple terraforming
		else if (G_CurrentSequence == C_Sequence_Simple_Terraforming) {
			declare metadata Text GamepadEditor_TerrainId for Map;
			G_PreviewTerrainId = GamepadEditor_TerrainId;
		}
		// ---------------------------------- //
		// Simple automatic terraforming
		else if (G_CurrentSequence == C_Sequence_Simple_AutoTerrain) {
			if (!IsTerraformed()) {
				RandomLandscape(True, False);
				// Save terrain
				declare metadata Boolean GamepadEditor_IsTerraformed for Map;
				declare metadata Text GamepadEditor_TerrainId for Map;
				GamepadEditor_IsTerraformed = True;
				if (GamepadEditor_TerrainId == "") GamepadEditor_TerrainId = "Beginner";
				G_PreviewTerrainTime = -1;
				G_PreviewTerrainId = GamepadEditor_TerrainId;
			}
		}
		// ---------------------------------- //
		// Simple build track
		else if (G_CurrentSequence == C_Sequence_Simple_BuildTrack) {
			if (PrevSelectedModelIdUpdate != UI_MacroblockSelection::GetMacroblockUpdate()) {
				PrevSelectedModelIdUpdate = UI_MacroblockSelection::GetMacroblockUpdate();
				PreviewMacroblock(UI_MacroblockSelection::GetMacroblockId(), UI_MacroblockSelection::GetMacroblockPlacement(), False);
			}
			
			if (IsEditor(C_Editor_Advanced) && GetStartLineBlock() == Null && MapContent::Count() > 0) {
				Alert(
					_("|Alert window title|Warning"), 
					_("You can't remove the starting line of the track."),
					_("|Infinitive|Cancel")
				);
				UndoHistory2();
			}
			
			// Remove the last placed block if no macroblocks are available to continue the track
			if (IsEditor(C_Editor_Beginner) && G_MacroblocksCount <= 0 && MapContent::HasStart() && !MapContent::HasFinish()) {
				Alert(
					_("Dead end"),
					_("The track is in a dead end. Try to go in another direction"),
					_("|Infinitive|Cancel")
				);
				declare TotalBeforeRemove = MapContent::Count();
				UndoHistory2();
				
				// Couldn't remove the block, reset the track
				if (MapContent::Count() >= TotalBeforeRemove) {
					Reset();
				}
			}
			
			if (IsEditor(C_Editor_Beginner)) {
				declare LastCheckpointDistance = MapContent::GetDistanceTo(MapContent::Block_Checkpoint());
				if (LastCheckpointDistance < 300. && !AskCheckpoint) AskCheckpoint = True;
				if (
					G_AvailableCheckpoint != NullId &&
					G_CanAskCheckpoint &&
					AskCheckpoint &&
					LastCheckpointDistance > C_CheckpointGap
				) {
					declare PlaceCheckpoint = Confirm(
						_("Try to place checkpoints regularly"), 
						_("Do you want to place a checkpoint now?"), 
						_("Yes"),
						_("No")
					);
					
					if (PlaceCheckpoint) {
						AddMacroblock2(G_AvailableCheckpoint);
					}
					
					AskCheckpoint = False;
				}
			}
			G_CanAskCheckpoint = False;
		} 
		// ---------------------------------- //
		// Simple move cursor
		else if (G_CurrentSequence == C_Sequence_Simple_MoveCursor) {
			if (PrevSelectedModelIdUpdate != UI_MacroblockSelection::GetMacroblockUpdate()) {
				PrevSelectedModelIdUpdate = UI_MacroblockSelection::GetMacroblockUpdate();
				
				declare MacroblockId = UI_MacroblockSelection::GetMacroblockId();
				if (MacroblockId != NullId) PreviewMacroblock(MacroblockId, True);
			}
		}
		// ---------------------------------- //
		// Outro menu
		else if (G_CurrentSequence == C_Sequence_Simple_Outro) {
			if (G_AskForValidation) {
				if (IsEditor(C_Editor_Beginner)) {
					RandomDecorate2(False);
				}
				
				if (ConfirmValidate()) {
					CustomValidate();
					Sleep(250);
				}
				
				G_AskForValidation = False;
			} else if (!UI_MenuOutro::LayerIsVisible()) {
				UI_Manager::Show(UI_Manager::C_File_MenuOutro);
			}
		}
		
		if (UI_SkinSelection::MustAutoSaveAfterSkinChangeAndUIHide()) {
			declare SkinCoord = UI_SkinSelection::GetLastSkinnedCoord();
			
			declare CMacroblockModel MacroblockModel = Null;
			declare SkinMacroblockInstance = GetMacroblockInstanceFromUnitCoord(SkinCoord);
			if (SkinMacroblockInstance != Null)
				MacroblockModel = SkinMacroblockInstance.MacroblockModel;
			else
				MacroblockModel = Cursor.MacroblockModel;
			
			declare Ident MacroblockModelId = NullId;
			if (MacroblockModel != Null) MacroblockModelId = MacroblockModel.Id;
			
			SaveHistory2(History2::Action_EditSkin(), G_Mode, MacroblockModelId, SkinCoord, Cursor.Dir);
		}
	}
	
	Unload();
	EnableEditorInputsCustomProcessing = False;
	HideEditorInterface = False;
	Cursor.Brightness = 1.;
}