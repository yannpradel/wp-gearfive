/**
 *	Display the player record for the season or overall
 */
#Const Version		"2023-03-31"
#Const ScriptName "ManiaApps/Nadeo/TMxSM/Race/UIModules/Record_Client.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/ManiaView2.Script.txt" as MV
#Include "Libs/Nadeo/MenuLibs/Common/Components/Grid.Script.txt" as Grid
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/Helpers.Script.txt" as MLHelpers
#Include "Libs/Nadeo/ModeLibs/Common/UIModules_Client.Script.txt" as UIModules
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/ButtonIcon2.Script.txt" as ButtonIcon
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/MedalStack.Script.txt" as MedalStack
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/PlayerName.Script.txt" as PlayerName
#Include "Libs/Nadeo/MenuLibs/Common/FontManager.Script.txt" as FontManager
#Include "Libs/Nadeo/MenuLibs/Common/Modes/Medals.Script.txt" as Medals
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/LoadingSpinner.Script.txt" as LoadingSpinner
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/Scroll.Script.txt" as Scroll
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/Navigation.Script.txt" as Navigation
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/Record_Common.Script.txt" as Record
#Include "Libs/Nadeo/CommonLibs/Common/Http.Script.txt" as Http
#Include "Libs/Nadeo/CommonLibs/Common/Task.Script.txt" as Task
#Include "Libs/Nadeo/CommonLibs/Common/Privileges.Script.txt" as Privileges
#Include "Libs/Nadeo/CommonLibs/Common/MainUser.Script.txt" as MainUser
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Components/Checkbox.Script.txt" as Checkbox
#Include "Libs/Nadeo/TMNext/TrackMania/ColorPalette.Script.txt" as ColorPalette
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Constants.Script.txt" as Const
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Components/Button.Script.txt" as Button
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Components/ExpendableButton.Script.txt" as ExpendableButton
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Components/ProfilePlayerInfo.Script.txt" as ProfilePlayerInfo
#Include "Libs/Nadeo/TMNext/TrackMania/API/LeaderboardAPI.Script.txt" as LeaderboardAPI
#Include "Libs/Nadeo/TMNext/TrackMania/Stores/ClubStore_MA.Script.txt" as ClubStore
#Include "Libs/Nadeo/TMNext/TrackMania/API/ClubAPI.Script.txt" as ClubAPI
#Include "Libs/Nadeo/TMNext/TrackMania/Structures/ClubStruct.Script.txt" as ClubStruct
#Include "Libs/Nadeo/TMNext/TrackMania/Stores/UserStore_MA.Script.txt" as UserStore_MA
#Include "Libs/Nadeo/TMNext/TrackMania/Stores/UserStore_ML.Script.txt" as UserStore_ML
#Include "Libs/Nadeo/TMNext/TrackMania/RBAC.Script.txt" as RBAC
#Include "Libs/Nadeo/TMNext/TrackMania/Modes/Constants.Script.txt" as ModeConst

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Structures
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Struct K_Celebration {
	Boolean IsActive;
	Integer PrevTime;
	Integer BestTime;
	Integer PrevMedal;
	Integer BestMedal;
}

#Struct K_RecordGhost {
	Text AccountId;
	Ident GhostId;
	Ident GhostInstanceId;
	Task::K_Task Task_RetrieveGhost;
	Task::K_Task Task_RetrieveRecords;
}

#Struct K_State {
	Integer SetupUpdate;
	Integer ForceMapUpdate;
	Boolean AlwaysDisplayRecords;
	Boolean ReloadRecords;
	Boolean PBGhostEnabled;
	Boolean DisplayPBGhost;
	Boolean MedalEnabled;
	Boolean CelebratePB;
	Boolean CelebrateMedal;
	Text CurrentMapUid;
	Ident TaskIdGetRecordGhost;
	Ident PBGhostId;
	Ident PBGhostInstanceId;
	Ident PBCpSyncedGhostInstanceId;
	Text ScopeSeason;
	Text ScopeNotSeason;
	Text ModeName;
	Text CustomData;
	Text[Text] SeasonIds;
	Boolean RequestCelebration;
	K_Celebration Celebration;
	Integer CurrentMedal;
	Boolean RecordsEnabled;
	Integer MapAvailaibleOnNadeoServices;
	Task::K_Task TaskGetMapFromUid;
	Boolean PlayerIsDisplayingRecords;
	Integer RecordsSelectedZone;
	Integer RecordsPlayerTime;
	Integer RecordsServerUpdate;
	Integer[] RecordsAreDirty;
	Integer[] RecordsNeedInit;
	Boolean RequestRecordsInProgress;
	Integer[] RecordsErrorCodes;
	Http::K_Request RequestZonesTopRecords;
	Http::K_Request RequestZonesSurroundingRecords;
	Http::K_Request RequestClubTopRecords;
	Http::K_Request RequestClubSurroundingRecords;
	Http::K_Request RequestClubVIPList;
	Http::K_Request RequestGlobalVIPList;
	Ident TaskIdGetClubVIPRecords;
	Ident TaskIdGetGlobalVIPRecords;
	LeaderboardAPI::K_ResponseFromGetMapTopRankings ResponseZonesTopRecords;
	LeaderboardAPI::K_ResponseFromGetSurroundingRankings ResponseZonesSurroundingRecords;
	LeaderboardAPI::K_ResponseFromGetMapTopRankingsInClub ResponseClubTopRecords;
	LeaderboardAPI::K_ResponseFromGetMapSurroundingRankingsInClub ResponseClubSurroundingRecords;
	Integer[Text] ResponseClubVIPRecords;
	Integer[Text] ResponseGlobalVIPRecords;
	Boolean LoadingRecords;
	Text RecordsLoadedForMapUid;
	Text RecordsLoadingForMapUid;
	Ident TaskIdRetrieveDisplayName;
	Integer RecordsClubId;
	Text RecordsClubName;
	Record::K_TMxSM_Record_Records[] ZonesRecords;
	K_RecordGhost[Text] LoadingRecordGhosts;
	K_RecordGhost[Text] LoadedRecordGhosts;
	K_RecordGhost SpectatorTargetRecordGhost;
	Boolean ManialinkIsInitialized;
	Boolean CanViewLeaderboards;
	Privileges::K_PrivilegeCheck LeaderboardPrivilegeCheck;
}

#Struct K_Scope {
	Text Type;
	Text Id;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_Name "component-tmxsm-record"
#Const P "LibTMxSMRecord_"
#Const C_NavGroupName "navgroup-tmxsm-record"
#Const C_NavGroup_Global "navgroup-tmxsm-record-global"
#Const C_ForceMedalScope "PersonalBest"
#Const C_ForceRecordScope "PersonalBest"

#Const C_Col_Rank 0
#Const C_Col_Name 1
#Const C_Col_Time 2
#Const C_Col_ToggleGhost 3

#Const C_RecordStatus_Loading 0
#Const C_RecordStatus_Loaded 1
#Const C_RecordStatus_Followed 2

#Const C_RecordType_None 0
#Const C_RecordType_Zones 1
#Const C_RecordType_Club 2
#Const C_RecordType_ClubVIP 3
#Const C_RecordType_GlobalVIP 4
#Const C_RecordTypes [1, 2, 3, 4]

#Const C_RecordsError_CouldNotLoadZonesTop 1
#Const C_RecordsError_CouldNotLoadZonesSurround 2
#Const C_RecordsError_CouldNotLoadClubTop 3
#Const C_RecordsError_CouldNotLoadClubSurround 4
#Const C_RecordsError_CouldNotGetClubVIPList 5
#Const C_RecordsError_CouldNotGetClubVIPRecords 6
#Const C_RecordsError_CouldNotGetGlobalVIPList 7
#Const C_RecordsError_CouldNotGetGlobalVIPRecords 8
#Const C_RecordsError_MapNotFound 9

#Const C_NLSError_MapNotFound "NLS::Leaderboard::MapNotFound"

#Const C_Event_SpectateGhost "TMxSM_Race_Record_SpectateGhost"
#Const C_Event_ToggleGhost "TMxSM_Race_Record_ToggleGhost"
#Const C_Event_TogglePB "TMxSM_Race_Record_TogglePB"

#Const C_MedalToUnlockWorldRecords 4 //< == ScoreMgr::C_ScoreMgrMedal_Author
#Const C_MedalToUnlockClubRecords 3 //< == ScoreMgr::C_ScoreMgrMedal_Gold
#Const C_MedalToUnlockGlobalVIPRecords 4 //< == ScoreMgr::C_ScoreMgrMedal_Author

#Const C_FakeZone_Club "_Club_"
#Const C_FakeZone_ClubVIP "_ClubVIP_"
#Const C_FakeZone_GlobalVIP "_GlobalVIP_"

#Const C_Sound_MedalIntro "SoloMedalIntro"
#Const C_Sound_MedalGainBronze "SoloMedalGainBronze"
#Const C_Sound_MedalGainSilver "SoloMedalGainSilver"
#Const C_Sound_MedalGainGold "SoloMedalGainGold"
#Const C_Sound_MedalGainAuthor "SoloMedalGainAuthor"
#Const C_Sound_MedalOutro "SoloMedalOutro"

#Const C_MapAvailable_NotChecked 0
#Const C_MapAvailable_Available 1
#Const C_MapAvailable_NotAvailable 2

#Const C_Row_Select 0
#Const C_Row_Action1 1
#Const C_Row_Action2 2
#Const C_Row_Cancel 3
#Const C_ControllerInfos [
	//L16N [Record] Text displayed to inform the player how to spectate the ghost of the focused record when navigating through the records UI with a controller.
	0 => ["select", _("Spectate ghost")],
	//L16N [Record] Text displayed to inform the player how to toggle the ghost of the focused record when navigating through the records UI with a controller.
	1 => ["action1", _("Toggle ghost")],
	//L16N [Record] Text displayed to inform the player how to consult the profile of the player when navigating through the records UI with a controller.
	2 => ["action2", _("Show profile")],
	//L16N [Record] Text displayed to inform the player how to go back to the race when navigating through the records UI with a controller.
	3 => ["cancel", _("Back to race")]
]

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Globales
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
declare Text[Integer] G_RecordPermission;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the id of the UI module
Text GetId() {
	return Record::C_Id;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the type of layer of the UI module
CUILayer::EUILayerType GetLayerType() {
	return Record::C_LayerType;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the record component
Text Component() {
	return MV::Component(
		C_Name,
		"",
		"",
		"""
Boolean {{{P}}}IsRecordsModuleAvailable() {
	declare Boolean Race_Record_IsRecordsModuleDisplayed for ClientUI;
	return Race_Record_IsRecordsModuleDisplayed;
}

Boolean {{{P}}}IsControllerNavigationEnabled() {
	declare Boolean Race_Record_IsControllerNavigationEnabled for ClientUI;
	return Race_Record_IsControllerNavigationEnabled;
}

Boolean {{{P}}}UpdateControllerNavigationState(Boolean _NewState) {
	declare Boolean Race_Record_IsControllerNavigationEnabled for ClientUI;
	Race_Record_IsControllerNavigationEnabled = _NewState;
	return _NewState;
}
Boolean {{{P}}}EnableControllerNavigation() {
	return {{{P}}}UpdateControllerNavigationState(True);
}
Boolean {{{P}}}DisableControllerNavigation() {
	return {{{P}}}UpdateControllerNavigationState(False);
}

		""",
		[],
		[]
	);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the module manialink
 *
 *	@return													The module manialink
 */
Text GetML() {
	//L16N [Record] The player won a new medal on the track
	declare Text Text_ImproveMedal = _("New medal");
	//L16N [Record] The player improved their time on the track
	declare Text Text_ImproveTime = _("New best time");
	//L16N [Record] Title of an UI displaying the records (best times, eg: world records, regional records, ...) on the current track
	declare Text Text_Records = _("Records");
	//L16N [Record] Text displayed while the records (best times, eg: world records, regional records, ...) are being loaded
	declare Text Text_LoadingRecordGhosts = _("Loading records");
	//L16N [Record] Text displayed when there are no records (best times, eg: world records, regional records, ...) on the track
	declare Text Text_NoRecords = _("No records");
	//L16N [Record] Text displayed when the player does not have a Standard or Club access
	declare Text Text_StandardRequired = _("Standard access required to view world records");
	//L16N [Record] Text displayed when the track is not available on the nadeo services which prevent records to be saved on the track
	declare Text Text_MapNotAvailable = _("Track not uploaded to the Nadeo services");
	//L16N [Record] Text displayed when the user does not have the required permission to view the records (best times, eg: world records, regional records, ...)
	declare Text Text_MissingPrivilege = _("Cannot display records");
	//L16N [Record] Text displayed when there an error prevented the records (best times, eg: world records, regional records, ...) from being loaded
	declare Text Text_RecordsError = _("Could not load records");
	//L16N [Record] Text displayed when the track was not uploaded to the Trackmania servers beforehand
	declare Text Text_MapNotFound = _("Track not found");
	//L16N [Record] Text displayed when the records (best times, eg: world records, regional records, ...) are disabled. The player can see the current records but not drive a new one.
	declare Text Text_RecordsDisabled = _("New records disabled");
	//L16N [Record] Header of the time required to earn the next medal (ex "Next medal 00:12.000").
	declare Text Text_NextMedal = _("Next medal");
	//L16N [Record] Hide the ghost of the player's personal best (PB) time
	declare Text Text_HidePB = _("Hide PB ghost");

	declare Text Image_Close = "file://Media/Manialinks/Nadeo/TMxSM/Race/Icon_Hide.dds";
	declare Text Image_Open = "file://Media/Manialinks/Nadeo/TMxSM/Race/Icon_WorldRecords.dds";
	declare Text Image_Add = "file://Media/Manialinks/Nadeo/TMxSM/Race/Icon_Ghost_Hidden.dds";
	declare Text Image_Remove = "file://Media/Manialinks/Nadeo/TMxSM/Race/Icon_Ghost_Showed.dds";
	declare Text Image_NextZone = "file://Media/Manialinks/Nadeo/TMxSM/Race/Icon_ArrowLeft.dds";
	declare Text Image_PrevZone = "file://Media/Manialinks/Nadeo/TMxSM/Race/Icon_ArrowRight.dds";

	declare Real PosY_Celebration = 14.;
	
	declare Vec2 Size_RecordRow = <50., 6.>;
	declare GridConfig_Record = Grid::Create(Size_RecordRow.X, 1., 1., Grid::C_Direction_Right);
	GridConfig_Record = Grid::AddColumn(GridConfig_Record, C_Col_Rank, 0.1, Grid::C_Align_Right);
	GridConfig_Record = Grid::AddColumn(GridConfig_Record, C_Col_Name, 0.5, Grid::C_Align_Left);
	GridConfig_Record = Grid::AddColumn(GridConfig_Record, C_Col_Time, 0.3, Grid::C_Align_Right);
	GridConfig_Record = Grid::AddColumn(GridConfig_Record, C_Col_ToggleGhost, 0.1, Grid::C_Align_Center);
	declare Grid_Record = Grid::Compile(GridConfig_Record);

	declare Text ML_Records ="";
	declare Integer RecordsNb = Record::C_RecordsNb + Record::C_BeforeMe + 1 + Record::C_AfterMe;
	for (I, 0, RecordsNb - 1) {
		declare Real PosY = -I * Size_RecordRow.Y;
		ML_Records ^= """
			<frameinstance 
				modelid="framemodel-record-row" id="button-record-{{{I}}}" pos="0 {{{PosY}}}" 
				class="{{{Navigation::C_Class}}}"
				data-nav-inputs="select;cancel;action1;action2;up;down"
				data-nav-targets="_;_;_;_;button-record-{{{ML::Clamp(I-1, 0, RecordsNb - 1)}}};button-record-{{{ML::Clamp(I+1, 0, RecordsNb - 1)}}}"
				data-nav-group="{{{C_NavGroupName}}}"
				data-nav-zone="{{{Button::C_NavZone}}}"
			/>
		""";
	}

	declare MedalAnim_FinalScale = 0.55;
	declare MedalAnim_BannerFinalPosX = -155;

	declare Vec2 Size_ScrollRecords = <Size_RecordRow.X, Size_RecordRow.Y * RecordsNb>;
	declare Integer ElementsNb = Scroll::GetRequiredElementsNb(Size_ScrollRecords, Size_RecordRow, <0., 0.>, 1);
	declare Text ML_ScrollRecords = "";
	for (I, 1, ElementsNb) {
		ML_ScrollRecords ^= """
			<frameinstance 
				modelid="framemodel-record-row"
				class="{{{Scroll::C_Class_Element}}}"
				hidden="1"
			/>
		""";
	}

	// Controller infos
	declare Text ML_ControllerInfos = "";
	declare Real SizeY_ControllerInfo = 5.;
	declare GridConfig_ControllerInfos = Grid::Create(C_ControllerInfos.count * SizeY_ControllerInfo, 0., 0., Grid::C_Direction_Bottom);
	GridConfig_ControllerInfos = Grid::AddRow(GridConfig_ControllerInfos, C_Row_Select, SizeY_ControllerInfo, Grid::C_Align_Center);
	GridConfig_ControllerInfos = Grid::AddRow(GridConfig_ControllerInfos, C_Row_Action1, SizeY_ControllerInfo, Grid::C_Align_Center);
	GridConfig_ControllerInfos = Grid::AddRow(GridConfig_ControllerInfos, C_Row_Action2, SizeY_ControllerInfo, Grid::C_Align_Center);
	GridConfig_ControllerInfos = Grid::AddRow(GridConfig_ControllerInfos, C_Row_Cancel, SizeY_ControllerInfo, Grid::C_Align_Center);
	declare Grid = Grid::Compile(GridConfig_ControllerInfos);
	declare Text GridConfigJson_ControllerInfos = GridConfig_ControllerInfos.tojson();
	foreach (Action => ActionInfos in C_ControllerInfos) {
		ML_ControllerInfos ^= """
			<frame id="frame-info-{{{Action}}}" class="{{{Grid::C_Class_Element}}}" data-grid-row="{{{Action}}}">
				<frameinstance id="buttonicon-info" modelid="{{{ButtonIcon::C_Name}}}" data-size="6 6" data-halign="center" data-valign="center" data-bind="{{{ActionInfos[0]}}}"/>
				<label id="label-info" text="{{{ActionInfos[1]}}}" pos="5 0" class="text-base" halign="left" valign="center2" size="{{{Size_RecordRow.X*0.9}}} 10" italicslope=".2" textsize="2"/>
			</frame>
		""";
	}

	// Back to race button
	declare Vec2 Pos_ButtonVisible = MLHelpers::SkewX(<22., -111.5>, 10.);
	declare Vec2 Pos_ButtonHidden = MLHelpers::SkewX(<22., -126.>, 10.);

	return MV::Create(
GetId(), 3,
"""
<stylesheet>
	<style class="text-base" textsize="3" textfont="{{{FontManager::C_GameFontSemiBold}}}" />
	<style class="quad-default" halign="center" valign="center" />
</stylesheet>

<!-- Frame models -->
<framemodel id="framemodel-record-row">
	<quad id="button-spec-record" {{{MLHelpers::Size(Size_RecordRow)}}} opacity="0" scriptevents="1" z-index="-2"/>
	<quad id="quad-activation" {{{MLHelpers::Size(Size_RecordRow)}}} class="{{{Scroll::C_Class_ActivationZone}}}" opacity="0" scriptevents="1" z-index="-1" hidden="1"/>
	<quad id="quad-bg" size="{{{Size_RecordRow.X}}} {{{Size_RecordRow.Y}}}" bgcolor="000" opacity="0.6" z-index="0"/>
	<label id="label-rank" class="text-base" pos="{{{Grid_Record.Pos[C_Col_Rank]}}} {{{-Size_RecordRow.Y * 0.5}}}" size="{{{Grid_Record.Size[C_Col_Rank]}}} {{{Size_RecordRow.Y - 2}}}" textfont="{{{FontManager::C_GameFontExtraBold}}}" halign="right" valign="center2" textsize="1" z-index="5" />
	<frameinstance id="playername-name" modelid="{{{PlayerName::C_Name}}}" pos="{{{Grid_Record.Pos[C_Col_Name]}}} {{{-Size_RecordRow.Y * 0.5}}}" data-size="{{{Grid_Record.Size[C_Col_Name]}}} {{{Size_RecordRow.Y - 2}}}" data-valign="center" data-textprefix="$t$i" data-textfont="{{{FontManager::C_GameFontSemiBold}}}" data-textsize="1" z-index="5" />
	<label id="label-time" class="text-base" pos="{{{Grid_Record.Pos[C_Col_Time]}}} {{{-Size_RecordRow.Y * 0.5}}}" size="{{{Grid_Record.Size[C_Col_Time]}}} {{{Size_RecordRow.Y - 2}}}" textprefix="$i" textfont="{{{FontManager::C_GameFontSemiBold}}}" halign="right" valign="center2" textsize="1" z-index="5" />
	<quad id="button-toggle-ghost" pos="{{{Grid_Record.Pos[C_Col_ToggleGhost]}}} {{{-Size_RecordRow.Y * 0.5}}}" size="{{{Size_RecordRow.Y - 2}}} {{{Size_RecordRow.Y - 2}}}" class="quad-default" colorize="ffffff" image="{{{Image_Add}}}" scriptevents="1" opacity="0.5" z-index="5"/>
	<frameinstance id="loading-spinner-rank" modelid="{{{LoadingSpinner::C_Name}}}" pos="{{{Grid_Record.Pos[C_Col_Rank]-2}}} {{{-Size_RecordRow.Y * 0.5}}}" scale="0.25" z-index="5" />
	<frameinstance id="loading-spinner-toggle-ghost" modelid="{{{LoadingSpinner::C_Name}}}" pos="{{{Grid_Record.Pos[C_Col_ToggleGhost]}}} {{{-Size_RecordRow.Y * 0.5}}}" scale="0.25" z-index="5" />
</framemodel>

<!-- Frame profile -->
<frame id="frame-profile" hidden="1" z-index="10">
	<frameinstance modelid="{{{ProfilePlayerInfo::C_Name}}}" data-enable-players-pager="0" data-enable-zone-selection="0" data-enable-my-access-info="0" data-enable-garage="0"/>
</frame>

<!-- Frame global -->
<frame id="frame-global" class="{{{Navigation::C_Class}}}" data-nav-inputs="left;right;pageup;pagedown" data-nav-targets="_;_;_;_" data-nav-group="{{{C_NavGroup_Global}}}" z-index="1" hidden="1">
	<frame id="clip-medal-banner" size="320 200" halign="center" valign="center">
		<frame id="frame-medal" pos="-142 50" z-index="1">
			<frame id="frame-medal-banner" rot="-80" z-index="1" scale="{{{MedalAnim_FinalScale}}}" pos="{{{MedalAnim_BannerFinalPosX + 142}}} {{{PosY_Celebration}}}">
				<quad id="quad-medal-banner" z-index="0" image="{{{Const::C_ImageUrl_Race_Mode_Banner_MedalsShortSymetry}}}" size="47.7 90" class="quad-default" keepratio="Fit"/>
				<quad id="quad-medal-banner-glow" z-index="1" image="{{{Const::C_ImageUrl_Race_Mode_Banner_MedalsShortGlowSymetry}}}" size="47.7 90" class="quad-default" keepratio="Fit"/>
			</frame>
			<quad id="quad-medal" scale="{{{MedalAnim_FinalScale}}}" pos="-2 {{{PosY_Celebration}}}" size="36.5 36.5" class="quad-default" autoscale="0" z-index="2"/>
			<frameinstance id="medal-stack-current" modelid="{{{MedalStack::C_Name}}}" data-bigmedaldirection="{{{MedalStack::C_BigMedal_Vertical}}}" data-iscolorize="0" hidden="1"/>
			<label id="label-medal-name" class="text-base" textsize="2" pos="-4 2" size="25 6" halign="center" />
			<label id="label-medal-time" class="text-base" textsize="2" pos="-4 -3" size="25 6" halign="center" />
		</frame>
	</frame>
	<frame id="frame-celebration" z-index="0">
		<quad id="quad-celebration-background" z-index="0" size="320 180" fullscreen="1" halign="center" valign="center" bgcolor="000000" opacity="0" />
		<frame id="frame-celebration-medal" pos="0 {{{PosY_Celebration}}}" z-index="1" hidden="1">
			<label class="text-base" halign="center" textsize="6" text="{{{Text_ImproveMedal}}}" textprefix="$t$i" italicslope="0.2"/>
			<label id="label-new-medal" class="text-base" pos="0 -9" halign="center" textsize="8" />
			<frame id="clip-medal-banner" size="320 200" halign="center" valign="center">
				<frame id="frame-medal-banner-celebration" rot="-80" z-index="1">
					<quad id="quad-medal-banner" z-index="0" image="{{{Const::C_ImageUrl_Race_Mode_Banner_MedalsShortSymetry}}}" size="47.7 90" class="quad-default" keepratio="Fit"/>
					<quad id="quad-medal-banner-glow" z-index="1" image="{{{Const::C_ImageUrl_Race_Mode_Banner_MedalsShortGlowSymetry}}}" size="47.7 90" class="quad-default" keepratio="Fit"/>
				</frame>
				<quad id="quad-medal" scale="{{{MedalAnim_FinalScale}}}" pos="-2 {{{PosY_Celebration}}}" size="36.5 36.5" class="quad-default" autoscale="0" z-index="2"/>
				<frameinstance id="medal-stack-current" modelid="{{{MedalStack::C_Name}}}" data-bigmedaldirection="{{{MedalStack::C_BigMedal_Vertical}}}" data-iscolorize="0" hidden="1"/>
			</frame>
		</frame>
		<frame id="frame-celebration-time" pos="0 {{{-PosY_Celebration}}}" z-index="1" hidden="1">
			<label class="text-base" halign="center" textsize="6" text="{{{Text_ImproveTime}}}" textprefix="$t$i" italicslope="0.2"/>
			<label id="label-new-time" class="text-base" pos="0 -9" halign="center" textsize="8" />
			<label id="label-new-time-difference" class="text-base" pos="-1 -19" halign="center" textsize="8" />
		</frame>
	</frame>
	<frame id="frame-content">
		<frame {{{UIModules::CustomizableUIModule(Record::C_UIModuleConfig)}}}>
			<frame id="frame-records" size="{{{Size_RecordRow.X + 10}}} 180" hidden="1">
				<frame>
					<quad id="button-toggle-records" size="{{{Size_RecordRow.Y+2}}} {{{Size_RecordRow.Y+2}}}" pos="0 {{{-Size_RecordRow.Y+2}}}" valign="center" opacity="0.6" bgcolor="000000" bgcolorfocus="222222" scriptevents="1" />
					<quad id="quad-toggle-records-icon" pos="{{{(Size_RecordRow.Y+2.)*0.5}}} {{{-Size_RecordRow.Y+2}}}" z-index="1" size="{{{Size_RecordRow.Y+2.}}} {{{Size_RecordRow.Y+2.}}}" halign="center" valign="center" colorize="ffffff" opacity=".4" image="{{{Image_Open}}}" />
					<frameinstance modelid="{{{ButtonIcon::C_Name}}}" pos="{{{Size_RecordRow.Y+7.}}} {{{-Size_RecordRow.Y+2}}}" id="button-icon-toggle-records" data-size="6 6" data-halign="center" data-valign="center" data-bind="pageup" hidden="1"/>
				</frame>
				<frame id="frame-slide">
					<frame pos="0 {{{-Size_RecordRow.Y*2}}}">
						<quad size="{{{Size_RecordRow.X}}} {{{Size_RecordRow.Y}}}" valign="center" opacity="0.6" bgcolor="000000" />
						<label
							class="text-base"
							pos="{{{Size_RecordRow.X*0.5}}} -0.2" z-index="1"
							size="{{{Size_RecordRow.X-2}}} {{{Size_RecordRow.Y-2}}}"
							halign="center" valign="center2"
							textprefix="$t$i" textfont="{{{FontManager::C_GameFontExtraBold}}}" text="{{{Text_Records}}}"
						/>
					</frame>
					<frame id="frame-zone" pos="0 {{{-Size_RecordRow.Y*3}}}" z-index="2">
						<quad size="{{{Size_RecordRow.X}}} {{{Size_RecordRow.Y}}}" valign="center" opacity="0.6" bgcolor="000000" />
						<quad id="button-zone-next" class="basic-mouse-over" z-index="1" size="{{{Size_RecordRow.Y-1}}} {{{Size_RecordRow.Y-1}}}" valign="center" colorize="ffffff" opacity=".4" image="{{{Image_NextZone}}}" scriptevents="1" />
						<quad id="button-zone-prev" class="basic-mouse-over" pos="{{{Size_RecordRow.X}}} 0" z-index="1" size="{{{Size_RecordRow.Y-1}}} {{{Size_RecordRow.Y-1}}}" halign="right" valign="center" colorize="ffffff" opacity=".4" image="{{{Image_PrevZone}}}" scriptevents="1" />
						<label id="label-zone" class="text-base" pos="{{{Size_RecordRow.X*0.5}}} 0" z-index="2" size="{{{Size_RecordRow.X-8}}} {{{Size_RecordRow.Y-2}}}" halign="center" valign="center2" textprefix="$t$i" textfont="{{{FontManager::C_GameFontExtraBold}}}" />
						<quad id="quad-zone-icon" pos="0 0.4" z-index="3" size="{{{Size_RecordRow.Y}}} {{{Size_RecordRow.Y}}}" halign="center" valign="center" colorize="ffffff" />
					</frame>
					<frame id="frame-loading" pos="0 {{{-Size_RecordRow.Y*3}}}" z-index="3">
						<quad size="{{{Size_RecordRow.X}}} {{{Size_RecordRow.Y}}}" valign="center" opacity="0.6" bgcolor="000000" />
						<frameinstance id="loading-spinner-records" modelid="{{{LoadingSpinner::C_Name}}}" pos="{{{1+Size_RecordRow.Y*0.5}}} 0" z-index="1" scale="0.25" />
						<label class="text-base" pos="{{{1+Size_RecordRow.Y+1}}} 0" z-index="1" size="{{{Size_RecordRow.X-Size_RecordRow.Y-3}}} {{{Size_RecordRow.Y-2}}}" valign="center2" text="{{{Text_LoadingRecordGhosts}}}" />
					</frame>
					<frame id="frame-no-records" pos="0 {{{-Size_RecordRow.Y*4}}}" z-index="4">
						<quad size="{{{Size_RecordRow.X}}} {{{Size_RecordRow.Y}}}" valign="center" opacity="0.6" bgcolor="000000" />
						<label id="label-no-records" class="text-base" pos="{{{Size_RecordRow.X*0.5}}} 0" z-index="1" size="{{{Size_RecordRow.X-2}}} {{{Size_RecordRow.Y-2}}}" halign="center" valign="center2" text="{{{Text_NoRecords}}}" />
					</frame>
					<frame id="frame-standard-required" pos="0 {{{-Size_RecordRow.Y*4.5}}}" z-index="5" hidden="1">
						<quad size="{{{Size_RecordRow.X}}} {{{Size_RecordRow.Y*4}}}" valign="center" opacity="0.6" bgcolor="000000" />
						<label id="label-standard-required" class="text-base" pos="{{{Size_RecordRow.X*0.5}}} 0" z-index="1" size="{{{Size_RecordRow.X-2}}} {{{(Size_RecordRow.Y*4)-2}}}" halign="center" valign="center2" text="{{{Text_StandardRequired}}}" maxline="7" />
					</frame>
					<frame id="frame-map-not-available" pos="0 {{{-Size_RecordRow.Y*4.5}}}" z-index="6" hidden="1">
						<quad size="{{{Size_RecordRow.X}}} {{{Size_RecordRow.Y*4}}}" valign="center" opacity="0.6" bgcolor="000000" />
						<label id="label-map-not-available" class="text-base" pos="{{{Size_RecordRow.X*0.5}}} 0" z-index="1" size="{{{Size_RecordRow.X-2}}} {{{(Size_RecordRow.Y*4)-2}}}" halign="center" valign="center2" text="{{{Text_MapNotAvailable}}}" maxline="7" />
					</frame>
					<frame id="frame-missing-privilege" pos="0 {{{-Size_RecordRow.Y*4.5}}}" z-index="7" hidden="1">
						<quad size="{{{Size_RecordRow.X}}} {{{Size_RecordRow.Y*4}}}" valign="center" opacity="0.6" bgcolor="000000" />
						<label id="label-missing-privilege" class="text-base" pos="{{{Size_RecordRow.X*0.5}}} 0" z-index="1" size="{{{Size_RecordRow.X-2}}} {{{(Size_RecordRow.Y*4)-2}}}" halign="center" valign="center2" text="{{{Text_MissingPrivilege}}}" maxline="7" />
					</frame>
					<frame id="frame-rankings-container">
						<frame id="frame-ranking" pos="0 {{{-Size_RecordRow.Y*3.5}}}" z-index="5">
							{{{ML_Records}}}
						</frame>
						<frame id="frame-scroll-ranking" pos="0 {{{-Size_RecordRow.Y*3.5}}}" z-index="6" hidden="1">
							<frameinstance modelid="{{{Scroll::C_Name}}}" data-scroll-parent="scroll-ranking" z-index="1" />
							<frame
								id="scroll-ranking"
								class="{{{Scroll::C_Class_Window}}} {{{Navigation::C_Class}}}"
								data-elements-per-line="1"
								data-elements-per-page="{{{ElementsNb}}}"
								data-element-size="{{{Size_RecordRow.X}}} {{{Size_RecordRow.Y}}}"
								data-margin-size="0 0"
								data-window-size="{{{Size_ScrollRecords.X}}} {{{Size_ScrollRecords.Y}}}"
								data-scroll-indicator-y-offset="-10."
								data-scroll-indicator-image="{{{Const::C_ImageUrl_Icon_Arrow_Bottom}}}"
								data-scroll-indicator-colorize="ffffff"
								data-scroll-indicator-size="12"
								data-nav-group="{{{C_NavGroupName}}}"					
							>
								<quad class="{{{Scroll::C_Class_ScrollEvent}}}" z-index="-1" scriptevents="1" />
								{{{ML_ScrollRecords}}}
							</frame>
						</frame>
					</frame>
					<frame id="frame-toggle-pb" pos="0 {{{-Size_RecordRow.Y*5}}}" z-index="7">
						<quad size="{{{Size_RecordRow.X}}} {{{Size_RecordRow.Y}}}" valign="center" opacity="0.6" bgcolor="000000" />
						<frameinstance modelid="{{{ButtonIcon::C_Name}}}" pos="{{{Size_RecordRow.X-1.}}} 0" id="button-icon-toggle-pb" data-size="6 6" data-halign="right" data-valign="center" data-bind="pagedown" z-index="10" hidden="1" />
						<frameinstance 
							modelid="{{{Checkbox::C_Name}}}" id="checkbox-toggle-pb" pos="1 0" z-index="10"
							data-labelsize="{{{Size_RecordRow.X-16.}}} {{{Size_RecordRow.Y}}}"
							data-opacityunfocus="0.5"
							data-text="{{{Text_HidePB}}}"
							data-textxpos="0.1"
							data-textsize="1.5"
							data-texthalign="left"
							data-textitalicslope=".2"
							data-textfont="{{{FontManager::C_GameFontExtraBold}}}"
							data-iconchecked="{{{Const::C_ImageUrl_Icon_Checkbox_Active_Square}}}"
							data-iconunchecked="{{{Const::C_ImageUrl_Icon_Checkbox_Inactive_Square}}}"
							data-iconcolor="{{{ColorPalette::C_Color_White}}}"
							data-iconsize="6 6"
							data-iconxpos="0."
							data-halign="left" data-valign="center"
						/>
					</frame>
					<frame id="frame-records-disabled" pos="0 {{{-Size_RecordRow.Y*5}}}" z-index="7">
						<quad size="{{{Size_RecordRow.X}}} {{{Size_RecordRow.Y}}}" valign="center" opacity="0.6" bgcolor="000000" />
						<label class="text-base" pos="{{{Size_RecordRow.X*0.5}}} 0" z-index="1" size="{{{Size_RecordRow.X-2}}} {{{Size_RecordRow.Y-2}}}" halign="center" valign="center2" textcolor="e07603" text="{{{Text_RecordsDisabled}}}" />
					</frame>
					<frame id="frame-controller-info" pos="4 -60" class="{{{Grid::C_Class_Container}}}" z-index="5" hidden="1">
						{{{ML_ControllerInfos}}}
					</frame>
				</frame>
			</frame>
			<frameinstance
				id="button-back-to-race" z-index="0" hidden="1"
				pos="{{{Pos_ButtonHidden.X}}} {{{Pos_ButtonHidden.Y}}}" 
				modelid="{{{ExpendableButton::C_Name}}}"
				data-text="{{{C_ControllerInfos[C_Row_Cancel][1]}}}"
				class="{{{Navigation::C_Class}}}"
				data-halign="left" data-valign="center"
				data-styles="{{{ExpendableButton::C_Style_SizeExpendable}}} {{{ExpendableButton::C_Style_ButtonSecondary}}}"
				data-nav-inputs="select;cancel"
				data-nav-targets="_;_"
				data-nav-group="{{{C_NavGroupName}}}"
				data-nav-zone="{{{ExpendableButton::C_NavZone}}}"
			/>
		</frame>
	</frame>
</frame>
""",
"""
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "ColorLib" as CL
#Include "Libs/Nadeo/CommonLibs/Common/AudioManager_ML.Script.txt" as AudioManager
#Include "Libs/Nadeo/MenuLibs/Common/Components/Grid.Script.txt" as Grid
#Include "Libs/Nadeo/MenuLibs/Common/Components/Tools.Script.txt" as Tools
#Include "Libs/Nadeo/MenuLibs/Common/Modes/Medals.Script.txt" as Medals
#Include "Libs/Nadeo/ModeLibs/TrackMania/MV_Utils.Script.txt" as MV_Utils
#Include "Libs/Nadeo/TMNext/TrackMania/RBAC.Script.txt" as RBAC
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/Helpers_Client.Script.txt" as Helpers
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/PrestigeEarned_Common.Script.txt" as UIModules_PrestigeEarned_Common
#Include "Libs/Nadeo/TMNext/TrackMania/Structures/ReportStruct.Script.txt" as ReportStruct
#Include "Libs/Nadeo/CommonLibs/Common/Platform.Script.txt" as Platform

{{{dumptype(K_Celebration)}}}
{{{dumptype(Record::K_TMxSM_Record_Record)}}}
{{{dumptype(Record::K_TMxSM_Record_Records)}}}

#Struct K_State {
	Boolean IsControllerNavigationEnabled;
	Boolean IsLocalMode;
	Boolean NewRecordsEnabled;
	Integer CurrentMedal;
	Integer SelectedZone;
	Grid::K_GridConfig GridConfig_ControllerInfos;
	K_TMxSM_Record_Records CurrentZoneRecords;
	Text SpectatorTargetAccountId;
}

#Struct K_Controls {
	CMlFrame ButtonIcon_TogglePB;
	CMlFrame ButtonIcon_ToggleRecords;
	CMlFrame Button_BackToRace;
	CMlFrame Checkbox_TogglePB;
	CMlFrame Frame_Celebration;
	CMlFrame Frame_CelebrationMedal;
	CMlFrame Frame_CelebrationTime;
	CMlFrame Frame_Content;
	CMlFrame Frame_ControllerInfo;
	CMlFrame Frame_MapNotAvailable;
	CMlFrame Frame_Medal;
	CMlFrame Frame_MissingPrivilege;
	CMlFrame Frame_NoRecords;
	CMlFrame Frame_Profile;
	CMlFrame Frame_Ranking;
	CMlFrame Frame_Records;
	CMlFrame Frame_RecordsDisabled;
	CMlFrame Frame_ScrollRanking;
	CMlFrame Frame_StandardRequired;
	CMlFrame Frame_TogglePB;
	CMlFrame Frame_Zone;
	CMlFrame Scroll_Ranking;
	CMlLabel Label_MedalTime;
	CMlLabel Label_MissingPrivilege;
	CMlQuad Button_ZoneNext;
	CMlQuad Button_ZonePrev;
}

#Const C_RecordsOffsetY 10.		//< The Y offset to fit the module in the screen when the controller navigation is enabled
#Const C_RecordsScale 1.		//< The size of the module when the controller navigation is enabled

#Const C_InputPriority_Records 10		//< Must be higher than other UIs inputs (e.g. 2 for the pause menu)

#Const C_DelayBeforeAutoHide 6000		//< Delay before hidding the back to race button

#Const C_MedalToUnlockWorldRecords {{{dump(C_MedalToUnlockWorldRecords)}}}
#Const C_MedalToUnlockClubRecords {{{dump(C_MedalToUnlockClubRecords)}}}

#Const C_RecordType_None {{{dump(C_RecordType_None)}}}
#Const C_RecordType_Zones {{{dump(C_RecordType_Zones)}}}
#Const C_RecordType_Club {{{dump(C_RecordType_Club)}}}
#Const C_RecordType_ClubVIP {{{dump(C_RecordType_ClubVIP)}}}
#Const C_RecordType_GlobalVIP {{{dump(C_RecordType_GlobalVIP)}}}

#Const C_FakeZone_Club {{{dump(C_FakeZone_Club)}}}
#Const C_FakeZone_ClubVIP {{{dump(C_FakeZone_ClubVIP)}}}
#Const C_FakeZone_GlobalVIP {{{dump(C_FakeZone_GlobalVIP)}}}

#Const C_RecordPermission {{{dump(G_RecordPermission)}}}

#Const C_Zone_Translations {{{dump(Const::C_Zone_Translations)}}}
""",
"""
Boolean HasRecordPermission(Integer _RecordType) {
	return (
		C_RecordPermission.existskey(_RecordType) && (
			C_RecordPermission[_RecordType] == "" ||
			{{{UserStore_ML::P}}}HasGamePermission(PrivilegeMgr, C_RecordPermission[_RecordType])
		)
	);
}

// Display the player's profile associated to the given account id
Void DisplayProfile(K_Controls _Controls, CMlControl _Control, Boolean _Display) {
	declare Text RecordClient_PlayerAccountId for _Control = "";
	declare Text RecordClient_PlayerRecordDetail for _Control = "";
	declare Text RecordClient_PlayerRecordId for _Control = "";

	_Controls.Frame_Profile.Visible = _Display && RecordClient_PlayerAccountId != "";
	{{{Navigation::P}}}EnableGroup(This, "{{{C_NavGroupName}}}", !_Controls.Frame_Profile.Visible);
	{{{Scroll::P}}}LockNavigation(_Controls.Scroll_Ranking, _Controls.Frame_Profile.Visible);
	{{{ProfilePlayerInfo::P}}}Enable(_Controls.Frame_Profile.Visible);
	if (_Controls.Frame_Profile.Visible) {
		{{{ProfilePlayerInfo::P}}}SetUserAccountId(RecordClient_PlayerAccountId);
		{{{ProfilePlayerInfo::P}}}SetUserRecord(RecordClient_PlayerRecordDetail, RecordClient_PlayerRecordId);
	}
}

Void SetMedalImage(CMlQuad _Quad_Medal, CMlFrame _Frame_Banner, Integer _Medal) {
	if (_Quad_Medal == Null || _Frame_Banner == Null) return;
	switch (_Medal) {
		case Medals::C_ScoreMgrMedal_Bronze: {
			_Quad_Medal.ChangeImageUrl("{{{Const::C_ImageUrl_Medal_Bronze}}}");
			_Frame_Banner.Show();
		}
		case Medals::C_ScoreMgrMedal_Silver: {
			_Quad_Medal.ChangeImageUrl("{{{Const::C_ImageUrl_Medal_Silver}}}");
			_Frame_Banner.Show();
		}
		case Medals::C_ScoreMgrMedal_Gold: {
			_Quad_Medal.ChangeImageUrl("{{{Const::C_ImageUrl_Medal_Gold}}}");
			_Frame_Banner.Show();
		}
		case Medals::C_ScoreMgrMedal_Author: {
			_Quad_Medal.ChangeImageUrl("{{{Const::C_ImageUrl_Medal_Nadeo}}}");
			_Frame_Banner.Show();
		}
		default: {
			_Quad_Medal.ChangeImageUrl("");
			_Frame_Banner.Hide();
		}
	}
}

Void SetMedal(K_Controls _Controls, Integer _Medal) {
	declare CMlFrame Frame_MedalBanner <=> (_Controls.Frame_Medal.GetFirstChild("frame-medal-banner") as CMlFrame);
	declare CMlFrame MedalStack_Current = (_Controls.Frame_Medal.GetFirstChild("medal-stack-current") as CMlFrame);
	declare CMlLabel Label_MedalName <=> (_Controls.Frame_Medal.GetFirstChild("label-medal-name") as CMlLabel);
	declare CMlLabel Label_MedalTime <=> (_Controls.Frame_Medal.GetFirstChild("label-medal-time") as CMlLabel);
	declare CMlQuad Quad_Medal <=> (_Controls.Frame_Medal.GetFirstChild("quad-medal") as CMlQuad);
	declare Integer MedalTime = -1;

	{{{MedalStack::P}}}SetMedalsNumber(MedalStack_Current, _Medal); //@TODO @QG remove if needed (perma hidden for now)
	SetMedalImage(Quad_Medal, Frame_MedalBanner, _Medal);
	MedalStack_Current.Hide();

	switch (_Medal) {
		case Medals::C_ScoreMgrMedal_None: {
			if (Map != Null) {
				MedalTime = Map.MapInfo.TMObjective_BronzeTime;
			}
		}
		case Medals::C_ScoreMgrMedal_Bronze: {
			if (Map != Null) {
				MedalTime = Map.MapInfo.TMObjective_SilverTime;
			}
		}
		case Medals::C_ScoreMgrMedal_Silver: {
			if (Map != Null) {
				MedalTime = Map.MapInfo.TMObjective_GoldTime;
			}
		}
	}

	if (MedalTime >= 0) {
		Label_MedalName.Value = "{{{Text_NextMedal}}}";
		Label_MedalTime.Value = TL::TimeToText(MedalTime, True, True);
	} else {
		Label_MedalName.Value = "";
		Label_MedalTime.Value = "";
	}
}

Integer GetAfterRecordsShift(K_Controls _Controls, Integer _ZonesRecordsCount) {
	declare Integer AfterRecordsShiftY = 4;

	if (_Controls.Frame_Ranking.Visible) AfterRecordsShiftY += _ZonesRecordsCount;
	else if (_Controls.Frame_StandardRequired.Visible) AfterRecordsShiftY += 4;
	else if (_Controls.Frame_MapNotAvailable.Visible) AfterRecordsShiftY += 4;
	else if (_Controls.Frame_MissingPrivilege.Visible) AfterRecordsShiftY += 4;
	else if (_Controls.Frame_ScrollRanking.Visible) AfterRecordsShiftY += ML::Min(_ZonesRecordsCount, {{{RecordsNb}}});
	else if (_Controls.Frame_NoRecords.Visible) AfterRecordsShiftY += 1;
	if (!_Controls.Frame_Zone.Visible) AfterRecordsShiftY -= 1;

	return AfterRecordsShiftY;
}

CMlControl GetParentNavigationControl(CMlControl _Control) {
	if (_Control == Null || _Control.ControlId == "frame-rankings-container") return Null;
	if ({{{Navigation::P}}}IsNavigationControl(_Control)) return _Control;
	return GetParentNavigationControl(_Control.Parent);
}

Void FocusRecord(CMlFrame _Frame_Record, Text _SpectatorTargetAccountId, Boolean _IsFocused) {
	if (_Frame_Record == Null) return;
	declare Text RecordClient_PlayerAccountId for _Frame_Record = "";
	if (RecordClient_PlayerAccountId == "") return;

	declare CMlFrame PlayerName_Name = (_Frame_Record.GetFirstChild("playername-name") as CMlFrame);
	declare CMlLabel Label_Rank = (_Frame_Record.GetFirstChild("label-rank") as CMlLabel);
	declare CMlLabel Label_Time = (_Frame_Record.GetFirstChild("label-time") as CMlLabel);
	declare CMlQuad Quad_Bg = (_Frame_Record.GetFirstChild("quad-bg") as CMlQuad);
	declare CMlQuad Quad_ToggleGhost = (_Frame_Record.GetFirstChild("button-toggle-ghost") as CMlQuad);
	declare Boolean IsCameraTarget = (
		(_SpectatorTargetAccountId == "" && RecordClient_PlayerAccountId == LocalUser.WebServicesUserId) || 
		(_SpectatorTargetAccountId == RecordClient_PlayerAccountId)
	);

	if (_IsFocused) {
		{{{PlayerName::P}}}SetTextColor(This, PlayerName_Name, <0., 0., 0.>);
		Label_Rank.TextColor = <0., 0., 0.>;
		Label_Time.TextColor = <0., 0., 0.>;
		Quad_ToggleGhost.Colorize = <0., 0., 0.>;
	} else if (IsCameraTarget) {
		{{{PlayerName::P}}}SetTextColor(This, PlayerName_Name, {{{ColorPalette::C_Color_Vec3_GreenOne}}});
		Label_Rank.TextColor = {{{ColorPalette::C_Color_Vec3_GreenOne}}};
		Label_Time.TextColor = {{{ColorPalette::C_Color_Vec3_GreenOne}}};
		Quad_ToggleGhost.Colorize = <1., 1., 1.>;
	} else {
		{{{PlayerName::P}}}SetTextColor(This, PlayerName_Name, <1., 1., 1.>);
		Label_Rank.TextColor = <1., 1., 1.>;
		Label_Time.TextColor = <1., 1., 1.>;
		Quad_ToggleGhost.Colorize = <1., 1., 1.>;
	}

	AnimMgr.Flush(Quad_Bg);
	if (!_IsFocused) {
		AnimMgr.Add(Quad_Bg, "<a opacity=\"0.6\"  bgcolor=\"000\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	} else if (IsCameraTarget) {
		AnimMgr.Add(Quad_Bg, "<a opacity=\"0.8\" bgcolor=\"{{{ColorPalette::C_Color_GreenOne}}}\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	} else {
		AnimMgr.Add(Quad_Bg, "<a opacity=\"0.8\" bgcolor=\"FFF\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	}
}

Void FocusToggleGhost(CMlQuad _Button_ToggleGhost, Boolean _IsFocused) {
	AnimMgr.Flush(_Button_ToggleGhost);
	if (_IsFocused || _Button_ToggleGhost.ImageUrl == "{{{Image_Remove}}}") {
		AnimMgr.Add(_Button_ToggleGhost, "<anim opacity=\"1.0\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	} else {
		AnimMgr.Add(_Button_ToggleGhost, "<anim opacity=\"0.4\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	}
}

Void Focus(CMlControl _From, CMlControl _To, K_State _State, Boolean _IsMouse, Boolean _ForceFocusUpdate) {
	declare Boolean IsNavigationControlUnfocusPossible = !(_State.IsControllerNavigationEnabled && (_To == Null || {{{Checkbox::P}}}IsCheckbox(_To)));
	declare Boolean IsRecordFocusPossible = !_IsMouse || _State.IsLocalMode || _ForceFocusUpdate;

	if (_From != Null) {
		declare CMlControl NavigationControl = GetParentNavigationControl(_From);
		if ({{{Navigation::P}}}IsNavigationControl(NavigationControl) && IsNavigationControlUnfocusPossible && IsRecordFocusPossible) { //< Always keep a record focused if controller is enabled
			{{{Navigation::P}}}Unfocus(This, NavigationControl);
			if (TL::StartsWith("button-record-", NavigationControl.ControlId)) {
				FocusRecord(NavigationControl as CMlFrame, _State.SpectatorTargetAccountId, False);
				if (!_IsMouse) FocusToggleGhost((NavigationControl as CMlFrame).GetFirstChild("button-toggle-ghost") as CMlQuad, False);
			} else if ({{{Scroll::P}}}IsScroll(NavigationControl)) {
				{{{Scroll::P}}}Unfocus(This, (NavigationControl as CMlFrame));
			} else if ({{{ExpendableButton::P}}}IsButton(NavigationControl)) {
				{{{ExpendableButton::P}}}Unfocus(This, (NavigationControl as CMlFrame));
			}
		}
		if ({{{Checkbox::P}}}IsCheckbox(_From)) {
			{{{Checkbox::P}}}Unfocus(This, _From as CMlFrame);
		} else if (_From.ControlId == "button-toggle-ghost") {
			FocusToggleGhost(_From as CMlQuad, False);
		}
	}

	if (_To != Null) {
		declare CMlControl NavigationControl = GetParentNavigationControl(_To);
		if ({{{Navigation::P}}}IsNavigationControl(NavigationControl) && IsRecordFocusPossible) {
			{{{Navigation::P}}}Focus(This, NavigationControl);
			if (TL::StartsWith("button-record-", NavigationControl.ControlId)) {
				FocusRecord(NavigationControl as CMlFrame, _State.SpectatorTargetAccountId, True);
			} else if ({{{Scroll::P}}}IsScroll(NavigationControl)) {
				{{{Scroll::P}}}Focus(This, (NavigationControl as CMlFrame));
			} else if ({{{ExpendableButton::P}}}IsButton(NavigationControl)) {
				{{{ExpendableButton::P}}}Focus(This, (NavigationControl as CMlFrame));
			}
		}
		if ({{{Checkbox::P}}}IsCheckbox(_To)) {
			{{{Checkbox::P}}}Focus(This, _To as CMlFrame);
		} else if (_To.ControlId == "button-toggle-ghost") {
			FocusToggleGhost(_To as CMlQuad, True);
		}
	}
}
Void Focus(CMlControl _From, CMlControl _To, K_State _State, Boolean _IsMouse) {
	Focus(_From, _To, _State, _IsMouse, False);
}

Void Select(K_State _State, CMlControl _Control) {
	if (_Control == Null) return;
	
	switch (_Control.ControlId) {
		case "button-back-to-race": SendCustomEvent("{{{C_Event_SpectateGhost}}}", [_State.SpectatorTargetAccountId]);
	}
}

Boolean UpdateCelebration(K_Controls _Controls, K_Celebration _Celebration) {
	declare CMlLabel Label_NewMedal <=> (_Controls.Frame_Celebration.GetFirstChild("label-new-medal") as CMlLabel);
	declare CMlLabel Label_NewTime <=> (_Controls.Frame_Celebration.GetFirstChild("label-new-time") as CMlLabel);
	declare CMlLabel Label_NewTimeDiff <=> (_Controls.Frame_Celebration.GetFirstChild("label-new-time-difference") as CMlLabel);
	declare CMlQuad Quad_CelebrationBg <=> (_Controls.Frame_Celebration.GetFirstChild("quad-celebration-background") as CMlQuad);

	declare NewTimeDiff = False;

	if (
		_Celebration.IsActive &&
		_Celebration.BestTime >= 0 &&
		(_Celebration.PrevTime < 0 || _Celebration.BestTime < _Celebration.PrevTime)
	) {
		Label_NewTime.Value = TL::TimeToText(_Celebration.BestTime, True, True);
		Label_NewTimeDiff.Hide();
		if (_Celebration.PrevTime >= 0) {
			Label_NewTimeDiff.Value = "$<$22f"^TL::TimeToText(_Celebration.BestTime - _Celebration.PrevTime, True, True)^"$>";
			NewTimeDiff = True;
		}
		_Controls.Frame_CelebrationTime.Visible = True;
	} else {
		_Controls.Frame_CelebrationTime.Visible = False;
	}

	if (
		_Celebration.IsActive &&
		Medals::ABetterThanB(
			Medals::ConvertFromScoreMgrMedal(_Celebration.BestMedal),
			Medals::ConvertFromScoreMgrMedal(_Celebration.PrevMedal)
		)
	) {
		Label_NewMedal.Value = Medals::GetScoreMgrMedalName(_Celebration.BestMedal);
		_Controls.Frame_CelebrationMedal.Visible = True;
	} else {
		_Controls.Frame_CelebrationMedal.Visible = False;
	}

	if (_Controls.Frame_CelebrationTime.Visible && _Controls.Frame_CelebrationMedal.Visible) {
		_Controls.Frame_CelebrationTime.RelativePosition_V3.Y = {{{-PosY_Celebration}}};
		_Controls.Frame_CelebrationMedal.RelativePosition_V3.Y = {{{PosY_Celebration}}};
	} else {
		_Controls.Frame_CelebrationTime.RelativePosition_V3.Y = 0.;
		_Controls.Frame_CelebrationMedal.RelativePosition_V3.Y = 0.;
	}

	if (_Controls.Frame_CelebrationTime.Visible || _Controls.Frame_CelebrationMedal.Visible) {
		UIModules_PrestigeEarned_Common::BlockPrestigeCelebration(UI, "{{{Record::C_Id}}}");
		AnimMgr.Add(Quad_CelebrationBg, "<a opacity=\"0.7\" hidden=\"0\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
		if (_Controls.Frame_CelebrationTime.Visible) {
			// Label anim
			Label_NewTime.RelativePosition_V3 = <140., -9.>;
			Label_NewTime.Hide();
			AnimMgr.Flush(Label_NewTime);
			AnimMgr.Add(Label_NewTime, "<a pos=\"0 -9\" hidden=\"0\" />", Now + 50, 150, CAnimManager::EAnimManagerEasing::QuadIn);
			if (NewTimeDiff) {
				Label_NewTimeDiff.RelativePosition_V3 = <140., -19.>;
				Label_NewTimeDiff.Hide();
				AnimMgr.Flush(Label_NewTimeDiff);
				AnimMgr.Add(Label_NewTimeDiff, "<a pos=\"0 -19\" hidden=\"0\" />", Now + 100, 150, CAnimManager::EAnimManagerEasing::QuadIn);
			}
		}
		if (_Controls.Frame_CelebrationMedal.Visible) {
			// Label anim
			Label_NewMedal.RelativePosition_V3 = <140., -9.>;
			Label_NewMedal.Hide();
			AnimMgr.Flush(Label_NewMedal);
			AnimMgr.Add(Label_NewMedal, "<a pos=\"0 -9\" hidden=\"0\" />", Now, 150, CAnimManager::EAnimManagerEasing::QuadIn);

			// Medal anim
			declare CMlFrame Frame_MedalBannerCelebration <=> (_Controls.Frame_CelebrationMedal.GetFirstChild("frame-medal-banner-celebration") as CMlFrame);
			declare CMlQuad Quad_BannerGlow <=> (_Controls.Frame_CelebrationMedal.GetFirstChild("quad-medal-banner-glow") as CMlQuad);
			declare CMlQuad Quad_Medal <=> (_Controls.Frame_CelebrationMedal.GetFirstChild("quad-medal") as CMlQuad);

			SetMedalImage(Quad_Medal, Frame_MedalBannerCelebration, _Celebration.BestMedal);

			declare StartTime = Now;
			declare GlowStartTime = Now;
			declare WaitTime0 = 0;
			declare BgTravelTime = 150;
			declare WaitTime1 = 250;
			declare PunchTime = 125;
			declare WaitTime2 = 1200;
			declare TravelTime = 200;
			declare TotalDuration = 3000;
			declare GlowPulsation = TotalDuration/4;

			declare BgTravelEasing = CAnimManager::EAnimManagerEasing::QuadIn ;
			declare PunchEasing = CAnimManager::EAnimManagerEasing::QuadIn ;
			declare TravelEasing = CAnimManager::EAnimManagerEasing::QuadIn ;
			declare FadeEasing = CAnimManager::EAnimManagerEasing::QuadOut ;
			declare GlowEasing = CAnimManager::EAnimManagerEasing::Linear ;

			declare Text MedalGainSound;
			switch (_Celebration.BestMedal) {
				case Medals::C_ScoreMgrMedal_Bronze: {
					MedalGainSound = "{{{C_Sound_MedalGainBronze}}}";
				}
				case Medals::C_ScoreMgrMedal_Silver: {
					MedalGainSound = "{{{C_Sound_MedalGainSilver}}}";
				}
				case Medals::C_ScoreMgrMedal_Gold: {
					MedalGainSound = "{{{C_Sound_MedalGainGold}}}";
				}
				case Medals::C_ScoreMgrMedal_Author: {
					MedalGainSound = "{{{C_Sound_MedalGainAuthor}}}";
				}
			}

			Quad_Medal.RelativeRotation = ML::Rand(2.,4.);
			Quad_Medal.RelativeScale = 1.5;
			Quad_Medal.RelativePosition_V3 = <5., 55.>;
			Quad_Medal.Hide();
			Frame_MedalBannerCelebration.RelativePosition_V3 = <200., 50.>;
			Frame_MedalBannerCelebration.RelativeScale = 1.;
			StartTime += WaitTime0;
			AnimMgr.Flush(Frame_MedalBannerCelebration);
			AnimMgr.Flush(Quad_Medal);
			AnimMgr.Add(Frame_MedalBannerCelebration, "<a pos=\"0 50\" hidden=\"0\" />", StartTime, BgTravelTime, BgTravelEasing);
			AudioManager::StopSound(This, "{{{C_Sound_MedalIntro}}}");
			AudioManager::PlaySoundWithDelay(This, "{{{Record::C_Id}}}", "{{{C_Sound_MedalIntro}}}", StartTime);
			StartTime += BgTravelTime + WaitTime1;
			AnimMgr.Add(Quad_Medal, "<a scale=\"1\" rot=\"0\" pos=\"0 50\" hidden=\"0\" />", StartTime, PunchTime, PunchEasing);
			AudioManager::StopSound(This, MedalGainSound);
			AudioManager::PlaySoundWithDelay(This, "{{{Record::C_Id}}}", MedalGainSound, StartTime);
			StartTime += PunchTime;
			AnimMgr.Add(Frame_MedalBannerCelebration, "<a rot=\"-78.5\" />", StartTime, 40, CAnimManager::EAnimManagerEasing::Linear);
			AnimMgr.Add(Frame_MedalBannerCelebration, "<a rot=\"-80\" />", StartTime + 40, 40, CAnimManager::EAnimManagerEasing::Linear);
			StartTime += WaitTime2;
			AnimMgr.Add(Frame_MedalBannerCelebration, "<a pos=\"{{{MedalAnim_BannerFinalPosX}}} 50\" scale=\"{{{MedalAnim_FinalScale}}}\" hidden=\"0\" />", StartTime, TravelTime, FadeEasing);
			AnimMgr.Add(Quad_Medal, "<a pos=\"-144 50\" scale=\"{{{MedalAnim_FinalScale}}}\" hidden=\"0\" />", StartTime, TravelTime, FadeEasing);
			AudioManager::StopSound(This, "{{{C_Sound_MedalOutro}}}");
			AudioManager::PlaySoundWithDelay(This, "{{{Record::C_Id}}}", "{{{C_Sound_MedalOutro}}}", StartTime);

			// Glow
			Quad_BannerGlow.Opacity = 1.;
			AnimMgr.Flush(Quad_BannerGlow);
			AnimMgr.Add(Quad_BannerGlow, "<a opacity=\"0.6\" />", GlowStartTime, GlowPulsation, GlowEasing);
			GlowStartTime += GlowPulsation;
			AnimMgr.Add(Quad_BannerGlow, "<a opacity=\"1.\" />", GlowStartTime, GlowPulsation, GlowEasing);
			GlowStartTime += GlowPulsation;
			AnimMgr.Add(Quad_BannerGlow, "<a opacity=\"0.6\" />", GlowStartTime, GlowPulsation, GlowEasing);
			GlowStartTime += GlowPulsation;
			AnimMgr.Add(Quad_BannerGlow, "<a opacity=\"1.\" />", GlowStartTime, GlowPulsation, GlowEasing);
		}
	} else {
		UIModules_PrestigeEarned_Common::UnblockPrestigeCelebration(UI, "{{{Record::C_Id}}}");
		AnimMgr.Add(Quad_CelebrationBg, "<a opacity=\"0\" hidden=\"1\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	}

	return _Celebration.IsActive;
}

Void SetFrameRecord(K_State _State, CMlFrame _Frame_Record, K_TMxSM_Record_Record _Record, Integer[Text] _RecordsStatus) {
	if (_Frame_Record == Null) return;

	declare CMlFrame LoadingSpinner_Rank <=> (_Frame_Record.GetFirstChild("loading-spinner-rank") as CMlFrame);
	declare CMlFrame LoadingSpinner_ToggleGhost <=> (_Frame_Record.GetFirstChild("loading-spinner-toggle-ghost") as CMlFrame);
	declare CMlFrame PlayerName_Name = (_Frame_Record.GetFirstChild("playername-name") as CMlFrame);
	declare CMlLabel Label_Rank <=> (_Frame_Record.GetFirstChild("label-rank") as CMlLabel);
	declare CMlLabel Label_Time <=> (_Frame_Record.GetFirstChild("label-time") as CMlLabel);
	declare CMlQuad Button_SpecRecord <=> (_Frame_Record.GetFirstChild("button-spec-record") as CMlQuad);
	declare CMlQuad Button_ToggleGhost <=> (_Frame_Record.GetFirstChild("button-toggle-ghost") as CMlQuad);
	declare CMlQuad Quad_Bg <=> (_Frame_Record.GetFirstChild("quad-bg") as CMlQuad);

	declare Text RecordClient_PlayerAccountId for _Frame_Record = "";
	RecordClient_PlayerAccountId = _Record.AccountId;

	declare Boolean CanPlayAgainstRecords = {{{UserStore_ML::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_PlayRecords);
	if (CanPlayAgainstRecords) {
		Label_Time.RelativePosition_V3.X = {{{Grid_Record.Pos[C_Col_Time]}}};
		{{{PlayerName::P}}}SetSize(This, PlayerName_Name, <{{{Grid_Record.Size[C_Col_Name]}}}, {{{Size_RecordRow.Y - 2}}}>);
	} else {
		Label_Time.RelativePosition_V3.X = {{{Grid_Record.Pos[C_Col_ToggleGhost] + (Grid_Record.Size[C_Col_ToggleGhost] * 0.5)}}};
		{{{PlayerName::P}}}SetSize(This, PlayerName_Name, <{{{Grid_Record.Size[C_Col_Name] + Grid_Record.Size[C_Col_ToggleGhost]}}}, {{{Size_RecordRow.Y - 2}}}>);
	}

	if (_Record.Rank <= 0 || !CanPlayAgainstRecords) {
		Button_ToggleGhost.Visible = False;
		{{{LoadingSpinner::P}}}StopAnimation(This, LoadingSpinner_ToggleGhost);
	} else if (!_RecordsStatus.existskey(_Record.AccountId)) {
		Button_ToggleGhost.Colorize = <1., 1., 1.>;
		Button_ToggleGhost.ImageUrl = "{{{Image_Add}}}";
		Button_ToggleGhost.Opacity = 0.5;
		Button_ToggleGhost.Visible = True;
		{{{LoadingSpinner::P}}}StopAnimation(This, LoadingSpinner_ToggleGhost);
	} else if (_RecordsStatus[_Record.AccountId] == {{{C_RecordStatus_Loading}}}) {
		Button_ToggleGhost.Visible = False;
		{{{LoadingSpinner::P}}}StartAnimation(This, LoadingSpinner_ToggleGhost);
	} else if (_RecordsStatus[_Record.AccountId] == {{{C_RecordStatus_Loaded}}} || _RecordsStatus[_Record.AccountId] == {{{C_RecordStatus_Followed}}}) {
		Button_ToggleGhost.Colorize = {{{ColorPalette::C_Color_Vec3_GreenOne}}};
		Button_ToggleGhost.ImageUrl = "{{{Image_Remove}}}";
		Button_ToggleGhost.Opacity = 1.;
		Button_ToggleGhost.Visible = True;
		{{{LoadingSpinner::P}}}StopAnimation(This, LoadingSpinner_ToggleGhost);
	}

	if (_Record.Rank > 0) {
		Label_Rank.Value = Tools::FormatTop(_Record.Rank, False, 10000);
		Label_Rank.Visible = True;
		{{{LoadingSpinner::P}}}StopAnimation(This, LoadingSpinner_Rank);
	} else {
		Label_Rank.Visible = False;
		{{{LoadingSpinner::P}}}StartAnimation(This, LoadingSpinner_Rank);
	}

	{{{PlayerName::P}}}SetAccountId(This, PlayerName_Name, _Record.AccountId, False);
	Label_Time.Value = TL::TimeToText(_Record.Time, True, True);
	Tools::FitLabelValue(Label_Rank, 1., 0.25, 0.25);
		
	// Save player record for report system in Profile
	if (Map != Null && Map.MapInfo != Null)	{
		declare Text RecordClient_PlayerRecordDetail for _Frame_Record = "";
		RecordClient_PlayerRecordDetail = ReportStruct::FormatRecordDetail(_Record.DisplayName, _Record.Time);

		declare Text RecordClient_PlayerRecordId for _Frame_Record = "";
		declare netread Text[Text] Net_Race_Record_SeasonIds for Teams[0] = [];
		RecordClient_PlayerRecordId = ReportStruct::FormatRecordId(_Record.AccountId, Net_Race_Record_SeasonIds.get(Map.MapInfo.MapUid, ""), Map.MapInfo.MapUid);
	}

	Button_SpecRecord.Visible = _State.IsLocalMode;
	FocusRecord(_Frame_Record, _State.SpectatorTargetAccountId, {{{Navigation::P}}}IsFocused(This, _Frame_Record, "{{{C_NavGroupName}}}")); //< Keep the focus if the record was focused before the black screen
}

K_TMxSM_Record_Records SetRecords(
	K_State _State,
	K_Controls _Controls,
	K_TMxSM_Record_Records[] _ZonesRecords,
	Boolean _IsLoading,
	Integer[Text] _RecordsStatus,
	Integer[] _RecordsErrorCodes,
	Boolean _MapAvailaibleOnNadeoServices,
	Boolean _CanViewLeaderboards
) {
	declare CMlFrame Frame_Loading <=> (_Controls.Frame_Records.GetFirstChild("frame-loading") as CMlFrame);
	declare CMlFrame LoadingSpinner_Records <=> (_Controls.Frame_Records.GetFirstChild("loading-spinner-records") as CMlFrame);
	declare CMlFrame Frame_RankingsContainer <=> (_Controls.Frame_Records.GetFirstChild("frame-rankings-container") as CMlFrame);
	declare Boolean CanPlayAgainstRecords = {{{UserStore_ML::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_PlayRecords);

	declare K_TMxSM_Record_Records ZoneRecords;
	if (_ZonesRecords.existskey(_State.SelectedZone)) {
		ZoneRecords = _ZonesRecords[_State.SelectedZone];
	} else if (_ZonesRecords.count > 0) {
		ZoneRecords = _ZonesRecords[0];
	}

	declare Integer Race_Record_RecordsSelectedZone for ClientUI = C_RecordType_None;
	if (_ZonesRecords.count <= 0) {
		Race_Record_RecordsSelectedZone = C_RecordType_None;
	} else if (ZoneRecords.Type == C_RecordType_Club) {
		Race_Record_RecordsSelectedZone = C_RecordType_Club;
	} else if (ZoneRecords.Type == C_RecordType_ClubVIP) {
		Race_Record_RecordsSelectedZone = C_RecordType_ClubVIP;
	} else if (ZoneRecords.Type == C_RecordType_GlobalVIP) {
		Race_Record_RecordsSelectedZone = C_RecordType_GlobalVIP;
	} else {
		Race_Record_RecordsSelectedZone = C_RecordType_Zones;
	}

	Frame_Loading.Visible = _IsLoading;
	Frame_RankingsContainer.Visible = !_IsLoading && _MapAvailaibleOnNadeoServices && ZoneRecords.Records.count > 0;
	_Controls.Frame_StandardRequired.Visible = !_IsLoading && ZoneRecords.Records.count <= 0 && !HasRecordPermission(ZoneRecords.Type);
	_Controls.Frame_MissingPrivilege.Visible = !_IsLoading && !_CanViewLeaderboards && !_Controls.Frame_StandardRequired.Visible;
	_Controls.Frame_MapNotAvailable.Visible = !_IsLoading && !_MapAvailaibleOnNadeoServices && !_Controls.Frame_MissingPrivilege.Visible && !_Controls.Frame_StandardRequired.Visible;
	_Controls.Frame_NoRecords.Visible = !_IsLoading && _MapAvailaibleOnNadeoServices && ZoneRecords.Records.count <= 0 && !_Controls.Frame_StandardRequired.Visible;
	_Controls.Frame_ScrollRanking.Visible = (Frame_RankingsContainer.Visible && (ZoneRecords.Type == C_RecordType_ClubVIP || ZoneRecords.Type == C_RecordType_GlobalVIP));
	_Controls.Frame_Ranking.Visible = (Frame_RankingsContainer.Visible && !_Controls.Frame_ScrollRanking.Visible);
	_Controls.Frame_Zone.Visible = !_IsLoading && _MapAvailaibleOnNadeoServices && _ZonesRecords.count >= 1;
	_Controls.Frame_TogglePB.Visible = (
		CanPlayAgainstRecords &&
		(_Controls.Frame_ScrollRanking.Visible || _Controls.Frame_Ranking.Visible) && 
		(_RecordsStatus.exists({{{C_RecordStatus_Loaded}}}) || _RecordsStatus.exists({{{C_RecordStatus_Followed}}}))
	);
	_Controls.Frame_RecordsDisabled.Visible = !_State.NewRecordsEnabled && _MapAvailaibleOnNadeoServices && !_Controls.Frame_StandardRequired.Visible;
	{{{LoadingSpinner::P}}}SetIsLoading(This, LoadingSpinner_Records, _IsLoading);

	{{{Scroll::P}}}SetElementsTotal(This, _Controls.Scroll_Ranking, ZoneRecords.Records.count);
	foreach (Key => Control in _Controls.Frame_Ranking.Controls) {
		declare K_TMxSM_Record_Record Record;
		if (ZoneRecords.Records.existskey(Key)) {
			Record = ZoneRecords.Records[Key];
		}

		Control.Visible = Record.AccountId != "";
		{{{Navigation::P}}}Lock(Control, !Control.Visible);
		if (Record.AccountId != "") {
			SetFrameRecord(_State, (Control as CMlFrame), Record, _RecordsStatus);
		} else {
			declare Text RecordClient_PlayerAccountId for Control = "";
			RecordClient_PlayerAccountId = "";
		}
	}
	if (_Controls.Frame_ScrollRanking.Visible) {
		if (_Controls.Frame_TogglePB.Visible) {
			{{{Scroll::P}}}SetScrollIndicatorOffset(_Controls.Scroll_Ranking, <0., -10. - {{{Size_RecordRow.Y}}}>);
		} else {
			{{{Scroll::P}}}SetScrollIndicatorOffset(_Controls.Scroll_Ranking, <0., -10.>);
		}
	}

	declare Integer AfterRecordsShiftY = GetAfterRecordsShift(_Controls, ZoneRecords.Records.count);
	if (_Controls.Frame_TogglePB.Visible || _Controls.Frame_RecordsDisabled.Visible) {
		if (_Controls.Frame_TogglePB.Visible) {
			_Controls.Frame_TogglePB.RelativePosition_V3.Y = -{{{Size_RecordRow.Y}}} * AfterRecordsShiftY;
			AfterRecordsShiftY += 1;
		}
		if (_Controls.Frame_RecordsDisabled.Visible) {
			_Controls.Frame_RecordsDisabled.RelativePosition_V3.Y = -{{{Size_RecordRow.Y}}} * AfterRecordsShiftY;
			AfterRecordsShiftY += 1;
		}
	}

	if (_Controls.Frame_Zone.Visible) {
		declare CMlLabel Label_Zone <=> (_Controls.Frame_Zone.GetFirstChild("label-zone") as CMlLabel);
		declare CMlQuad Quad_ZoneIcon <=> (_Controls.Frame_Zone.GetFirstChild("quad-zone-icon") as CMlQuad);

		Label_Zone.Value = C_Zone_Translations.get(ZoneRecords.ZoneName, TL::GetTranslatedText(ZoneRecords.ZoneName));

		if (ZoneRecords.Type == C_RecordType_ClubVIP || ZoneRecords.Type == C_RecordType_GlobalVIP) {
			if (ZoneRecords.Records.count > 8) AfterRecordsShiftY += 2; //< The scroll indicator is visible
			Label_Zone.Size.X = {{{Size_RecordRow.X - 8 - Size_RecordRow.Y}}};
			Tools::FitLabelValue(Label_Zone, 2.5, 1., 0.5);
			declare Real LabelWidth = Label_Zone.ComputeWidth(Label_Zone.Value);
			LabelWidth = ML::Min(LabelWidth, Label_Zone.Size.X);
			Quad_ZoneIcon.Visible = True;
			Quad_ZoneIcon.ImageUrl = "{{{Const::C_ImageUrl_Icon_VIP_2}}}";
			Label_Zone.RelativePosition_V3.X = {{{Size_RecordRow.X * 0.5}}} + (Quad_ZoneIcon.Size.X * -0.5);
			Quad_ZoneIcon.RelativePosition_V3.X = {{{Size_RecordRow.X * 0.5}}} + (LabelWidth * 0.5);
		} else {
			Label_Zone.Size.X = {{{Size_RecordRow.X - 8}}};
			Tools::FitLabelValue(Label_Zone, 2.5, 1., 0.5);
			Label_Zone.RelativePosition_V3.X = {{{Size_RecordRow.X * 0.5}}};
			Quad_ZoneIcon.Visible = False;
		}
	}

	if (_Controls.Frame_NoRecords.Visible) {
		declare CMlLabel Label_NoRecords <=> (_Controls.Frame_NoRecords.GetFirstChild("label-no-records") as CMlLabel);
		if (_RecordsErrorCodes.count == 0) {
			Label_NoRecords.Value = "{{{Text_NoRecords}}}";
			Label_NoRecords.TextColor = <1., 1., 1.>;
		} else {
			if (_RecordsErrorCodes.exists({{{C_RecordsError_MapNotFound}}})) {
				Label_NoRecords.Value = "{{{Text_MapNotFound}}}";
			} else {
				Label_NoRecords.Value = "{{{Text_RecordsError}}}";
			}
			Label_NoRecords.TextColor = CL::Hex6ToRgb("ff3d1d");
		}
		if (_Controls.Frame_Zone.Visible) {
			_Controls.Frame_NoRecords.RelativePosition_V3.Y = {{{-Size_RecordRow.Y*4}}};
		} else {
			_Controls.Frame_NoRecords.RelativePosition_V3.Y = {{{-Size_RecordRow.Y*3}}};
		}
	}

	if (_Controls.Frame_StandardRequired.Visible) {
		Tools::FitLabelValue((_Controls.Frame_StandardRequired.GetFirstChild("label-standard-required") as CMlLabel), 3., 1., 0.5);
	}

	if (_Controls.Frame_MapNotAvailable.Visible) {
		Tools::FitLabelValue((_Controls.Frame_MapNotAvailable.GetFirstChild("label-map-not-available") as CMlLabel), 3., 1., 0.5);
	}

	if (_Controls.Frame_MissingPrivilege.Visible) {
		Tools::FitLabelValue(_Controls.Label_MissingPrivilege, 3., 1., 0.5);
	}

	// Update controller infos
	AnimMgr.Flush(_Controls.Frame_ControllerInfo);
	AnimMgr.Add(_Controls.Frame_ControllerInfo, "<anim pos=\""^_Controls.Frame_ControllerInfo.RelativePosition_V3.X^" "^AfterRecordsShiftY * {{{-Size_RecordRow.Y}}}^"\" />", Now, 250, CAnimManager::EAnimManagerEasing::QuadOut);
	_Controls.Frame_ControllerInfo.Controls[{{{C_Row_Select}}}].Visible = CanPlayAgainstRecords && ZoneRecords.Records.count != 0  && _State.IsLocalMode;
	_Controls.Frame_ControllerInfo.Controls[{{{C_Row_Action1}}}].Visible = CanPlayAgainstRecords && ZoneRecords.Records.count != 0;
	_Controls.Frame_ControllerInfo.Controls[{{{C_Row_Action2}}}].Visible = CanPlayAgainstRecords && ZoneRecords.Records.count != 0;
	Grid::Update(_State.GridConfig_ControllerInfos, AnimMgr, _Controls.Frame_ControllerInfo, False, True);

	return ZoneRecords;
}

Void ShowScrollRecord(K_State _State, CMlFrame _Frame_Record, K_TMxSM_Record_Record _Record, Integer[Text] _RecordsStatus) {
	SetFrameRecord(_State, _Frame_Record, _Record, _RecordsStatus);
	(_Frame_Record.GetFirstChild("quad-activation") as CMlQuad).Visible = _State.IsLocalMode;
	_Frame_Record.Visible = True;
}

Void HideScrollRecord(CMlFrame _Frame_Record) {
	declare Text RecordClient_PlayerAccountId for _Frame_Record = "";
	RecordClient_PlayerAccountId = "";
	(_Frame_Record.GetFirstChild("quad-activation") as CMlQuad).Visible = False;
	_Frame_Record.Visible = False;
}

Integer SelectZone(K_Controls _Controls, K_TMxSM_Record_Records[] _Records, Integer _Zone) {
	declare Integer ZoneMax = ML::Max(0, _Records.count - 1);
	declare Integer Zone = ML::Clamp(_Zone, 0, ZoneMax);

	if (_Records.count <= 1) {
		_Controls.Button_ZoneNext.Visible = False;
		_Controls.Button_ZonePrev.Visible = False;
	} else {
		_Controls.Button_ZoneNext.Visible = True;
		_Controls.Button_ZonePrev.Visible = True;
		if (Zone <= 0) _Controls.Button_ZonePrev.Visible = False;
		else _Controls.Button_ZonePrev.Visible = True;
		if (Zone >= ZoneMax) _Controls.Button_ZoneNext.Visible = False;
		else _Controls.Button_ZoneNext.Visible = True;
	}

	return Zone;
}

Boolean PinRecords(CMlFrame _Frame_Records, Boolean _IsPinned) {
	declare CMlQuad Quad_ToggleRecordsIcon <=> (_Frame_Records.GetFirstChild("quad-toggle-records-icon") as CMlQuad);

	Quad_ToggleRecordsIcon.Opacity = 1.;
	if (_IsPinned) Quad_ToggleRecordsIcon.ImageUrl = "{{{Const::C_ImageUrl_Icon_Pin_Full}}}";
	else Quad_ToggleRecordsIcon.ImageUrl = "{{{Const::C_ImageUrl_Icon_Pin_Empty}}}";

	return _IsPinned;
}

Void DisplayRecords(CMlFrame _Frame_Records, Boolean _Display, Boolean _PlayAnim) {
	declare CMlQuad Quad_ToggleRecordsIcon <=> (_Frame_Records.GetFirstChild("quad-toggle-records-icon") as CMlQuad);
	declare CMlFrame Frame_Slide <=> (_Frame_Records.GetFirstChild("frame-slide") as CMlFrame);

	if (_Display) {
		Quad_ToggleRecordsIcon.ImageUrl = "{{{Image_NextZone}}}";
		Quad_ToggleRecordsIcon.Opacity = .4;
		if (_PlayAnim) {
			AnimMgr.Add(Frame_Slide, "<a pos=\"0 0\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
		} else {
			AnimMgr.Flush(Frame_Slide);
			Frame_Slide.RelativePosition_V3.X = 0.;
		}
	} else {
		Quad_ToggleRecordsIcon.ImageUrl = "{{{Image_Open}}}";
		Quad_ToggleRecordsIcon.Opacity = 1.;
		if (_PlayAnim) {
			AnimMgr.Add(Frame_Slide, "<a pos=\"{{{-Size_RecordRow.X-11}}} 0\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
		} else {
			AnimMgr.Flush(Frame_Slide);
			Frame_Slide.RelativePosition_V3.X = {{{-Size_RecordRow.X-11}}};
		}
	}
	
	declare Boolean Race_Record_PlayerIsDisplayingRecords for ClientUI = False;
	Race_Record_PlayerIsDisplayingRecords = _Display;
}
Void DisplayRecords(CMlFrame _Frame_Records, Boolean _Display) {
	DisplayRecords(_Frame_Records, _Display, True);
}
Boolean ToggleRecords(CMlFrame _Frame_Records, Boolean _IsVisible) {
	DisplayRecords(_Frame_Records, !_IsVisible);
	return !_IsVisible;
}

Boolean RecordsAreUnlocked(Integer _CurrentMedal, Integer _ClubId) {
	return (
		(
			UserMgr.MainUserProfile.Interface_AlwaysDisplayRecords ||
			_CurrentMedal >= C_MedalToUnlockWorldRecords || (
				_CurrentMedal >= C_MedalToUnlockClubRecords &&
				_ClubId != {{{ClubStruct::P}}}C_ClubNullId
			)
		)
	);
}

Text SaveSelectedZone(K_TMxSM_Record_Records[] _ZonesRecords, Integer _SelectedZone) {
	if (_ZonesRecords.existskey(_SelectedZone)) {
		if (_ZonesRecords[_SelectedZone].Type == C_RecordType_Club) {
			return C_FakeZone_Club;
		} else if (_ZonesRecords[_SelectedZone].Type == C_RecordType_ClubVIP) {
			return C_FakeZone_ClubVIP;
		} else if (_ZonesRecords[_SelectedZone].Type == C_RecordType_GlobalVIP) {
			return C_FakeZone_GlobalVIP;
		} else {
			return _ZonesRecords[_SelectedZone].ZoneName;
		}
	}
	return "";
}

Integer LoadSelectedZone(K_TMxSM_Record_Records[] _ZonesRecords, Text _SavedZone) {
	foreach (Key => ZoneRecords in _ZonesRecords) {
		if (_SavedZone == C_FakeZone_Club) {
			if (ZoneRecords.Type == C_RecordType_Club) return Key;
		} else if (_SavedZone == C_FakeZone_ClubVIP) {
			if (ZoneRecords.Type == C_RecordType_ClubVIP) return Key;
		} else if (_SavedZone == C_FakeZone_GlobalVIP) {
			if (ZoneRecords.Type == C_RecordType_GlobalVIP) return Key;
		} else if (_SavedZone == ZoneRecords.ZoneName) {
			return Key;
		}
	}
	return 0;
}

Void ToggleGhost(CMlControl _Control, Text _SpectatorTargetAccountId) {
	declare Text RecordClient_PlayerAccountId for _Control = "";
	if (RecordClient_PlayerAccountId == _SpectatorTargetAccountId && InputPlayer != Null && InputPlayer.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned)	{
		SendCustomEvent("{{{C_Event_SpectateGhost}}}", [RecordClient_PlayerAccountId]);
	} else {
		SendCustomEvent("{{{C_Event_ToggleGhost}}}", [RecordClient_PlayerAccountId]);
	}
}

Boolean DisplayBackToRaceButton(CMlFrame _Button_BackToRace, Boolean _IsDisplayed) {
	AnimMgr.Flush(_Button_BackToRace);
	if (_IsDisplayed) {
		AnimMgr.Add(_Button_BackToRace, "<anim pos=\""^{{{Pos_ButtonVisible.X}}}^" "^{{{Pos_ButtonVisible.Y}}}^"\" hidden=\"0\"/>", Now+500, 250, CAnimManager::EAnimManagerEasing::QuadOut);
	} else {
		AnimMgr.Add(_Button_BackToRace, "<anim pos=\""^{{{Pos_ButtonHidden.X}}}^" "^{{{Pos_ButtonHidden.Y}}}^"\" hidden=\"1\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	}

	return _IsDisplayed;
}

K_State ChangeZone(
	K_State _State, 
	K_Controls _Controls, 
	K_TMxSM_Record_Records[] _ZonesRecords,
	Boolean _IsLoading,
	Integer[Text] _RecordsStatus,
	Integer[] _RecordsErrorCodes,
	Boolean _MapAvailaibleOnNadeoServices,
	Boolean _CanViewLeaderboards,
	Boolean _IsMouse,
	Integer _ZoneShift
) {
	declare K_State State = _State;

	// Update current zone
	State.SelectedZone = SelectZone(_Controls, _ZonesRecords, State.SelectedZone + _ZoneShift);
	State.CurrentZoneRecords = SetRecords(State, _Controls, _ZonesRecords, _IsLoading, _RecordsStatus, _RecordsErrorCodes, _MapAvailaibleOnNadeoServices, _CanViewLeaderboards);

	// Update focus
	if (!_IsMouse || State.IsControllerNavigationEnabled) {
		if (State.CurrentZoneRecords.Type == C_RecordType_ClubVIP || State.CurrentZoneRecords.Type == C_RecordType_GlobalVIP) { //< Focus scroll if VIP records
			Focus({{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroupName}}}"), _Controls.Scroll_Ranking, State, _IsMouse, True);
		} else {
			declare CMlControl ControlToFocus;
			if (_Controls.Frame_Ranking.Controls.count > 0) ControlToFocus = _Controls.Frame_Ranking.Controls[0]; //< Set a default focus in case there is no local user's record
			foreach (Key => Control in _Controls.Frame_Ranking.Controls) { //< Try to focus the local user's record
				if (State.CurrentZoneRecords.Records.existskey(Key) && State.CurrentZoneRecords.Records[Key].AccountId == LocalUser.WebServicesUserId) {
					ControlToFocus = Control;
					break;
				}
			}
			Focus({{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroupName}}}"), ControlToFocus, State, _IsMouse, True);
		}
	}

	return State;
}

***MainInit***
***
declare CMlFrame Frame_Global;

declare K_State State;
declare K_Controls Controls;

declare netread Boolean Net_Race_Record_MedalEnabled for Teams[0] = False;
declare netread Boolean Net_Race_Record_CelebratePB for Teams[0] = False;
declare netread Boolean Net_Race_Record_CelebrateMedal for Teams[0] = False;
declare netread Boolean Net_Race_Record_DisplayRecords for Teams[0] = False;
declare netread Boolean Net_Race_Record_NewRecordsEnabled for Teams[0] = False;
declare netread Boolean Net_Race_Record_SpecialVisibility for Teams[0] = True;
declare netread Text Net_Race_Record_SpectatorTargetAccountId for Teams[0] = "";

declare persistent Boolean TMxSM_Race_Record_DisplayRecords for UserMgr.MainUser = False;
declare persistent Text TMxSM_Race_Record_SelectedZone_V2 for UserMgr.MainUser = "";

// Use `for ClientUI` instead of `for UI` so the data
// is correctly shared between all players in splitscreen
// `for UI` is only sent the the first player
declare Boolean Race_Record_IsRecordsModuleDisplayed for ClientUI = False;
declare Boolean Race_Record_IsControllerNavigationEnabled for ClientUI = False;
declare Integer Race_Record_CurrentMedal for ClientUI = Medals::C_ScoreMgrMedal_None;
declare Integer Race_Record_ClubId for ClientUI = {{{ClubStruct::P}}}C_ClubNullId;
declare K_Celebration Race_Record_Celebration for ClientUI;
declare K_TMxSM_Record_Records[] Race_Record_ZonesRecords for ClientUI;
declare Boolean Race_Record_LoadingRecords for ClientUI;
declare Integer[] Race_Record_RecordsErrorCodes for ClientUI;
declare Integer Race_Record_ZonesRecordsUpdate for ClientUI;
declare Integer[Text] Race_Record_RecordsStatus for ClientUI;
declare Integer Race_Record_RecordsStatusUpdate for ClientUI;
declare Boolean Race_Record_MapAvailaibleOnNadeoServices for ClientUI = False;
declare Boolean Race_Record_CanViewLeaderboards for ClientUI = False;
declare Boolean Race_Record_ManialinkIsInitialized for ClientUI = False;
declare Boolean Race_Record_PBGhostIsVisible for ClientUI;
declare Text Race_Record_SpectatorTargetAccountId for ClientUI = "";
declare Integer Race_Record_RecordsSelectedZone for ClientUI = C_RecordType_None;

declare Boolean Net_TMxSM_ScoresTable_IsDisplayed for UI;
declare Boolean Race_Record_CelebrationIsActive for UI;

declare Boolean DisplayModule;
declare Boolean DisplayContent;
declare Boolean DisplayMedal; // Frame.Visible
declare Boolean MedalIsVisible; // frame elements shown by animation
declare Boolean DisplayCelebration;
declare Integer ZonesRecordsUpdate;
declare Integer RecordsStatusUpdate;
declare CUIConfig::EUISequence PrevUISequence;
declare CSmPlayer::ESpawnStatus PrevSpawnStatus;
declare Integer MedalShowTime;
declare Integer MedalHideTime;
declare Boolean PBGhostIsVisible;
declare Boolean IsBackToRaceButtonActive;
declare Boolean IsBackToRaceButtonDisplaying;
declare Boolean IsMouse;
***

***MainStart***
***
Frame_Global <=> (Page.GetFirstChild("frame-global") as CMlFrame);

Controls = K_Controls {
	ButtonIcon_TogglePB = (Frame_Global.GetFirstChild("button-icon-toggle-pb") as CMlFrame),
	ButtonIcon_ToggleRecords = (Frame_Global.GetFirstChild("button-icon-toggle-records") as CMlFrame),
	Button_BackToRace = (Frame_Global.GetFirstChild("button-back-to-race") as CMlFrame),
	Button_ZoneNext = (Frame_Global.GetFirstChild("button-zone-next") as CMlQuad),
	Button_ZonePrev = (Frame_Global.GetFirstChild("button-zone-prev") as CMlQuad),
	Checkbox_TogglePB = (Frame_Global.GetFirstChild("checkbox-toggle-pb") as CMlFrame),
	Frame_Celebration = (Frame_Global.GetFirstChild("frame-celebration") as CMlFrame),
	Frame_CelebrationMedal = (Frame_Global.GetFirstChild("frame-celebration-medal") as CMlFrame),
	Frame_CelebrationTime = (Frame_Global.GetFirstChild("frame-celebration-time") as CMlFrame),
	Frame_Content = (Frame_Global.GetFirstChild("frame-content") as CMlFrame),
	Frame_ControllerInfo = (Frame_Global.GetFirstChild("frame-controller-info") as CMlFrame),
	Frame_MapNotAvailable = (Frame_Global.GetFirstChild("frame-map-not-available") as CMlFrame),
	Frame_Medal = (Frame_Global.GetFirstChild("frame-medal") as CMlFrame),
	Frame_MissingPrivilege = (Frame_Global.GetFirstChild("frame-missing-privilege") as CMlFrame),
	Frame_NoRecords = (Frame_Global.GetFirstChild("frame-no-records") as CMlFrame),
	Frame_Profile = (Page.GetFirstChild("frame-profile") as CMlFrame),
	Frame_Ranking = (Frame_Global.GetFirstChild("frame-ranking") as CMlFrame),
	Frame_Records = (Frame_Global.GetFirstChild("frame-records") as CMlFrame),
	Frame_RecordsDisabled = (Frame_Global.GetFirstChild("frame-records-disabled") as CMlFrame),
	Frame_ScrollRanking = (Frame_Global.GetFirstChild("frame-scroll-ranking") as CMlFrame),
	Frame_StandardRequired = (Frame_Global.GetFirstChild("frame-standard-required") as CMlFrame),
	Frame_TogglePB = (Frame_Global.GetFirstChild("frame-toggle-pb") as CMlFrame),
	Frame_Zone = (Frame_Global.GetFirstChild("frame-zone") as CMlFrame),
	Label_MissingPrivilege = (Frame_Global.GetFirstChild("label-missing-privilege") as CMlLabel),
	Scroll_Ranking = (Frame_Global.GetFirstChild("scroll-ranking") as CMlFrame)
};

State = K_State {
	CurrentMedal = Medals::C_ScoreMgrMedal_None,
	SelectedZone = LoadSelectedZone(Race_Record_ZonesRecords, TMxSM_Race_Record_SelectedZone_V2),
	NewRecordsEnabled = Controls.Frame_Records.Visible
};
State.GridConfig_ControllerInfos.fromjson({{{"\"\"\""^GridConfigJson_ControllerInfos^"\"\"\""}}});

DisplayModule = Frame_Global.Visible;
DisplayContent = Controls.Frame_Content.Visible;
DisplayMedal = Controls.Frame_Medal.Visible;
DisplayCelebration = Controls.Frame_Celebration.Visible;
ZonesRecordsUpdate = -123;
RecordsStatusUpdate = -123;
MedalShowTime = -123;
MedalHideTime = -123;
PBGhostIsVisible = !{{{Checkbox::P}}}Check(This, Controls.Checkbox_TogglePB, !Race_Record_PBGhostIsVisible);
Race_Record_IsRecordsModuleDisplayed = Controls.Frame_Records.Visible;
Race_Record_CelebrationIsActive = UpdateCelebration(Controls, Race_Record_Celebration);
Race_Record_RecordsSelectedZone = C_RecordType_None;
Race_Record_ManialinkIsInitialized = True; //< Tell the ManiaApp that the Manialink is initialized

{{{Scroll::P}}}UseLocalEvents(This, True);
{{{Scroll::P}}}SetElementsTotal(This, Controls.Scroll_Ranking, 0);
{{{Navigation::P}}}UseLocalEvents(This, True);

SetMedal(Controls, State.CurrentMedal);
DisplayRecords(Controls.Frame_Records, TMxSM_Race_Record_DisplayRecords, False);
if (SplitScreenCount > 1) MV_Utils::AutoScaleSplitScreen(Frame_Global, 0.5, 1.);
// Must move this UI to respect safe area on Playstation (see /trackmania-next/tmnext/-/issues/5400)
if (Platform::IsSony(System)) {
	if (SplitScreenCount > 1) {
		Controls.Frame_Records.RelativePosition_V3.X = Controls.Frame_Records.RelativePosition_V3.X + 26;
	} else {
		Controls.Frame_Records.RelativePosition_V3.X = Controls.Frame_Records.RelativePosition_V3.X + 9.5;
	}
}
***

***MainLoop***
***
if (!EnableMenuNavigationInputs && Frame_Global.Visible && State.IsControllerNavigationEnabled && !IsInGameMenuDisplayed) {
	ClientUI.UISequence = CUIConfig::EUISequence::UIInteraction;
	EnableMenuNavigation(True, False, False, Null, C_InputPriority_Records);
} else if (EnableMenuNavigationInputs && (!Frame_Global.Visible || !State.IsControllerNavigationEnabled || IsInGameMenuDisplayed)) {
	ClientUI.UISequence = CUIConfig::EUISequence::None;
	EnableMenuNavigation(False, False, False, Null, C_InputPriority_Records);
}

if (PageIsVisible) {
	declare Owner <=> MV_Utils::GetOwner(This);
	if (Owner != Null) {
		declare netread Boolean Net_Race_Record_IsVisible for Owner;
		if (DisplayModule != Net_Race_Record_IsVisible) {
			DisplayModule = Net_Race_Record_IsVisible;
			Frame_Global.Visible = DisplayModule;
			DisplayProfile(Controls, Null, False);
			if (DisplayModule && !State.IsLocalMode && State.IsControllerNavigationEnabled) { //< Force focus update on map change if the controller navigation is enabled
				State = ChangeZone(State, Controls, Race_Record_ZonesRecords, Race_Record_LoadingRecords, Race_Record_RecordsStatus, Race_Record_RecordsErrorCodes, Race_Record_MapAvailaibleOnNadeoServices, Race_Record_CanViewLeaderboards, False, 0);
			}
		}
	}

	if (Owner == Null && DisplayModule) {
		DisplayModule = False;
		Frame_Global.Visible = DisplayModule;
	}

	if (Frame_Global.Visible) {
		if (DisplayContent != Net_Race_Record_SpecialVisibility) {
			DisplayContent = Net_Race_Record_SpecialVisibility;
			Controls.Frame_Content.Visible = DisplayContent;
		}
		if (DisplayMedal != (Net_Race_Record_MedalEnabled && !Race_Record_CelebrationIsActive)) {
			DisplayMedal = (Net_Race_Record_MedalEnabled && !Race_Record_CelebrationIsActive);
			Controls.Frame_Medal.Visible = DisplayMedal;
		}
		if (InputPlayer != Null && InputPlayer.SpawnStatus != PrevSpawnStatus) {
			PrevSpawnStatus = InputPlayer.SpawnStatus;
			if (UI.UISequence == CUIConfig::EUISequence::Playing && InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawning) {
				MedalHideTime = Now + 3000;
				MedalShowTime = Now;
			}
		}
		if (PrevUISequence != UI.UISequence) {
			PrevUISequence = UI.UISequence;
			if (UI.UISequence == CUIConfig::EUISequence::Playing) {
				MedalHideTime = Now + 3000;
				MedalShowTime = 0;
				AudioManager::StopSound(This, "{{{C_Sound_MedalGainBronze}}}");
				AudioManager::StopSound(This, "{{{C_Sound_MedalGainSilver}}}");
				AudioManager::StopSound(This, "{{{C_Sound_MedalGainGold}}}");
				AudioManager::StopSound(This, "{{{C_Sound_MedalGainAuthor}}}");
			} else {
				MedalShowTime = Now + 250;
				MedalHideTime = 0;
			}
		}
		if (UI.UISequence == CUIConfig::EUISequence::Playing) {
			if (Net_TMxSM_ScoresTable_IsDisplayed && !MedalIsVisible) {
				MedalShowTime = Now;
				MedalHideTime = 0;
			} else if (!Net_TMxSM_ScoresTable_IsDisplayed && MedalIsVisible && MedalHideTime <= 0) {
				MedalHideTime = Now;
				MedalShowTime = 0;
			}
		}
		
		if (MedalShowTime > 0 && MedalShowTime <= Now) {
			MedalShowTime = 0;
			AnimMgr.Flush(Controls.Frame_Medal);
			AnimMgr.Add(Controls.Frame_Medal, "<a pos=\"-142 50\" />", Now, 250, CAnimManager::EAnimManagerEasing::QuadOut);
			MedalIsVisible = True;
		} else if (MedalHideTime > 0 && MedalHideTime <= Now) {
			MedalHideTime = 0;
			AnimMgr.Flush(Controls.Frame_Medal);
			AnimMgr.Add(Controls.Frame_Medal, "<a pos=\"-200 50\" />", Now, 250, CAnimManager::EAnimManagerEasing::QuadIn);
			MedalIsVisible = False;
		}

		if (DisplayCelebration != (Net_Race_Record_CelebratePB || Net_Race_Record_CelebrateMedal)) {
			DisplayCelebration = (Net_Race_Record_CelebratePB || Net_Race_Record_CelebrateMedal);
			Controls.Frame_Celebration.Visible = DisplayCelebration;
		}
		if (Race_Record_IsRecordsModuleDisplayed != (Net_Race_Record_DisplayRecords && RecordsAreUnlocked(Race_Record_CurrentMedal, Race_Record_ClubId))) {
			Race_Record_IsRecordsModuleDisplayed = (Net_Race_Record_DisplayRecords && RecordsAreUnlocked(Race_Record_CurrentMedal, Race_Record_ClubId));
			Controls.Frame_Records.Visible = Race_Record_IsRecordsModuleDisplayed;
		}

		if (Controls.Frame_Medal.Visible) {
			if (State.CurrentMedal != Race_Record_CurrentMedal) {
				State.CurrentMedal = Race_Record_CurrentMedal;
				SetMedal(Controls, State.CurrentMedal);
			}
		}

		if (Controls.Frame_Celebration.Visible) {
			if (Race_Record_CelebrationIsActive != Race_Record_Celebration.IsActive) {
				Race_Record_CelebrationIsActive = UpdateCelebration(Controls, Race_Record_Celebration);
			}
		}

		if (!IsInGameMenuDisplayed) {
			if (Controls.Frame_Records.Visible) {
				if (State.IsLocalMode != Helpers::IsLocalMode(Teams[0])) {
					State.IsLocalMode = Helpers::IsLocalMode(Teams[0]);
				}
				
				if (State.SpectatorTargetAccountId != Race_Record_SpectatorTargetAccountId) {
					State.SpectatorTargetAccountId = Race_Record_SpectatorTargetAccountId;
					State.CurrentZoneRecords = SetRecords(State, Controls, Race_Record_ZonesRecords, Race_Record_LoadingRecords, Race_Record_RecordsStatus, Race_Record_RecordsErrorCodes, Race_Record_MapAvailaibleOnNadeoServices, Race_Record_CanViewLeaderboards);
					IsBackToRaceButtonActive = State.SpectatorTargetAccountId != "" && !Race_Record_IsControllerNavigationEnabled;
					IsBackToRaceButtonDisplaying = DisplayBackToRaceButton(Controls.Button_BackToRace, IsBackToRaceButtonActive);
				}
	
				if (IsBackToRaceButtonActive) {
					if (Controls.Button_BackToRace.Visible && IsBackToRaceButtonDisplaying && Input.TimeSinceLatestActivity > C_DelayBeforeAutoHide) {
						IsBackToRaceButtonDisplaying = DisplayBackToRaceButton(Controls.Button_BackToRace, False);
					} else if (!Controls.Button_BackToRace.Visible && !IsBackToRaceButtonDisplaying && Input.TimeSinceLatestActivity < 100) {
						if (IsMouse) Focus(Controls.Button_BackToRace, Null, State, IsMouse, True); //< Force unfocus if mouse
						IsBackToRaceButtonDisplaying = DisplayBackToRaceButton(Controls.Button_BackToRace, True);
					}
				}
	
				if (State.IsControllerNavigationEnabled != Race_Record_IsControllerNavigationEnabled) {
					State.IsControllerNavigationEnabled = Race_Record_IsControllerNavigationEnabled;
					Controls.Frame_ControllerInfo.Visible = Race_Record_IsControllerNavigationEnabled;
					Controls.ButtonIcon_ToggleRecords.Visible = Race_Record_IsControllerNavigationEnabled;
					Controls.ButtonIcon_TogglePB.Visible = Race_Record_IsControllerNavigationEnabled;
					
					AnimMgr.Flush(Controls.Frame_Records);
					if (Race_Record_IsControllerNavigationEnabled) {
						IsBackToRaceButtonActive = False;
						DisplayRecords(Controls.Frame_Records, True);
						PinRecords(Controls.Frame_Records, TMxSM_Race_Record_DisplayRecords);
						IsBackToRaceButtonDisplaying = DisplayBackToRaceButton(Controls.Button_BackToRace, False);
						State = ChangeZone(State, Controls, Race_Record_ZonesRecords, Race_Record_LoadingRecords, Race_Record_RecordsStatus, Race_Record_RecordsErrorCodes, Race_Record_MapAvailaibleOnNadeoServices, Race_Record_CanViewLeaderboards, False, 0);
						AnimMgr.Add(Controls.Frame_Records, "<anim scale=\""^C_RecordsScale^"\" pos=\""^Controls.Frame_Records.RelativePosition_V3.X^" "^Controls.Frame_Records.RelativePosition_V3.Y + C_RecordsOffsetY^"\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
					} else {
						Focus({{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroupName}}}"), Null, State, True, True);
						AnimMgr.Add(Controls.Frame_Records, "<anim scale=\"1.\"  pos=\""^Controls.Frame_Records.RelativePosition_V3.X^" "^Controls.Frame_Records.RelativePosition_V3.Y - C_RecordsOffsetY^"\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
						DisplayRecords(Controls.Frame_Records, TMxSM_Race_Record_DisplayRecords);
					}
				}
	
				if (
					ZonesRecordsUpdate != Race_Record_ZonesRecordsUpdate ||
					State.NewRecordsEnabled != Net_Race_Record_NewRecordsEnabled ||
					RecordsStatusUpdate != Race_Record_RecordsStatusUpdate
				) {
					ZonesRecordsUpdate = Race_Record_ZonesRecordsUpdate;
					State.NewRecordsEnabled = Net_Race_Record_NewRecordsEnabled;
					RecordsStatusUpdate = Race_Record_RecordsStatusUpdate;
					State.SelectedZone = SelectZone(Controls, Race_Record_ZonesRecords, LoadSelectedZone(Race_Record_ZonesRecords, TMxSM_Race_Record_SelectedZone_V2));
					State.CurrentZoneRecords = SetRecords(State, Controls, Race_Record_ZonesRecords, Race_Record_LoadingRecords, Race_Record_RecordsStatus, Race_Record_RecordsErrorCodes, Race_Record_MapAvailaibleOnNadeoServices, Race_Record_CanViewLeaderboards);
				}
	
				if (PBGhostIsVisible != Race_Record_PBGhostIsVisible) {
					PBGhostIsVisible = !{{{Checkbox::P}}}Check(This, Controls.Checkbox_TogglePB, !Race_Record_PBGhostIsVisible);
				}
	
				foreach (Event in {{{Scroll::P}}}GetPendingEvents(This)) {
					if (Event.Scroll != Null && Event.Scroll.Id == Controls.Scroll_Ranking.Id) {
						switch (Event.Type) {
							case {{{Scroll::P}}}C_EventType_Cancel: {
								Race_Record_IsControllerNavigationEnabled = False;
								if (State.SpectatorTargetAccountId != "") {
									SendCustomEvent("{{{C_Event_SpectateGhost}}}", [State.SpectatorTargetAccountId]);
								}
							}
							case {{{Scroll::P}}}C_EventType_Select: {
								if (!Event.IsActionAutoRepeat && {{{UserStore_ML::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_PlayRecords) && State.IsLocalMode) {
									declare Text RecordClient_PlayerAccountId for Event.To = "";
									SendCustomEvent("{{{C_Event_SpectateGhost}}}", [RecordClient_PlayerAccountId]);
								}
							}
							case {{{Scroll::P}}}C_EventType_Update: {
								foreach (Key => Frame_Element in Event.ElementsVisible) {
									if (State.CurrentZoneRecords.Records.existskey(Key)) {
										ShowScrollRecord(State, Frame_Element, State.CurrentZoneRecords.Records[Key], Race_Record_RecordsStatus);
									} else {
										HideScrollRecord(Frame_Element);
									}
								}
								foreach (Key => Frame_Element in Event.ElementsHidden) {
									HideScrollRecord(Frame_Element);
								}
							}
							case {{{Scroll::P}}}C_EventType_Focus: {
								if (Event.From != Null) FocusRecord(Event.From, State.SpectatorTargetAccountId, False);
								if (Event.To != Null && {{{Scroll::P}}}IsFocused(Controls.Scroll_Ranking)) {
									FocusRecord(Event.To, State.SpectatorTargetAccountId, True);
								}
							}
							case {{{Scroll::P}}}C_EventType_NavAction: {
								if (!Event.IsActionAutoRepeat) {
									switch (Event.NavAction) {
										case CMlScriptEvent::EMenuNavAction::Action1: ToggleGhost(Event.To, State.SpectatorTargetAccountId);
										case CMlScriptEvent::EMenuNavAction::Action2: DisplayProfile(Controls, Event.To, True);
									}
								}
							}
						}
					}
				}
			}

			/* Profile player info events */
			foreach (Event in {{{ProfilePlayerInfo::P}}}PendingEvents) {
				switch (Event.Type) {
					case {{{ProfilePlayerInfo::P}}}C_EventType_Close: {
						DisplayProfile(Controls, Null, False);
					}
				}
			}
	
			foreach (Event in {{{Navigation::P}}}GetPendingEvents(This)) {
				switch (Event.Type) {
					case {{{Navigation::P}}}C_EventType_NavigateInput: {
						if ({{{Navigation::P}}}IsEventFromGroup(This, Event, "{{{C_NavGroup_Global}}}")) {
							switch (Event.Input) {
								case CMlScriptEvent::EMenuNavAction::Left: {
									State = ChangeZone(State, Controls, Race_Record_ZonesRecords, Race_Record_LoadingRecords, Race_Record_RecordsStatus, Race_Record_RecordsErrorCodes, Race_Record_MapAvailaibleOnNadeoServices, Race_Record_CanViewLeaderboards, False, 1);
									TMxSM_Race_Record_SelectedZone_V2 = SaveSelectedZone(Race_Record_ZonesRecords, State.SelectedZone);
									UserMgr.MainUser.PersistentSave(); //< Save the selected zone only when the user explicitly select another zone
								}
								case CMlScriptEvent::EMenuNavAction::Right: {
									State = ChangeZone(State, Controls, Race_Record_ZonesRecords, Race_Record_LoadingRecords, Race_Record_RecordsStatus, Race_Record_RecordsErrorCodes, Race_Record_MapAvailaibleOnNadeoServices, Race_Record_CanViewLeaderboards, False, -1);
									TMxSM_Race_Record_SelectedZone_V2 = SaveSelectedZone(Race_Record_ZonesRecords, State.SelectedZone);
									UserMgr.MainUser.PersistentSave(); //< Save the selected zone only when the user explicitly select another zone
								}
								case CMlScriptEvent::EMenuNavAction::PageUp: {
									if (!Event.IsActionAutoRepeat) {
										if (Race_Record_IsControllerNavigationEnabled) {
											TMxSM_Race_Record_DisplayRecords = PinRecords(Controls.Frame_Records, !TMxSM_Race_Record_DisplayRecords);
										} else {
											TMxSM_Race_Record_DisplayRecords = ToggleRecords(Controls.Frame_Records, TMxSM_Race_Record_DisplayRecords);
										}
										UserMgr.MainUser.PersistentSave();
									}
								}
								case CMlScriptEvent::EMenuNavAction::PageDown: {
									if (!Event.IsActionAutoRepeat && Controls.Frame_TogglePB.Visible) {
										SendCustomEvent("{{{C_Event_TogglePB}}}", []);
									}
								}
							}
						} else if ({{{Navigation::P}}}IsEventFromGroup(This, Event, "{{{C_NavGroupName}}}")) {
							switch (Event.Input) {
								case CMlScriptEvent::EMenuNavAction::Action1: if (!Event.IsActionAutoRepeat) ToggleGhost(Event.To, State.SpectatorTargetAccountId);
								case CMlScriptEvent::EMenuNavAction::Action2: if (!Event.IsActionAutoRepeat) DisplayProfile(Controls, Event.To, True);
								case CMlScriptEvent::EMenuNavAction::Cancel: {
									Race_Record_IsControllerNavigationEnabled = False;
									if (State.SpectatorTargetAccountId != "") {
										SendCustomEvent("{{{C_Event_SpectateGhost}}}", [State.SpectatorTargetAccountId]);
									}
								}
								case CMlScriptEvent::EMenuNavAction::Select: {
									if (!Event.IsActionAutoRepeat && {{{UserStore_ML::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_PlayRecords) && State.IsLocalMode) {
										declare Text RecordClient_PlayerAccountId for Event.To = "";
										SendCustomEvent("{{{C_Event_SpectateGhost}}}", [RecordClient_PlayerAccountId]);
									}
								}
								default: {
									Focus(Event.From, Event.To, State, False);
								}
							}
						}
					}
					case {{{Navigation::P}}}C_EventType_NavigateMouse: {
						if ({{{Navigation::P}}}IsEventFromGroup(This, Event, "{{{C_NavGroupName}}}")) {
							switch (Event.Mouse) {
								case CMlScriptEvent::Type::MouseClick: Select(State, Event.To);
							}
						}
					}
				}
			}
	
			foreach (Event in PendingEvents) {
				switch (Event.Type) {
					case CMlScriptEvent::Type::KeyPress: {
						if (!Race_Record_IsControllerNavigationEnabled && State.SpectatorTargetAccountId != "") {
							foreach (Pad in Input.Pads) {
								if (Pad.Type == CInputPad::EPadType::Keyboard) {
									if (Event.KeyName == Input.GetActionBinding(Input.Pads[Pad.Id], "Vehicle", "GiveUp")) {
										SendCustomEvent("{{{C_Event_SpectateGhost}}}", [State.SpectatorTargetAccountId]);
									} else if (Event.KeyName == "Return" && {{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroupName}}}") == Controls.Button_BackToRace) {
										SendCustomEvent("{{{C_Event_SpectateGhost}}}", [State.SpectatorTargetAccountId]);
									}
									break;
								}
							}
						}
					}
					case CMlScriptEvent::Type::MouseClick: {
						if (Controls.Frame_Records.Visible) {
							if (Event.ControlId == "button-toggle-records") {
								if (Race_Record_IsControllerNavigationEnabled) {
									TMxSM_Race_Record_DisplayRecords = PinRecords(Controls.Frame_Records, !TMxSM_Race_Record_DisplayRecords);
								} else {
									TMxSM_Race_Record_DisplayRecords = ToggleRecords(Controls.Frame_Records, TMxSM_Race_Record_DisplayRecords);
								}
								UserMgr.MainUser.PersistentSave();
							} else if (Event.ControlId == "button-toggle-ghost") {
								ToggleGhost(Event.Control.Parent, State.SpectatorTargetAccountId);
							} else if (Event.ControlId == "button-zone-next") {
								State = ChangeZone(State, Controls, Race_Record_ZonesRecords, Race_Record_LoadingRecords, Race_Record_RecordsStatus, Race_Record_RecordsErrorCodes, Race_Record_MapAvailaibleOnNadeoServices, Race_Record_CanViewLeaderboards, True, 1);
								TMxSM_Race_Record_SelectedZone_V2 = SaveSelectedZone(Race_Record_ZonesRecords, State.SelectedZone);
								UserMgr.MainUser.PersistentSave(); //< Save the selected zone only when the user explicitly select another zone
							} else if (Event.ControlId == "button-zone-prev") {
								State = ChangeZone(State, Controls, Race_Record_ZonesRecords, Race_Record_LoadingRecords, Race_Record_RecordsStatus, Race_Record_RecordsErrorCodes, Race_Record_MapAvailaibleOnNadeoServices, Race_Record_CanViewLeaderboards, True, -1);
								TMxSM_Race_Record_SelectedZone_V2 = SaveSelectedZone(Race_Record_ZonesRecords, State.SelectedZone);
								UserMgr.MainUser.PersistentSave(); //< Save the selected zone only when the user explicitly select another zone
							} else if ({{{Checkbox::P}}}IsCheckboxTrigger(Event.Control)) {
								declare CMlFrame Checkbox_TogglePB = {{{Checkbox::P}}}GetCheckboxFromTrigger(Event.Control);
								if (Checkbox_TogglePB != Null && Checkbox_TogglePB.ControlId == "checkbox-toggle-pb") {
									SendCustomEvent("{{{C_Event_TogglePB}}}", []);
								}
							} else if ({{{UserStore_ML::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_PlayRecords) && State.IsLocalMode && Event.ControlId == "button-spec-record") {
								declare Text RecordClient_PlayerAccountId for Event.Control.Parent = "";
								SendCustomEvent("{{{C_Event_SpectateGhost}}}", [RecordClient_PlayerAccountId]);
							}
						}
					}
					case CMlScriptEvent::Type::MouseOver: {
						if (Event.Control != Null && Event.Control.HasClass("basic-mouse-over")) {
							AnimMgr.Add(Event.Control, "<a colorize=\"ffffff\" opacity=\"1.\" />", 150, CAnimManager::EAnimManagerEasing::QuadOut);
						} else if ({{{Checkbox::P}}}IsCheckboxTrigger(Event.Control)) {
							Focus({{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroupName}}}"), {{{Checkbox::P}}}GetCheckboxFromTrigger(Event.Control), State, True);
						} else if ({{{UserStore_ML::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_PlayRecords)) {
							Focus({{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroupName}}}"), Event.Control, State, True);
						}
					}
					case CMlScriptEvent::Type::MouseOut: {
						if (Event.Control != Null && Event.Control.HasClass("basic-mouse-over")) {
							AnimMgr.Add(Event.Control, "<a colorize=\"ffffff\" opacity=\"0.4\" />", 150, CAnimManager::EAnimManagerEasing::QuadOut);
						} else if ({{{Checkbox::P}}}IsCheckboxTrigger(Event.Control)) {
							Focus({{{Checkbox::P}}}GetCheckboxFromTrigger(Event.Control), Null, State, True);
						} else if ({{{UserStore_ML::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_PlayRecords)) {
							Focus(Event.Control, Null, State, True);
						}
					}
				}
			}
	
			/* Focus or unfocus the back to race button depending on the current controller */
			if (IsMouse != Tools::IsUsingMouse(Input)) {
				IsMouse = Tools::IsUsingMouse(Input);
				if (IsBackToRaceButtonActive) {
					if (IsMouse) Focus(Controls.Button_BackToRace, Null, State, IsMouse, True);
					else Focus({{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroupName}}}"), Controls.Button_BackToRace, State, IsMouse, True);
				} else {
					if (IsMouse) {
						AnimMgr.Add(Controls.Button_ZoneNext, "<a colorize=\"ffffff\" opacity=\"0.4\" />", 150, CAnimManager::EAnimManagerEasing::QuadOut);
						AnimMgr.Add(Controls.Button_ZonePrev, "<a colorize=\"ffffff\" opacity=\"0.4\" />", 150, CAnimManager::EAnimManagerEasing::QuadOut);
						{{{Checkbox::P}}}Unfocus(This, Controls.Checkbox_TogglePB, True);
					} else {
						AnimMgr.Add(Controls.Button_ZoneNext, "<a colorize=\"ffffff\" opacity=\"1.\" />", 150, CAnimManager::EAnimManagerEasing::QuadOut);
						AnimMgr.Add(Controls.Button_ZonePrev, "<a colorize=\"ffffff\" opacity=\"1.\" />", 150, CAnimManager::EAnimManagerEasing::QuadOut);
						{{{Checkbox::P}}}Focus(This, Controls.Checkbox_TogglePB, False, True);
					}
				}
			}
		}
	}
}
***
""",
[
	UIModules::Component(),
	Checkbox::ComponentV2(),
	MedalStack::Component(),
	Navigation::ComponentV2(),
	LoadingSpinner::ComponentV2(),
	UserStore_ML::ComponentV2(),
	Scroll::ComponentV2(),
	ButtonIcon::ComponentV2(),
	ProfilePlayerInfo::Component(),
	ExpendableButton::ComponentV2(),
	Button::ComponentV2(),
	ClubStruct::Component(),
	PlayerName::ComponentV2()
],
[]
	);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the scope of the current state
K_Scope GetScope(K_State _State) {
	declare K_Scope Scope = K_Scope {
		Type = _State.ScopeNotSeason,
		Id = ""
	};
	if (_State.SeasonIds.existskey(_State.CurrentMapUid)) {
		Scope.Type = _State.ScopeSeason;
		Scope.Id = _State.SeasonIds[_State.CurrentMapUid];
	}
	return Scope;
}

K_State AddRecordsError(K_State _State, Integer _ErrorCode) {
	declare K_State State = _State;
	if (!State.RecordsErrorCodes.exists(_ErrorCode)) {
		State.RecordsErrorCodes.add(_ErrorCode);
	}
	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Send the records to the manialink UI
Void SendRecordsToML(K_State _State) {
	declare Record::K_TMxSM_Record_Records[] Race_Record_ZonesRecords for ClientUI;
	declare Boolean Race_Record_LoadingRecords for ClientUI;
	declare Integer[] Race_Record_RecordsErrorCodes for ClientUI;
	declare Integer Race_Record_ClubId for ClientUI = ClubStruct::C_ClubNullId;
	declare Boolean Race_Record_MapAvailaibleOnNadeoServices for ClientUI = False;
	declare Boolean Race_Record_CanViewLeaderboards for ClientUI = False;
	declare Integer Race_Record_ZonesRecordsUpdate for ClientUI;
	Race_Record_ZonesRecords = _State.ZonesRecords;
	Race_Record_LoadingRecords = _State.LoadingRecords;
	Race_Record_RecordsErrorCodes = _State.RecordsErrorCodes;
	Race_Record_ClubId = _State.RecordsClubId;
	Race_Record_MapAvailaibleOnNadeoServices = (_State.MapAvailaibleOnNadeoServices == C_MapAvailable_Available);
	Race_Record_CanViewLeaderboards = _State.CanViewLeaderboards;
	Race_Record_ZonesRecordsUpdate += 1;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Send the records status to the manialink UI
Void SendRecordsStatusToML(K_State _State) {
	declare Integer[Text] Race_Record_RecordsStatus for ClientUI;
	declare Integer Race_Record_RecordsStatusUpdate for ClientUI;

	Race_Record_RecordsStatus = [];

	foreach (AccountId => Record in _State.LoadingRecordGhosts) {
		Race_Record_RecordsStatus[AccountId] = C_RecordStatus_Loading;
	}
	foreach (AccountId => Record in _State.LoadedRecordGhosts) {
		Race_Record_RecordsStatus[AccountId] = C_RecordStatus_Loaded;
	}
	if (_State.SpectatorTargetRecordGhost.AccountId != "") {
		Race_Record_RecordsStatus[_State.SpectatorTargetRecordGhost.AccountId] = C_RecordStatus_Followed;
	}

	Race_Record_RecordsStatusUpdate += 1;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Send the spectator target account id the manialink UI
Void SendSpectatorTargetAccountIdToML(K_State _State) {
	declare Text Race_Record_SpectatorTargetAccountId for ClientUI;
	Race_Record_SpectatorTargetAccountId = _State.SpectatorTargetRecordGhost.AccountId;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/**	Variable used by the game modes that manage
 *	the PB ghost themselves to check if they have
 *	to display the PB ghost or not.
 */
Void SendPBGhostVisibilityToModeAndML(K_State _State) {
	declare netwrite Boolean Net_Race_Record_PBGhostIsVisible for UI;
	declare Boolean Race_Record_PBGhostIsVisible for ClientUI;
	Net_Race_Record_PBGhostIsVisible = _State.DisplayPBGhost || (_State.SpectatorTargetRecordGhost.AccountId == "" && _State.LoadedRecordGhosts.count <= 0);
	Race_Record_PBGhostIsVisible = Net_Race_Record_PBGhostIsVisible;
	SendCustomEvent(Record::C_Event_UpdatePBGhostVisibility, [""^Net_Race_Record_PBGhostIsVisible]);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Show/hide the PB ghost on the client
K_State DisplayPBGhost(K_State _State, Boolean _DisplayPBGhost) {
	declare K_State State = _State;

	// @Todo Once this has been playtested extensively we might consider
	// saving this value in a persistent variable to remember
	// the choice of the user
	State.DisplayPBGhost = _DisplayPBGhost;

	if (GhostMgr != Null) {
		// Remove previous PB ghost
		if (State.PBGhostInstanceId != NullId) {
			GhostMgr.Ghost_Remove(State.PBGhostInstanceId);
			State.PBGhostInstanceId = NullId;
		}
		if (State.PBCpSyncedGhostInstanceId != NullId) {
			GhostMgr.Ghost_Remove(State.PBCpSyncedGhostInstanceId);
			State.PBCpSyncedGhostInstanceId = NullId;
		}

		// Add new PBGhost
		if (
			State.PBGhostEnabled &&
			(State.DisplayPBGhost || (_State.SpectatorTargetRecordGhost.AccountId == "" && _State.LoadedRecordGhosts.count <= 0)) &&
			State.PBGhostId != NullId &&
			DataFileMgr.Ghosts.existskey(State.PBGhostId)
		) {
			declare CGhost PBGhost <=> DataFileMgr.Ghosts[State.PBGhostId];
			State.PBGhostInstanceId = GhostMgr.Ghost_Add(PBGhost, True);
			if (ModeConst::C_EnableCPSyncedGhost) {
				State.PBCpSyncedGhostInstanceId = GhostMgr.Ghost_AddWaypointSynced(PBGhost, True);
			}
		}
	}

	SendPBGhostVisibilityToModeAndML(State);

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Release record ghost data
K_State ReleaseRecordGhost(K_State _State, Text _AccountId) {
	declare K_State State = _State;

	declare K_RecordGhost[] Records;
	if (State.LoadingRecordGhosts.existskey(_AccountId)) Records.add(State.LoadingRecordGhosts[_AccountId]);
	if (State.LoadedRecordGhosts.existskey(_AccountId)) Records.add(State.LoadedRecordGhosts[_AccountId]);

	foreach (Record in Records) {
		Task::Destroy(Record.Task_RetrieveRecords);
		Task::Destroy(Record.Task_RetrieveGhost);
		if (Record.GhostInstanceId != NullId) {
			GhostMgr.Ghost_Remove(Record.GhostInstanceId);
		}
		if (Record.GhostId != NullId && DataFileMgr.Ghosts.existskey(Record.GhostId)) {
			DataFileMgr.Ghost_Release(Record.GhostId);
		}
	}

	State.LoadingRecordGhosts.removekey(_AccountId);
	State.LoadedRecordGhosts.removekey(_AccountId);

	State = DisplayPBGhost(State, State.DisplayPBGhost);

	return State;
}
K_State ReleaseAllRecordGhosts(K_State _State) {
	declare K_State State = _State;

	declare TmpLoadingRecordGhosts = State.LoadingRecordGhosts;
	foreach (AccountId => Record in TmpLoadingRecordGhosts) {
		State = ReleaseRecordGhost(State, AccountId);
	}
	State.LoadingRecordGhosts = [];

	declare TmpLoadedRecordGhosts = State.LoadedRecordGhosts;
	foreach (AccountId => Record in TmpLoadedRecordGhosts) {
		State = ReleaseRecordGhost(State, AccountId);
	}
	State.LoadedRecordGhosts = [];

	SendRecordsStatusToML(State);
	State = DisplayPBGhost(State, State.DisplayPBGhost);

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Retrieve a player record ghost
K_State RetrieveRecordGhost(K_State _State, Text _AccountId) {
	declare K_State State = _State;

	// Release previous record if any
	State = ReleaseRecordGhost(State, _AccountId);

	declare K_RecordGhost Record = K_RecordGhost {
		AccountId = _AccountId
	};
	declare K_Scope Scope;
	if (C_ForceRecordScope != "") {
		Scope = K_Scope {
			Type = C_ForceRecordScope,
			Id = ""
		};
	} else {
		Scope = GetScope(_State);
	}

	Record.Task_RetrieveRecords = Task::DestroyAndCreate(
		Record.Task_RetrieveRecords, 
		ScoreMgr, 
		ScoreMgr.Map_GetPlayerListRecordList(MainUser::GetMainUserId(), [Record.AccountId], State.CurrentMapUid, Scope.Type, Scope.Id, State.ModeName, State.CustomData)
	);

	State.LoadingRecordGhosts[Record.AccountId] = Record;
	SendRecordsStatusToML(State);

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Check if we can retrieve the records
Boolean CanRetrieveRecords(K_State _State) {
	return (
		_State.RecordsEnabled && //< The mode enabled the records
		_State.CurrentMapUid != "" && //< A map is loaded
		_State.PlayerIsDisplayingRecords && (//< The records are displayed on the player screen
			UserMgr.MainUserProfile.Interface_AlwaysDisplayRecords ||
			_State.CurrentMedal >= C_MedalToUnlockWorldRecords || (
				_State.CurrentMedal >= C_MedalToUnlockClubRecords &&
				_State.RecordsClubId != ClubStruct::C_ClubNullId
			)
		) //< The player has the correct medal
	);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Check if the records are dirty and we should update them
Boolean RecordsAreDirty(K_State _State) {
	return (
		_State.RecordsAreDirty.count > 0 ||
		_State.RecordsLoadedForMapUid != _State.CurrentMapUid
	);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Mark all types of records as dirty
K_State SetAllRecordsDirty(K_State _State) {
	declare K_State State = _State;

	foreach (RecordType in C_RecordTypes) {
		if (!State.RecordsAreDirty.exists(RecordType)) {
			if ((RecordType != C_RecordType_Club && RecordType != C_RecordType_ClubVIP) || State.RecordsClubId != ClubStruct::C_ClubNullId) {
				State.RecordsAreDirty.add(RecordType);
			}
		}
	}

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Check if the user has the permission to retrive the records of a given type
Boolean Private_HasGamePermission(Integer _RecordType) {
	return (
		G_RecordPermission.existskey(_RecordType) && (
			G_RecordPermission[_RecordType] == "" ||
			UserStore_MA::HasGamePermission(PrivilegeMgr, G_RecordPermission[_RecordType])
		)
	);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/* Start requests to get the map records
 *
 *	@param	_RaceTime								If negative get the player's best time
 *																	If positive get an estimation of the ranking for the given race time
 */
K_State RetrieveRecords(K_State _State, Integer _RaceTime) {
	declare K_State State = _State;

	declare Boolean HasStartedRequest = False;
	if (
		State.RecordsAreDirty.exists(C_RecordType_Zones) &&
		Private_HasGamePermission(C_RecordType_Zones) && (
			UserMgr.MainUserProfile.Interface_AlwaysDisplayRecords ||
			State.CurrentMedal >= C_MedalToUnlockWorldRecords
		) && (
			State.RecordsSelectedZone == C_RecordType_None ||
			State.RecordsSelectedZone == C_RecordType_Zones ||
			State.RecordsNeedInit.exists(C_RecordType_Zones)
		)
	) {
		if (Http::IsInitialized(State.RequestZonesTopRecords)) {
			State.RequestZonesTopRecords = Http::Destroy(State.RequestZonesTopRecords);
		}
		if (Http::IsInitialized(State.RequestZonesSurroundingRecords)) {
			State.RequestZonesSurroundingRecords = Http::Destroy(State.RequestZonesSurroundingRecords);
		}

		State.RequestZonesTopRecords = LeaderboardAPI::GetMapTopRankings(LeaderboardAPI::C_GroupUid_PersonalBest, State.CurrentMapUid, _RaceTime);
		State.RequestZonesSurroundingRecords = LeaderboardAPI::GetSurroundingRankings(LeaderboardAPI::C_GroupUid_PersonalBest, State.CurrentMapUid, Record::C_BeforeMe, Record::C_AfterMe, _RaceTime);
		State.RecordsNeedInit.remove(C_RecordType_Zones);
		HasStartedRequest = True;
	}
	if (
		State.RecordsClubId != ClubStruct::C_ClubNullId &&
		State.RecordsAreDirty.exists(C_RecordType_Club) &&
		Private_HasGamePermission(C_RecordType_Club) && (
			UserMgr.MainUserProfile.Interface_AlwaysDisplayRecords ||
			State.CurrentMedal >= C_MedalToUnlockClubRecords
		) && (
			State.RecordsSelectedZone == C_RecordType_None ||
			State.RecordsSelectedZone == C_RecordType_Club ||
			State.RecordsNeedInit.exists(C_RecordType_Club)
		)
	) {
		if (Http::IsInitialized(State.RequestClubTopRecords)) {
			State.RequestClubTopRecords = Http::Destroy(State.RequestClubTopRecords);
		}
		if (Http::IsInitialized(State.RequestClubSurroundingRecords)) {
			State.RequestClubSurroundingRecords = Http::Destroy(State.RequestClubSurroundingRecords);
		}
	
		State.RequestClubTopRecords = LeaderboardAPI::GetMapTopRankingsInClub(LeaderboardAPI::C_GroupUid_PersonalBest, State.CurrentMapUid, _State.RecordsClubId, _RaceTime);
		State.RequestClubSurroundingRecords = LeaderboardAPI::GetMapSurroundingRankingsInClub(LeaderboardAPI::C_GroupUid_PersonalBest, State.CurrentMapUid, _State.RecordsClubId, Record::C_BeforeMe, Record::C_AfterMe, _RaceTime);
		State.RecordsNeedInit.remove(C_RecordType_Club);
		HasStartedRequest = True;
	}
	if (
		State.RecordsClubId != ClubStruct::C_ClubNullId &&
		State.RecordsAreDirty.exists(C_RecordType_ClubVIP) &&
		Private_HasGamePermission(C_RecordType_ClubVIP) && (
			UserMgr.MainUserProfile.Interface_AlwaysDisplayRecords ||
			State.CurrentMedal >= C_MedalToUnlockClubRecords
		) && (
			State.RecordsSelectedZone == C_RecordType_None ||
			State.RecordsSelectedZone == C_RecordType_ClubVIP ||
			State.RecordsNeedInit.exists(C_RecordType_ClubVIP)
		)
	) {
		if (Http::IsInitialized(State.RequestClubVIPList)) {
			State.RequestClubVIPList = Http::Destroy(State.RequestClubVIPList);
		}
		if (State.TaskIdGetClubVIPRecords != NullId) {
			if (ScoreMgr.TaskResults.existskey(State.TaskIdGetClubVIPRecords)) {
				ScoreMgr.TaskResult_Release(State.TaskIdGetClubVIPRecords);
			}
			State.TaskIdGetClubVIPRecords = NullId;
		}
		
		State.RequestClubVIPList = ClubAPI::GetVIPListOnMap(_State.RecordsClubId, State.CurrentMapUid, LeaderboardAPI::C_GroupUid_PersonalBest);
		State.RecordsNeedInit.remove(C_RecordType_ClubVIP);
		HasStartedRequest = True;
	}
	if (
		State.RecordsAreDirty.exists(C_RecordType_GlobalVIP) &&
		Private_HasGamePermission(C_RecordType_GlobalVIP) && (
			UserMgr.MainUserProfile.Interface_AlwaysDisplayRecords ||
			State.CurrentMedal >= C_MedalToUnlockGlobalVIPRecords
		) && (
			State.RecordsSelectedZone == C_RecordType_None ||
			State.RecordsSelectedZone == C_RecordType_GlobalVIP ||
			State.RecordsNeedInit.exists(C_RecordType_GlobalVIP)
		)
	) {
		if (Http::IsInitialized(State.RequestGlobalVIPList)) {
			State.RequestGlobalVIPList = Http::Destroy(State.RequestGlobalVIPList);
		}
		if (State.TaskIdGetGlobalVIPRecords != NullId) {
			if (ScoreMgr.TaskResults.existskey(State.TaskIdGetGlobalVIPRecords)) {
				ScoreMgr.TaskResult_Release(State.TaskIdGetGlobalVIPRecords);
			}
			State.TaskIdGetGlobalVIPRecords = NullId;
		}
		
		State.RequestGlobalVIPList = ClubAPI::GetGlobalVIPListOnMap(State.CurrentMapUid, LeaderboardAPI::C_GroupUid_PersonalBest);
		State.RecordsNeedInit.remove(C_RecordType_GlobalVIP);
		HasStartedRequest = True;
	}

	if (State.MapAvailaibleOnNadeoServices == C_MapAvailable_NotChecked) {
		State.TaskGetMapFromUid = Task::DestroyAndCreate(
			State.TaskGetMapFromUid,
			DataFileMgr,
			DataFileMgr.Map_NadeoServices_GetFromUid(MainUser::GetMainUserId(), State.CurrentMapUid)
		);
		HasStartedRequest = True;
	}

	if (HasStartedRequest) {
		State.RequestRecordsInProgress = True;
		State.RecordsErrorCodes = [];
		State.ResponseZonesTopRecords = LeaderboardAPI::K_ResponseFromGetMapTopRankings {};
		State.ResponseZonesSurroundingRecords = LeaderboardAPI::K_ResponseFromGetSurroundingRankings {};
		State.ResponseClubTopRecords = LeaderboardAPI::K_ResponseFromGetMapTopRankingsInClub {};
		State.ResponseClubSurroundingRecords = LeaderboardAPI::K_ResponseFromGetMapSurroundingRankingsInClub {};
		State.ResponseClubVIPRecords = [];
		State.ResponseGlobalVIPRecords = [];
		State.LoadingRecords = (State.RecordsLoadedForMapUid != State.CurrentMapUid); //< Display the loading in the UI only if there are no prior records.
		State.RecordsLoadingForMapUid = State.CurrentMapUid;
		SendRecordsToML(State);
	}

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Update the records
K_State SetRecordsFromResponses(K_State _State) {
	declare K_State State = _State;
	declare Record::K_TMxSM_Record_Record[Text][Text] TmpRanking;

	// The record `Position` attribute is rounded when above 10 000.
	// This means that several players can have the same rank.
	// Do not use it as an array key anymore. Instead use the account id.

	// Add the new zones records
	if (State.ResponseZonesTopRecords.TopRankings.count > 0 || State.ResponseZonesSurroundingRecords.TopsByZone.count > 0) {
		foreach (ZoneRecords in State.ResponseZonesTopRecords.TopRankings) {
			if (!TmpRanking.existskey(ZoneRecords.ZoneName)) {
				TmpRanking[ZoneRecords.ZoneName] = [];
			}
			foreach (Record in ZoneRecords.Tops) {
				if (Record.Position >= 1 && Record.Position <= Record::C_RecordsNb) {
					TmpRanking[ZoneRecords.ZoneName][Record.AccountId] = Record::K_TMxSM_Record_Record {
						Rank = Record.Position,
						AccountId = Record.AccountId,
						DisplayName = UserStore_MA::GetUserMgrPlayerName(Record.AccountId),
						Time = Record.Score
					};
					if (TmpRanking[ZoneRecords.ZoneName].count >= Record::C_RecordsNb) break; 
				}
			}
		}
		foreach (ZoneName => ZoneRecords in State.ResponseZonesSurroundingRecords.TopsByZone) {
			if (!TmpRanking.existskey(ZoneName)) {
				TmpRanking[ZoneName] = [];
			}
			foreach (Record in ZoneRecords) {
				TmpRanking[ZoneName][Record.AccountId] = Record::K_TMxSM_Record_Record {
					Rank = Record.Position,
					AccountId = Record.AccountId,
					DisplayName = UserStore_MA::GetUserMgrPlayerName(Record.AccountId),
					Time = Record.Score
				};
				if (Record.AccountId == LocalUser.WebServicesUserId && Record.Score >= 0) {
					if (State.RecordsPlayerTime < 0 || Record.Score < State.RecordsPlayerTime) {
						State.RecordsPlayerTime = Record.Score;
					}
				}
			}
		}

		State.ResponseZonesTopRecords = LeaderboardAPI::K_ResponseFromGetMapTopRankings {};
		State.ResponseZonesSurroundingRecords = LeaderboardAPI::K_ResponseFromGetSurroundingRankings {};
		State.RecordsAreDirty.remove(C_RecordType_Zones);
	}
	// Restore the old zones records
	else {
		foreach (ZoneRecords in State.ZonesRecords) {
			if (ZoneRecords.Type == C_RecordType_Zones) {
				if (!TmpRanking.existskey(ZoneRecords.ZoneName)) {
					TmpRanking[ZoneRecords.ZoneName] = [];
				}
				foreach (Record in ZoneRecords.Records) {
					TmpRanking[ZoneRecords.ZoneName][Record.AccountId] = Record;
				}
			}
		}
	}
	
	// Add the new global VIP records
	if (State.ResponseGlobalVIPRecords.count > 0) {
		State.ResponseGlobalVIPRecords = State.ResponseGlobalVIPRecords.sort();
		if (!TmpRanking.existskey(C_FakeZone_GlobalVIP)) {
			TmpRanking[C_FakeZone_GlobalVIP] = [];
		}
		declare Integer Rank = 1;
		foreach (AccountId => Time in State.ResponseGlobalVIPRecords) {
			TmpRanking[C_FakeZone_GlobalVIP][AccountId] = Record::K_TMxSM_Record_Record {
				Rank = Rank,
				AccountId = AccountId,
				DisplayName = UserStore_MA::GetUserMgrPlayerName(AccountId),
				Time = Time
			};
			Rank += 1;
		}

		State.ResponseGlobalVIPRecords = [];
		State.RecordsAreDirty.remove(C_RecordType_GlobalVIP);
	}
	// Restore the old global VIP records
	else {
		foreach (ZoneRecords in State.ZonesRecords) {
			if (ZoneRecords.Type == C_RecordType_GlobalVIP) {
				if (!TmpRanking.existskey(C_FakeZone_GlobalVIP)) {
					TmpRanking[C_FakeZone_GlobalVIP] = [];
				}
				foreach (Record in ZoneRecords.Records) {
					TmpRanking[C_FakeZone_GlobalVIP][Record.AccountId] = Record;
				}
			}
		}
	}
	
	// Add the new club VIP records
	if (State.ResponseClubVIPRecords.count > 0) {
		State.ResponseClubVIPRecords = State.ResponseClubVIPRecords.sort();
		if (!TmpRanking.existskey(C_FakeZone_ClubVIP)) {
			TmpRanking[C_FakeZone_ClubVIP] = [];
		}
		declare Integer Rank = 1;
		foreach (AccountId => Time in State.ResponseClubVIPRecords) {
			TmpRanking[C_FakeZone_ClubVIP][AccountId] = Record::K_TMxSM_Record_Record {
				Rank = Rank,
				AccountId = AccountId,
				DisplayName = UserStore_MA::GetUserMgrPlayerName(AccountId),
				Time = Time
			};
			Rank += 1;
		}

		State.ResponseClubVIPRecords = [];
		State.RecordsAreDirty.remove(C_RecordType_ClubVIP);
	}
	// Restore the old club VIP records
	else {
		foreach (ZoneRecords in State.ZonesRecords) {
			if (ZoneRecords.Type == C_RecordType_ClubVIP) {
				if (!TmpRanking.existskey(C_FakeZone_ClubVIP)) {
					TmpRanking[C_FakeZone_ClubVIP] = [];
				}
				foreach (Record in ZoneRecords.Records) {
					TmpRanking[C_FakeZone_ClubVIP][Record.AccountId] = Record;
				}
			}
		}
	}

	// Add the new club records
	if (State.ResponseClubTopRecords.Tops.count > 0 || State.ResponseClubSurroundingRecords.Tops.count > 0) {
		if (!TmpRanking.existskey(C_FakeZone_Club)) {
			TmpRanking[C_FakeZone_Club] = [];
		}
		foreach (Record in State.ResponseClubTopRecords.Tops) {
			if (Record.Position >= 1 && Record.Position <= Record::C_RecordsNb) {
				TmpRanking[C_FakeZone_Club][Record.AccountId] = Record::K_TMxSM_Record_Record {
					Rank = Record.Position,
					AccountId = Record.AccountId,
					DisplayName = UserStore_MA::GetUserMgrPlayerName(Record.AccountId),
					Time = Record.Score
				};
				if (TmpRanking[C_FakeZone_Club].count >= Record::C_RecordsNb) break; 
			}
		}
		foreach (Record in State.ResponseClubSurroundingRecords.Tops) {
			TmpRanking[C_FakeZone_Club][Record.AccountId] = Record::K_TMxSM_Record_Record {
				Rank = Record.Position,
				AccountId = Record.AccountId,
				DisplayName = UserStore_MA::GetUserMgrPlayerName(Record.AccountId),
				Time = Record.Score
			};
			if (Record.AccountId == LocalUser.WebServicesUserId && Record.Score >= 0) {
				if (State.RecordsPlayerTime < 0 || Record.Score < State.RecordsPlayerTime) {
					State.RecordsPlayerTime = Record.Score;
				}
			}
		}

		State.ResponseClubTopRecords = LeaderboardAPI::K_ResponseFromGetMapTopRankingsInClub {};
		State.ResponseClubSurroundingRecords = LeaderboardAPI::K_ResponseFromGetMapSurroundingRankingsInClub {};
		State.RecordsAreDirty.remove(C_RecordType_Club);
	}
	// Restore the old club records
	else {
		foreach (ZoneRecords in State.ZonesRecords) {
			if (ZoneRecords.Type == C_RecordType_Club) {
				if (!TmpRanking.existskey(C_FakeZone_Club)) {
					TmpRanking[C_FakeZone_Club] = [];
				}
				foreach (Record in ZoneRecords.Records) {
					TmpRanking[C_FakeZone_Club][Record.AccountId] = Record;
				}
			}
		}
	}

	// Create the new records
	State.ZonesRecords = [];
	declare Text[] RecordAccountIds;
	declare Integer RecordsMaxNb = Record::C_RecordsNb + Record::C_BeforeMe + 1 + Record::C_AfterMe;
	foreach (ZoneName => Records in TmpRanking) {
		declare Record::K_TMxSM_Record_Records ZoneRecords = Record::K_TMxSM_Record_Records {
			ZoneName = ZoneName,
			WorstTime = -1,
			IsFull = False,
			Type = C_RecordType_Zones
		};
		
		if (ZoneName == C_FakeZone_Club) {
			ZoneRecords.ZoneName = State.RecordsClubName;
			ZoneRecords.Type = C_RecordType_Club;
		} else if (ZoneName == C_FakeZone_ClubVIP) {
			ZoneRecords.ZoneName = _("|Club|Club VIP");
			ZoneRecords.Type = C_RecordType_ClubVIP;
		} else if (ZoneName == C_FakeZone_GlobalVIP) {
			ZoneRecords.ZoneName = _("|Club|Global VIP");
			ZoneRecords.Type = C_RecordType_GlobalVIP;
		}

		declare Integer PlayerRank = -1;
		foreach (Record in Records) {
			// Sometimes the ranks returned by the top and surrounding records API collides.
			// We avoid that here by rewriting the rank to be always above the number of players
			// displayed before in the ranking.
			// Check issue #2303 for more details.
			declare Record::K_TMxSM_Record_Record RecordWithFixedRank = Record;
			RecordWithFixedRank.Rank = ML::Max(RecordWithFixedRank.Rank, ZoneRecords.Records.count + 1); //< Rank must be superior to the number of players already in the ranking
			
			ZoneRecords.Records.add(RecordWithFixedRank);
			if (!RecordAccountIds.exists(RecordWithFixedRank.AccountId)) {
				RecordAccountIds.add(RecordWithFixedRank.AccountId);
			}
			if (RecordWithFixedRank.Time >= 0 && (ZoneRecords.WorstTime < 0 || RecordWithFixedRank.Time > ZoneRecords.WorstTime)) {
				ZoneRecords.WorstTime = RecordWithFixedRank.Time;
			}
			if (RecordWithFixedRank.AccountId == LocalUser.WebServicesUserId) {
				PlayerRank = RecordWithFixedRank.Rank;
			}
		}

		ZoneRecords.IsFull = (
			ZoneRecords.Records.count >= Record::C_RecordsNb &&
			PlayerRank >= 1 && 
			(
				ZoneRecords.Records.count >= RecordsMaxNb ||
				ZoneRecords.Records.count >= PlayerRank + Record::C_AfterMe
			)
		);

		State.ZonesRecords.add(ZoneRecords);
	}

	// Remove old records ghost
	declare TmpLoadingRecordGhosts = State.LoadingRecordGhosts;
	foreach (AccountId => Record in TmpLoadingRecordGhosts) {
		if (!RecordAccountIds.exists(AccountId)) {
			State = ReleaseRecordGhost(State, AccountId);
		}
	}

	declare TmpLoadedRecordGhosts = State.LoadedRecordGhosts;
	foreach (AccountId => Record in TmpLoadedRecordGhosts) {
		if (!RecordAccountIds.exists(AccountId)) {
			State = ReleaseRecordGhost(State, AccountId);
		}
	}

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Reset all records
K_State ResetRecords(K_State _State) {
	declare K_State State = _State;

	if (Http::IsInitialized(State.RequestZonesTopRecords)) {
		State.RequestZonesTopRecords = Http::Destroy(State.RequestZonesTopRecords);
	}
	if (Http::IsInitialized(State.RequestZonesSurroundingRecords)) {
		State.RequestZonesSurroundingRecords = Http::Destroy(State.RequestZonesSurroundingRecords);
	}
	if (Http::IsInitialized(State.RequestClubTopRecords)) {
		State.RequestClubTopRecords = Http::Destroy(State.RequestClubTopRecords);
	}
	if (Http::IsInitialized(State.RequestClubSurroundingRecords)) {
		State.RequestClubSurroundingRecords = Http::Destroy(State.RequestClubSurroundingRecords);
	}
	if (Http::IsInitialized(State.RequestClubVIPList)) {
		State.RequestClubVIPList = Http::Destroy(State.RequestClubVIPList);
	}
	if (State.TaskIdGetClubVIPRecords != NullId) {
		if (ScoreMgr.TaskResults.existskey(State.TaskIdGetClubVIPRecords)) {
			ScoreMgr.TaskResult_Release(State.TaskIdGetClubVIPRecords);
		}
		State.TaskIdGetClubVIPRecords = NullId;
	}
	if (Http::IsInitialized(State.RequestGlobalVIPList)) {
		State.RequestGlobalVIPList = Http::Destroy(State.RequestGlobalVIPList);
	}
	if (State.TaskIdGetGlobalVIPRecords != NullId) {
		if (ScoreMgr.TaskResults.existskey(State.TaskIdGetGlobalVIPRecords)) {
			ScoreMgr.TaskResult_Release(State.TaskIdGetGlobalVIPRecords);
		}
		State.TaskIdGetGlobalVIPRecords = NullId;
	}
	if (Task::IsInitialized(State.TaskGetMapFromUid)) {
		State.TaskGetMapFromUid = Task::Destroy(State.TaskGetMapFromUid);
	}
	State.RequestRecordsInProgress = False;
	State.RecordsErrorCodes = [];
	State.ResponseZonesTopRecords = LeaderboardAPI::K_ResponseFromGetMapTopRankings {};
	State.ResponseZonesSurroundingRecords = LeaderboardAPI::K_ResponseFromGetSurroundingRankings {};
	State.ResponseClubTopRecords = LeaderboardAPI::K_ResponseFromGetMapTopRankingsInClub {};
	State.ResponseClubSurroundingRecords = LeaderboardAPI::K_ResponseFromGetMapSurroundingRankingsInClub {};
	State.ResponseClubVIPRecords = [];
	State.ResponseGlobalVIPRecords = [];
	State.LoadingRecords = False;
	State.RecordsLoadedForMapUid = "";
	State.RecordsLoadingForMapUid = "";
	State.RecordsPlayerTime = -1;
	State.ZonesRecords = [];
	State.RecordsSelectedZone = C_RecordType_None;
	State.RecordsAreDirty = [];
	State = SetAllRecordsDirty(State);
	State.RecordsNeedInit = [];
	foreach (RecordType in C_RecordTypes) {
		State.RecordsNeedInit.add(RecordType);
	}
	State = ReleaseAllRecordGhosts(State);
	SendRecordsToML(State);

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Start a task to retrieve the display name of the records
K_State RetrieveDisplayName(K_State _State) {
	if (UserMgr == Null) return _State;
	
	declare K_State State = _State;

	declare Text[] AccountIds;
	foreach (ZoneRecords in State.ZonesRecords) {
		foreach (Record in ZoneRecords.Records) {
			if (UserStore_MA::GetUserMgrPlayerName(Record.AccountId) == "" && !AccountIds.exists(Record.AccountId)) {
				AccountIds.add(Record.AccountId);
			}
		}
	}

	if (AccountIds.count > 0) {
		if (State.TaskIdRetrieveDisplayName != NullId && UserMgr.TaskResults.existskey(State.TaskIdRetrieveDisplayName)) {
			UserMgr.TaskResult_Release(State.TaskIdRetrieveDisplayName);
			State.TaskIdRetrieveDisplayName = NullId;
		}
		
		declare Task = UserMgr.RetrieveDisplayName(MainUser::GetMainUserId(), AccountIds);
		if (Task == Null) {
			State.TaskIdRetrieveDisplayName = NullId;
		} else {
			State.TaskIdRetrieveDisplayName = Task.Id;
		}
	}

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the display names in the records
K_State UpdateDisplayName(K_State _State) {
	if (UserMgr == Null) return _State;
	
	declare K_State State = _State;

	declare TmpRecords = State.ZonesRecords;
	foreach (ZoneKey => ZoneRecords in TmpRecords) {
		foreach (RecordKey => Record in ZoneRecords.Records) {
			if (Record.DisplayName == "") {
				State.ZonesRecords[ZoneKey].Records[RecordKey].DisplayName = UserStore_MA::GetUserMgrPlayerName(Record.AccountId);
			}
		}
	}

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Set the PB ghost on the client
K_State SetPBGhost(K_State _State, CGhost _Ghost, Boolean _CanCelebrate) {
	if (_Ghost == Null || _Ghost.Id == _State.PBGhostId) return _State;

	declare K_State State = _State;
	declare CGhost Ghost = _Ghost;

	if (State.PBGhostEnabled) {
		//L16N [Record] Best time done by the player.
		Ghost.Nickname = _("Personal best");
		//L16N [Record] Best time done by the player. PB stands for Personnal Best. The translation must be 3 or less letters because it's displayed on the back of the car (as the trigram).
		Ghost.Trigram = _("|Personal best|PB");

		if (GhostMgr != Null) {
			if (State.PBGhostInstanceId != NullId) {
				GhostMgr.Ghost_Remove(State.PBGhostInstanceId);
				State.PBGhostInstanceId = NullId;
			}
			if (State.PBCpSyncedGhostInstanceId != NullId) {
				GhostMgr.Ghost_Remove(State.PBCpSyncedGhostInstanceId);
				State.PBCpSyncedGhostInstanceId = NullId;
			}
		}
	}
	if (State.PBGhostEnabled || State.CelebratePB) {
		if (State.PBGhostId != NullId && DataFileMgr.Ghosts.existskey(State.PBGhostId)) {
			DataFileMgr.Ghost_Release(State.PBGhostId);
		}
		State.PBGhostId = Ghost.Id;
	}

	State.Celebration.PrevTime = State.Celebration.BestTime;
	State.Celebration.BestTime = Ghost.Result.Time;
	if (_CanCelebrate && (State.Celebration.PrevTime < 0 || State.Celebration.BestTime < State.Celebration.PrevTime)) {
		State.RequestCelebration = True;
	}

	State = DisplayPBGhost(State, State.DisplayPBGhost);

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Remove the client PB ghost
K_State ResetPBGhost(K_State _State) {
	declare K_State State = _State;

	if (State.TaskIdGetRecordGhost != NullId && ScoreMgr.TaskResults.existskey(State.TaskIdGetRecordGhost)) {
		ScoreMgr.TaskResult_Release(State.TaskIdGetRecordGhost);
	}
	State.TaskIdGetRecordGhost = NullId;
	if (GhostMgr != Null) {
		if (State.PBGhostInstanceId != NullId) {
			GhostMgr.Ghost_Remove(State.PBGhostInstanceId);
			State.PBGhostInstanceId = NullId;
		}
		if (State.PBCpSyncedGhostInstanceId != NullId) {
			GhostMgr.Ghost_Remove(State.PBCpSyncedGhostInstanceId);
			State.PBCpSyncedGhostInstanceId = NullId;
		}
	}
	if (State.PBGhostId != NullId && DataFileMgr.Ghosts.existskey(State.PBGhostId)) {
		DataFileMgr.Ghost_Release(State.PBGhostId);
	}
	State.PBGhostId = NullId;
	State.Celebration.PrevTime = -1;
	State.Celebration.BestTime = -1;

	State = DisplayPBGhost(State, State.DisplayPBGhost);

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the PB Ghost of the client on the given map
K_State RetrievePBGhost(K_State _State) {
	declare K_State State = ResetPBGhost(_State);

	if ((State.PBGhostEnabled || State.CelebratePB) && State.CurrentMapUid != "") {
		declare K_Scope Scope = GetScope(State);
		declare TaskGetRecordGhost = ScoreMgr.Map_GetRecordGhost_v2(MainUser::GetMainUserId(), State.CurrentMapUid, Scope.Type, Scope.Id, State.ModeName, State.CustomData);
		if (TaskGetRecordGhost != Null) {
			State.TaskIdGetRecordGhost = TaskGetRecordGhost.Id;
		}
	}

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Set the client medal
K_State SetMedal(K_State _State, Integer _Medal, Boolean _CanCelebrate) {
	declare K_State State = _State;

	declare Race_Record_CurrentMedal for ClientUI = Medals::C_ScoreMgrMedal_None;
	Race_Record_CurrentMedal = _Medal;

	State.CurrentMedal = _Medal;

	State.Celebration.PrevMedal = State.Celebration.BestMedal;
	State.Celebration.BestMedal = _Medal;
	if (_CanCelebrate && Medals::ABetterThanB(Medals::ConvertFromScoreMgrMedal(State.Celebration.BestMedal), Medals::ConvertFromScoreMgrMedal(State.Celebration.PrevMedal))) {
		State.RequestCelebration = True;
	}

	if (CanRetrieveRecords(State) && RecordsAreDirty(State)) {
		State = RetrieveRecords(State, State.RecordsPlayerTime);
	}

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Reset the client medal
K_State ResetMedal(K_State _State) {
	declare K_State State = _State;

	declare Race_Record_CurrentMedal for ClientUI = Medals::C_ScoreMgrMedal_None;
	Race_Record_CurrentMedal = Medals::C_ScoreMgrMedal_None;
	
	State.CurrentMedal = Medals::C_ScoreMgrMedal_None;

	State.Celebration.PrevMedal = Medals::C_ScoreMgrMedal_None;
	State.Celebration.BestMedal = Medals::C_ScoreMgrMedal_None;

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the medal of the client on the given map
K_State RetrieveMedal(K_State _State, Boolean _CanCelebrate) {
	declare K_State State = _State;

	if ((_State.MedalEnabled || _State.CelebrateMedal || _State.RecordsEnabled) && _State.CurrentMapUid != "") {
		declare K_Scope Scope;
		if (C_ForceMedalScope != "") {
			Scope = K_Scope {
				Type = C_ForceMedalScope,
				Id = ""
			};
		} else {
			Scope = GetScope(_State);
		}
		State = SetMedal(State, ScoreMgr.Map_GetMedal(MainUser::GetMainUserId(), _State.CurrentMapUid, Scope.Type, Scope.Id, _State.ModeName, _State.CustomData), _CanCelebrate);
	} else {
		State = ResetMedal(State);
	}

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the state
K_State Update(
	K_State _State,
	CMap _Map,
	Text _ScopeSeason,
	Text _ScopeNotSeason,
	Text _ModeName,
	Text _CustomData,
	Text[Text] _SeasonIds
) {
	declare K_State State = _State;

	if (_Map == Null && State.CurrentMapUid != "") {
		State.CurrentMapUid = "";
		State.MapAvailaibleOnNadeoServices = C_MapAvailable_NotChecked;
	} else if (_Map != Null && State.CurrentMapUid != _Map.MapInfo.MapUid) {
		State.CurrentMapUid = _Map.MapInfo.MapUid;
		State.MapAvailaibleOnNadeoServices = C_MapAvailable_NotChecked;
	}

	State.ScopeSeason = _ScopeSeason;
	State.ScopeNotSeason = _ScopeNotSeason;
	State.ModeName = _ModeName;
	State.CustomData = _CustomData;
	State.SeasonIds = _SeasonIds;
	State.RequestCelebration = False;
	State.Celebration.IsActive = False;

	declare Boolean RetrieveRecords = False;
	if (State.RecordsLoadedForMapUid != State.CurrentMapUid || State.ReloadRecords) {
		State.ReloadRecords = False;
		declare PinnedClub = ClubStore::GetUserPinnedClub();
		State.RecordsClubId = PinnedClub.Id;
		State.RecordsClubName = PinnedClub.Name;
		if (State.RecordsLoadedForMapUid != "") {
			State = ResetRecords(State);
		}
		// Retrieve the player's record one time at the loading
		// of the map. Otherwise the player would notify the server
		// and force an update in the other players mania app
		// every time they improved their time even if it was
		// not a new record.
		// So do not use CanRetrieveRecords(State) here.
		if (
			State.RecordsEnabled &&
			State.CurrentMapUid != ""
		) {
			State = SetAllRecordsDirty(State);
			RetrieveRecords = True;
		}
	}
	
	declare K_Celebration Race_Record_Celebration for ClientUI;
	Race_Record_Celebration = State.Celebration;

	State = RetrievePBGhost(State);
	State = RetrieveMedal(State, False);
	// Retrieve records after updating the medal
	// because they are a condition to start
	// the records requests
	if (RetrieveRecords) {
		State = RetrieveRecords(State, State.RecordsPlayerTime);
	}

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Check if the records can be enabled
Boolean UpdateRecordsEnabled(Boolean _DisplayRecords, Boolean _CanViewLeaderboards) {
	return _DisplayRecords && _CanViewLeaderboards;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the library
Void Yield() {
	declare K_State Race_Record_State for UI;

	// Update the library only if the GhostMgr is available
	if (GhostMgr != Null) {
		declare Boolean ForceUpdate = False;

		// Enable or disable record from the server
		declare netread Integer Net_Race_Record_SetupUpdate for Playground.Teams[0] = -1;
		if (
			Race_Record_State.SetupUpdate != Net_Race_Record_SetupUpdate ||
			Race_Record_State.AlwaysDisplayRecords != UserMgr.MainUserProfile.Interface_AlwaysDisplayRecords
		) {
			declare netread Boolean Net_Race_Record_PBGhostEnabled for Playground.Teams[0] = False;
			declare netread Boolean Net_Race_Record_CelebratePB for Playground.Teams[0] = False;
			declare netread Boolean Net_Race_Record_MedalEnabled for Playground.Teams[0] = False;
			declare netread Boolean Net_Race_Record_CelebrateMedal for Playground.Teams[0] = False;
			declare netread Boolean Net_Race_Record_DisplayRecords for Playground.Teams[0] = False;
			declare netread Integer Net_Race_Record_ForceMapUpdate for Playground.Teams[0] = -1;
			Race_Record_State.SetupUpdate = Net_Race_Record_SetupUpdate;
			Race_Record_State.PBGhostEnabled = (Net_Race_Record_PBGhostEnabled && UserStore_MA::HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_ViewPBGhostMultiplayer));
			Race_Record_State.CelebratePB = Net_Race_Record_CelebratePB;
			Race_Record_State.MedalEnabled = Net_Race_Record_MedalEnabled;
			Race_Record_State.CelebrateMedal = Net_Race_Record_CelebrateMedal;
			Race_Record_State.RecordsEnabled = UpdateRecordsEnabled(Net_Race_Record_DisplayRecords, Race_Record_State.CanViewLeaderboards);

			if (Race_Record_State.ForceMapUpdate != Net_Race_Record_ForceMapUpdate) {
				Race_Record_State.ForceMapUpdate = Net_Race_Record_ForceMapUpdate;
				Race_Record_State.ReloadRecords = True;
			}

			if (Race_Record_State.AlwaysDisplayRecords != UserMgr.MainUserProfile.Interface_AlwaysDisplayRecords) {
				Race_Record_State.AlwaysDisplayRecords = UserMgr.MainUserProfile.Interface_AlwaysDisplayRecords;
				if (Race_Record_State.AlwaysDisplayRecords) {
					Race_Record_State.ReloadRecords = True;
				}
			}

			ForceUpdate = True;
		}

		// Check leaderboard privilege
		if (!Privileges::Check_IsComplete(Race_Record_State.LeaderboardPrivilegeCheck)) {
			Race_Record_State.LeaderboardPrivilegeCheck = Privileges::Check_Update(Race_Record_State.LeaderboardPrivilegeCheck);
			if (Privileges::Check_IsComplete(Race_Record_State.LeaderboardPrivilegeCheck)) {
				Race_Record_State.LeaderboardPrivilegeCheck = Privileges::Check_Destroy(Race_Record_State.LeaderboardPrivilegeCheck);
				if (Race_Record_State.CanViewLeaderboards != Privileges::Check_HasPrivilege(Race_Record_State.LeaderboardPrivilegeCheck)) {
					Race_Record_State.CanViewLeaderboards = Privileges::Check_HasPrivilege(Race_Record_State.LeaderboardPrivilegeCheck);

					declare netread Boolean Net_Race_Record_DisplayRecords for Playground.Teams[0] = False;
					Race_Record_State.RecordsEnabled = UpdateRecordsEnabled(Net_Race_Record_DisplayRecords, Race_Record_State.CanViewLeaderboards);
					SendRecordsToML(Race_Record_State);
					ForceUpdate = True;
				}
			}
		}

		// Setup or map updated
		if (
			ForceUpdate || (
				(
					(Map == Null && Race_Record_State.CurrentMapUid != "") ||
					(Map != Null && Race_Record_State.CurrentMapUid != Map.MapInfo.MapUid)
				) && (
					Race_Record_State.PBGhostEnabled ||
					Race_Record_State.CelebratePB ||
					Race_Record_State.MedalEnabled ||
					Race_Record_State.CelebrateMedal ||
					Race_Record_State.RecordsEnabled
				)
			)
		) {
			declare netread Text Net_Race_Record_ScopeSeason for Playground.Teams[0] = "";
			declare netread Text Net_Race_Record_ScopeNotSeason for Playground.Teams[0] = "";
			declare netread Text Net_Race_Record_ModeName for Playground.Teams[0] = "";
			declare netread Text Net_Race_Record_CustomData for Playground.Teams[0] = "";
			declare netread Text[Text] Net_Race_Record_SeasonIds for Playground.Teams[0] = [];
			Race_Record_State = Update(
				Race_Record_State,
				Map,
				Net_Race_Record_ScopeSeason,
				Net_Race_Record_ScopeNotSeason,
				Net_Race_Record_ModeName,
				Net_Race_Record_CustomData,
				Net_Race_Record_SeasonIds
			);
		}

		// PB ghost retrieved
		if (
			Race_Record_State.TaskIdGetRecordGhost != NullId &&
			ScoreMgr.TaskResults.existskey(Race_Record_State.TaskIdGetRecordGhost) &&
			!ScoreMgr.TaskResults[Race_Record_State.TaskIdGetRecordGhost].IsProcessing
		) {
			declare TaskGetRecordGhost = (ScoreMgr.TaskResults[Race_Record_State.TaskIdGetRecordGhost] as CTaskResult_Ghost);
			if (TaskGetRecordGhost.HasSucceeded) {
				Race_Record_State = SetPBGhost(Race_Record_State, TaskGetRecordGhost.Ghost, False);
			}
			ScoreMgr.TaskResult_Release(TaskGetRecordGhost.Id);
			Race_Record_State.TaskIdGetRecordGhost = NullId;
		}

		// Trigger celebration screen
		if (
			Race_Record_State.RequestCelebration &&
			UI.UISequence == CUIConfig::EUISequence::Finish &&
			UI.ScoreTableVisibility != CUIConfig::EVisibility::ForcedVisible
		) {
			Race_Record_State.RequestCelebration = False;
			Race_Record_State.Celebration.IsActive = True;
			declare K_Celebration Race_Record_Celebration for ClientUI;
			Race_Record_Celebration = Race_Record_State.Celebration;
		} else if (
			Race_Record_State.Celebration.IsActive && (
				UI.UISequence != CUIConfig::EUISequence::Finish ||
				UI.ScoreTableVisibility == CUIConfig::EVisibility::ForcedVisible
			)
		) {
			Race_Record_State.Celebration.IsActive = False;
			declare K_Celebration Race_Record_Celebration for ClientUI;
			Race_Record_Celebration = Race_Record_State.Celebration;
		}
	}

	if (ScoreMgr != Null && UserMgr != Null && DataFileMgr != Null) {
		// Initialize the manialink related variables only once the manialink is initialized properly
		declare Boolean Race_Record_ManialinkIsInitialized for ClientUI = False;
		if (Race_Record_State.ManialinkIsInitialized != Race_Record_ManialinkIsInitialized) {
			Race_Record_State.ManialinkIsInitialized = Race_Record_ManialinkIsInitialized;
	
			if (Race_Record_State.ManialinkIsInitialized) {
				declare Boolean Race_Record_PlayerIsDisplayingRecords for ClientUI = False;
				declare Integer Race_Record_RecordsSelectedZone for ClientUI = C_RecordType_None;
				Race_Record_State.PlayerIsDisplayingRecords = Race_Record_PlayerIsDisplayingRecords;
				Race_Record_State.RecordsSelectedZone = Race_Record_RecordsSelectedZone;
			}
		}

		// Player started displaying the records
		if (Race_Record_State.ManialinkIsInitialized) {
			declare Boolean Race_Record_PlayerIsDisplayingRecords for ClientUI = False;
			declare Integer Race_Record_RecordsSelectedZone for ClientUI = C_RecordType_None;
			if (
				Race_Record_State.PlayerIsDisplayingRecords != Race_Record_PlayerIsDisplayingRecords ||
				Race_Record_State.RecordsSelectedZone != Race_Record_RecordsSelectedZone
			) {
				Race_Record_State.PlayerIsDisplayingRecords = Race_Record_PlayerIsDisplayingRecords;
				Race_Record_State.RecordsSelectedZone = Race_Record_RecordsSelectedZone;
				if (CanRetrieveRecords(Race_Record_State) && RecordsAreDirty(Race_Record_State)) {
					Race_Record_State = RetrieveRecords(Race_Record_State, Race_Record_State.RecordsPlayerTime);
				}
			}
		}

		// New record by another player
		declare netread Integer Net_Race_Record_NewRecordsUpdate for Playground.Teams[0];
		if (Race_Record_State.RecordsServerUpdate != Net_Race_Record_NewRecordsUpdate) {
			Race_Record_State.RecordsServerUpdate = Net_Race_Record_NewRecordsUpdate;

			declare netread Integer[Text][Integer] Net_Race_Record_NewRecords for UI;
			declare netwrite Integer[] Net_Race_Record_ReceivedRecords for UI;

			// Remove already received records
			declare Integer[] TmpReceivedRecords = Net_Race_Record_ReceivedRecords;
			foreach (Key in TmpReceivedRecords) {
				if (!Net_Race_Record_NewRecords.existskey(Key)) {
					Net_Race_Record_ReceivedRecords.remove(Key);
				}
			}

			// Receive new records
			declare Integer[Text] NewZonesRecordTime;
			declare Text[] LocalUserZones = TL::Split("|", LocalUser.ZonePath);
			foreach (Key => ZonesNewRecord in Net_Race_Record_NewRecords) {
				if (!Net_Race_Record_ReceivedRecords.exists(Key)) {
					Net_Race_Record_ReceivedRecords.add(Key);
					foreach (Zone => Time in ZonesNewRecord) {
						if (Time >= 0 && LocalUserZones.exists(Zone) && (!NewZonesRecordTime.existskey(Zone) || Time < NewZonesRecordTime[Zone])) {
							NewZonesRecordTime[Zone] = Time;
						}
					}
				}
			}

			// Check if the best new record is better than one
			// of the time in the local records
			// If so request an update of the records to retrieve
			// the new record from the API
			if (Race_Record_State.RecordsEnabled && NewZonesRecordTime.count > 0) {
				if (Race_Record_State.ZonesRecords.count <= 0) {
					Race_Record_State = SetAllRecordsDirty(Race_Record_State);
				} else {
					foreach (ZoneRecords in Race_Record_State.ZonesRecords) {
						declare Boolean HasRecordsForZone = NewZonesRecordTime.existskey(ZoneRecords.ZoneName);
						if (
							(
								ZoneRecords.Type == C_RecordType_Club ||
								ZoneRecords.Type == C_RecordType_ClubVIP ||
								ZoneRecords.Type == C_RecordType_GlobalVIP ||
								HasRecordsForZone
							) && (
								!ZoneRecords.IsFull ||
								(HasRecordsForZone && NewZonesRecordTime[ZoneRecords.ZoneName] <= ZoneRecords.WorstTime)
							)
						) {
							if (
								ZoneRecords.Type == C_RecordType_Club &&
								Race_Record_State.RecordsClubId != ClubStruct::C_ClubNullId &&
								!Race_Record_State.RecordsAreDirty.exists(C_RecordType_Club)
							) {
								Race_Record_State.RecordsAreDirty.add(C_RecordType_Club);
							}
							if (
								ZoneRecords.Type == C_RecordType_ClubVIP &&
								Race_Record_State.RecordsClubId != ClubStruct::C_ClubNullId &&
								!Race_Record_State.RecordsAreDirty.exists(C_RecordType_ClubVIP)
							) {
								Race_Record_State.RecordsAreDirty.add(C_RecordType_ClubVIP);
							}
							if (
								ZoneRecords.Type == C_RecordType_GlobalVIP &&
								Race_Record_State.RecordsClubId != ClubStruct::C_ClubNullId &&
								!Race_Record_State.RecordsAreDirty.exists(C_RecordType_GlobalVIP)
							) {
								Race_Record_State.RecordsAreDirty.add(C_RecordType_GlobalVIP);
							}
							if (ZoneRecords.Type == C_RecordType_Zones && !Race_Record_State.RecordsAreDirty.exists(C_RecordType_Zones)) {
								Race_Record_State.RecordsAreDirty.add(C_RecordType_Zones);
							}
							if (
								Race_Record_State.RecordsAreDirty.count >= 4 &&
								Race_Record_State.RecordsAreDirty.exists(C_RecordType_Club) &&
								Race_Record_State.RecordsAreDirty.exists(C_RecordType_ClubVIP) &&
								Race_Record_State.RecordsAreDirty.exists(C_RecordType_GlobalVIP) &&
								Race_Record_State.RecordsAreDirty.exists(C_RecordType_Zones)
							) break;
						}
					}
				}
				if (CanRetrieveRecords(Race_Record_State) && RecordsAreDirty(Race_Record_State)) {
					Race_Record_State = RetrieveRecords(Race_Record_State, Race_Record_State.RecordsPlayerTime);
				}
			}
		}

		// Process records requests
		if (Race_Record_State.RequestRecordsInProgress) {
			if (
				Http::IsInitialized(Race_Record_State.RequestZonesTopRecords) ||
				Http::IsInitialized(Race_Record_State.RequestZonesSurroundingRecords) ||
				Http::IsInitialized(Race_Record_State.RequestClubTopRecords) ||
				Http::IsInitialized(Race_Record_State.RequestClubSurroundingRecords) ||
				Http::IsInitialized(Race_Record_State.RequestClubVIPList) ||
				Http::IsInitialized(Race_Record_State.RequestGlobalVIPList) ||
				Race_Record_State.TaskIdGetClubVIPRecords != NullId ||
				Race_Record_State.TaskIdGetGlobalVIPRecords != NullId ||
				Task::IsInitialized(Race_Record_State.TaskGetMapFromUid)
			) {
				if (Http::IsInitialized(Race_Record_State.RequestZonesTopRecords)) {
					Race_Record_State.RequestZonesTopRecords = Http::Update(Race_Record_State.RequestZonesTopRecords);
					if (!Http::IsRunning(Race_Record_State.RequestZonesTopRecords)) {
						if (Http::IsSuccess(Race_Record_State.RequestZonesTopRecords)) {
							Race_Record_State.ResponseZonesTopRecords = LeaderboardAPI::GetResponseFromGetMapTopRankings(Race_Record_State.RequestZonesTopRecords);
							Race_Record_State.RecordsLoadedForMapUid = Race_Record_State.RecordsLoadingForMapUid;
						} else {
							declare NLSError = Http::GetNLSError(Race_Record_State.RequestZonesTopRecords);
							if (NLSError.Error == C_NLSError_MapNotFound) {
								Race_Record_State = AddRecordsError(Race_Record_State, C_RecordsError_MapNotFound);
							} else {
								Race_Record_State = AddRecordsError(Race_Record_State, C_RecordsError_CouldNotLoadZonesTop);
							}
						}
						Race_Record_State.RequestZonesTopRecords = Http::Destroy(Race_Record_State.RequestZonesTopRecords);
					}
				}
				if (Http::IsInitialized(Race_Record_State.RequestZonesSurroundingRecords)) {
					Race_Record_State.RequestZonesSurroundingRecords = Http::Update(Race_Record_State.RequestZonesSurroundingRecords);
					if (!Http::IsRunning(Race_Record_State.RequestZonesSurroundingRecords)) {
						if (Http::IsSuccess(Race_Record_State.RequestZonesSurroundingRecords)) {
							Race_Record_State.ResponseZonesSurroundingRecords = LeaderboardAPI::GetResponseFromGetSurroundingRankings(Race_Record_State.RequestZonesSurroundingRecords);
							Race_Record_State.RecordsLoadedForMapUid = Race_Record_State.RecordsLoadingForMapUid;
						} else {
							Race_Record_State = AddRecordsError(Race_Record_State, C_RecordsError_CouldNotLoadZonesSurround);
						}
						Race_Record_State.RequestZonesSurroundingRecords = Http::Destroy(Race_Record_State.RequestZonesSurroundingRecords);
					}
				}
				if (Http::IsInitialized(Race_Record_State.RequestClubTopRecords)) {
					Race_Record_State.RequestClubTopRecords = Http::Update(Race_Record_State.RequestClubTopRecords);
					if (!Http::IsRunning(Race_Record_State.RequestClubTopRecords)) {
						if (Http::IsSuccess(Race_Record_State.RequestClubTopRecords)) {
							Race_Record_State.ResponseClubTopRecords = LeaderboardAPI::GetResponseFromGetMapTopRankingsInClub(Race_Record_State.RequestClubTopRecords);
							Race_Record_State.RecordsLoadedForMapUid = Race_Record_State.RecordsLoadingForMapUid;
						} else {
							declare NLSError = Http::GetNLSError(Race_Record_State.RequestClubTopRecords);
							if (NLSError.Error == C_NLSError_MapNotFound) {
								Race_Record_State = AddRecordsError(Race_Record_State, C_RecordsError_MapNotFound);
							} else {
								Race_Record_State = AddRecordsError(Race_Record_State, C_RecordsError_CouldNotLoadClubTop);
							}
						}
						Race_Record_State.RequestClubTopRecords = Http::Destroy(Race_Record_State.RequestClubTopRecords);
					}
				}
				if (Http::IsInitialized(Race_Record_State.RequestClubSurroundingRecords)) {
					Race_Record_State.RequestClubSurroundingRecords = Http::Update(Race_Record_State.RequestClubSurroundingRecords);
					if (!Http::IsRunning(Race_Record_State.RequestClubSurroundingRecords)) {
						if (Http::IsSuccess(Race_Record_State.RequestClubSurroundingRecords)) {
							Race_Record_State.ResponseClubSurroundingRecords = LeaderboardAPI::GetResponseFromGetMapSurroundingRankingsInClub(Race_Record_State.RequestClubSurroundingRecords);
							Race_Record_State.RecordsLoadedForMapUid = Race_Record_State.RecordsLoadingForMapUid;
						} else {
							Race_Record_State = AddRecordsError(Race_Record_State, C_RecordsError_CouldNotLoadClubSurround);
						}
						Race_Record_State.RequestClubSurroundingRecords = Http::Destroy(Race_Record_State.RequestClubSurroundingRecords);
					}
				}
				if (Http::IsInitialized(Race_Record_State.RequestClubVIPList)) {
					Race_Record_State.RequestClubVIPList = Http::Update(Race_Record_State.RequestClubVIPList);
					if (!Http::IsRunning(Race_Record_State.RequestClubVIPList)) {
						if (Http::IsSuccess(Race_Record_State.RequestClubVIPList)) {
							declare Text[] VIPAccountIds = ClubAPI::GetResponseFromGetVIPListOnMap(Race_Record_State.RequestClubVIPList);
							if (VIPAccountIds.count > 0) {
								declare K_Scope Scope;
								if (C_ForceRecordScope != "") {
									Scope = K_Scope {
										Type = C_ForceRecordScope,
										Id = ""
									};
								} else {
									Scope = GetScope(Race_Record_State);
								}
								declare CTaskResult_MapRecordList Task = ScoreMgr.Map_GetPlayerListRecordList(
									MainUser::GetMainUserId(),
									VIPAccountIds.slice(0, 200), //< Limit the number of account ids requested. see: /trackmania-next/tmnext/-/issues/3499
									Race_Record_State.CurrentMapUid,
									Scope.Type,
									Scope.Id,
									Race_Record_State.ModeName,
									Race_Record_State.CustomData
								);
								if (Task != Null) {
									Race_Record_State.TaskIdGetClubVIPRecords = Task.Id;
								} else {
									Race_Record_State = AddRecordsError(Race_Record_State, C_RecordsError_CouldNotGetClubVIPRecords);
								}
							}
						} else {
							Race_Record_State = AddRecordsError(Race_Record_State, C_RecordsError_CouldNotGetClubVIPList);
						}
						Race_Record_State.RequestClubVIPList = Http::Destroy(Race_Record_State.RequestClubVIPList);
					}
				}
				if (Race_Record_State.TaskIdGetClubVIPRecords != NullId) {
					if (ScoreMgr.TaskResults.existskey(Race_Record_State.TaskIdGetClubVIPRecords)) {
						if (!ScoreMgr.TaskResults[Race_Record_State.TaskIdGetClubVIPRecords].IsProcessing) {
							if (ScoreMgr.TaskResults[Race_Record_State.TaskIdGetClubVIPRecords].HasSucceeded) {
								declare CTaskResult_MapRecordList Result = (ScoreMgr.TaskResults[Race_Record_State.TaskIdGetClubVIPRecords] as CTaskResult_MapRecordList);
								foreach (Record in Result.MapRecordList) {
									Race_Record_State.ResponseClubVIPRecords[Record.AccountId] = Record.Time;
								}
								Race_Record_State.RecordsLoadedForMapUid = Race_Record_State.RecordsLoadingForMapUid;
							} else {
								Race_Record_State = AddRecordsError(Race_Record_State, C_RecordsError_CouldNotGetClubVIPRecords);
							}
							ScoreMgr.TaskResult_Release(Race_Record_State.TaskIdGetClubVIPRecords);
							Race_Record_State.TaskIdGetClubVIPRecords = NullId;
						}
					} else {
						Race_Record_State.TaskIdGetClubVIPRecords = NullId;
						Race_Record_State = AddRecordsError(Race_Record_State, C_RecordsError_CouldNotGetClubVIPRecords);
					}
				}
				if (Http::IsInitialized(Race_Record_State.RequestGlobalVIPList)) {
					Race_Record_State.RequestGlobalVIPList = Http::Update(Race_Record_State.RequestGlobalVIPList);
					if (!Http::IsRunning(Race_Record_State.RequestGlobalVIPList)) {
						if (Http::IsSuccess(Race_Record_State.RequestGlobalVIPList)) {
							declare Text[] VIPAccountIds = ClubAPI::GetResponseFromGetVIPListOnMap(Race_Record_State.RequestGlobalVIPList);
							if (VIPAccountIds.count > 0) {
								declare K_Scope Scope;
								if (C_ForceRecordScope != "") {
									Scope = K_Scope {
										Type = C_ForceRecordScope,
										Id = ""
									};
								} else {
									Scope = GetScope(Race_Record_State);
								}
								declare CTaskResult_MapRecordList Task = ScoreMgr.Map_GetPlayerListRecordList(
									MainUser::GetMainUserId(),
									VIPAccountIds.slice(0, 200), //< Limit the number of account ids requested. see: /trackmania-next/tmnext/-/issues/3499
									Race_Record_State.CurrentMapUid,
									Scope.Type,
									Scope.Id,
									Race_Record_State.ModeName,
									Race_Record_State.CustomData
								);
								if (Task != Null) {
									Race_Record_State.TaskIdGetGlobalVIPRecords = Task.Id;
								} else {
									Race_Record_State = AddRecordsError(Race_Record_State, C_RecordsError_CouldNotGetGlobalVIPRecords);
								}
							}
						} else {
							Race_Record_State = AddRecordsError(Race_Record_State, C_RecordsError_CouldNotGetGlobalVIPList);
						}
						Race_Record_State.RequestGlobalVIPList = Http::Destroy(Race_Record_State.RequestGlobalVIPList);
					}
				}
				if (Race_Record_State.TaskIdGetGlobalVIPRecords != NullId) {
					if (ScoreMgr.TaskResults.existskey(Race_Record_State.TaskIdGetGlobalVIPRecords)) {
						if (!ScoreMgr.TaskResults[Race_Record_State.TaskIdGetGlobalVIPRecords].IsProcessing) {
							if (ScoreMgr.TaskResults[Race_Record_State.TaskIdGetGlobalVIPRecords].HasSucceeded) {
								declare CTaskResult_MapRecordList Result = (ScoreMgr.TaskResults[Race_Record_State.TaskIdGetGlobalVIPRecords] as CTaskResult_MapRecordList);
								foreach (Record in Result.MapRecordList) {
									Race_Record_State.ResponseGlobalVIPRecords[Record.AccountId] = Record.Time;
								}
								Race_Record_State.RecordsLoadedForMapUid = Race_Record_State.RecordsLoadingForMapUid;
							} else {
								Race_Record_State = AddRecordsError(Race_Record_State, C_RecordsError_CouldNotGetGlobalVIPRecords);
							}
							ScoreMgr.TaskResult_Release(Race_Record_State.TaskIdGetGlobalVIPRecords);
							Race_Record_State.TaskIdGetGlobalVIPRecords = NullId;
						}
					} else {
						Race_Record_State.TaskIdGetGlobalVIPRecords = NullId;
						Race_Record_State = AddRecordsError(Race_Record_State, C_RecordsError_CouldNotGetGlobalVIPRecords);
					}
				}
				if (Task::IsInitialized(Race_Record_State.TaskGetMapFromUid)) {
					Race_Record_State.TaskGetMapFromUid = Task::Update(Race_Record_State.TaskGetMapFromUid);
					if (!Task::IsRunning(Race_Record_State.TaskGetMapFromUid)) {
						if (Task::IsSuccess(Race_Record_State.TaskGetMapFromUid)) {
							Race_Record_State.MapAvailaibleOnNadeoServices = C_MapAvailable_Available;
						} else {
							Race_Record_State.MapAvailaibleOnNadeoServices = C_MapAvailable_NotAvailable;
						}
						Race_Record_State.TaskGetMapFromUid = Task::Destroy(Race_Record_State.TaskGetMapFromUid);
					}
				}
			} else {
				Race_Record_State = SetRecordsFromResponses(Race_Record_State);
				Race_Record_State = RetrieveDisplayName(Race_Record_State);
				Race_Record_State.RequestRecordsInProgress = False;
				Race_Record_State.RecordsLoadingForMapUid = "";
				Race_Record_State.LoadingRecords = False;
				SendRecordsToML(Race_Record_State);
			}
		}

		// Get display name of the players in the records
		if (Race_Record_State.TaskIdRetrieveDisplayName != NullId) {
			if (UserMgr.TaskResults.existskey(Race_Record_State.TaskIdRetrieveDisplayName)) {
				if (!UserMgr.TaskResults[Race_Record_State.TaskIdRetrieveDisplayName].IsProcessing) {
					if (UserMgr.TaskResults[Race_Record_State.TaskIdRetrieveDisplayName].HasSucceeded) {
						Race_Record_State = UpdateDisplayName(Race_Record_State);
						SendRecordsToML(Race_Record_State);
					}
					UserMgr.TaskResult_Release(Race_Record_State.TaskIdRetrieveDisplayName);
				}
			} else {
				Race_Record_State.TaskIdRetrieveDisplayName = NullId;
			}
		}

		// Load records selected by the player
		if (Race_Record_State.LoadingRecordGhosts.count > 0) {
			declare TmpLoadingRecordGhosts = Race_Record_State.LoadingRecordGhosts;
			foreach (AccountId => LoadingRecord in TmpLoadingRecordGhosts) {
				if (Task::IsInitialized(LoadingRecord.Task_RetrieveRecords)) {
					declare Task::K_Task Task_RetrieveRecords_Updated = Task::Update(LoadingRecord.Task_RetrieveRecords);
					if (!Task::IsRunning(Task_RetrieveRecords_Updated)) {
						declare CTaskResult_MapRecordList SourceTask = Task::GetSourceTask_MapRecordList(Task_RetrieveRecords_Updated);
						if (Task::IsSuccess(Task_RetrieveRecords_Updated) && SourceTask != Null && SourceTask.MapRecordList.count >= 1) {
							declare CMapRecord MapRecord <=> SourceTask.MapRecordList[0];
							Race_Record_State.LoadingRecordGhosts[AccountId].Task_RetrieveGhost = Task::DestroyAndCreate(
								Race_Record_State.LoadingRecordGhosts[AccountId].Task_RetrieveGhost, 
								DataFileMgr, 
								DataFileMgr.Ghost_Download(MapRecord.FileName, MapRecord.ReplayUrl)
							);
						}
						Race_Record_State.LoadingRecordGhosts[AccountId].Task_RetrieveRecords = Task::Destroy(Task_RetrieveRecords_Updated);
					} else {
						Race_Record_State.LoadingRecordGhosts[AccountId].Task_RetrieveRecords = Task_RetrieveRecords_Updated;
					}
				} else if (Task::IsInitialized(LoadingRecord.Task_RetrieveGhost)) {
					declare Task::K_Task Task_RetrieveGhost_Updated = Task::Update(LoadingRecord.Task_RetrieveGhost);
					if (!Task::IsRunning(Task_RetrieveGhost_Updated)) {
						declare CTaskResult_Ghost SourceTask = Task::GetSourceTask_Ghost(Task_RetrieveGhost_Updated);
						if (Task::IsSuccess(Task_RetrieveGhost_Updated) && SourceTask != Null && SourceTask.Ghost != Null) {
							declare Text DisplayName = UserStore_MA::GetUserMgrPlayerName(LoadingRecord.AccountId);
							if (DisplayName != "") SourceTask.Ghost.Nickname = DisplayName;
							Race_Record_State.LoadingRecordGhosts[AccountId].GhostId = SourceTask.Ghost.Id;
							Race_Record_State.LoadingRecordGhosts[AccountId].GhostInstanceId = GhostMgr.Ghost_Add(SourceTask.Ghost, True);
						}
						Race_Record_State.LoadingRecordGhosts[AccountId].Task_RetrieveGhost = Task::Destroy(Task_RetrieveGhost_Updated);
					} else {
						Race_Record_State.LoadingRecordGhosts[AccountId].Task_RetrieveGhost = Task_RetrieveGhost_Updated;
					}
				} else {
					if (Race_Record_State.LoadingRecordGhosts[AccountId].GhostId != NullId) {
						Race_Record_State.LoadedRecordGhosts[AccountId] = Race_Record_State.LoadingRecordGhosts[AccountId];
					}
					Race_Record_State.LoadingRecordGhosts.removekey(AccountId);
					SendRecordsStatusToML(Race_Record_State);
					Race_Record_State = DisplayPBGhost(Race_Record_State, Race_Record_State.DisplayPBGhost);
				}
			}
		}

		// Set spectator record account id
		declare netread Text Net_Race_Record_SpectatorTargetAccountId for Playground.Teams[0] = "";
		if (Race_Record_State.SpectatorTargetRecordGhost.AccountId != Net_Race_Record_SpectatorTargetAccountId) {
			Race_Record_State = ReleaseRecordGhost(Race_Record_State, Race_Record_State.SpectatorTargetRecordGhost.AccountId);
			Race_Record_State.SpectatorTargetRecordGhost = K_RecordGhost {
				AccountId = Net_Race_Record_SpectatorTargetAccountId
			};
			
			SendSpectatorTargetAccountIdToML(Race_Record_State);
			SendRecordsStatusToML(Race_Record_State);
		}
	}

	foreach (Event in PendingEvents) {
		// Update PB and medal if player improve their time
		if (Event.PlaygroundType == CManiaAppPlaygroundEvent::Type::RecordUpdated) {
			if (Event.Ghost != Null) {
				if (Race_Record_State.PBGhostEnabled || Race_Record_State.CelebratePB) {
					declare Boolean IsBetter = True;
					if (Race_Record_State.PBGhostId != NullId && DataFileMgr.Ghosts.existskey(Race_Record_State.PBGhostId)) {
						declare CGhost PBGhost = DataFileMgr.Ghosts[Race_Record_State.PBGhostId];
						IsBetter = (
							Event.Ghost.Result.Checkpoints.count > 0 &&
							Event.Ghost.Result.Checkpoints.count == PBGhost.Result.Checkpoints.count &&
							Event.Ghost.Result.Checkpoints[Event.Ghost.Result.Checkpoints.count - 1] < PBGhost.Result.Checkpoints[PBGhost.Result.Checkpoints.count - 1]
						);
					}
					if (IsBetter) {
						Race_Record_State = SetPBGhost(Race_Record_State, Event.Ghost, Race_Record_State.CelebratePB);
					}
				}
				if (Race_Record_State.MedalEnabled || Race_Record_State.CelebrateMedal || Race_Record_State.RecordsEnabled) {
					Race_Record_State = RetrieveMedal(Race_Record_State, Race_Record_State.CelebrateMedal);
				}
				if (Race_Record_State.RecordsEnabled) {
					if (Event.Ghost.Result.Checkpoints.count > 0 && Event.Ghost.Result.Checkpoints[Event.Ghost.Result.Checkpoints.count - 1] >= 0) {
						if (Race_Record_State.RecordsPlayerTime < 0 || Event.Ghost.Result.Checkpoints[Event.Ghost.Result.Checkpoints.count - 1] < Race_Record_State.RecordsPlayerTime) {
							Race_Record_State.RecordsPlayerTime = Event.Ghost.Result.Checkpoints[Event.Ghost.Result.Checkpoints.count - 1];
							Race_Record_State = SetAllRecordsDirty(Race_Record_State);
							SendCustomEvent(Record::C_Event_NewRecord, [""^Race_Record_State.RecordsPlayerTime]);
							if (CanRetrieveRecords(Race_Record_State)) {
								Race_Record_State = RetrieveRecords(Race_Record_State, Race_Record_State.RecordsPlayerTime);
							}
						}
					}
				}
			}
		} else if (Event.PlaygroundType == CManiaAppPlaygroundEvent::Type::LayerCustomEvent) {
			switch (Event.CustomEventType) {
				case C_Event_SpectateGhost: {
					if (Event.CustomEventData.count >= 1) {
						SendCustomEvent(Record::C_Event_Spectate, [Event.CustomEventData[0]]);
					}
				}
				case C_Event_TogglePB: {
					Race_Record_State = DisplayPBGhost(Race_Record_State, !Race_Record_State.DisplayPBGhost);
				}
				case C_Event_ToggleGhost: {
					if (Event.CustomEventData.count >= 1) {
						declare Text AccountId = Event.CustomEventData[0];
						if (Race_Record_State.LoadedRecordGhosts.existskey(AccountId)) {
							Race_Record_State = ReleaseRecordGhost(Race_Record_State, AccountId);
							SendRecordsStatusToML(Race_Record_State);
						} else if (!Race_Record_State.LoadingRecordGhosts.existskey(AccountId)) {
							if (UserStore_MA::HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_PlayRecords)) {
								Race_Record_State = RetrieveRecordGhost(Race_Record_State, AccountId);
							}
						}
					}
				}
			}
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Unload the library
Void Unload() {
	// Wait for the manialink to be initialized before
	declare Boolean Race_Record_ManialinkIsInitialized for ClientUI = False;
	Race_Record_ManialinkIsInitialized = False;

	// Save the state in a declare for variable so data survive a script restart
	// The ghost instances are not removed between script restarts
	// so we must keep their id to remove them manually
	declare K_State Race_Record_State for UI;
	Race_Record_State.ManialinkIsInitialized = Race_Record_ManialinkIsInitialized;
	Race_Record_State.SetupUpdate = -123;
	Race_Record_State.ForceMapUpdate = -123;
	Race_Record_State.AlwaysDisplayRecords = UserMgr.MainUserProfile.Interface_AlwaysDisplayRecords;
	Race_Record_State.ReloadRecords = False;
	Race_Record_State.PBGhostEnabled = False;
	Race_Record_State.DisplayPBGhost = True;
	Race_Record_State.CelebratePB = False;
	Race_Record_State.MedalEnabled = False;
	Race_Record_State.CelebrateMedal = False;
	Race_Record_State.RecordsEnabled = False;
	Race_Record_State.MapAvailaibleOnNadeoServices = C_MapAvailable_NotChecked;
	Race_Record_State.TaskGetMapFromUid = Task::GetEmptyTask();
	Race_Record_State.PlayerIsDisplayingRecords = False;
	Race_Record_State.RecordsSelectedZone = C_RecordType_None;
	Race_Record_State.CurrentMedal = Medals::C_ScoreMgrMedal_None;
	Race_Record_State.RecordsPlayerTime = -1;
	Race_Record_State.RecordsServerUpdate = -1;
	Race_Record_State.RequestZonesTopRecords = Http::GetEmptyRequest();
	Race_Record_State.RequestZonesSurroundingRecords = Http::GetEmptyRequest();
	Race_Record_State.RequestClubTopRecords = Http::GetEmptyRequest();
	Race_Record_State.RequestClubSurroundingRecords = Http::GetEmptyRequest();
	Race_Record_State.RequestClubVIPList = Http::GetEmptyRequest();
	Race_Record_State.RequestGlobalVIPList = Http::GetEmptyRequest();
	Race_Record_State.RequestRecordsInProgress = False;
	Race_Record_State.RecordsErrorCodes = [];
	Race_Record_State.ResponseZonesTopRecords = LeaderboardAPI::K_ResponseFromGetMapTopRankings {};
	Race_Record_State.ResponseZonesSurroundingRecords = LeaderboardAPI::K_ResponseFromGetSurroundingRankings {};
	Race_Record_State.ResponseClubTopRecords = LeaderboardAPI::K_ResponseFromGetMapTopRankingsInClub {};
	Race_Record_State.ResponseClubSurroundingRecords = LeaderboardAPI::K_ResponseFromGetMapSurroundingRankingsInClub {};
	Race_Record_State.ResponseClubVIPRecords = [];
	Race_Record_State.ResponseGlobalVIPRecords = [];
	Race_Record_State.LoadingRecords = False;
	Race_Record_State.RecordsLoadedForMapUid = "";
	Race_Record_State.RecordsLoadingForMapUid = "";
	Race_Record_State.RecordsClubId = ClubStruct::C_ClubNullId;
	Race_Record_State.RecordsClubName = "";
	Race_Record_State.ZonesRecords = [];
	Race_Record_State.RecordsAreDirty = [];
	Race_Record_State = SetAllRecordsDirty(Race_Record_State);
	Race_Record_State.RecordsNeedInit = [];
	foreach (RecordType in C_RecordTypes) {
		Race_Record_State.RecordsNeedInit.add(RecordType);
	}
	Race_Record_State.LeaderboardPrivilegeCheck = Privileges::Check_Destroy(Race_Record_State.LeaderboardPrivilegeCheck);
	Race_Record_State = ReleaseAllRecordGhosts(Race_Record_State);
	Race_Record_State = Update(Race_Record_State, Null, "", "", "", "", []);
	SendRecordsToML(Race_Record_State);
	Race_Record_State = DisplayPBGhost(Race_Record_State, Race_Record_State.DisplayPBGhost);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Load the library
Void Load() {
	Unload();

	G_RecordPermission = [
		0 => RBAC::C_GamePermission_ViewRecords, //< Check for permission even when no records are selected to display the right warning message.
		1 => RBAC::C_GamePermission_ViewRecords,
		2 => RBAC::C_GamePermission_ViewRecords,
		3 => RBAC::C_GamePermission_ViewRecords,
		4 => ""
	];

	// Check if the user has the required privileges to see the widget
	declare K_State Race_Record_State for UI;
	Race_Record_State.CanViewLeaderboards = Privileges::Cache_HasPrivilege(CPrivilegeMgr::EPrivilege::PlayMultiplayerAsync);
	Race_Record_State.LeaderboardPrivilegeCheck = Privileges::Check_DestroyAndCreate(
		Race_Record_State.LeaderboardPrivilegeCheck,
		PrivilegeMgr,
		MainUser::GetMainUserId(),
		CPrivilegeMgr::EPrivilege::PlayMultiplayerAsync
	);
}