/**
 *	UI module: Vote client side
 */
#Const Version		"2023-01-20"
#Const ScriptName	"ManiaApps/Nadeo/TMxSM/Race/UIModules/Vote_Client.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/ManiaView2.Script.txt" as MV
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/Helpers.Script.txt" as MLHelpers
#Include "Libs/Nadeo/MenuLibs/Common/FontManager.Script.txt" as FontManager
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/ButtonIcon2.Script.txt" as ButtonIcon
#Include "Libs/Nadeo/ModeLibs/Common/UIModules_Client.Script.txt" as UIModules
#Include "Libs/Nadeo/TMNext/TrackMania/ColorPalette.Script.txt" as ColorPalette
#Include "ManiaApps/Nadeo/TMxSM/Race/ZIndex.Script.txt" as ZIndex
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/Vote_Common.Script.txt" as UIModules_Vote_Common

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
//L16N [Vote] Answer positively to the question asked in the vote
#Const C_Text_Yes _("|VoteAnswer|Yes")
//L16N [Vote] Answer negatively to the question asked in the vote
#Const C_Text_No _("|VoteAnswer|No")
//L16N [Vote] The use must open the pause menu to be able to vote
#Const C_Text_OpenMenu _("Open the menu to vote")

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the id of the UI module
Text GetId() {
	return UIModules_Vote_Common::C_Id;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the type of layer of the UI module
CUILayer::EUILayerType GetLayerType() {
	return UIModules_Vote_Common::C_LayerType;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Check if the custom vote UI is available
Boolean CustomUIIsAvailable(CSystemPlatform _System) {
	return UIModules_Vote_Common::CustomUIIsAvailable(_System);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the module manialink
 *
 *  @return                           The module manialink
 */
Text GetML() {
	declare Vec2 Size_Vote = <80., 17.>;
	declare Vec2 Pos_VoteContent = <Size_Vote.X * -0.5, 0.>;
	declare Vec2 Size_ButtonIcon = <6., 6.>;
	declare Vec2 Size_Answer = <(Size_Vote.X * 0.5) - 3. - Size_ButtonIcon.X, 6.>;
	declare Vec2 Size_HelperText = <Size_Vote.X, 6.>;
	declare Vec2 Pos_HelperText = <0., -Size_Vote.Y>;
	declare Vec2 Size_Panel = <Size_Vote.X, Size_Vote.Y + Size_HelperText.Y>;

	return MV::Create(
GetId(), 3,
"""
<stylesheet>
	<style class="text-semibold" textprefix="$i" textfont="{{{FontManager::C_GameFontSemiBold}}}" textcolor="{{{ColorPalette::C_Color_White}}}" textsize="3" />
</stylesheet>
<frame id="frame-global" z-index="{{{ZIndex::C_ZIndex_Vote_Pause}}}">
	<frame {{{UIModules::CustomizableUIModule(UIModules_Vote_Common::C_UIModuleConfig)}}}>
		<frame {{{MLHelpers::Size(Size_Panel)}}} halign="right">
			<frame id="frame-visibility-panel" pos="{{{Size_Panel.X}}} 0" hidden="1">
				<frame z-index="2">
					<quad z-index="0" {{{MLHelpers::Size(Size_Vote)}}} halign="right" bgcolor="{{{ColorPalette::C_Color_DarkBlue}}}" opacity="0.6" />
					<frame {{{MLHelpers::Pos(Pos_VoteContent)}}} z-index="1">
						<label id="label-question" class="text-semibold" pos="0 -6" size="{{{Size_Vote.X - 2}}} 15" halign="center" valign="center2" maxline="2" />
						<frame pos="0 -14">
							<label id="label-yes" class="text-semibold" pos="-1 0" {{{MLHelpers::Size(Size_Answer)}}} halign="right" valign="center2" text="{{{C_Text_Yes}}}" />
							<label id="label-no" class="text-semibold" pos="1 0" {{{MLHelpers::Size(Size_Answer)}}} valign="center2" text="{{{C_Text_No}}}" />
							<frameinstance id="buttonicon-yes" modelid="{{{ButtonIcon::C_Name}}}" data-size="{{{Size_ButtonIcon.X}}} {{{Size_ButtonIcon.Y}}}" data-halign="right" data-valign="center" hidden="1" />
							<frameinstance id="buttonicon-no" modelid="{{{ButtonIcon::C_Name}}}" data-size="{{{Size_ButtonIcon.X}}} {{{Size_ButtonIcon.Y}}}" data-halign="left" data-valign="center" hidden="1" />
						</frame>
					</frame>
				</frame>
				<frame {{{MLHelpers::Pos(Pos_HelperText)}}} z-index="1" {{{MLHelpers::Size(Size_HelperText)}}} halign="right">
					<frame id="frame-visibility-helper-text" pos="0 {{{Size_HelperText.Y}}}" hidden="1">
						<quad z-index="0" {{{MLHelpers::Size(Size_HelperText)}}} halign="right" bgcolor="{{{ColorPalette::C_Color_DarkBlue}}}" opacity="0.6" />
						<label id="label-helper-text" class="text-semibold" pos="{{{Size_HelperText.X * -0.5}}} {{{Size_HelperText.Y * -0.5}}}" size="{{{Size_Vote.X - 2}}} {{{Size_Vote.Y - 1}}}" halign="center" valign="center2" textprefix="$t$i" text="{{{C_Text_OpenMenu}}}" />
					</frame>
				</frame>
			</frame>
		</frame>
	</frame>
</frame>
""",
"""
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/MenuLibs/Common/Components/Tools.Script.txt" as Tools
#Include "Libs/Nadeo/TMNext/TrackMania/ColorPalette.Script.txt" as ColorPalette
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/Vote_Common.Script.txt" as Vote
#Include "ManiaApps/Nadeo/TMxSM/Race/ZIndex.Script.txt" as ZIndex

#Struct K_Controls {
	CMlFrame Frame_Global;
	CMlFrame Frame_VisibilityPanel;
	CMlLabel Label_Question;
	CMlLabel Label_Yes;
	CMlLabel Label_No;
	CMlFrame ButtonIcon_Yes;
	CMlFrame ButtonIcon_No;
	CMlFrame Frame_VisibilityHelperText;
}
#Struct K_State {
	K_Controls Controls;
	Boolean DisplayModule;
	Boolean IsVisible;
	Boolean CanVote;
	Text Question;
	Boolean VoteActionEnabled;
	Integer ButtonInputsUpdate;
	Integer CurrentVoteChoice;
}

#Const C_State_Null K_State {
	Controls = K_Controls {},
	DisplayModule = False,
	IsVisible = False,
	CanVote = False,
	Question = "",
	VoteActionEnabled = False,
	ButtonInputsUpdate = 0,
	CurrentVoteChoice = 0
}

#Const C_Size_Panel {{{dump(Size_Panel)}}}
#Const C_Size_HelperText {{{dump(Size_HelperText)}}}
""",
"""
Void AlignVoteAnswers(K_State _State) {
	Tools::FitLabelValue(_State.Controls.Label_Yes, 3., 1., 0.5);
	Tools::FitLabelValue(_State.Controls.Label_No, 3., 1., 0.5);
	_State.Controls.ButtonIcon_Yes.RelativePosition_V3.X = _State.Controls.Label_Yes.RelativePosition_V3.X - 1. - ML::Min(_State.Controls.Label_Yes.Size.X, _State.Controls.Label_Yes.ComputeWidth(_State.Controls.Label_Yes.Value));
	_State.Controls.ButtonIcon_No.RelativePosition_V3.X = _State.Controls.Label_No.RelativePosition_V3.X + 1. + ML::Min(_State.Controls.Label_No.Size.X, _State.Controls.Label_No.ComputeWidth(_State.Controls.Label_No.Value));
}

K_State SetVisibility(K_State _State, Boolean _DisplayModule) {
	declare K_State State = _State;

	State.DisplayModule = _DisplayModule;

	declare Boolean IsVisible = State.DisplayModule && State.Question != "";
	if (State.IsVisible != IsVisible) {
		State.IsVisible = IsVisible;
		
		AnimMgr.Flush(State.Controls.Frame_VisibilityPanel);
		if (State.IsVisible) {
			AnimMgr.Add(State.Controls.Frame_VisibilityPanel, "<anim pos=\"0 0\" hidden=\"0\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
		} else {
			AnimMgr.Add(State.Controls.Frame_VisibilityPanel, "<anim pos=\""^C_Size_Panel.X^" 0\" hidden=\"1\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
		}
	}

	return State;
}

K_State SetVoteActionEnabled(K_State _State, Boolean _VoteActionEnabled) {
	declare K_State State = _State;

	State.VoteActionEnabled = _VoteActionEnabled;
	State.Controls.ButtonIcon_Yes.Visible = State.VoteActionEnabled && State.CanVote;
	State.Controls.ButtonIcon_No.Visible = State.VoteActionEnabled && State.CanVote;
	// The menu navigation is enabled in another manialink
	// So the button icon are not refreshed automatically here
	// We need to do it manually
	{{{ButtonIcon::P}}}RedrawAllIcons(This);

	AnimMgr.Flush(State.Controls.Frame_VisibilityHelperText);
	if (State.VoteActionEnabled) {
		State.Controls.Frame_Global.ZIndex = ZIndex::C_ZIndex_Vote_Pause;
		AnimMgr.Add(State.Controls.Frame_VisibilityHelperText, "<anim pos=\"0 "^C_Size_HelperText.Y^"\" hidden=\"1\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	} else {
		State.Controls.Frame_Global.ZIndex = ZIndex::C_ZIndex_Vote_Ingame;
		AnimMgr.Add(State.Controls.Frame_VisibilityHelperText, "<anim pos=\"0 0\" hidden=\"0\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	}

	return State;
}

K_State SetVoteState(K_State _State, Boolean _CanVote, Text _Question) {
	declare K_State State = _State;

	// New vote started
	if (State.Question != _Question && _Question != "") {
		Vote::ResetCurrentVoteChoice(LocalUser);
	}

	State.CanVote = _CanVote;
	State.Question = _Question;

	// The question is preformatted by the C++ (text in green color), we want to get rid of that
	State.Controls.Label_Question.Value = TL::StripFormatting(State.Question);
	Tools::FitLabelValue(State.Controls.Label_Question, 3., 1., 0.5);

	State = SetVisibility(State, State.DisplayModule);
	State = SetVoteActionEnabled(State, State.VoteActionEnabled);

	return State;
}

K_State SetButtonInputs(K_State _State, Vote::K_ButtonInputs _ButtonInputs) {
	declare K_State State = _State;

	State.ButtonInputsUpdate = _ButtonInputs.Update;
	{{{ButtonIcon::P}}}SetBind(This, State.Controls.ButtonIcon_Yes, _ButtonInputs.YesIcon);
	{{{ButtonIcon::P}}}SetBind(This, State.Controls.ButtonIcon_No, _ButtonInputs.NoIcon);

	return State;
}

Vec3 GetTextColor(Boolean _IsSelected) {
	if (_IsSelected) return ColorPalette::C_Color_Vec3_GreenOne;
	return ColorPalette::C_Color_Vec3_White;
}

K_State SetCurrentVoteChoice(K_State _State, Integer _CurrentVoteChoice) {
	declare K_State State = _State;

	State.CurrentVoteChoice = _CurrentVoteChoice;
	State.Controls.Label_Yes.TextColor = GetTextColor(State.CurrentVoteChoice == Vote::C_VoteChoice_Yes);
	State.Controls.Label_No.TextColor = GetTextColor(State.CurrentVoteChoice == Vote::C_VoteChoice_No);

	return State;
}

***MainInit***
***
declare netread Boolean Net_Race_Vote_IsVisible for UI;

declare K_State State = C_State_Null;
***

***MainStart***
***
State.Controls.Frame_Global <=> (Page.GetFirstChild("frame-global") as CMlFrame);
State.Controls.Frame_VisibilityPanel <=> (State.Controls.Frame_Global.GetFirstChild("frame-visibility-panel") as CMlFrame);
State.Controls.Label_Question <=> (State.Controls.Frame_VisibilityPanel.GetFirstChild("label-question") as CMlLabel);
State.Controls.Label_Yes <=> (State.Controls.Frame_VisibilityPanel.GetFirstChild("label-yes") as CMlLabel);
State.Controls.Label_No <=> (State.Controls.Frame_VisibilityPanel.GetFirstChild("label-no") as CMlLabel);
State.Controls.ButtonIcon_Yes <=> (State.Controls.Frame_VisibilityPanel.GetFirstChild("buttonicon-yes") as CMlFrame);
State.Controls.ButtonIcon_No <=> (State.Controls.Frame_VisibilityPanel.GetFirstChild("buttonicon-no") as CMlFrame);
State.Controls.Frame_VisibilityHelperText <=> (State.Controls.Frame_VisibilityPanel.GetFirstChild("frame-visibility-helper-text") as CMlFrame);

AlignVoteAnswers(State);
State = SetVisibility(State, Net_Race_Vote_IsVisible);
State = SetVoteState(State, Playground.Vote_CanVote, Playground.Vote_Question);
State = SetVoteActionEnabled(State, Vote::VoteActionEnabled(LocalUser));
State = SetButtonInputs(State, Vote::GetButtonInputs(LocalUser));
State = SetCurrentVoteChoice(State, Vote::GetCurrentVoteChoice(LocalUser));
***

***MainLoop***
***
if (PageIsVisible) {
	if (State.DisplayModule != Net_Race_Vote_IsVisible) {
		State = SetVisibility(State, Net_Race_Vote_IsVisible);
	}

	if (State.DisplayModule) {
		if (State.CanVote != Playground.Vote_CanVote || State.Question != Playground.Vote_Question) {
			State = SetVoteState(State, Playground.Vote_CanVote, Playground.Vote_Question);
		}
	}
	if (State.IsVisible) {
		if (State.VoteActionEnabled != Vote::VoteActionEnabled(LocalUser)) {
			State = SetVoteActionEnabled(State, Vote::VoteActionEnabled(LocalUser));
		}

		declare Vote::K_ButtonInputs ButtonInputs = Vote::GetButtonInputs(LocalUser);
		if (State.ButtonInputsUpdate != ButtonInputs.Update) {
			State = SetButtonInputs(State, Vote::GetButtonInputs(LocalUser));
		}

		if (State.CurrentVoteChoice != Vote::GetCurrentVoteChoice(LocalUser)) {
			State = SetCurrentVoteChoice(State, Vote::GetCurrentVoteChoice(LocalUser));
		}
	}
}
***
""",
[
	UIModules::Component(),
	ButtonIcon::ComponentV2()
],
[]
	);
}