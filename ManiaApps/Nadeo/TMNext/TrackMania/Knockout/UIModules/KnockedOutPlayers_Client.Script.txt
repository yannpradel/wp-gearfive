/**
 *  UI module: KnockedOutPlayers client side
 */
#Const Version		"2023-01-13"
#Const ScriptName "ManiaApps/Nadeo/TMNext/TrackMania/Knockout/UIModules/KnockedOutPlayers_Client.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/ManiaView2.Script.txt" as MV
#Include "Libs/Nadeo/MenuLibs/Common/FontManager.Script.txt" as FontManager
#Include "Libs/Nadeo/TMNext/TrackMania/ColorPalette.Script.txt" as ColorPalette
#Include "Libs/Nadeo/TMNext/TrackMania/Stores/UserStore_ML.Script.txt" as UserStore
#Include "MathLib" as ML


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_Id "UIModule_Knockout_KnockedOutPlayers"
#Const C_Type CUILayer::EUILayerType::Normal

#Const C_SlotNb 4 //max 4 min 1

#Const C_Sound_KnockOutPlayer "KnockOutPlayer"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Public
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the module manialink
 *
 *  @return                           The module manialink
 */
Text GetML() {
	//L16N [Knockout] Header for the table displayed at the end of each round. It shows the eliminated players this round and their final rank.
	declare Text_EliminatedPlayers = _("Knocked out players");
	//L16N [Knockout] Number of players eliminated this round.
	declare Text_EliminatedPlayersNb_One = _("1 player eliminated");
	//L16N [Knockout] Number of players eliminated this round. %1 will be replaced by a number greater than 1. e.g. "2 players eliminated".
	declare Text_EliminatedPlayersNb_Multiple = _("%1 players eliminated");
	//L16N [Knockout] Final rank of a player in the talbe displayed at the end of each round. It shows the eliminated players this round and their final rank.
	declare Text_FinalRank = _("Final Rank");
	//L16N [Knockout] End of 1st round message.
	declare Text_NoElimination = _("No elimination in first round");

	declare SlotsML4 = "";
	declare SlotsML3 = "";
	declare SlotsML2 = "";
	declare SlotsML1 = "";

	/// Param√®tres
	declare Real BgSizeX = 190.;
	declare Real BgSizeY = BgSizeX *624./1088.;
	declare Real SideAddMarginRatio = 0.18;
	declare Real BotAddMarginRatio = 0.06;
	declare Real TitleMarginRatio = 0.23;
	///

	declare Img_KOStamp = "file://Media/Manialinks/Nadeo/TMNext/Modes/Knockout/TM_UI_HUD_02_KnockOut_KOSign.dds";
	declare Img_Background = "file://Media/Manialinks/Nadeo/TMNext/Modes/Knockout/TM_UI_HUD_02_KnockOut_Popup.dds";

	for(SlotNb, 1, C_SlotNb) {
		declare SlotsML = "";
		declare Real SlotsZoneSizeY = BgSizeY * (1. - TitleMarginRatio -BotAddMarginRatio);
		declare Real SlotsZone_MarginRatio = 0.12;
		declare Real SlotMarginY = SlotsZoneSizeY/SlotNb * SlotsZone_MarginRatio;
		declare Real SlotSizeY = SlotsZoneSizeY/SlotNb * (1-SlotsZone_MarginRatio);
		declare Real SlotSizeX = BgSizeX * (1-SideAddMarginRatio);
		declare Real NameRatioX = 0.30;
		declare Real RankRatioX = 0.10;
		declare Real LeftSizeX = BgSizeX*(1-2.*SideAddMarginRatio-NameRatioX-RankRatioX);
		declare Real PictureSizeX = ML::Min(SlotSizeY/104.*232., LeftSizeX-2);
		declare Real PictureSizeY = PictureSizeX/232.*104.;

		SlotsML ^= """
<frame pos="0 {{{BgSizeY/2. - SlotSizeY/2. - (BgSizeY * TitleMarginRatio)}}}" id="frame-slots-{{{SlotNb}}}">
""";
		for (Index, 0, SlotNb-1) {
			SlotsML ^= """
	<frame pos="{{{0.176*(Index*-(SlotMarginY + SlotSizeY) + TitleMarginRatio*BgSizeY)}}} {{{Index*-(SlotMarginY + SlotSizeY)}}}" id="frame-slot-{{{Index}}}">
		<label id="label-name" z-index="1" pos="{{{BgSizeX*(-0.5 + SideAddMarginRatio + RankRatioX) + LeftSizeX}}} 0" size="{{{BgSizeX*NameRatioX}}} 12" class="label-base" textsize="4." halign="left"/>
		<label id="label-rank" z-index="1" pos="{{{BgSizeX*(-0.5 + SideAddMarginRatio)}}} 0" size="{{{BgSizeX*RankRatioX}}} 12" class="label-base" textsize="4." halign="left"/>
		<quad id="quad-K-O" z-index="2" size="{{{PictureSizeX}}} {{{PictureSizeY}}}" pos="{{{BgSizeX*(-0.5 + SideAddMarginRatio + RankRatioX) + LeftSizeX/2.}}} 0" halign="center" valign="center" image="{{{Img_KOStamp}}}" />
	</frame>
""";
		}
		SlotsML ^= """
</frame>
""";
		switch (SlotNb) {
			case 1: SlotsML1 = SlotsML;
			case 2: SlotsML2 = SlotsML;
			case 3: SlotsML3 = SlotsML;
			case 4: SlotsML4 = SlotsML;
		}
	}
	
	return MV::Create(
C_Id, 3,
"""
<stylesheet>
	<style class="label-base" halign="center" valign="center2" textfont="{{{FontManager::C_GameFontExtraBold}}}" textprefix="$i$t" textsize="2.25" textcolor="FFF"/>
	<style class="quad-base" halign="center" valign="center"/>
</stylesheet>
<frame z-index="5" hidden="1" id="frame-global">
	<frame z-index="2" hidden="1" id="frame-content">
		<frame z-index="2" hidden="1" id="frame-no-elimination">
			<label z-index="1" pos="0 0" size="{{{BgSizeX*0.8}}} 12" class="label-base" textsize="5" text="{{{Text_NoElimination}}}" />
		</frame>
		<quad id="quad-black-bg" z-index="-1" size="400 200" halign="center" valign="center" bgcolor="000" opacity="0.4" fullscreen="1"/>
		<quad id="quad-pop-up-bg" z-index="0" size="{{{BgSizeX}}} {{{BgSizeY}}}" halign="center" valign="center" image="{{{Img_Background}}}" />
		<label z-index="1" pos="{{{0.176*BgSizeY/2.*(1.-TitleMarginRatio)}}} {{{BgSizeY/2.*(1.-TitleMarginRatio)}}}" size="100 12" class="label-base" textsize="7" text="{{{Text_EliminatedPlayers}}}" />
		<label id="label-eliminated-nb" z-index="1" pos="{{{0.176*(BgSizeY/2.*(1.-TitleMarginRatio) - 6)}}} {{{BgSizeY/2.*(1.-TitleMarginRatio) - 6}}}" size="100 5" class="label-base" textsize="3" />
		<frame z-index="3" id="frame-slots">
			{{{SlotsML1}}}
			{{{SlotsML2}}}
			{{{SlotsML3}}}
			{{{SlotsML4}}}
		</frame>
	</frame>
</frame>
""",
"""
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/CommonLibs/Common/AudioManager_ML.Script.txt" as AudioManager
#Include "Libs/Nadeo/MenuLibs/Common/Components/Tools.Script.txt" as Tools
#Include "Libs/Nadeo/ModeLibs/TrackMania/MV_Utils.Script.txt" as MV_Utils

#Struct K_ScheduledAnimation {
	Integer Delay;
	Integer AnimTime;
	Integer WaitTime;
	Integer TotalAnimTime;
	Integer EliminatedPlayersNb;
	Text[] AccountIds;
	Integer[] Ranks;
	CMlFrame Frame_Slots;
}
""",
"""
declare Text[Integer] G_ScheduledSounds;

Void DisplayNoElimination(CMlFrame _Frame_NoElim, Boolean _IsVisible) {
	if (_Frame_NoElim != Null) _Frame_NoElim.Visible = _IsVisible;
}

Void DisplayEliminations(K_ScheduledAnimation _ScheduledAnimation) {
	if (_ScheduledAnimation.Frame_Slots == Null) return;
	declare CUser[Text] Users;
	foreach (Score in Scores) {
		if (
			Score != Null &&
			_ScheduledAnimation.AccountIds.exists(Score.User.WebServicesUserId)
		) {
			Users[Score.User.WebServicesUserId] <=> Score.User;
		}
	}

	declare StartTime = Now + _ScheduledAnimation.Delay;
	declare AnimTime = _ScheduledAnimation.AnimTime;
	declare WaitTime = _ScheduledAnimation.WaitTime;
	declare LabelFadeInTime = 100;
	declare CMlFrame Frame_Content <=> (Page.GetFirstChild("frame-content") as CMlFrame);
	declare CMlLabel Label_EliminatedPlayersNb <=> (Frame_Content.GetFirstChild("label-eliminated-nb") as CMlLabel);
	Label_EliminatedPlayersNb.Value = "";
	if (_ScheduledAnimation.EliminatedPlayersNb == 1) Label_EliminatedPlayersNb.Value = "{{{Text_EliminatedPlayersNb_One}}}";
	else if (_ScheduledAnimation.EliminatedPlayersNb > 1) Label_EliminatedPlayersNb.Value = TL::Compose("{{{Text_EliminatedPlayersNb_Multiple}}}", ""^_ScheduledAnimation.EliminatedPlayersNb);
	for (FrameIndex, 0, {{{C_SlotNb}}}-1) {
		declare CMlFrame Frame_Slot <=> (_ScheduledAnimation.Frame_Slots.GetFirstChild("frame-slot-"^FrameIndex) as CMlFrame);
		if (Frame_Slot != Null) {
			declare CMlQuad Quad_KO <=> (Frame_Slot.GetFirstChild("quad-K-O") as CMlQuad);
			declare CMlLabel Label_Name <=> (Frame_Slot.GetFirstChild("label-name") as CMlLabel);
			declare CMlLabel Label_Rank <=> (Frame_Slot.GetFirstChild("label-rank") as CMlLabel);
			declare CUser User;
			declare SlotAnimStartTime = StartTime + (AnimTime + WaitTime)*FrameIndex;
			if (
				_ScheduledAnimation.AccountIds.existskey(FrameIndex) &&
				Users.existskey(_ScheduledAnimation.AccountIds[FrameIndex])
			) {
				User <=> Users[_ScheduledAnimation.AccountIds[FrameIndex]];
			}
			declare Rank = 0;
			if (_ScheduledAnimation.Ranks.existskey(FrameIndex)) Rank = _ScheduledAnimation.Ranks[FrameIndex];
			declare Name = "";
			declare NameColor = <1.,1.,1.>;
			declare Text_Rank = "";
			if (Rank > 0) {
				Text_Rank = TL::FormatRank(Rank, False);
				declare RandRot = ML::Rand(-6., 6.);
				Frame_Slot.RelativeRotation = RandRot;
				Frame_Slot.RelativeScale = 1.3;
				Frame_Slot.Hide();
				AnimMgr.Flush(Frame_Slot);
				declare ShakeFrequency = 50;
				declare ShakeDelay = -75;
				declare RandRange = 1 - 2*ML::Rand(0,1) * ML::Rand(0.,0.1);
				G_ScheduledSounds[SlotAnimStartTime] = "{{{C_Sound_KnockOutPlayer}}}";
				AnimMgr.Add(Frame_Slot, "<anim scale=\"1.\" hidden=\"0\" rot=\""^0^"\"/>", SlotAnimStartTime, AnimTime, CAnimManager::EAnimManagerEasing::QuadIn);
				AnimMgr.Add(Frame_Content, "<anim scale=\"1.\" rot=\""^ML::Rand(-0.75*RandRange, -0.5*RandRange)^"\"/>", SlotAnimStartTime + AnimTime, ShakeFrequency + ShakeDelay, CAnimManager::EAnimManagerEasing::SineInOut);
				AnimMgr.Add(Frame_Content, "<anim scale=\"1.\" rot=\""^ML::Rand(0.5*RandRange, 0.75*RandRange)^"\"/>", SlotAnimStartTime + AnimTime + 2*ShakeFrequency + ShakeDelay, ShakeFrequency, CAnimManager::EAnimManagerEasing::SineInOut);
				AnimMgr.Add(Frame_Content, "<anim scale=\"1.\" rot=\""^ML::Rand(-0.25*RandRange, -0.1*RandRange)^"\"/>", SlotAnimStartTime + AnimTime + 3*ShakeFrequency + ShakeDelay, ShakeFrequency, CAnimManager::EAnimManagerEasing::SineInOut);
				AnimMgr.Add(Frame_Content, "<anim scale=\"1.\" rot=\""^0^"\"/>", SlotAnimStartTime + AnimTime + 5*ShakeFrequency + ShakeDelay, ShakeFrequency, CAnimManager::EAnimManagerEasing::SineInOut);
				if (User != Null) {
					Name = {{{UserStore::P}}}GetPlayerName(User, True);
					if (InputPlayer != Null && InputPlayer.User.WebServicesUserId == User.WebServicesUserId) NameColor = {{{ColorPalette::C_Color_Vec3_GreenOne}}};
				} else { // can happen if a player disconnects before scoring any time
					//L16N Placeholder for what should be the player's name, but the player is disconnected.
					Name = _("Disconnected player");
				}
			}
			
			Quad_KO.Visible = (Name != "");
			Label_Name.Value = Name;
			Label_Name.TextColor = NameColor;
			Label_Name.Opacity = 0.;
			Tools::FitLabelValue(Label_Name, 4., 1., 0.5);
			Tools::FirstPartyLogoMatchLuminance(Label_Name);
			AnimMgr.Flush(Label_Name);
			AnimMgr.Add(Label_Name, "<anim opacity=\"1\" />", SlotAnimStartTime + AnimTime - LabelFadeInTime, LabelFadeInTime, CAnimManager::EAnimManagerEasing::Linear);
			Label_Rank.Value = Text_Rank;
			Label_Rank.TextColor = NameColor;
			Label_Rank.Opacity = 0.;
			AnimMgr.Flush(Label_Rank);
			AnimMgr.Add(Label_Rank, "<anim opacity=\"1\" />", SlotAnimStartTime + AnimTime - LabelFadeInTime, LabelFadeInTime, CAnimManager::EAnimManagerEasing::Linear);
		}
	}
}

***MainInit***
***
declare CMlFrame Frame_Global;
declare CMlFrame Frame_Content;
declare CMlFrame Frame_Slots1;
declare CMlFrame Frame_Slots2;
declare CMlFrame Frame_Slots3;
declare CMlFrame Frame_Slots4;
declare CMlFrame Frame_NoElim;
declare CMlQuad Quad_BlackBg;

declare netread Boolean Net_Knockout_KnockedOutPlayers_DisplayContent for Teams[0] = False;
declare netread Text[] Net_Knockout_KnockedOutPlayers_AccountIds for Teams[0];
declare netread Integer[] Net_Knockout_KnockedOutPlayers_Ranks for Teams[0];
declare netread Integer Net_Knockout_KnockedOutPlayers_EliminatedPlayerUpdate for Teams[0];

declare Boolean DisplayModule;
declare Integer EliminatedPlayerUpdate;
declare K_ScheduledAnimation[] ScheduledAnimations;
declare Integer CurrentAnimationEndTime;
***

***MainStart***
***
Frame_Global <=> (Page.GetFirstChild("frame-global") as CMlFrame);
Frame_Content <=> (Page.GetFirstChild("frame-content") as CMlFrame);
Frame_Slots1 <=> (Page.GetFirstChild("frame-slots-1") as CMlFrame);
Frame_Slots2 <=> (Page.GetFirstChild("frame-slots-2") as CMlFrame);
Frame_Slots3 <=> (Page.GetFirstChild("frame-slots-3") as CMlFrame);
Frame_Slots4 <=> (Page.GetFirstChild("frame-slots-4") as CMlFrame);
Frame_NoElim <=> (Page.GetFirstChild("frame-no-elimination") as CMlFrame);
Quad_BlackBg <=> (Page.GetFirstChild("quad-black-bg") as CMlQuad);

DisplayModule = Frame_Global.Visible;
EliminatedPlayerUpdate = -123;
G_ScheduledSounds = [];
***

***MainLoop***
***
if (PageIsVisible) {
	declare Owner <=> MV_Utils::GetOwner(This);
	if (Owner != Null) {
		declare netread Boolean Net_Knockout_KnockedOutPlayers_IsVisible for Owner;
		if (DisplayModule != Net_Knockout_KnockedOutPlayers_IsVisible) {
			DisplayModule = Net_Knockout_KnockedOutPlayers_IsVisible;
			Frame_Global.Visible = Net_Knockout_KnockedOutPlayers_IsVisible;
		}
	}

	if (Frame_Content.Visible != Net_Knockout_KnockedOutPlayers_DisplayContent) {
		Frame_Content.Visible = Net_Knockout_KnockedOutPlayers_DisplayContent;
		declare InitialOpacity = 0.;
		declare TargetOpacity = 0.;
		if (Net_Knockout_KnockedOutPlayers_DisplayContent) {
			TargetOpacity = 0.4;
		} else {
			InitialOpacity = 0.4;
		}
		Quad_BlackBg.Opacity = InitialOpacity;
		AnimMgr.Flush(Quad_BlackBg);
		AnimMgr.Add(Quad_BlackBg, "<anim opacity=\""^TargetOpacity^"\"/>", Now, 250, CAnimManager::EAnimManagerEasing::Linear);

	}

	if (EliminatedPlayerUpdate != Net_Knockout_KnockedOutPlayers_EliminatedPlayerUpdate) {
		EliminatedPlayerUpdate = Net_Knockout_KnockedOutPlayers_EliminatedPlayerUpdate;
		DisplayEliminations(K_ScheduledAnimation {Frame_Slots = Frame_Slots1});
		DisplayEliminations(K_ScheduledAnimation {Frame_Slots = Frame_Slots2});
		DisplayEliminations(K_ScheduledAnimation {Frame_Slots = Frame_Slots3});
		DisplayEliminations(K_ScheduledAnimation {Frame_Slots = Frame_Slots4});
		DisplayNoElimination(Frame_NoElim, False);
		declare ScheduledAnimation = K_ScheduledAnimation {
			Delay = 1200,
			AnimTime = 250, // /!\ please change "{{{C_Sound_KnockOutPlayer}}}" sound if changing this timer
			WaitTime = 700,
			EliminatedPlayersNb = Net_Knockout_KnockedOutPlayers_AccountIds.count,
			AccountIds = Net_Knockout_KnockedOutPlayers_AccountIds,
			Ranks = Net_Knockout_KnockedOutPlayers_Ranks
		};
		switch (Net_Knockout_KnockedOutPlayers_AccountIds.count) {
			case 0: {
				DisplayNoElimination(Frame_NoElim, True);
			}
			case 1: {
				ScheduledAnimation.Frame_Slots <=> Frame_Slots1;
				DisplayEliminations(ScheduledAnimation);
			}
			case 2: {
				ScheduledAnimation.Frame_Slots <=> Frame_Slots2;
				DisplayEliminations(ScheduledAnimation);
			}
			case 3: {
				ScheduledAnimation.Frame_Slots <=> Frame_Slots3;
				DisplayEliminations(ScheduledAnimation);
			}
			case 4: {
				ScheduledAnimation.Frame_Slots <=> Frame_Slots4;
				DisplayEliminations(ScheduledAnimation);
			}
			default: {
				if (Net_Knockout_KnockedOutPlayers_AccountIds.count > 4) {
					for (PageIndex, 0, Net_Knockout_KnockedOutPlayers_AccountIds.count / 4 + 1) {
						declare Text[] AccountIds;
						declare Integer[] Ranks;
						for (FrameIndex, 0, 3) {
							if (Net_Knockout_KnockedOutPlayers_AccountIds.existskey(PageIndex*4 + FrameIndex)) {
								AccountIds.add(Net_Knockout_KnockedOutPlayers_AccountIds[PageIndex*4 + FrameIndex]);
								if (Net_Knockout_KnockedOutPlayers_Ranks.existskey(PageIndex*4 + FrameIndex)) {
									Ranks.add(Net_Knockout_KnockedOutPlayers_Ranks[PageIndex*4 + FrameIndex]);
								} else {
									Ranks.add(-1);
								}
							}
						}
						if (AccountIds.count > 0) {
							// MODIFY MB_Sleep time in Knockout mode when modifying these timers !
							declare Delay = 100;
							if (PageIndex == 0) Delay = 1200;
							declare Anim = K_ScheduledAnimation {
								Delay = Delay,
								WaitTime = 100,
								AnimTime = 250, // /!\ please change "{{{C_Sound_KnockOutPlayer}}}" sound if changing this timer
								TotalAnimTime = Delay + (250 + 100)*AccountIds.count + 1500,
								EliminatedPlayersNb = Net_Knockout_KnockedOutPlayers_AccountIds.count,
								AccountIds = AccountIds,
								Ranks = Ranks,
								Frame_Slots = Frame_Slots4
							};
							ScheduledAnimations.add(Anim);
						}
					}
				}
			}
		}
	}

	if (Owner == Null && DisplayModule) {
		DisplayModule = False;
		Frame_Global.Visible = DisplayModule;
	}

	if (
		CurrentAnimationEndTime <= Now &&
		ScheduledAnimations.count > 0
	) {
		declare ScheduledAnimation = ScheduledAnimations[0];
		DisplayEliminations(K_ScheduledAnimation {Frame_Slots = ScheduledAnimation.Frame_Slots});
		DisplayEliminations(ScheduledAnimation);
		CurrentAnimationEndTime = Now + ScheduledAnimation.TotalAnimTime;
		ScheduledAnimations.removekey(0);
	}

	if (G_ScheduledSounds.count > 0) {
		declare Integer[] SoundsToRemove_Key;
		foreach (Time => SoundName in G_ScheduledSounds) {
			if (Time <= 0) {
				SoundsToRemove_Key.add(Time);
			} else if (Time <= Now) {
				AudioManager::StopSound(This, SoundName);
				AudioManager::PlaySound(This, SoundName);
				SoundsToRemove_Key.add(Time);
			}
		}
		foreach (SoundTime in SoundsToRemove_Key) {
			if (G_ScheduledSounds.existskey(SoundTime)) G_ScheduledSounds.removekey(SoundTime);
		}
	}
}
***
""",
[
	UserStore::ComponentV2()
],
[]
	);
}