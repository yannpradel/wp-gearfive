/**
 *	UI module: RaceRanking client side
 */
#Const Version		"2021-05-31"
#Const ScriptName	"ManiaApps/Nadeo/TMNext/TrackMania/RoundsBoulet/UIModules/RaceRanking_Client.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "ColorLib" as CL
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/ManiaView2.Script.txt" as MV
#Include "Libs/Nadeo/MenuLibs/Common/FontManager.Script.txt" as FontManager
#Include "Libs/Nadeo/MenuLibs/Common/Components/Grid.Script.txt" as Grid
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/Helpers.Script.txt" as MLHelpers
#Include "Libs/Nadeo/ModeLibs/Common/UIModules_Client.Script.txt" as UIModules
#Include "Libs/Nadeo/TMNext/TrackMania/ColorPalette.Script.txt" as ColorPalette
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Constants.Script.txt" as MenuConst
#Include "ManiaApps/Nadeo/TMNext/TrackMania/RoundsBoulet/UIModules/RaceRanking_Common.Script.txt" as UIModules_RaceRanking_Common

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_Column_Rank 0
#Const C_Column_Name 1
#Const C_Column_Points 2
#Const C_UpdateInterval 100 //< Time interval between two updates check in the race ranking

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Public
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the id of the UI module
Text GetId() {
	return UIModules_RaceRanking_Common::C_Id;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the type of layer of the UI module
CUILayer::EUILayerType GetLayerType() {
	return UIModules_RaceRanking_Common::C_LayerType;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the module manialink
 *
 *  @return                           The module manialink
 */
Text GetML() {
	//L16N [RoundsBoulet RaceRanking] Ranking of the teams in the current race
	declare Text Text_LiveRanking = _("Live Ranking");
	//L16N [RoundsBoulet RaceRanking] Number of teams that could not be displayed because there was not enough place.
	declare Text Text_PlusOneTeam = _("+1 team");
	//L16N [RoundsBoulet RaceRanking] Number of teams that could not be displayed because there was not enough place. %1 will be replaced by the number of teams, always greater than 1. eg: "+7 teams"
	declare Text Text_PlusNTeams = _("+%1 teams");

	declare Text Img_ButtonToggleClose = MenuConst::C_ImageUrl_Icon_Arrow_Left_Oblique;
	declare Text Img_ButtonToggleOpen = MenuConst::C_ImageUrl_Icon_Arrow_Right_Oblique;

	declare Vec2 Size_LiveRanking = <50., 120.>;
	declare Vec2 Size_LiveRankingClip = Size_LiveRanking + <10., 0.>;
	declare Vec2 Size_ToggleButton = <7., 7.>;
	declare Vec2 Pos_ToggleButton = <Size_LiveRanking.X + 1. + Size_ToggleButton.X * 0.5, Size_ToggleButton.Y * -0.5>;
	declare Real Opacity_ButtonToggle = 0.6;
	declare Vec2 Size_Team = <Size_LiveRanking.X, 4.66>;
	declare Real SizeY_TeamMargin = 0.5;
	declare Vec2 Size_Finish = <10., Size_Team.Y + SizeY_TeamMargin>;

	declare GridConfig = Grid::Create(Size_Team.X, 1., 1., Grid::C_Direction_Right);
	GridConfig = Grid::AddColumn(GridConfig, C_Column_Rank, 10., Grid::C_Align_Center);
	GridConfig = Grid::AddColumn(GridConfig, C_Column_Name, 75., Grid::C_Align_Left);
	GridConfig = Grid::AddColumn(GridConfig, C_Column_Points, 15., Grid::C_Align_Right);
	declare Grid = Grid::Compile(GridConfig);

	declare Integer MaxTeamsNb = 20;
	declare Text ML_Teams = "";
	for (I, 0, MaxTeamsNb - 1) {
		ML_Teams ^= """<frameinstance modelid="framemodel-team" pos="0 {{{-I * (Size_Team.Y + SizeY_TeamMargin)}}}" hidden="1" />""";
	}

	return MV::Create(
GetId(), 3,
"""
<stylesheet>
	<style class="text-bold" textcolor="ffffff" textfont="{{{FontManager::C_GameFontExtraBold}}}" textprefix="$t$i" />
	<style class="text-semibold" textcolor="ffffff" textfont="{{{FontManager::C_GameFontSemiBold}}}" textprefix="$t$i" />
</stylesheet>
<framemodel id="framemodel-team">
	<label id="label-rank" {{{Grid::Pos(Grid, C_Column_Rank)}}} {{{Grid::Size(Grid, C_Column_Rank)}}} halign="center" valign="center2" textsize="1.25" class="text-bold" />
	<label id="label-name" {{{Grid::Pos(Grid, C_Column_Name)}}} {{{Grid::Size(Grid, C_Column_Name)}}} valign="center2" textsize="1.25" class="text-bold" />
	<label id="label-points" {{{Grid::Pos(Grid, C_Column_Points)}}} {{{Grid::Size(Grid, C_Column_Points)}}} halign="right" valign="center2" textsize="1.25" class="text-bold" />
	<quad id="button-team" z-index="-1" {{{MLHelpers::Size(Size_Team)}}} valign="center" bgcolor="{{{ColorPalette::C_Color_DarkBlue}}}" opacity="0" scriptevents="1" />
	<quad id="quad-target" z-index="-2" {{{MLHelpers::Size(Size_Team)}}} valign="center" bgcolor="{{{ColorPalette::C_Color_DarkBlue}}}" opacity="0.9" hidden="1" />
	<frame id="frame-finish">
		<label id="label-finish" pos="{{{Size_Team.X + Size_Finish.X - 1}}} 0" size="{{{Size_Finish.X - 2}}} {{{Size_Team.Y}}}" halign="right" valign="center2" textsize="1.25" class="text-semibold" />
		<quad z-index="-1" pos="{{{Size_Team.X}}} 0" {{{MLHelpers::Size(Size_Finish)}}} valign="center" bgcolor="{{{ColorPalette::C_Color_DarkBlue}}}" opacity="0.5" />
	</frame>
</framemodel>
<frame id="frame-global" z-index="-2" hidden="1">
	<frame {{{UIModules::CustomizableUIModule(UIModules_RaceRanking_Common::C_UIModuleConfig)}}}>
		<frame {{{MLHelpers::Size(Size_LiveRankingClip)}}}>
			<frame id="frame-slide-anim">
				<quad id="quad-background" z-index="0" {{{MLHelpers::Size(Size_LiveRanking)}}} bgcolor="{{{ColorPalette::C_Color_DarkBlue}}}" opacity="0.5" />
				<quad id="button-toggle" {{{MLHelpers::Pos(Pos_ToggleButton)}}} z-index="2" size="7 7" halign="center" valign="center" opacity="{{{Opacity_ButtonToggle}}}" colorize="ffffff" image="{{{Img_ButtonToggleClose}}}" scriptevents="1" />
				<frame pos="0 -1" z-index="1">
					<label pos="{{{Size_LiveRanking.X * 0.5}}} 0" size="{{{Size_LiveRanking.X-2}}} 10" halign="center" textsize="3" text="{{{Text_LiveRanking}}}" class="text-bold" />
					<label id="label-more-teams" pos="{{{Size_LiveRanking.X * 0.5}}} 0" size="{{{Size_LiveRanking.X-2}}} 10" halign="center" textsize="1.25" class="text-bold" />
					<frame id="frame-teams" pos="0 -10">
						{{{ML_Teams}}}
					</frame>
				</frame>
			</frame>
		</frame>
	</frame>
</frame>
""",
"""
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/ModeLibs/Common/Clans_Client.Script.txt" as Clans
#Include "Libs/Nadeo/ModeLibs/TrackMania/MV_Utils.Script.txt" as MV_Utils

#Struct K_Controls {
	CMlFrame Frame_SlideAnim;
	CMlQuad Button_Toggle;
	CMlFrame Frame_Teams;
	CMlQuad Quad_Background;
	CMlLabel Label_MoreTeams;
}

#Struct K_State {
	K_Controls Controls;
	Boolean IsVisible;
	Integer TeamsRankingUpdate;
	Integer TeamsRoundPointsUpdate;
	Integer TeamsFinishUpdate;
	Ident TargetPlayerId;
	Integer TargetTeamId;
	Integer[Integer] PrevTeamKeys;
}

#Const C_UpdateInterval {{{dump(C_UpdateInterval)}}}
#Const C_Color_DarkBlue {{{dump(CL::Hex6ToRgb(ColorPalette::C_Color_DarkBlue))}}}
#Const C_Color_GreenOne {{{dump(CL::Hex6ToRgb(ColorPalette::C_Color_GreenOne))}}}
#Const C_Color_White <1., 1., 1.>
""",
"""
Boolean GetVisibility() {
	declare persistent Boolean Persistent_RoundsBoulet_RaceRanking_IsVisible for This = True;
	return Persistent_RoundsBoulet_RaceRanking_IsVisible;
}

Void UpdateTeamFinish(CMlFrame _Frame_Finish, Integer _FinishedNb, Integer _MembersNb, Integer _RoundPoints) {
	if (_RoundPoints > 0) {
		declare CMlLabel Label_Finish <=> (_Frame_Finish.GetFirstChild("label-finish") as CMlLabel);
		Label_Finish.Value = "+"^_RoundPoints;
		_Frame_Finish.Visible = True;
	} else if (_FinishedNb > 0 && _MembersNb > 0) {
		declare CMlLabel Label_Finish <=> (_Frame_Finish.GetFirstChild("label-finish") as CMlLabel);
		Label_Finish.Value = ML::Min(_FinishedNb, _MembersNb)^"/"^_MembersNb;
		_Frame_Finish.Visible = True;
	} else {
		_Frame_Finish.Visible = False;
	}
}

Void UpdateTeamFinish(
	CMlFrame _Frame_Finish,
	Integer _TeamId,
	Integer[Integer] _TeamsRoundPoints,
	Integer[][Integer] _TeamsFinish
) {
	declare Integer[] TeamFinish = _TeamsFinish.get(_TeamId, [0, 0]);
	declare Integer TeamRoundPoints = _TeamsRoundPoints.get(_TeamId, 0);

	if (TeamFinish.count > 1) {
		UpdateTeamFinish(_Frame_Finish, TeamFinish[0], TeamFinish[1], TeamRoundPoints);
	} else {
		UpdateTeamFinish(_Frame_Finish, 0, 0, TeamRoundPoints);
	}
}

K_State UpdateTeamsFinish(
	K_State _State,
	Integer _TeamsRoundPointsUpdate,
	Integer _TeamsFinishUpdate,
	Integer[][] _TeamsRanking,
	Integer[Integer] _TeamsRoundPoints,
	Integer[][Integer] _TeamsFinish
) {
	declare K_State State = _State;

	State.TeamsRoundPointsUpdate = _TeamsRoundPointsUpdate;
	State.TeamsFinishUpdate = _TeamsFinishUpdate;

	foreach (Key => Control in _State.Controls.Frame_Teams.Controls) {
		if (Key <= _TeamsRanking.count - 1) {
			declare CMlFrame Frame_Team <=> (Control as CMlFrame);
			declare CMlFrame Frame_Finish <=> (Frame_Team.GetFirstChild("frame-finish") as CMlFrame);

			declare Integer[] TeamRanking = _TeamsRanking[Key];
			declare Integer TeamId = 0;
			if (TeamRanking.count > 0) TeamId = TeamRanking[0];
			
			UpdateTeamFinish(Frame_Finish, TeamId, _TeamsRoundPoints, _TeamsFinish);

			Frame_Team.Visible = True;
		} else {
			Control.Visible = False;
		}
	}

	return State;
}

K_State UpdateTeamsRanking(
	K_State _State,
	Integer _TeamsRankingUpdate,
	Integer _TeamsRoundPointsUpdate,
	Integer _TeamsFinishUpdate,
	Integer[][] _TeamsRanking,
	Integer[Integer] _TeamsRoundPoints,
	Integer[][Integer] _TeamsFinish
) {
	declare K_State State = _State;

	declare Integer DisplayedTeamsNb = ML::Min(_State.Controls.Frame_Teams.Controls.count, _TeamsRanking.count);
	State.TeamsRankingUpdate = _TeamsRankingUpdate;
	State.TeamsRoundPointsUpdate = _TeamsRoundPointsUpdate;
	State.TeamsFinishUpdate = _TeamsFinishUpdate;
	declare Integer[Integer] PrevTeamKeys = State.PrevTeamKeys;
	State.PrevTeamKeys = [];

	foreach (Key => Control in _State.Controls.Frame_Teams.Controls) {
		if (Key <= _TeamsRanking.count - 1) {
			declare CMlFrame Frame_Team <=> (Control as CMlFrame);
			declare CMlLabel Label_Rank <=> (Frame_Team.GetFirstChild("label-rank") as CMlLabel);
			declare CMlLabel Label_Name <=> (Frame_Team.GetFirstChild("label-name") as CMlLabel);
			declare CMlLabel Label_Points <=> (Frame_Team.GetFirstChild("label-points") as CMlLabel);
			declare CMlQuad Quad_Target <=> (Frame_Team.GetFirstChild("quad-target") as CMlQuad);
			declare CMlQuad Button_Team <=> (Frame_Team.GetFirstChild("button-team") as CMlQuad);
			declare CMlFrame Frame_Finish <=> (Frame_Team.GetFirstChild("frame-finish") as CMlFrame);

			declare Integer[] TeamRanking = _TeamsRanking[Key];
			declare Integer TeamId = 0;
			if (TeamRanking.count > 0) TeamId = TeamRanking[0];
			declare Integer Points = 0;
			if (ClanScores.existskey(TeamId)) {
				Points = ClanScores[TeamId];
			}

			Label_Rank.Value = ""^TeamRanking[1];
			Label_Name.Value = Clans::GetClanName(TeamId);
			Label_Points.Value = ""^Points;
			UpdateTeamFinish(Frame_Finish, TeamId, _TeamsRoundPoints, _TeamsFinish);

			if (State.TargetTeamId == TeamId) {
				Quad_Target.Visible = True;
				Label_Rank.TextColor = C_Color_GreenOne;
				Label_Name.TextColor = C_Color_GreenOne;
				Label_Points.TextColor = C_Color_GreenOne;
			} else {
				Quad_Target.Visible = False;
				Label_Rank.TextColor = C_Color_White;
				Label_Name.TextColor = C_Color_White;
				Label_Points.TextColor = C_Color_White;
			}

			declare Real TargetPosY = Key * -{{{Size_Team.Y + SizeY_TeamMargin}}};
			declare Real StartPosY = DisplayedTeamsNb * -{{{Size_Team.Y + SizeY_TeamMargin}}};
			if (PrevTeamKeys.existskey(TeamId)) {
				StartPosY = PrevTeamKeys[TeamId] * -{{{Size_Team.Y + SizeY_TeamMargin}}};
			}
			AnimMgr.Flush(Frame_Team);
			Frame_Team.RelativePosition_V3.Y = StartPosY;
			AnimMgr.Add(Frame_Team, "<a pos=\"0 "^TargetPosY^"\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
			State.PrevTeamKeys[TeamId] = Key;

			declare Integer RaceRanking_TeamId for Button_Team = 0;
			RaceRanking_TeamId = TeamId;

			Frame_Team.Visible = True;
		} else {
			Control.Visible = False;
		}
	}

	State.Controls.Quad_Background.Size.Y = (State.Controls.Frame_Teams.RelativePosition_V3.Y * -1) + (DisplayedTeamsNb * {{{Size_Team.Y + SizeY_TeamMargin}}});

	if (_TeamsRanking.count > _State.Controls.Frame_Teams.Controls.count) {
		declare Integer PlusTeams = _TeamsRanking.count - _State.Controls.Frame_Teams.Controls.count;
		State.Controls.Quad_Background.Size.Y += 6.;
		if (PlusTeams > 1) {
			State.Controls.Label_MoreTeams.Value = TL::Compose("{{{Text_PlusNTeams}}}", ""^PlusTeams);
		} else {
			State.Controls.Label_MoreTeams.Value = "{{{Text_PlusOneTeam}}}";
		}
		State.Controls.Label_MoreTeams.RelativePosition_V3.Y = -State.Controls.Quad_Background.Size.Y + 6.;
		State.Controls.Label_MoreTeams.Visible = True;
	} else {
		State.Controls.Label_MoreTeams.Visible = False;
	}

	return State;
}

K_State SetVisibility(K_State _State, Boolean _IsVisible) {
	declare persistent Boolean Persistent_RoundsBoulet_RaceRanking_IsVisible for This = True;
	Persistent_RoundsBoulet_RaceRanking_IsVisible = _IsVisible;

	declare K_State State = _State;
	State.IsVisible = Persistent_RoundsBoulet_RaceRanking_IsVisible;

	AnimMgr.Flush(_State.Controls.Frame_SlideAnim);
	if (_IsVisible) {
		AnimMgr.Add(_State.Controls.Frame_SlideAnim, "<a pos=\"0 0\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
		_State.Controls.Button_Toggle.ImageUrl = "{{{Img_ButtonToggleClose}}}";
		_State.Controls.Frame_Teams.Visible = True;
	} else {
		AnimMgr.Add(_State.Controls.Frame_SlideAnim, "<a pos=\"{{{-Size_LiveRanking.X}}} 0\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
		_State.Controls.Button_Toggle.ImageUrl = "{{{Img_ButtonToggleOpen}}}";
		_State.Controls.Frame_Teams.Visible = False;
	}

	return State;
}

K_State UpdateTargetPlayer(K_State _State, CSmPlayer _TargetedPlayer) {
	declare K_State State = _State;

	if (_TargetedPlayer == Null) {
		State.TargetPlayerId = NullId;
		State.TargetTeamId = 0;
	} else {
		State.TargetPlayerId = _TargetedPlayer.Id;
		State.TargetTeamId = _TargetedPlayer.CurrentClan;
	}

	return State;
}

Void SpectateNextClanPlayer(CSmPlayer _TargetedPlayer) {
	if (_TargetedPlayer != Null) {
		declare CSmPlayer TargetPlayer;
		declare Boolean CanSelectNextPlayer = False;
		foreach (Player in Players) {
			if (Player == _TargetedPlayer) {
				CanSelectNextPlayer = True;
			} else if (
				Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned &&
				Player.CurrentClan == _TargetedPlayer.CurrentClan
			) {
				if (TargetPlayer == Null) {
					TargetPlayer <=> Player;
				}
				if (CanSelectNextPlayer) {
					TargetPlayer <=> Player;
					break;
				}
			}
		}
		if (TargetPlayer != Null && TargetPlayer != _TargetedPlayer) {
			SetSpectateTarget(TargetPlayer.User.Login);
		}
	}
}

Void SpectateLastClanPlayer(Integer _TargetClan) {
	declare Integer LastCheckpointCount = 0;
	declare Integer LastCheckpointTime = 0;
	declare Boolean Init = True;
	declare Text TargetLogin = "";
	foreach (Player in Players) {
		if (
			Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned &&
			Player.CurrentClan == _TargetClan
		) {
			if (
				Init ||
				Player.RaceWaypointTimes.count < LastCheckpointCount || (
					Player.RaceWaypointTimes.count == LastCheckpointCount && 
					Player.RaceWaypointTimes.count > 0 &&
					Player.RaceWaypointTimes[Player.RaceWaypointTimes.count - 1] > LastCheckpointTime
				)
			) {
				Init = False;
				LastCheckpointCount = Player.RaceWaypointTimes.count;
				if (Player.RaceWaypointTimes.count > 0) LastCheckpointTime = Player.RaceWaypointTimes[Player.RaceWaypointTimes.count - 1];
				else LastCheckpointTime = 0;
				TargetLogin = Player.User.Login;
			}
		}
	}
	if (TargetLogin != "") {
		SetSpectateTarget(TargetLogin);
	}
}

Void FocusToggleButton(K_State _State, Boolean _IsFocused) {
	if (!GetVisibility()) {
		AnimMgr.Flush(_State.Controls.Frame_SlideAnim);
		if (_IsFocused) {
			AnimMgr.Add(_State.Controls.Frame_SlideAnim, "<a pos=\"{{{-Size_LiveRanking.X + 1}}} 0\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
		} else {
			AnimMgr.Add(_State.Controls.Frame_SlideAnim, "<a pos=\"{{{-Size_LiveRanking.X}}} 0\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
		}
	}

	AnimMgr.Flush(_State.Controls.Button_Toggle);
	if (_IsFocused) {
		AnimMgr.Add(_State.Controls.Button_Toggle, "<a opacity=\"1\" scale=\"1.2\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	} else {
		AnimMgr.Add(_State.Controls.Button_Toggle, "<a opacity=\"{{{Opacity_ButtonToggle}}}\" scale=\"1\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	}
}

Void FocusTeamButton(CMlQuad _Button_Team, Boolean _IsFocused) {
	AnimMgr.Flush(_Button_Team);
	_Button_Team.BgColor = C_Color_DarkBlue;
	if (_IsFocused) {
		AnimMgr.Add(_Button_Team, "<a opacity=\"0.5\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	} else {
		AnimMgr.Add(_Button_Team, "<a opacity=\"0\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	}
}

Void SelectTeamButton(CMlQuad _Button_Team, CSmPlayer _TargetedPlayer) {
	AnimMgr.Flush(_Button_Team);
	_Button_Team.BgColor = C_Color_DarkBlue;
	AnimMgr.Add(_Button_Team, "<a bgcolor=\"{{{ColorPalette::C_Color_GreenThree}}}\" />", 125, CAnimManager::EAnimManagerEasing::QuadIn);
	AnimMgr.AddChain(_Button_Team, "<a bgcolor=\"{{{ColorPalette::C_Color_DarkBlue}}}\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);

	declare Integer RaceRanking_TeamId for _Button_Team = 0;
	if (RaceRanking_TeamId != 0) {
		// Already spectating this team, select the next player in the team
		if (_TargetedPlayer != Null && _TargetedPlayer.CurrentClan == RaceRanking_TeamId) {
			SpectateNextClanPlayer(_TargetedPlayer);
		}
		// Spectating a new team, select the last player in the team
		else {
			SpectateLastClanPlayer(RaceRanking_TeamId);
		}
	}
}

***MainInit***
***
declare CMlFrame Frame_Global;

declare netread Integer[][] Net_RoundsBoulet_RaceRanking_TeamsRanking for Teams[0];
declare netread Integer Net_RoundsBoulet_RaceRanking_TeamsRankingUpdate for Teams[0];
declare netread Integer[Integer] Net_RoundsBoulet_RaceRanking_TeamsRoundPoints for Teams[0];
declare netread Integer Net_RoundsBoulet_RaceRanking_TeamsRoundPointsUpdate for Teams[0];
declare netread Integer[][Integer] Net_RoundsBoulet_RaceRanking_TeamsFinish for Teams[0];
declare netread Integer Net_RoundsBoulet_RaceRanking_TeamsFinishUpdate for Teams[0];

declare Boolean DisplayModule;
declare K_State State;
declare Integer NextUpdateTime;
***

***MainStart***
***
Frame_Global <=> (Page.GetFirstChild("frame-global") as CMlFrame);
State.Controls.Frame_SlideAnim <=> (Frame_Global.GetFirstChild("frame-slide-anim") as CMlFrame);
State.Controls.Button_Toggle <=> (State.Controls.Frame_SlideAnim.GetFirstChild("button-toggle") as CMlQuad);
State.Controls.Frame_Teams <=> (State.Controls.Frame_SlideAnim.GetFirstChild("frame-teams") as CMlFrame);
State.Controls.Quad_Background <=> (State.Controls.Frame_SlideAnim.GetFirstChild("quad-background") as CMlQuad);
State.Controls.Label_MoreTeams <=> (State.Controls.Frame_SlideAnim.GetFirstChild("label-more-teams") as CMlLabel);

DisplayModule = Frame_Global.Visible;
NextUpdateTime = Now;

State = SetVisibility(State, GetVisibility());
State = UpdateTargetPlayer(State, GUIPlayer);
State = UpdateTeamsRanking(
	State,
	Net_RoundsBoulet_RaceRanking_TeamsRankingUpdate,
	Net_RoundsBoulet_RaceRanking_TeamsRoundPointsUpdate,
	Net_RoundsBoulet_RaceRanking_TeamsFinishUpdate,
	Net_RoundsBoulet_RaceRanking_TeamsRanking,
	Net_RoundsBoulet_RaceRanking_TeamsRoundPoints,
	Net_RoundsBoulet_RaceRanking_TeamsFinish
);
***

***MainLoop***
***
if (PageIsVisible) {
	declare Owner <=> MV_Utils::GetOwner(This);
	if (Owner != Null) {
		declare netread Boolean Net_RoundsBoulet_RaceRanking_IsVisible for Owner;
		if (DisplayModule != Net_RoundsBoulet_RaceRanking_IsVisible) {
			DisplayModule = Net_RoundsBoulet_RaceRanking_IsVisible;
			Frame_Global.Visible = Net_RoundsBoulet_RaceRanking_IsVisible;
		}
	}

	if (Owner == Null && DisplayModule) {
		DisplayModule = False;
		Frame_Global.Visible = DisplayModule;
	}

	if (Frame_Global.Visible) {
		foreach (Event in PendingEvents) {
			switch (Event.Type) {
				case CMlScriptEvent::Type::MouseOver: {
					if (Event.ControlId == "button-toggle") {
						FocusToggleButton(State, True);
					} else if (Event.ControlId == "button-team") {
						FocusTeamButton((Event.Control as CMlQuad), True);
					}
				}
				case CMlScriptEvent::Type::MouseOut: {
					if (Event.ControlId == "button-toggle") {
						FocusToggleButton(State, False);
					} else if (Event.ControlId == "button-team") {
						FocusTeamButton((Event.Control as CMlQuad), False);
					}
				}
				case CMlScriptEvent::Type::MouseClick: {
					if (Event.ControlId == "button-toggle") {
						State = SetVisibility(State, !GetVisibility());
					} else if (Event.ControlId == "button-team") {
						// Only spectating users can interact with the button
						if (InputPlayer != Null && InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
							SelectTeamButton((Event.Control as CMlQuad), GUIPlayer);
						}
					}
				}
			}
		}

		if (Now >= NextUpdateTime) {
			NextUpdateTime = Now + C_UpdateInterval;

			if (State.IsVisible) {
				if (State.TeamsRankingUpdate != Net_RoundsBoulet_RaceRanking_TeamsRankingUpdate) {
					State = UpdateTeamsRanking(
						State,
						Net_RoundsBoulet_RaceRanking_TeamsRankingUpdate,
						Net_RoundsBoulet_RaceRanking_TeamsRoundPointsUpdate,
						Net_RoundsBoulet_RaceRanking_TeamsFinishUpdate,
						Net_RoundsBoulet_RaceRanking_TeamsRanking,
						Net_RoundsBoulet_RaceRanking_TeamsRoundPoints,
						Net_RoundsBoulet_RaceRanking_TeamsFinish
					);
				}
				if (
					State.TeamsRoundPointsUpdate != Net_RoundsBoulet_RaceRanking_TeamsRoundPointsUpdate ||
					State.TeamsFinishUpdate != Net_RoundsBoulet_RaceRanking_TeamsFinishUpdate
				) {
					State = UpdateTeamsFinish(
						State,
						Net_RoundsBoulet_RaceRanking_TeamsRoundPointsUpdate,
						Net_RoundsBoulet_RaceRanking_TeamsFinishUpdate,
						Net_RoundsBoulet_RaceRanking_TeamsRanking,
						Net_RoundsBoulet_RaceRanking_TeamsRoundPoints,
						Net_RoundsBoulet_RaceRanking_TeamsFinish
					);
				}

				if (
					GUIPlayer != Null && (State.TargetPlayerId != GUIPlayer.Id || State.TargetTeamId != GUIPlayer.CurrentClan) ||
					GUIPlayer == Null && (State.TargetPlayerId != NullId || State.TargetTeamId != 0)
				) {
					State = UpdateTargetPlayer(State, GUIPlayer);
					State = UpdateTeamsRanking(
						State,
						Net_RoundsBoulet_RaceRanking_TeamsRankingUpdate,
						Net_RoundsBoulet_RaceRanking_TeamsRoundPointsUpdate,
						Net_RoundsBoulet_RaceRanking_TeamsFinishUpdate,
						Net_RoundsBoulet_RaceRanking_TeamsRanking,
						Net_RoundsBoulet_RaceRanking_TeamsRoundPoints,
						Net_RoundsBoulet_RaceRanking_TeamsFinish
					);
				}
			}
		}
	}
}
***
""",
[
	UIModules::Component()
],
[]
	);
}