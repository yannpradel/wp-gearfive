/**
 *	Functions to sort scores
 *	This library can be used in any context
 */
#Const	Version			"2022-10-05"
#Const	ScriptName	"Libs/Nadeo/TMxSM/Race/ScoresSort.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_Order_Ascending 1
#Const C_Order_Descending -1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Sort keys by waypoint times
 *	Return an array with the following format :
 *	[Rank0 => [KeyA, KeyB], Rank1 => [KeyC], Rank2 => [KeyD, KeyE, KeyF]]
 *	Rank starts at 0.
 */
Integer[][Integer] SortKeysByWaypointTimes(Integer[][Integer] _WaypointTimes) {
	declare Integer[][Integer] WaypointsCountGroups;
	declare Integer[] NoWaypointTimesKeys;
	foreach (Key => WaypointTimes in _WaypointTimes) {
		if (WaypointTimes.count <= 0) {
			NoWaypointTimesKeys.add(Key);
		} else if (WaypointsCountGroups.existskey(WaypointTimes.count)) {
			WaypointsCountGroups[WaypointTimes.count].add(Key);
		} else {
			WaypointsCountGroups[WaypointTimes.count] = [Key];
		}
	}
	WaypointsCountGroups = WaypointsCountGroups.sortkeyreverse();
	
	declare Integer[][Integer] SortedKeys;
	foreach (WaypointsCount => Keys in WaypointsCountGroups) {
		if (Keys.count > 1) {
			declare Integer[][Integer] WaypointTimesGroups;
			foreach (Key in Keys) {
				declare Integer WaypointTime = _WaypointTimes[Key][WaypointsCount - 1];
				if (WaypointTimesGroups.existskey(WaypointTime)) {
					WaypointTimesGroups[WaypointTime].add(Key);
				} else {
					WaypointTimesGroups[WaypointTime] = [Key];
				}
			}
			WaypointTimesGroups = WaypointTimesGroups.sortkey();
			
			foreach (Keys in WaypointTimesGroups) {
				if (Keys.count > 1 && WaypointsCount > 1) {
					declare Integer[][Integer] ToSort;
					foreach (Key in Keys) {
						declare Integer[] WaypointTimes = _WaypointTimes[Key];
						WaypointTimes.removekey(WaypointsCount - 1);
						ToSort[Key] = WaypointTimes;
					}
					declare Integer[][Integer] Sorted = SortKeysByWaypointTimes(ToSort);
					foreach (Keys in Sorted) {
						SortedKeys[SortedKeys.count] = Keys;
					}
				} else {
					SortedKeys[SortedKeys.count] = Keys;
				}
			}
		} else {
			SortedKeys[SortedKeys.count] = Keys;
		}
	}
	
	if (NoWaypointTimesKeys.count > 0) {
		SortedKeys[SortedKeys.count] = NoWaypointTimesKeys;
	}
	
	return SortedKeys;
}
Ident[][Integer] SortIdsByWaypointTimes(Integer[][Ident] _WaypointTimes) {
	declare Ident[][Integer] WaypointsCountGroups;
	declare Ident[] NoWaypointTimesKeys;
	foreach (Key => WaypointTimes in _WaypointTimes) {
		if (WaypointTimes.count <= 0) {
			NoWaypointTimesKeys.add(Key);
		} else if (WaypointsCountGroups.existskey(WaypointTimes.count)) {
			WaypointsCountGroups[WaypointTimes.count].add(Key);
		} else {
			WaypointsCountGroups[WaypointTimes.count] = [Key];
		}
	}
	WaypointsCountGroups = WaypointsCountGroups.sortkeyreverse();
	
	declare Ident[][Integer] SortedKeys;
	foreach (WaypointsCount => Keys in WaypointsCountGroups) {
		if (Keys.count > 1) {
			declare Ident[][Integer] WaypointTimesGroups;
			foreach (Key in Keys) {
				declare Integer WaypointTime = _WaypointTimes[Key][WaypointsCount - 1];
				if (WaypointTimesGroups.existskey(WaypointTime)) {
					WaypointTimesGroups[WaypointTime].add(Key);
				} else {
					WaypointTimesGroups[WaypointTime] = [Key];
				}
			}
			WaypointTimesGroups = WaypointTimesGroups.sortkey();
			
			foreach (Keys in WaypointTimesGroups) {
				if (Keys.count > 1 && WaypointsCount > 1) {
					declare Integer[][Ident] ToSort;
					foreach (Key in Keys) {
						declare Integer[] WaypointTimes = _WaypointTimes[Key];
						WaypointTimes.removekey(WaypointsCount - 1);
						ToSort[Key] = WaypointTimes;
					}
					declare Ident[][Integer] Sorted = SortIdsByWaypointTimes(ToSort);
					foreach (Keys in Sorted) {
						SortedKeys[SortedKeys.count] = Keys;
					}
				} else {
					SortedKeys[SortedKeys.count] = Keys;
				}
			}
		} else {
			SortedKeys[SortedKeys.count] = Keys;
		}
	}
	
	if (NoWaypointTimesKeys.count > 0) {
		SortedKeys[SortedKeys.count] = NoWaypointTimesKeys;
	}
	
	return SortedKeys;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/**	Sort keys by points
 *
 *	@param	_KeysPoints								The points of each key
 *	@param	_SortDirection						In which direction the points must be sorted (high to low or low to high)
 *	@param	_NotRankedPoints					The value that must be considered as "no points", key will be sorted last
 *
 *	@return														Return an array with the following format :
 *																		[[KeyA, KeyB], [KeyC], [KeyD, KeyE, KeyF]]
 */
Integer[][] SortKeysByPoints(Integer[Integer] _KeysPoints, Integer _SortDirection, Integer _NotRankedPoints) {
	declare Integer[Integer] SortedKeysPoints;
	if (_SortDirection == C_Order_Ascending) {
		SortedKeysPoints = _KeysPoints.sort();
	} else if (_SortDirection == C_Order_Descending) {
		SortedKeysPoints = _KeysPoints.sortreverse();
	}
	
	declare Integer[][] SortedKeys;
	declare Integer[] UnrankedKeys;
	declare Integer TiePoints;
	declare Boolean CanTie = False;
	foreach (Key => KeyPoints in SortedKeysPoints) {
		if (KeyPoints == _NotRankedPoints) {
			UnrankedKeys.add(Key);
		} else if (CanTie && KeyPoints == TiePoints) {
			SortedKeys[SortedKeys.count - 1].add(Key);
		} else {
			TiePoints = KeyPoints;
			CanTie = True;
			SortedKeys.add([Key]);
		}
	}
	if (UnrankedKeys.count > 0) {
		SortedKeys.add(UnrankedKeys);
	}
	
	return SortedKeys;
}
Ident[][] SortIdsByPoints(Integer[Ident] _KeysPoints, Integer _SortDirection, Integer _NotRankedPoints) {
	declare Integer[Ident] SortedKeysPoints;
	if (_SortDirection == C_Order_Ascending) {
		SortedKeysPoints = _KeysPoints.sort();
	} else if (_SortDirection == C_Order_Descending) {
		SortedKeysPoints = _KeysPoints.sortreverse();
	}
	
	declare Ident[][] SortedKeys;
	declare Ident[] UnrankedKeys;
	declare Integer TiePoints;
	declare Boolean CanTie = False;
	foreach (Key => KeyPoints in SortedKeysPoints) {
		if (KeyPoints == _NotRankedPoints) {
			UnrankedKeys.add(Key);
		} else if (CanTie && KeyPoints == TiePoints) {
			SortedKeys[SortedKeys.count - 1].add(Key);
		} else {
			TiePoints = KeyPoints;
			CanTie = True;
			SortedKeys.add([Key]);
		}
	}
	if (UnrankedKeys.count > 0) {
		SortedKeys.add(UnrankedKeys);
	}
	
	return SortedKeys;
}