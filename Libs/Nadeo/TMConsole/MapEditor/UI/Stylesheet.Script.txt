/** 
 * Track editor UI stylesheet
 */

#Const Version		"2023-01-30"
#Const ScriptName	"Stylesheet.Script.txt"

#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/TMConsole/Buttons.Script.txt" as Buttons2
#Include "Libs/Nadeo/TMConsole/FontManager.Script.txt" as Font
#Include "Libs/Nadeo/TMNext/TrackMania/ColorPalette.Script.txt" as Colors
#Include "Libs/Nadeo/TMConsole/MLEffects.Script.txt" as MLE

// Constants
#Const C_DefaultSize		<1024., 80.>	///< Size of the background image (in px)
#Const C_DefaultTopMargin	11.				///< Margin at the top of the background image (in px)
#Const C_DefaultSideMargin	1.				///< Margin on the sides of the background image (in px)
#Const C_DefaultTextPadding	20.				///< Padding on text label (in px)
#Const C_DefaultCirclesNb	15				///< Number of circles in the background image
#Const C_ManialinkRatio		0.1666666667	///< Pixel ratio between source image and manialink size (320. / 1920.)
#Const C_DefaultCircleRatio	0.45			///< Default multiplier on the circle size
#Const C_DefaultLabelMargin	0.25			///< Default margin size (circle size ratio)
#Const C_DefaultQuadMargin	0.1				///< Default margin size (circle size ratio)
#Const C_DefaultBackgroundImage "file://Media/Manialinks/Nadeo/TMConsole/MapEditor/Images/Menu/slot-medium-bg-color.dds"	///< Default background image

#Const C_Img_SlantedLeft 	"TrackEditor_Helper_Left.dds"
#Const C_Img_SlantedRight "TrackEditor_Helper_Right.dds"
#Const C_Img_TitleLeft 		"TrackEditor_Title_Left.dds"
#Const C_Img_TitleRight 	"TrackEditor_Title_Right.dds"
#Const C_Img_HeaderRight 	"TrackEditor_Header_Right.dds"

// Default UI properties
#Const C_HeaderSize			48
#Const C_Margin_Top			80.
#Const C_Margin_Bottom		-77.
/// Alignements
#Const C_Align_LeftTop			0
#Const C_Align_LeftCenter		1
#Const C_Align_LeftCenter2		2
#Const C_Align_LeftBottom		3
#Const C_Align_CenterTop		4
#Const C_Align_CenterCenter		5
#Const C_Align_CenterCenter2	6
#Const C_Align_CenterBottom		7
#Const C_Align_RightTop			8
#Const C_Align_RightCenter		9
#Const C_Align_RightCenter2		10
#Const C_Align_RightBottom		11

#Const C_HAlign_Left			0
#Const C_HAlign_Center		1
#Const C_HAlign_Right			2
/// Default circles sizes
#Const C_CircleSize_Top		0.414
#Const C_CircleSize_Bottom	0.420

#Const C_SmartQuad_Margin_EdgeToButton 0.5
#Const C_SmartQuad_Margin_ButtonToText 2.2
#Const C_SmartQuad_Margin_TextToEdge 1.
#Const C_SmartQuad_Margin_TextToEdge_NoImg 0.


Vec2 Private_GetCircleSize2() {
	return <(C_DefaultSize.X / C_DefaultCirclesNb), C_DefaultSize.Y> * C_ManialinkRatio;
}

// Get margins at the sides of the background
Real Private_GetTopMargin() { return C_DefaultTopMargin * C_ManialinkRatio; }
Real Private_GetSideMargin() {	return C_DefaultSideMargin * C_ManialinkRatio; }
Real Private_GetTextPadding() {	return C_DefaultTextPadding * C_ManialinkRatio; }


Boolean Private_IsHorizontalLeftAlign(Integer _Align) {
	return (
		_Align == C_Align_LeftTop ||
		_Align == C_Align_LeftCenter ||
		_Align == C_Align_LeftCenter2 ||
		_Align == C_Align_LeftBottom
	);
}

Boolean Private_IsHorizontalCenterAlign(Integer _Align) {
	return (
		_Align == C_Align_CenterTop ||
		_Align == C_Align_CenterCenter ||
		_Align == C_Align_CenterCenter2 ||
		_Align == C_Align_CenterBottom
	);
}

Boolean Private_IsHorizontalRightAlign(Integer _Align) {
	return (
		_Align == C_Align_RightTop ||
		_Align == C_Align_RightCenter ||
		_Align == C_Align_RightCenter2 ||
		_Align == C_Align_RightBottom
	);
}

Boolean Private_IsVerticalTopAlign(Integer _Align) {
	return (
		_Align == C_Align_LeftTop ||
		_Align == C_Align_CenterTop ||
		_Align == C_Align_RightTop
	);
}

Boolean Private_IsVerticalCenterAlign(Integer _Align) {
	return (
		_Align == C_Align_LeftCenter ||
		_Align == C_Align_LeftCenter2 ||
		_Align == C_Align_CenterCenter ||
		_Align == C_Align_CenterCenter2 ||
		_Align == C_Align_RightCenter ||
		_Align == C_Align_RightCenter2
	);
}

Boolean Private_IsVerticalBottomAlign(Integer _Align) {
	return (
		_Align == C_Align_LeftBottom ||
		_Align == C_Align_CenterBottom ||
		_Align == C_Align_RightBottom
	);
}

Text GetScriptVersion() { return Version; }
Text GetScriptName() { return ScriptName; }

// Return the styles for the track editor UI
Text Get() {
	// new
	declare Regular = Font::GetFontName("Regular");
	declare SemiBold = Font::GetFontName("SemiBold");
	declare ExtraBold = Font::GetFontName("ExtraBold");
	
	// old
	declare FontMain = Font::GetFontName("SemiBold");
	declare FontMainSmall = Font::GetFontName("MainSmall");
	declare FontMainSmall2 = Font::GetFontName("MainSmall2");
	
	declare SelectorImage = "file://Media/Manialinks/Nadeo/TMConsole/MapEditor/Images/Menu/selector.dds";
	declare SelectorWideImage = "file://Media/Manialinks/Nadeo/TMConsole/MapEditor/Images/Menu/selector-wide.dds";
	declare ScreenOverlay = "file://Media/Manialinks/Nadeo/TMConsole/MapEditor/Images/Menu/rewards-bg.dds";
	declare ScreenValidation = "file://Media/Manialinks/Nadeo/TMConsole/MapEditor/Images/Menu/rewards-validation.dds";
	
	return """
<style class="tm2020-text-title-big" textfont="{{{ExtraBold}}}" textsize="5" textcolor="{{{Colors::C_Color_White}}}" textprefix="$t$i" />
<style class="tm2020-text-menu-big" textfont="{{{ExtraBold}}}" textsize="5" textcolor="{{{Colors::C_Color_GreenOne}}}" textprefix="$t$i" />
<style class="tm2020-text-header" textfont="{{{ExtraBold}}}" textsize="4" textcolor="{{{Colors::C_Color_GreenOne}}}" textprefix="$t$i" />
<style class="tm2020-text-helper" textfont="{{{SemiBold}}}" textsize="2" textcolor="{{{Colors::C_Color_White}}}" />
<style class="tm2020-text-copperlimit" textfont="{{{SemiBold}}}" textsize="3" textcolor="{{{Colors::C_Color_GreenOne}}}" textprefix="$i" />
<style class="tm2020-text-popup" textfont="{{{Regular}}}" textsize="2" textcolor="{{{Colors::C_Color_White}}}" />
<style class="tm2020-text-button" textfont="{{{SemiBold}}}" textsize="2" textcolor="{{{Colors::C_Color_White}}}" />
<style class="tm2020-text-menubutton" textfont="{{{ExtraBold}}}" textsize="2" textcolor="{{{Colors::C_Color_White}}}" textprefix="$t"/>
<style class="tm2020-text-authortime" textfont="{{{ExtraBold}}}" textsize="3" textcolor="{{{Colors::C_Color_GreenOne}}}" textprefix="$t"/>
<style class="tm2020-text-rosace" textfont="{{{SemiBold}}}" textsize="3" textcolor="{{{Colors::C_Color_White}}}" textprefix="$t" />
<style class="tm2020-text-experttoggle" textfont="{{{ExtraBold}}}" textsize="2" textcolor="{{{Colors::C_Color_White}}}" textprefix="$t$i" />
<style class="tm2020-text-rosace-pager" textfont="{{{ExtraBold}}}" textsize="2.5" textcolor="{{{Colors::C_Color_GreenOne}}}" textprefix="$t$i" />
<style class="tm2020-text-rosace-pager-side" textfont="{{{SemiBold}}}" textsize="2" textcolor="{{{Colors::C_Color_LightGrey}}}" textprefix="$t$i" />
<style class="tm2020-text-legend" textfont="{{{SemiBold}}}" textsize="1" autonewline="1" maxline="7" textcolor="{{{Colors::C_Color_White}}}" />


<style class="tm2020-background-text" bgcolor="{{{Colors::C_Color_DarkBlue}}}" opacity="0.6" />
<style class="tm2020-selector" image="{{{SelectorImage}}}" />
<style class="tm2020-selector-wide" image="{{{SelectorWideImage}}}" />
	
<style class="turbo2-text-title-big" textfont="{{{FontMain}}}" textsize="8" textcolor="{{{Colors::C_Color_White}}}" textprefix="$t" />
<style class="turbo2-text-title" textfont="{{{FontMain}}}" textsize="6" textcolor="{{{Colors::C_Color_White}}}" textprefix="$t" />
<style class="turbo2-text-category" textfont="{{{FontMainSmall}}}" textsize="2" textcolor="{{{Colors::C_Color_Black}}}" />
<style class="turbo2-text-helper" textfont="{{{FontMainSmall}}}" textsize="4" textcolor="{{{Colors::C_Color_White}}}" textemboss="1" />
<style class="turbo2-text-legend" textfont="{{{FontMainSmall2}}}" textsize="1" autonewline="1" maxline="7" textcolor="{{{Colors::C_Color_White}}}" />
<style class="turbo2-text-rosace" textfont="{{{FontMain}}}" textemboss="1" textcolor="{{{Colors::C_Color_White}}}" textprefix="$t" />
<style class="turbo2-text-pager" textfont="{{{FontMain}}}" textsize="5" textemboss="1" textcolor="{{{Colors::C_Color_White}}}" textprefix="$t" />
<style class="turbo2-text-button" textfont="{{{FontMainSmall2}}}" textsize="2" textcolor="{{{Colors::C_Color_White}}}" textprefix="$t" />
<style class="turbo2-text-gauge" textfont="{{{FontMainSmall2}}}" textsize="2" textcolor="{{{Colors::C_Color_Black}}}" />
<style class="turbo2-text-popup" textfont="{{{FontMainSmall2}}}" textsize="2" textcolor="{{{Colors::C_Color_White}}}" />
<style class="turbo2-text-menu" textfont="{{{FontMain}}}" textsize="2" textcolor="{{{Colors::C_Color_White}}}" textprefix="$t" />
<style class="turbo2-text-progress-description" textfont="{{{FontMainSmall2}}}" textsize="2" textprefix="$t" />
<style class="turbo2-text-progress-step" textfont="{{{FontMain}}}" textsize="2" textprefix="$t" />
<style class="turbo2-text-laps" textfont="{{{FontMain}}}" textsize="12" textcolor="{{{Colors::C_Color_White}}}" />
<style class="turbo2-text-cutpaste-more" textfont="{{{FontMainSmall}}}" textsize="3" textcolor="{{{Colors::C_Color_White}}}" />
<style class="turbo2-text-cutpaste" textfont="{{{FontMainSmall}}}" textsize="2" textcolor="{{{Colors::C_Color_White}}}" />
<style class="turbo2-text-validation" textfont="{{{FontMainSmall}}}" textsize="2" textcolor="{{{Colors::C_Color_White}}}" />
<style class="turbo2-text-pad-title" textfont="{{{FontMain}}}" textsize="11" textcolor="{{{Colors::C_Color_White}}}" textprefix="$t" />
<style class="turbo2-text-pad-message" textfont="{{{FontMain}}}" textsize="5" textcolor="{{{Colors::C_Color_Yellow}}}" textprefix="$t" />

<style class="turbo2-macroblock-disabled" bgcolor="{{{Colors::C_Color_Black}}}" opacity="0.7" />
<style class="turbo2-background-text" bgcolor="{{{Colors::C_Color_Black}}}" opacity="0.5" />
<style class="turbo2-selector" image="{{{SelectorImage}}}" />
<style class="turbo2-selector-wide" image="{{{SelectorWideImage}}}" />
<style class="turbo2-screen-overlay" size="320 180" halign="center" valign="center" image="{{{ScreenOverlay}}}" />
<style class="turbo2-screen-validation" size="320 180" halign="center" valign="center" image="{{{ScreenValidation}}}" />
""";
}

/// Get the circle size constants
Real CircleSize_Top()		{ return C_CircleSize_Top; }
Real CircleSize_Bottom()	{ return C_CircleSize_Bottom; }

/// Get the margin constants
Real Margin_Top()	{
	return C_Margin_Top; 
}

Real Margin_Bottom()	{ return C_Margin_Bottom; }

//  Remove the Z component of a Vec3 variable
Vec2 Vec3ToVec2(Vec3 _Input) {
	return <_Input.X, _Input.Y>;
}

//  Get the default header size
Real GetHeaderSize2() {
	return C_HeaderSize*1.;
}

Vec3 GetPosition2(
	Vec3 _Position,
	Real _CircleSize
) {
	declare CircleSize = Private_GetCircleSize2() * _CircleSize;
	return <
		_Position.X * CircleSize.X,
		_Position.Y * CircleSize.Y,
		_Position.Z
	>;
}

// Build a manialink pos and z-index properties
Text BuildPosition2(Vec3 _Position) {
	return "pos=\""^_Position.X^" "^_Position.Y^"\" z-index=\""^_Position.Z^"\"";
}

Vec2 GetSize2(Vec2 _Size, Real _CircleSize) {
	declare CircleSize = Private_GetCircleSize2() * _CircleSize;
	return <
		_Size.X * CircleSize.X,
		_Size.Y * CircleSize.Y
	>;
}

Text BuildSize2(Vec2 _Size) {
	return "size=\""^_Size.X^" "^_Size.Y^"\"";
}

/// Get the alignements constants
Integer Align_LeftTop()			{ return C_Align_LeftTop; }
Integer Align_LeftCenter()		{ return C_Align_LeftCenter; }
Integer Align_LeftCenter2()		{ return C_Align_LeftCenter2; }
Integer Align_LeftBottom()		{ return C_Align_LeftBottom; }
Integer Align_CenterTop()		{ return C_Align_CenterTop; }
Integer Align_CenterCenter()	{ return C_Align_CenterCenter; }
Integer Align_CenterCenter2()	{ return C_Align_CenterCenter2; }
Integer Align_CenterBottom()	{ return C_Align_CenterBottom; }
Integer Align_RightTop()		{ return C_Align_RightTop; }
Integer Align_RightCenter()		{ return C_Align_RightCenter; }
Integer Align_RightCenter2()	{ return C_Align_RightCenter2; }
Integer Align_RightBottom()		{ return C_Align_RightBottom; }

Text GetHAlign(Integer _Align) {
	switch(_Align) {
		case C_Align_LeftTop: return "left";
		case C_Align_LeftCenter: return "left";
		case C_Align_LeftCenter2: return "left";
		case C_Align_LeftBottom: return "left";
		case C_Align_CenterTop: return "center";
		case C_Align_CenterCenter: return "center";
		case C_Align_CenterCenter2: return "center";
		case C_Align_CenterBottom: return "center";
		case C_Align_RightTop: return "right";
		case C_Align_RightCenter: return "right";
		case C_Align_RightCenter2: return "right";
		case C_Align_RightBottom: return "right";
	}
	return "top";
}

Text GetVAlign(Integer _Align) {
	switch(_Align) {
		case C_Align_LeftTop: return "top";
		case C_Align_LeftCenter: return "center";
		case C_Align_LeftCenter2: return "center2";
		case C_Align_LeftBottom: return "bottom";
		case C_Align_CenterTop: return "top";
		case C_Align_CenterCenter: return "center";
		case C_Align_CenterCenter2: return "center2";
		case C_Align_CenterBottom: return "bottom";
		case C_Align_RightTop: return "top";
		case C_Align_RightCenter: return "center";
		case C_Align_RightCenter2: return "center2";
		case C_Align_RightBottom: return "bottom";
	}
	return "left";
}

Text BuildAlign(Integer _Align) {
	declare HAlign = "";
	declare VAlign = "";
	
	switch(_Align) {
		case C_Align_LeftTop: {
			HAlign = "left";
			VAlign = "top";
		}
		case C_Align_LeftCenter: {
			HAlign = "left";
			VAlign = "center";
		}
		case C_Align_LeftCenter2: {
			HAlign = "left";
			VAlign = "center2";
		}
		case C_Align_LeftBottom: {
			HAlign = "left";
			VAlign = "bottom";
		}
		case C_Align_CenterTop: {
			HAlign = "center";
			VAlign = "top";
		}
		case C_Align_CenterCenter: {
			HAlign = "center";
			VAlign = "center";
		}
		case C_Align_CenterCenter2: {
			HAlign = "center";
			VAlign = "center2";
		}
		case C_Align_CenterBottom: {
			HAlign = "center";
			VAlign = "bottom";
		}
		case C_Align_RightTop: {
			HAlign = "right";
			VAlign = "top";
		}
		case C_Align_RightCenter: {
			HAlign = "right";
			VAlign = "center";
		}
		case C_Align_RightCenter2: {
			HAlign = "right";
			VAlign = "center2";
		}
		case C_Align_RightBottom: {
			HAlign = "right";
			VAlign = "bottom";
		}
	}
	
	return "halign=\""^HAlign^"\" valign=\""^VAlign^"\"";
}

// Build a background manialink
Text BuildBackground(Vec3 _Position, Vec2 _Size, Real _CircleSize, Integer _Align) {
	declare DefaultImage = "file://Media/Manialinks/Nadeo/TMConsole/MapEditor/Images/Menu/menu-bg-1.dds";
	
	declare CircleSize = Private_GetCircleSize2() * _CircleSize;
	
	declare SizeX = _Size.X * CircleSize.X;
	declare FullNbX = ML::FloorInteger(_Size.X) / C_DefaultCirclesNb;
	declare FullSizeX = C_DefaultCirclesNb * CircleSize.X;
	declare PartialNbX = _Size.X - FullNbX;
	declare NbX = FullNbX;
	if (PartialNbX > 0.) NbX += 1;
	
	declare SizeY = _Size.Y * CircleSize.Y;
	declare FullNbY = ML::FloorInteger(_Size.Y);
	declare FullSizeY = CircleSize.Y;
	declare PartialNbY = _Size.Y - FullNbY;
	declare NbY = FullNbY;
	if (PartialNbY > 0.) NbY += 1;
	
	declare Position = GetPosition2(_Position, _CircleSize);
	if (Private_IsHorizontalCenterAlign(_Align)) {
		Position.X -= SizeX * 0.5;
	} else if (Private_IsHorizontalRightAlign(_Align)) {
		Position.X -= SizeX;
	}
	if (Private_IsVerticalCenterAlign(_Align)) {
		Position.Y += SizeY * 0.5;
	} else if (Private_IsVerticalBottomAlign(_Align)) {
		Position.Y += SizeY;
	}
	
	declare Background = "";
	for (Y, 0, NbY-1) {
		declare PosY = Y * -CircleSize.Y;
		for (X, 0, NbX-1) {
			declare PosX = X * FullSizeX;
			Background ^= """<quad pos="{{{PosX}}} {{{PosY}}}" size="{{{FullSizeX}}} {{{FullSizeY}}}" image="{{{DefaultImage}}}" />""";
		}
	}
	
	return """
<frame {{{BuildPosition2(Position)}}} {{{BuildSize2(<SizeX, SizeY>)}}}>
	{{{Background}}}
</frame>""";
}

//  Build a line manialink
Text BuildLine(
	Vec3 _Position,
	Vec2 _Size,
	Real _CircleSize,
	Integer _Align,
	Text _Color,
	Boolean _Background,
	Boolean _Foreground,
	Text[Text] _Custom
) {
	declare TopMargin = Private_GetTopMargin() * _CircleSize;
	
	// Compute quad size and position
	declare FullPosition = GetPosition2(_Position, _CircleSize);
	declare FullSize = GetSize2(_Size, _CircleSize);
	declare QuadPosition = FullPosition;
	declare QuadSize = FullSize;
	
	// Apply margins
	QuadPosition.Y -= TopMargin;
	QuadSize.Y -= TopMargin;
	
	if (Private_IsVerticalCenterAlign(_Align)) {
		QuadPosition.Y += TopMargin * 0.5;
	} else if (Private_IsVerticalBottomAlign(_Align)) {
		QuadPosition.Y += TopMargin;
	}
	
	// Background image
	declare BackgroundImage = "";
	declare BackgroundColor = "";
	if (_Background) {
		BackgroundImage = "image=\""^C_DefaultBackgroundImage^"\"";
		BackgroundColor = "colorize=\""^_Color^"\"";
	} else {
		BackgroundColor = "bgcolor=\""^_Color^"\"";
	}
	
	// Build custom params
	declare Params = "";
	foreach (Param => Value in _Custom) {
		Params ^= TL::MLEncode(Param)^"=\""^TL::MLEncode(Value)^"\"";
	}
		
	return """
<quad {{{BuildPosition2(QuadPosition)}}} {{{BuildSize2(QuadSize)}}} {{{BuildAlign(_Align)}}} {{{BackgroundImage}}} {{{BackgroundColor}}} {{{Params}}} />
""";
}

//  Build a quad manialink
Text BuildQuad(
	Vec3 _Position,
	Vec2 _Size,
	Real _CircleSize,
	Integer _Align,
	Text[Text] _Custom
) {
	declare TopMargin = Private_GetTopMargin() * _CircleSize;
	
	// Compute quad size and position
	declare QuadPosition = GetPosition2(_Position, _CircleSize);
	declare QuadSize = GetSize2(_Size, _CircleSize);
	
	// Apply margins
	QuadPosition.Y -= TopMargin;
	QuadSize.Y -= TopMargin;
	
	// Apply alignement
	if (Private_IsVerticalCenterAlign(_Align)) {
		QuadPosition.Y += TopMargin * 0.5;
	} else if (Private_IsVerticalBottomAlign(_Align)) {
		QuadPosition.Y += TopMargin;
	}
	
	// Build custom params
	declare Params = "";
	foreach (Param => Value in _Custom) {
		Params ^= TL::MLEncode(Param)^"=\""^TL::MLEncode(Value)^"\"";
	}
		
	return """<quad {{{BuildPosition2(QuadPosition)}}} {{{BuildSize2(QuadSize)}}} {{{BuildAlign(_Align)}}} {{{Params}}} />""";
}

Text BuildUnderline (
	Vec3 _Position,
	Real _SizeX,
	Real _CircleSize) {
		declare Text Upperline;
		declare Text Underline;
		Upperline = BuildQuad(<_Position.X+0.35, _Position.Y-0.5, 2.>, <_SizeX+0.75, 0.25>, _CircleSize, C_Align_RightTop, ["bgcolor" => Colors::C_Color_White, "opacity" => ".65"]);
		Underline = BuildQuad(<_Position.X+0.35, _Position.Y-(0.5+(0.25/2.)), 2.>, <(_SizeX/10.), 0.25>, _CircleSize, C_Align_RightTop, ["bgcolor" => Colors::C_Color_White, "opacity" => ".65"]);
	return """  
		{{{Upperline}}}
		{{{Underline}}}
	""";
}
// ---------------------------------- //
Text BuildButton(
	Text _ActionName,
	Vec3 _Position,
	Vec2 _Size,
	Real _CircleSize,
	Integer _Align,
	Text[Text] _Custom
) {
	declare TopMargin = Private_GetTopMargin() * _CircleSize;
	
	// Compute quad size and position
	declare QuadPosition = GetPosition2(_Position, _CircleSize);
	declare QuadSize = GetSize2(_Size, _CircleSize);
	
	// Apply margins
	QuadPosition.Y -= TopMargin;
	QuadSize.Y -= TopMargin;
	
	// Apply alignement
	if (Private_IsVerticalCenterAlign(_Align)) {
		QuadPosition.Y += TopMargin * 0.5;
	} else if (Private_IsVerticalBottomAlign(_Align)) {
		QuadPosition.Y += TopMargin;
	}
	
	declare Params = _Custom;
	Params["pos"] = QuadPosition.X^" "^QuadPosition.Y;
	Params["z-index"] = TL::ToText(QuadPosition.Z);
	Params["size"] = QuadSize.X^" "^QuadSize.Y;
	Params["halign"] = GetHAlign(_Align);
	Params["valign"] = GetVAlign(_Align);
	return Buttons2::ML_Button(_ActionName, Params);
}

//Build a label manialink
Text BuildLabel(
	Vec3 _Position,
	Vec2 _Size,
	Real _CircleSize,
	Integer _Align,
	Text[Text] _Custom
) {
	declare TopMargin = Private_GetTopMargin() * _CircleSize;
	declare SideMargin = Private_GetSideMargin() * _CircleSize;
	declare TextPadding = Private_GetTextPadding() * _CircleSize;
	declare Text AdditionnalQuad;
	
	// Compute label size and position
	declare FullPosition = GetPosition2(_Position, _CircleSize);
	declare FullSize = GetSize2(_Size, _CircleSize);
	declare LabelPosition = FullPosition;
	declare LabelSize = FullSize;
	
	// Apply margins and padding
	LabelPosition.X += SideMargin + TextPadding;
	LabelPosition.Y -= TopMargin + TextPadding;
	LabelSize.X -= 2 * (SideMargin + TextPadding);
	LabelSize.Y -= TopMargin + (2 * TextPadding);
	
	// Apply alignement
	if (Private_IsHorizontalCenterAlign(_Align)) {
		LabelPosition.X -= (SideMargin + TextPadding);
	} else if (Private_IsHorizontalRightAlign(_Align)) {
		LabelPosition.X -= 2 * (SideMargin + TextPadding);
	}
	if (Private_IsVerticalCenterAlign(_Align)) {
		LabelPosition.Y += TopMargin * 0.5 + TextPadding;
	} else if (Private_IsVerticalBottomAlign(_Align)) {
		LabelPosition.Y += TopMargin + (2 * TextPadding);
	}
	
	// Build custom params
	declare Params = "";
	foreach (Param => Value in _Custom) {
		Params ^= TL::MLEncode(Param)^"=\""^TL::MLEncode(Value)^"\"";
	}
		
	return """
<label {{{BuildPosition2(LabelPosition)}}} {{{BuildSize2(LabelSize)}}} {{{BuildAlign(_Align)}}} {{{Params}}} />
{{{AdditionnalQuad}}}
""";
}

// This will create a quad that can adapt to the size of the label and (optional) button inside, and will then
// add an image to the left and/or right of said quad.
// HOWEVER, I cannot compute the label width until it actually exists, so this will need a second pass to 
// resize & organize everything 
Text BuildSmartQuad(
	Vec3 _Position,		// Where to position the quad. 
	Real _Height,			// SizeY for quad. SizeX will be automatic depending on LabelText.
	Real _TextPosY,		// to center the text properly
	Text _LabelText,	// What is shown in the label
	Text _ImageLeft,	// leave empty for no image left
	Text _ImageRight, // leave empty for no image right
	Text _ActionName, // See BuildButton. Leave empty for no button indicator
	Boolean _Clickable, // whether you have mouseover/clicks or not. Can be clickable without action button and vice versa.
	Text _TextClass,	// Style from StyleSheet
	Text _BgColor,		// will be used to colorize imageleft/right + main quad
	Text _FrameId		// Used to find the frame back in ML
) {
	declare MLEHoverParams = ""; // Used to make Quad / Images hoverable, if necessary.
	if (_Clickable)
		MLEHoverParams = """scriptevents="1" {{{MLE::Data_Triggers()}}}="{{{_FrameId}}}" {{{MLE::Data_Effects()}}}="{{{_FrameId}}}:{{{MLE::Effect_QuadHover()}}}" class="{{{MLE::ML_Class()}}}" """;
	
	// MAIN FRAME
	declare FramePos = BuildPosition2(_Position);
	declare SmartQuad = """<frame {{{FramePos}}} id="{{{_FrameId}}}" class="MainFrame_SmartQuad">"""; 
	
	// LABEL
	declare LabelPos = BuildPosition2(<-13., _TextPosY, 2.>); // X is arbitrary, will be updated in SetupSmartQuad anyways
	declare LabelSize = BuildSize2(<320., _Height>); // arbitrary to make sure ComputeWidth is never limited
	SmartQuad ^= """<label {{{LabelPos}}} {{{LabelSize}}} valign="center2" id="Label_SmartQuad" class="{{{_TextClass}}}" text="{{{_LabelText}}}" />""";
	
	// BUTTON
	// Pos X doesn't really matter, it will be set later. Set to 19 for debug reasons. Y is centered. Z is used.
	declare ButtonWidth = ML::Min(5., _Height * 0.85); // try not using huge buttons, they're not made for high res anyways. May need to be adapted.
	SmartQuad ^= """{{{Buttons2::ML_Button(_ActionName, ["pos" => "-19 0.05", "z-index" => "2.", "size" => ButtonWidth^" "^ButtonWidth, "id" => "Button_SmartQuad", "halign" => "left"])}}}""";
	
	// QUAD BG
	declare QuadSize = BuildSize2(<20., _Height>); // X is arbitrary for debug reasons, it'll be set in Setup later. 
	SmartQuad ^= """<quad z-index="1" {{{QuadSize}}} bgcolor="{{{_BgColor}}}" opacity="0.6" id="Quad_SmartQuad" halign="center" valign="center2" {{{MLEHoverParams}}} />""";
	
	// IMAGE L&R
	// Since i'm using KeepRatio, I'm not too sure of how this works regarding X and Y... sometimes one works, sometimes not...
	declare ImageSizeLeft = BuildSize2(<0., 0.>);
	declare ImageSizeRight = BuildSize2(<0., 0.>);
	declare PosLeft = BuildPosition2(<-10., 0., 0.>);
	declare PosRight = BuildPosition2(<10., 0., 0.>);
	declare ImageLinkLeft = "";
	if (_ImageLeft != "") {
		ImageLinkLeft = "file://Media/Manialinks/Nadeo/TMConsole/MapEditor/Images/Menu/"^_ImageLeft;
		ImageSizeLeft = BuildSize2(<_Height, _Height>);
	}
	declare ImageLinkRight = "";
	if (_ImageRight != "") {
		ImageLinkRight = "file://Media/Manialinks/Nadeo/TMConsole/MapEditor/Images/Menu/"^_ImageRight;
		ImageSizeRight = BuildSize2(<_Height, _Height>);
	}
	
	// image left
	SmartQuad ^= """<quad {{{PosLeft}}} {{{ImageSizeLeft}}} image="{{{ImageLinkLeft}}}" id="ImageLeft_SmartQuad" colorize="{{{_BgColor}}}" opacity="0.6" halign="right" valign="center2" {{{MLEHoverParams}}} keepratio="fit"/> """;
	
	SmartQuad ^= """<quad {{{PosRight}}} {{{ImageSizeRight}}} image="{{{ImageLinkRight}}}" id="ImageRight_SmartQuad" colorize="{{{_BgColor}}}" opacity="0.6" halign="left" valign="center2"{{{MLEHoverParams}}} keepratio="fit" /> """;
	
	SmartQuad ^= """</frame>""";
	
	return SmartQuad;
}

Void SetupSmartQuad(CMlFrame _Frame, CMlControl::AlignHorizontal _HAlign, Real _QuadMinSize, Real _QuadMaxSize) {
	if(_Frame == Null || !_Frame.HasClass("MainFrame_SmartQuad"))
		return;
		
	declare Label_SmartQuad <=> (_Frame.GetFirstChild("Label_SmartQuad") as CMlLabel);
	declare Button_SmartQuad <=> (_Frame.GetFirstChild("Button_SmartQuad") as CMlFrame);
	declare Quad_SmartQuad <=> (_Frame.GetFirstChild("Quad_SmartQuad") as CMlQuad);
	declare ImageLeft_SmartQuad <=> (_Frame.GetFirstChild("ImageLeft_SmartQuad") as CMlQuad);
	declare ImageRight_SmartQuad <=> (_Frame.GetFirstChild("ImageRight_SmartQuad") as CMlQuad);
	
	declare LabelLength = Label_SmartQuad.ComputeWidth(Label_SmartQuad.Value);
	declare ButtonLength = 0.;
	
	if (Button_SmartQuad.DataAttributeGet(Buttons2::C_DataActionName) != "") {
		declare Quad_ButtonBackground <=> (Button_SmartQuad.GetFirstChild("Quad_ButtonBackground") as CMlQuad);
		ButtonLength = Quad_ButtonBackground.Size.X;
	}
	
	declare Margin1 = C_SmartQuad_Margin_EdgeToButton;
	declare Margin2 = C_SmartQuad_Margin_ButtonToText;
	declare Margin3 = C_SmartQuad_Margin_TextToEdge;
	
	if (((_HAlign == CMlControl::AlignHorizontal::Left || _HAlign == CMlControl::AlignHorizontal::None) && ImageRight_SmartQuad.ImageUrl != "")
			|| (_HAlign == CMlControl::AlignHorizontal::Right && ImageLeft_SmartQuad.ImageUrl != "")) 
	{
		Margin3 = C_SmartQuad_Margin_TextToEdge_NoImg; // move text closer to edge if there's an image
	}
	
	// Avoid label being too big
	declare LabelSizeX = _QuadMaxSize - (Margin1 + ButtonLength + Margin2 + Margin3);
	Label_SmartQuad.Size.X = ML::Max(0., LabelSizeX); // avoid annoying "negative size" assert/alert
	LabelLength = ML::Min(LabelLength, Label_SmartQuad.Size.X); // tbh this should be handled by ComputeWidth, but in the meantime...
	
	declare ContentLength = Margin1 + ButtonLength + Margin2 + LabelLength + Margin3;
	declare QuadLength = ML::Max(_QuadMinSize, ContentLength);
	QuadLength = ML::Min(QuadLength, _QuadMaxSize);
	
	Quad_SmartQuad.Size.X = QuadLength;
	
	if (_HAlign == CMlControl::AlignHorizontal::Left || _HAlign == CMlControl::AlignHorizontal::None) {
		Label_SmartQuad.HorizontalAlign = CMlControl::AlignHorizontal::Left;
		Quad_SmartQuad.HorizontalAlign = CMlControl::AlignHorizontal::Left;
		ImageLeft_SmartQuad.HorizontalAlign = CMlControl::AlignHorizontal::Left;
		ImageRight_SmartQuad.HorizontalAlign = CMlControl::AlignHorizontal::Left;
		
		Button_SmartQuad.RelativePosition_V3.X = Margin1;
		Label_SmartQuad.RelativePosition_V3.X = Margin1 + ButtonLength + Margin2;
		ImageLeft_SmartQuad.RelativePosition_V3.X = -ImageLeft_SmartQuad.Size.X;
		ImageRight_SmartQuad.RelativePosition_V3.X = QuadLength;
	}	else if (_HAlign == CMlControl::AlignHorizontal::HCenter) {
		Label_SmartQuad.HorizontalAlign = CMlControl::AlignHorizontal::Left;
		Quad_SmartQuad.HorizontalAlign = CMlControl::AlignHorizontal::HCenter;
		ImageLeft_SmartQuad.HorizontalAlign = CMlControl::AlignHorizontal::Right;
		ImageRight_SmartQuad.HorizontalAlign = CMlControl::AlignHorizontal::Left;
		
		Button_SmartQuad.RelativePosition_V3.X = -(ButtonLength + Margin2 + LabelLength) * 0.5;
		if (ButtonLength != 0)
			Label_SmartQuad.RelativePosition_V3.X = Button_SmartQuad.RelativePosition_V3.X + ButtonLength + Margin2;
		else
			Label_SmartQuad.RelativePosition_V3.X = -LabelLength*0.5;
			
		ImageLeft_SmartQuad.RelativePosition_V3.X = -QuadLength * 0.5;
		ImageRight_SmartQuad.RelativePosition_V3.X = QuadLength * 0.5;

	} else if (_HAlign == CMlControl::AlignHorizontal::Right) {
		Label_SmartQuad.HorizontalAlign = CMlControl::AlignHorizontal::Right;
		//Button_SmartQuad.HorizontalAlign = CMlControl::AlignHorizontal::Right; // this doesn't work; it's a frame, doesn't align quad inside. It's Left.
		Quad_SmartQuad.HorizontalAlign = CMlControl::AlignHorizontal::Right;
		ImageLeft_SmartQuad.HorizontalAlign = CMlControl::AlignHorizontal::Right;
		ImageRight_SmartQuad.HorizontalAlign = CMlControl::AlignHorizontal::Right;
		
		Button_SmartQuad.RelativePosition_V3.X = - (Margin1 + ButtonLength);
		Label_SmartQuad.RelativePosition_V3.X = -(Margin1 + ButtonLength + Margin2);
		ImageLeft_SmartQuad.RelativePosition_V3.X = -QuadLength;
		ImageRight_SmartQuad.RelativePosition_V3.X = ImageRight_SmartQuad.Size.X;
	}	
}

Void SetupSmartQuad(CMlFrame _Frame, CMlControl::AlignHorizontal _HAlign, Real _QuadMinSize) {
	SetupSmartQuad(_Frame, _HAlign, 0., 320.);
	
}
Void SetupSmartQuad(CMlFrame _Frame, CMlControl::AlignHorizontal _HAlign) {
	SetupSmartQuad(_Frame, _HAlign, 0.);
}

Void SetupSmartQuads(CMlFrame[] _Frames, CMlControl::AlignHorizontal _HAlign, Real _QuadMinSize) {
	foreach(Frame in _Frames){
		SetupSmartQuad(Frame, _HAlign, _QuadMinSize);
	}
}

Real GetSmartQuadTotalLength(CMlFrame _Frame) {
	if(_Frame == Null || !_Frame.HasClass("MainFrame_SmartQuad"))
		return 0.;
		
	declare Quad_SmartQuad <=> (_Frame.GetFirstChild("Quad_SmartQuad") as CMlQuad);
	declare ImageLeft_SmartQuad <=> (_Frame.GetFirstChild("ImageLeft_SmartQuad") as CMlQuad);
	declare ImageRight_SmartQuad <=> (_Frame.GetFirstChild("ImageRight_SmartQuad") as CMlQuad);
	
	declare QuadLength = Quad_SmartQuad.Size.X;
	declare ExtraImagesLength = 0.;
	
	if (ImageLeft_SmartQuad.ImageUrl != "")
		ExtraImagesLength += ImageLeft_SmartQuad.Size.X;
		
	if (ImageRight_SmartQuad.ImageUrl != "")
		ExtraImagesLength += ImageRight_SmartQuad.Size.X;
	
	declare TotalLength = QuadLength + ExtraImagesLength;
	return TotalLength;
}

// Example: for frames aligned like this, with possibly frames missing, ------ [Frame1] | [Frame2] | [Frame3]
// input [Frame3, Frame2, Frame1]
Void SetupAndAlignButtonsRightToLeft(CMlFrame[] _SmartQuads, Real _MinSize, Real _MaxSize) {
	if (_SmartQuads.count == 0) return;
	
	// first, initialise each smartquad
	foreach (SmartQuad in _SmartQuads) {
		SetupSmartQuad(SmartQuad, CMlControl::AlignHorizontal::Right, _MinSize, _MaxSize);
	}
	
	// This is where we'll align the first visible quad of the bunch
	declare Real RightmostSmartQuadPosX = _SmartQuads[0].RelativePosition_V3.X;
	
	// Every time a smartquad is visible, we'll add its size & a margin to NextSmartQuadPosX
	declare Real NextSmartQuadPosX = RightmostSmartQuadPosX;
	declare Real Margin = 0.5;
	
	foreach (Key => SmartQuad in _SmartQuads) {
		if (!SmartQuad.Visible) continue;
		
		SmartQuad.RelativePosition_V3.X = NextSmartQuadPosX;
		NextSmartQuadPosX -= GetSmartQuadTotalLength(SmartQuad);
		NextSmartQuadPosX -= Margin;
	}
}