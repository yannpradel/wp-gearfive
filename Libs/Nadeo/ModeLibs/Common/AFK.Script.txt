/**
 *	Library to manage Passive AFK players
 */
#Const Version		"2023-03-27"
#Const ScriptName	"Libs/Nadeo/ModeLibs/Common/AFK.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "TextLib" as TL
#Include "Libs/Nadeo/ModeLibs/Legacy/Utils.Script.txt" as Utils
#Include "Libs/Nadeo/CommonLibs/Common/Semver.Script.txt" as Semver
#Include "Libs/Nadeo/ModeLibs/Legacy/XmlRpc2.Script.txt" as XmlRpc


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Structures
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //

#Struct K_XmlRpc_AFK_Players {
	Text[] accountIds;
}

#Struct K_XmlRpc_AFK_Properties {
	Text responseid;
	Integer idletimelimit;
	Integer spawntimelimit;
	Integer checkpointtimelimit;
	Integer checkinterval;
	Boolean forcespec;
	Boolean kick;
	Boolean checkCP;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_IdleTimeLimit	30000 ///< after 30s of inactivity, a player is considered AFK
#Const C_SpawnTimeLimit 5000 ///< A player cannot be considered AFK during 5 s. after spawning
#Const C_CheckpointTimeLimit 15000 ///< A player cannot be considered AFK if they have passed a CP in the last 15s
#Const C_CheckInterval	10000	///< Time interval between automatic AFK players check
#Const C_ForceSpec			False	///< Force the player on spectator when AFK
#Const C_Kick					True	///< Kick the player from the server when AFK
#Const C_CheckCP	True	///< Check CP times of the players to determine if they are AFK
#Const C_IdleThreshold	2000	///< Minimum idle time to avoid false positive
// XmlRpc
#Const C_Callback_AFKPlayers "AFK.IsAFK"
#Const C_Callback_AFKProperties "AFK.Properties"
#Const C_Method_GetAFKProperties "AFK.GetProperties"
#Const C_Method_SetAFKProperties "AFK.SetProperties"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Globales
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
declare Integer G_IdleTimeLimit;
declare Integer G_SpawnTimeLimit;
declare Integer G_CheckpointTimeLimit;
declare Integer G_CheckInterval;
declare Integer G_NextCheck;
declare Boolean G_ForceSpec;
declare Boolean G_Kick;
declare Boolean G_CheckCP;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Public
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Check if a player is AFK
 *
 *	@param	_Player										The player to check
 *	@param	_MaxIdleDuration					Time of inactivity to be considered AFK
 *	@param	_SpawnTimeMercy						Time after spawning during which one can not be considered AFK
 */
Boolean IsAFK(CSmPlayer _Player, Integer _MaxIdleDuration, Integer _SpawnTimeMercy, Integer _CheckpointTimeMercy) {
	if (_Player == Null) return False;
	if (_Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) return False;
	// not for bots
	if (_Player.IsBot) return False;
	declare UI <=> UIManager.GetUI(_Player);
	if (UI.UISequence != CUIConfig::EUISequence::Playing && UI.UISequence != CUIConfig::EUISequence::None) return False;
	if (UI.ForceSpectator) return False;
	if (Now - _Player.StartTime < _SpawnTimeMercy) return False;
	// Check if player pass at least 1 CP in the race
	if (G_CheckCP && _Player.RaceWaypointTimes.count > 0 && _Player.RaceWaypointTimes[_Player.RaceWaypointTimes.count - 1] + _CheckpointTimeMercy > _Player.CurrentRaceTime) return False;
	return (_Player.IdleDuration > C_IdleThreshold && _Player.IdleDuration > _MaxIdleDuration);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/**	Try to force AFK players to spectators or kick them from server
 * 
 *	@param	_MaxIdleDuration					In milliSec., time of inactivity to be considered AFK
 *	@param	_SpawnTimeMercy						In milliSec., time after spawning during which one can not be considered AFK
 */
Void ManageAFKPlayers(Integer _MaxIdleDuration, Integer _SpawnTimeMercy, Integer _CheckpointTimeMercy) {
	declare netwrite Text[] Net_ModeLibsAFK_AFKPlayerAccountIds for Teams[0] = [];

	Net_ModeLibsAFK_AFKPlayerAccountIds.clear();
	foreach (Player in Players) {
		if (IsAFK(Player, _MaxIdleDuration, _SpawnTimeMercy, _CheckpointTimeMercy)) {
			if (!Player.IsBot) {
				Net_ModeLibsAFK_AFKPlayerAccountIds.add(Player.User.WebServicesUserId);
				if (ServerAdmin != Null) {
					if (G_ForceSpec) ServerAdmin.ForceSpectator(Player.User, CServerAdmin::ESpecMode::SpectatorForced);
					//L16N [AFK] Reason given to players when they are kicked from the server for being AFK
					if (G_Kick) ServerAdmin.Kick(Player.User, _("You were AFK"));
				}
			}
		}
	}
	
	if (Net_ModeLibsAFK_AFKPlayerAccountIds.count > 0 && Semver::Compare(XmlRpc::GetApiVersion(), ">=", "3.5.0")) {
		declare XmlRpcAFKPlayers = K_XmlRpc_AFK_Players {
			accountIds = Net_ModeLibsAFK_AFKPlayerAccountIds
		};		
		XmlRpc::SendCallback(C_Callback_AFKPlayers, [XmlRpcAFKPlayers.tojson()]);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Try to force AFK players to spectators or kick them from server
Void ManageAFKPlayers() {
	ManageAFKPlayers(G_IdleTimeLimit, G_SpawnTimeLimit, G_CheckpointTimeLimit);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Update the idle time limit
 *
 *	@param	_Time											The new idle time limit
 */
Void SetIdleTimeLimit(Integer _Time) {
	G_IdleTimeLimit = _Time;
	if (G_IdleTimeLimit < 0) G_IdleTimeLimit = 0;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the current idle time limit
 *
 *	@return														The idle time limit
 */
Integer GetIdleTimeLimit() {
	return G_IdleTimeLimit;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Update the spawn mercy time
 *
 *	@param	_Time		The new spawn mercy time
 */
Void SetSpawnTimeLimit(Integer _Time) {
	G_SpawnTimeLimit = _Time;
	if (G_SpawnTimeLimit < 0) G_SpawnTimeLimit = 0;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Update the checkpoint mercy time
 *
 *	@param	_Time		The new checkpoint mercy time
 */
Void SetCheckpointTimeLimit(Integer _Time) {
	G_CheckpointTimeLimit = _Time;
	if (G_CheckpointTimeLimit < 0) G_CheckpointTimeLimit = 0;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Update the check time interval
 *
 *	@param	_Interval									The new time interval
 */
Void SetCheckInterval(Integer _Interval) {
	G_CheckInterval = _Interval;
	if (G_CheckInterval < 0) G_CheckInterval = 0;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Update the force spec value
 *
 *	@param	_ForceSpec									The new force spec value
 */
Void SetForceSpec(Boolean _ForceSpec) {
	G_ForceSpec = _ForceSpec;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Update the kick value
 *
 *	@param	_ForceKick									The new kick value
 */
Void SetKick(Boolean _ForceKick) {
	G_Kick = _ForceKick;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Update the CheckCP value
 *
 *	@param	_CheckCP									The new CheckCP value
 */
Void SetCheckCP(Boolean _CheckCP) {
	G_CheckCP = _CheckCP;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Try to force AFK players to spectators
 *	This function can be piloted through XmlRpc
 */
Void AutoManageAFKPlayers() {
	if (G_NextCheck <= Now) {
		G_NextCheck = Now + G_CheckInterval;
		ManageAFKPlayers(G_IdleTimeLimit, G_SpawnTimeLimit, G_CheckpointTimeLimit);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the library
Void Yield() {
	// Manage AFK players
	AutoManageAFKPlayers();
	
	// Manage the XmlRpc events
	foreach (Event in XmlRpc.PendingEvents) {
		if (Event.Type == CXmlRpcEvent::EType::CallbackArray) {
			switch (Event.ParamArray1) {
				case C_Method_GetAFKProperties: {
					if (Semver::Compare(XmlRpc::GetApiVersion(), ">=", "3.5.0")) {
						declare ResponseId = "";
						if (Event.ParamArray2.existskey(0)) ResponseId = Event.ParamArray2[0];
						declare K_XmlRpc_AFK_Properties XmlRpcAFKProperties =	K_XmlRpc_AFK_Properties {
							responseid = ResponseId,
							idletimelimit = G_IdleTimeLimit,
							spawntimelimit = G_SpawnTimeLimit,
							checkpointtimelimit = G_CheckpointTimeLimit,
							checkinterval = G_CheckInterval,
							forcespec = G_ForceSpec,
							kick = G_Kick,
							checkCP = G_CheckCP
						};
						XmlRpc::SendCallback(C_Callback_AFKProperties, [XmlRpcAFKProperties.tojson()]);
					}
				}
				case C_Method_SetAFKProperties: {
					if (Semver::Compare(XmlRpc::GetApiVersion(), ">=", "3.5.0")) {
						if (Event.ParamArray2.existskey(0)) {
							declare IdleTimeLimit = TL::ToInteger(Event.ParamArray2[0]);
							SetIdleTimeLimit(IdleTimeLimit);
						}
						if (Event.ParamArray2.existskey(1)) {
							declare SpawnTimeLimit = TL::ToInteger(Event.ParamArray2[1]);
							SetSpawnTimeLimit(SpawnTimeLimit);
						}
						if (Event.ParamArray2.existskey(2)) {
							declare CheckpointTimeLimit = TL::ToInteger(Event.ParamArray2[2]);
							SetCheckpointTimeLimit(CheckpointTimeLimit);
						}
						if (Event.ParamArray2.existskey(3)) {
							declare CheckInterval = TL::ToInteger(Event.ParamArray2[3]);
							SetCheckInterval(CheckInterval);
						}
						if (Event.ParamArray2.existskey(4)) {
							declare ForceSpec = Utils::ToBoolean(Event.ParamArray2[4]);
							SetForceSpec(ForceSpec);
						}
						if (Event.ParamArray2.existskey(5)) {
							declare Kick = Utils::ToBoolean(Event.ParamArray2[5]);
							SetKick(Kick);
						}
						if (Event.ParamArray2.existskey(6)) {
							declare CheckCP = Utils::ToBoolean(Event.ParamArray2[6]);
							SetCheckCP(CheckCP);
						}
					}
				}
			}
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Unload the library
Void Unload() {
	// Unregister callbacks
	XmlRpc::UnregisterCallback(C_Callback_AFKPlayers);
	XmlRpc::UnregisterCallback(C_Callback_AFKProperties);
	// Unregister methods
	XmlRpc::UnregisterMethod(C_Method_GetAFKProperties);
	XmlRpc::UnregisterMethod(C_Method_SetAFKProperties);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Load the library
Void Load() {
	Unload();
	
	G_IdleTimeLimit = C_IdleTimeLimit;
	G_SpawnTimeLimit = C_SpawnTimeLimit;
	G_CheckpointTimeLimit = C_CheckpointTimeLimit;
	G_CheckInterval = C_CheckInterval;
	G_ForceSpec = C_ForceSpec;
	G_Kick = C_Kick;
	G_CheckCP = C_CheckCP;
	G_NextCheck = Now;
	
	// Register callbacks
	XmlRpc::RegisterCallback(C_Callback_AFKPlayers, """
* Name: {{{C_Callback_AFKPlayers}}}
* Type: CallbackArray
* Description: This callback is sent when the AFK library detects an AFK player, it will be sent at regular interval until the players are forced into spectator mode.
* Data:
	- Version >=3.5.0: 
	```
	[
		"{
			"accountIds": ["45b9cf1e-3c97-4753-ac63-ac61b48b4bb7", "6dde0f3e-ed3f-4216-97b0-ffed70601679"] //< AccountIds of the AFK players
		}"
	]
	```
""");
	XmlRpc::RegisterCallback(C_Callback_AFKProperties, """
* Name: {{{C_Callback_AFKProperties}}}
* Type: CallbackArray
* Description: AFK management library properties. Can be triggered with the "{{{C_Method_GetAFKProperties}}}" method.
* Data:
	- Version >=3.5.0: 
	```
	[
		"{
			"responseid": "xyz", //< Facultative id passed by a script event
			"idletimelimit": 90000, //< Time after which a player is considered to be AFK (ms)
			"spawntimelimit": 15000, //< Time after spawn before which a player can't be considered to be AFK (ms)
			"checkpointtimelimit": 60000, /// Time after passing a checkpoint which a player cannot be considered AFK (ms)
			"checkinterval": 10000, //< Time between each AFK check (ms)
			"forcespec": true //< Let the library force the AFK player into spectator mode
			"kick": false //< Let the library kick the AFK player from the server
			"checkCP" : false //< Tell the library to check CP times of the players to determine if they are AFK
		}"
	]
	```
""");
	// Register methods
	XmlRpc::RegisterMethod(C_Method_GetAFKProperties, """
* Name: {{{C_Method_GetAFKProperties}}}
* Type: TriggerModeScriptEventArray
* Description: Request the current properties of the AFK libraries.
* Data:
	- Version >=3.5.0: 
	```
	[
		"responseid" //< Facultative id that will be passed to the "{{{C_Callback_AFKProperties}}}" callback.
	]
	```
""");
	XmlRpc::RegisterMethod(C_Method_SetAFKProperties, """
* Name: {{{C_Method_SetAFKProperties}}}
* Type: TriggerModeScriptEventArray
* Description: Set the properties of the AFK library.
* Data:
	- Version >=3.5.0:
	```
	[
		"90000", //< IdleTimeLimit: Time after which a player is considered to be AFK (ms)
		"15000", //< SpawnTimeLimit: Time after spawn before which a player can't be considered to be AFK (ms)
		"60000", /// CheckpointTimeLimit: Time after passing a checkpoint which a player cannot be considered AFK (ms)
		"10000", //< CheckInterval: Time between each AFK check (ms)
		"True" //< ForceSpec: Let the library force the AFK player into spectator mode
		"False" //< Kick: Let the library kick the AFK player from the server
		"False" //< CheckCP: Tell the library to check CP times of the players to determine if they are AFK
	]
	```
""");
}