/**
 * UI modules client side
 */
#Const Version    "2021-10-14"
#Const ScriptName "Libs/Nadeo/ModeLibs/Common/UIModules_Client.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/ManiaView2.Script.txt" as MV
#Include "Libs/Nadeo/ModeLibs/Common/UIModules_Common.Script.txt" as UIModules_Common
#Include "ManiaApps/Nadeo/CommonLibs/Common/Layers.Script.txt" as Layers

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constant
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_Name "component-modelibs-uimodules" //< Component name
#Const P "ComponentModeLibsUIModules_" //< Prefix used to differentiate functions/variables in the script
#Const C_Class "component-modelibs-uimodules-module"

#Const C_SplitScreen_Disabled -2
#Const C_SplitScreen_Everyone -1 //< As much layers as there are players, 1 layer per screen
#Const C_SplitScreen_Common 0 //< One layer displayed one time on the whole screen
#Const C_SplitScreen_Player1 1
#Const C_SplitScreen_Player2 2
#Const C_SplitScreen_Player3 3
#Const C_SplitScreen_Player4 4

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Structures
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Struct K_Module {
	Text Id;
	Text Manialink;
	CUILayer::EUILayerType Type;
	Boolean SplitScreenEnable;
	Integer SplitScreenTarget;
	Text AttachId;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Globales
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
declare Text[] G_Modules_Loaded;
declare K_Module[Text] G_Modules;
declare Integer G_PrevModulesUpdate;
declare Boolean G_ForceModulesReload;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Private
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the id of the module layer
 *
 *	@param	_ModuleId									The module id
 *
 *	@return														The module layer id
 */
Text Private_GetLayerId(Text _ModuleId, Integer _SplitScreenTarget, Integer _ScreenNb) {
	declare Suffix = "";
	switch (_SplitScreenTarget) {
		case C_SplitScreen_Everyone: {
			Suffix = "_Everyone_Player"^_ScreenNb;
		}
		case C_SplitScreen_Common: {
			Suffix = "_Common";
		}
		case C_SplitScreen_Player1: {
			Suffix = "_Player1";
		}
		case C_SplitScreen_Player2: {
			Suffix = "_Player2";
		}
		case C_SplitScreen_Player3: {
			Suffix = "_Player3";
		}
		case C_SplitScreen_Player4: {
			Suffix = "_Player4";
		}
	}
	return "UIModules_"^_ModuleId^Suffix;
}
Text Private_GetLayerId(Text _ModuleId, Integer _SplitScreenTarget) {
	return Private_GetLayerId(_ModuleId, _SplitScreenTarget, 0);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Load a module
 *
 *  @param  _ModuleId                 The id of the module to load
 */
Void Private_LoadModule(Text _ModuleId) {
	if (
		G_Modules_Loaded.exists(_ModuleId) ||
		!G_Modules.existskey(_ModuleId)
	) return;

	declare Module = G_Modules[_ModuleId];

	if (Module.SplitScreenTarget == C_SplitScreen_Everyone) {
		for (I, 1, SplitScreenCount) {
			declare LayerId = Private_GetLayerId(_ModuleId, C_SplitScreen_Everyone, I);
			Layers::Create(LayerId, Module.Manialink);
			Layers::SetType(LayerId, Module.Type);
			Layers::SetAttachId(LayerId, Module.AttachId);
			SplitScreenAssignLayer(Layers::Get(LayerId), I);
		}
	} else {
		declare LayerId = Private_GetLayerId(_ModuleId, Module.SplitScreenTarget);
		Layers::Create(LayerId, Module.Manialink);
		Layers::SetType(LayerId, Module.Type);
		Layers::SetAttachId(LayerId, Module.AttachId);
		
		if (Module.SplitScreenTarget == C_SplitScreen_Common) {
			SplitScreenAssignLayer(Layers::Get(LayerId), 0);
		} else if (Module.SplitScreenTarget == C_SplitScreen_Player1) {
			SplitScreenAssignLayer(Layers::Get(LayerId), 1);
		} else if (Module.SplitScreenTarget == C_SplitScreen_Player2) {
			SplitScreenAssignLayer(Layers::Get(LayerId), 2);
		} else if (Module.SplitScreenTarget == C_SplitScreen_Player3) {
			SplitScreenAssignLayer(Layers::Get(LayerId), 3);
		} else if (Module.SplitScreenTarget == C_SplitScreen_Player4) {
			SplitScreenAssignLayer(Layers::Get(LayerId), 4);
		}
	}

	G_Modules_Loaded.add(_ModuleId);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Unload a module
 *
 *  @param  _ModuleId                 The id of the module to unload
 */
Void Private_UnloadModule(Text _ModuleId) {
	if (
		!G_Modules_Loaded.exists(_ModuleId) ||
		!G_Modules.existskey(_ModuleId)
	) return;

	declare Module = G_Modules[_ModuleId];

	if (Module.SplitScreenTarget == C_SplitScreen_Everyone) {
		for (I, 1, SplitScreenCount) {
			Layers::Destroy(Private_GetLayerId(_ModuleId, C_SplitScreen_Everyone, I));
		}
	} else {
		Layers::Destroy(Private_GetLayerId(_ModuleId, Module.SplitScreenTarget));
	}

	declare Removed = G_Modules_Loaded.remove(_ModuleId);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Public
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Return the version number of the script
 *
 *  @return   The version number of the script
 */
Text GetScriptVersion() {
	return Version;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Return the name of the script
 *
 *  @return   The name of the script
 */
Text GetScriptName() {
	return ScriptName;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Create a module
 *
 *  @param  _Id                       The id of the module
 *  @param  _Manialink                The manialink displayed by the module
 *  @param  _Type                     The type of layer containing the manialink
 *	@param	_SplitScreenEnable				If module is display in SplitScreen 
 *	@param	_SplitScreenTarget				On which screen the module will be displayed
 *	@param	_AttachId									Parameter for EUILayerType::ScreenIn3d 
 */
Void CreateModule(Text _Id, Text _Manialink, CUILayer::EUILayerType _Type,  Boolean _SplitScreenEnable, Integer _SplitScreenTarget, Text _AttachId) {
	// If the module we create already exists and is loaded, we need to reload it with its new properties
	if (G_Modules_Loaded.exists(_Id)) {
		Private_UnloadModule(_Id);
	}
	G_ForceModulesReload = True;

	G_Modules[_Id] = K_Module {
		Id = _Id,
		Manialink = _Manialink,
		Type = _Type,
		SplitScreenEnable = _SplitScreenEnable,
		SplitScreenTarget = _SplitScreenTarget,
		AttachId = _AttachId
	};
	if (!_SplitScreenEnable && G_Modules[_Id].SplitScreenTarget != C_SplitScreen_Disabled) G_Modules[_Id].SplitScreenTarget = C_SplitScreen_Disabled;
}

Void CreateModule(Text _Id, Text _Manialink, CUILayer::EUILayerType _Type,  Boolean _SplitScreenEnable, Integer _SplitScreenTarget) {
	CreateModule(_Id, _Manialink, _Type, _SplitScreenEnable, _SplitScreenTarget, "");
}

Void CreateModule(Text _Id, Text _Manialink, CUILayer::EUILayerType _Type, Text _AttachId) {
	CreateModule(_Id, _Manialink, _Type, False, C_SplitScreen_Disabled, _AttachId);
}

Void CreateModule(Text _Id, Text _Manialink, CUILayer::EUILayerType _Type) {
	CreateModule(_Id, _Manialink, _Type, False, C_SplitScreen_Disabled, "");
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Destroy a module
Void DestroyModule(Text _Id) {
	// If the module we create already exists and is loaded, we need to reload it with its new properties
	if (G_Modules_Loaded.exists(_Id)) {
		Private_UnloadModule(_Id);
	}
	G_ForceModulesReload = True;
	G_Modules.removekey(_Id);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the layers of a module
 *
 *  @param  _ModuleId                 The id of the module
 *
 *	@return														The module layers
 */
CUILayer[] GetModuleLayers(Text _ModuleId) {
	declare CUILayer[] Layers;

	if (
		!G_Modules_Loaded.exists(_ModuleId) ||
		!G_Modules.existskey(_ModuleId)
	) return Layers;
	
	declare Module = G_Modules[_ModuleId];

	if (Module.SplitScreenTarget == C_SplitScreen_Everyone) {
		for (I, 1, SplitScreenCount) {
			Layers.add(Layers::Get(Private_GetLayerId(_ModuleId, C_SplitScreen_Everyone, I)));
		}
	} else {
		Layers.add(Layers::Get(Private_GetLayerId(_ModuleId, Module.SplitScreenTarget)));
	}

	return Layers;
}
CUILayer GetModuleLayer(Text _ModuleId) {
	declare Layers = GetModuleLayers(_ModuleId);
	if (Layers.count > 0) return Layers[0];
	return Null;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the control id of the customizable module frame
Text GetCustomizableUIModuleFrameId(UIModules_Common::ComponentModeLibsUIModules_K_ModuleConfig _ModuleConfig) {
	return _ModuleConfig.Id;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Inject the parameters to make the control customizable
Text CustomizableUIModule(UIModules_Common::ComponentModeLibsUIModules_K_ModuleConfig _ModuleConfig) {
	declare Text Position = _ModuleConfig.Properties.Position.X^" "^_ModuleConfig.Properties.Position.Y;
	declare Text Hidden = "0";
	if (!_ModuleConfig.Properties.Visible) Hidden = "1";
	declare Text Enabled = "0";
	if (_ModuleConfig.IsCustomizable) Enabled = "1";
	return """ id="{{{GetCustomizableUIModuleFrameId(_ModuleConfig)}}}" class="{{{C_Class}}}" pos="{{{Position}}}" scale="{{{_ModuleConfig.Properties.Scale}}}" hidden="{{{Hidden}}}" data-customizable-module-enabled="{{{Enabled}}}" """;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the component
 *
 *	@return														The component id
 */
Text Component() {
	return MV::Component(
		C_Name,
		"""
		""",
		"""
#Include "Libs/Nadeo/MenuLibs/Common/Components/Tools.Script.txt" as {{{P}}}Tools

{{{dumptype(UIModules_Common::ComponentModeLibsUIModules_K_ModuleProperties)}}}

#Struct {{{P}}}K_Module {
	CMlControl Control;
	Boolean IsCustom;
	{{{P}}}K_ModuleProperties DefaultProperties;
}
		""",
		"""
{{{P}}}K_Module[Text] {{{P}}}Private_UpdateModulesProperties({{{P}}}K_Module[Text] _UIModules, {{{P}}}K_ModuleProperties[Text] _ModulesProperties) {
	declare {{{P}}}K_Module[Text] UIModules = _UIModules;
	foreach (ModuleId => Module in _UIModules) {
		// Module properties are customized
		if (_ModulesProperties.existskey(ModuleId)) {
			declare {{{P}}}K_ModuleProperties ModuleProperties = _ModulesProperties[ModuleId];
			Module.Control.RelativePosition_V3 = ModuleProperties.Position;
			Module.Control.RelativeScale = ModuleProperties.Scale;
			Module.Control.Visible = ModuleProperties.Visible;
			UIModules[ModuleId].IsCustom = True;
		}
		// Module properties are not customized anymore
		else if (Module.IsCustom) {
			Module.Control.RelativePosition_V3 = Module.DefaultProperties.Position;
			Module.Control.RelativeScale = Module.DefaultProperties.Scale;
			Module.Control.Visible = Module.DefaultProperties.Visible;
			UIModules[ModuleId].IsCustom = False;
		}
	}
	return UIModules;
}

{{{P}}}K_Module[Text] {{{P}}}Private_Initialize() {
	// Find UI modules controls
	declare {{{P}}}K_Module[Text] {{{P}}}UIModules;
	Page.GetClassChildren("{{{C_Class}}}", Page.MainFrame, True);
	foreach (Control in Page.GetClassChildren_Result) {
		declare TrueControlHandle = Control;
		assert(TrueControlHandle.ControlId != "", "[UIModules] A UI module CMlControl must have an id");
		assert(!{{{P}}}UIModules.existskey(TrueControlHandle.ControlId), "[UIModules] Two UI modules CMlControl cannot share the same id '"^TrueControlHandle.ControlId^"'");
		if (
			TrueControlHandle.DataAttributeExists("customizable-module-enabled") &&
			{{{P}}}Tools::TextToBoolean(TrueControlHandle.DataAttributeGet("customizable-module-enabled"))
		) {
			{{{P}}}UIModules[TrueControlHandle.ControlId] = {{{P}}}K_Module {
				Control = TrueControlHandle,
				IsCustom = False,
				DefaultProperties = {{{P}}}K_ModuleProperties {
					Position = TrueControlHandle.RelativePosition_V3,
					Scale = TrueControlHandle.RelativeScale,
					Visible = TrueControlHandle.Visible
				}
			};
		}
	}
	return {{{P}}}UIModules;
}

***MainInit***
***
declare netread {{{P}}}K_ModuleProperties[Text] Net_LibUI3_CustomizableModule_Properties for Teams[0];
declare netread Integer Net_LibUI3_CustomizableModule_PropertiesUpdate for Teams[0];

declare {{{P}}}K_Module[Text] {{{P}}}UIModules;
***

***MainStart***
***
declare Integer ModulesPropertiesUpdate = Net_LibUI3_CustomizableModule_PropertiesUpdate;

{{{P}}}UIModules = {{{P}}}Private_Initialize();
{{{P}}}UIModules = {{{P}}}Private_UpdateModulesProperties({{{P}}}UIModules, Net_LibUI3_CustomizableModule_Properties);
***

***MainLoop***
***
if (ModulesPropertiesUpdate != Net_LibUI3_CustomizableModule_PropertiesUpdate) {
	ModulesPropertiesUpdate = Net_LibUI3_CustomizableModule_PropertiesUpdate;
	{{{P}}}UIModules = {{{P}}}Private_UpdateModulesProperties({{{P}}}UIModules, Net_LibUI3_CustomizableModule_Properties);
}
***
		""",
		[],
		[]
	);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the library
Void Yield() {
	declare netread Net_LibUI3_ModulesUpdate for Playground.Teams[0] = -1;
	if (G_PrevModulesUpdate != Net_LibUI3_ModulesUpdate || G_ForceModulesReload) {
		G_PrevModulesUpdate = Net_LibUI3_ModulesUpdate;
		G_ForceModulesReload = False;

		// Load new modules
		declare netread Text[] Net_LibUI3_Modules for Playground.Teams[0];
		foreach (Module in Net_LibUI3_Modules) {
			Private_LoadModule(Module);
		}

		// Unload old modules
		declare TmpModules = G_Modules_Loaded;
		foreach (Module in TmpModules) {
			if (!Net_LibUI3_Modules.exists(Module)) {
				Private_UnloadModule(Module);
			}
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Unload the library
Void Unload() {
	declare netread Net_LibUI3_ModulesUpdate for Playground.Teams[0] = -1;
	G_PrevModulesUpdate = Net_LibUI3_ModulesUpdate - 1;
	G_ForceModulesReload = False;

	declare TmpModules = G_Modules_Loaded;
	foreach (Module in TmpModules) {
		Private_UnloadModule(Module);
	}
	G_Modules_Loaded = [];
	G_Modules = [];
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Load the library
Void Load() {
	Unload();
}