/**
 *	UI module: ScoresHeader client side
 */
#Const Version		"1.0.0"
#Const ScriptName	"Libs/Nadeo/Trackmania/Modes/FinalTMGL/UIModules/ScoresHeader_Client.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/CMGame/Utils/ManiaView2.Script.txt" as MV
#Include "Libs/Nadeo/CMGame/Utils/Stylesheet.Script.txt" as Stylesheet
#Include "Libs/Nadeo/CMGame/Modes/UIModules_Client.Script.txt" as UIModules
#Include "Libs/Nadeo/Trackmania/Modes/FinalTMGL/UIModules/ScoresHeader_Common.Script.txt" as UIModules_ScoresHeader_Common
#Include "Libs/Nadeo/CMGame/Utils/Icons.Script.txt" as Icons
#Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/ScoresTable_Client.Script.txt" as UIModules_ScoresTable

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_ImgFolder "file://Media/Manialinks/Nadeo/Trackmania/Modes/FinalTMGL"
#Const C_DisplayTeamColor True
#Const C_UseBackgroundColor True
#Const C_UseScoreTextColor False

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Public
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the id of the UI module
Text GetId() {
	return UIModules_ScoresHeader_Common::C_Id;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the type of layer of the UI module
CUILayer::EUILayerType GetLayerType() {
	return UIModules_ScoresHeader_Common::C_LayerType;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the module manialink
 *
 *  @return                           The module manialink
 */
Text GetML() {
	//L16N [ScoresHeader] This text is displayed instead of the score of the team when the team is qualified to the next stage of the competition. For example if a team must reach 3 points to be qualified, "Blue Q" will be displayed instead of "Blue 3". This text must stay really short, 1 or 2 characters max.
	declare Text Text_Qualified = _("|Qualified|Q");

	declare Text Img_GrandFinal = C_ImgFolder^"/grand_final_logo.dds";
	declare Text Img_HeadToHead = C_ImgFolder^"/head_to_head_logo.dds";
	declare Text Img_CornerTeam = C_ImgFolder^"/grand_final_team.dds";
	declare Text Img_CornerScore = C_ImgFolder^"/grand_final_score.dds";

	declare Text ML_MultiTeamsScores = "";
	declare Real TeamSizeX = 36.;
	declare Real MarginSizeX = 2.;
	declare Integer TeamsNb = 4;
	declare Real StartPosX = (((TeamSizeX + MarginSizeX) * TeamsNb) - MarginSizeX) * -0.5;
	for (I, 0, TeamsNb - 1) {
		declare Real PosX = StartPosX + (I * (TeamSizeX + MarginSizeX));
		ML_MultiTeamsScores ^= """<frameinstance modelid="framemodel-team-score" pos="{{{PosX}}} 0" />""";
	}

	declare Vec2 Size_ScoreCheckbox = <4., 4.>;
	declare Real SizeX_ScoreCheckboxMargin = 0.2;
	declare Text ML_ScoreCheckboxes = "";
	for (I, 0, 8) {
		declare Real PosX = I * (Size_ScoreCheckbox.X + SizeX_ScoreCheckboxMargin);
		ML_ScoreCheckboxes ^= """<frameinstance modelid="framemodel-checkbox" pos="{{{PosX}}} 0" />""";
	}

	return MV::Create(
GetId(), 3,
"""
<stylesheet>
	<style class="text-default" textsize="5" textfont="{{{Stylesheet::GetFont(Stylesheet::C_Font_Weight_ExtraBold)}}}" textcolor="{{{Stylesheet::GetColorHex6(Stylesheet::C_Color_TextLight)}}}" textprefix="$i$t" />
</stylesheet>
<framemodel id="framemodel-checkbox">
	<quad z-index="0" size="{{{Size_ScoreCheckbox.X}}} {{{Size_ScoreCheckbox.Y}}}" colorize="ffffff" image="{{{Icons::C_Icon_128x128_CheckBox_Inactive}}}" />
	<quad id="quad-enabled" z-index="1" size="{{{Size_ScoreCheckbox.X}}} {{{Size_ScoreCheckbox.Y}}}" colorize="ffffff" image="{{{Icons::C_Icon_128x128_CheckBox_Active}}}" />
</framemodel>
<framemodel id="framemodel-score-checkboxes">
	<frame id="frame-checkboxes">
		{{{ML_ScoreCheckboxes}}}
	</frame>
</framemodel>
<framemodel id="framemodel-team-score">
	<frame z-index="0">
		<quad id="quad-color-team" size="25.3 10" valign="center" opacity="0.7" colorize="{{{Stylesheet::GetColorHex6(Stylesheet::C_Color_BGDark)}}}" image="{{{Img_CornerTeam}}}" />
		<quad pos="25.3 0" size="10.66 10" valign="center" opacity="0.7" colorize="ffffff" image="{{{Img_CornerScore}}}" />
	</frame>
	<frame pos="0 -0.6" z-index="1">
		<label id="label-name-team" pos="12.7 0" size="24 9" halign="center" valign="center2" class="text-default" />
		<label id="label-score-team" pos="30.6 0" size="9 9" halign="center" valign="center2" textcolor="000000" class="text-default" />
	</frame>
	<frameinstance id="frame-score-checkboxes" modelid="framemodel-score-checkboxes" pos="18 -6" z-index="2" />
</framemodel>
<frame z-index="-2" hidden="1" id="frame-global">
	<frame {{{UIModules::CustomizableUIModule(UIModules_ScoresHeader_Common::C_UIModuleConfig)}}}>
		<frame id="frame-spectator">
			<frame id="frame-versus" hidden="1">
				<frame z-index="0">
					<quad z-index="0" size="42 10" halign="center" valign="center" bgcolor="{{{Stylesheet::GetColorHex6(Stylesheet::C_Color_BGDark)}}}" opacity="0.7" />
					<quad id="quad-match-logo" z-index="1" size="38 10" halign="center" valign="center" keepratio="fit" colorize="ffffff" image="{{{Img_GrandFinal}}}" />
					<quad pos="-21.7 0" z-index="2" size="10 10" halign="right" valign="center" bgcolor="ffffff" opacity="0.7" />
					<quad pos="21.7 0" z-index="2" size="10 10" halign="left" valign="center" bgcolor="ffffff" opacity="0.7" />
					<quad id="quad-color-team-1" pos="-31.7 0" z-index="3" size="25.3 10" halign="right" valign="center" opacity="0.7" colorize="{{{Stylesheet::GetColorHex6(Stylesheet::C_Color_BGDark)}}}" image="{{{Img_CornerTeam}}}" />
					<quad id="quad-color-team-2" pos="31.7 0" z-index="3" rot="180" size="25.3 10" halign="right" valign="center" opacity="0.7" colorize="{{{Stylesheet::GetColorHex6(Stylesheet::C_Color_BGDark)}}}" image="{{{Img_CornerTeam}}}" />
				</frame>
				<frame pos="0 -0.6" z-index="1">
					<label id="label-score-team-1" pos="-26.7 0" size="9 9" halign="center" valign="center2" textcolor="000000" class="text-default" />
					<label id="label-score-team-2" pos="26.7 0" size="9 9" halign="center" valign="center2" textcolor="000000" class="text-default" />
					<label id="label-name-team-1" pos="-44 0" size="24 9" halign="center" valign="center2" class="text-default" />
					<label id="label-name-team-2" pos="44 0" size="24 9" halign="center" valign="center2" class="text-default" />
				</frame>
				<frame id="frame-score-checkboxes" pos="0 -6" z-index="2">
					<frameinstance id="frame-score-checkboxes-team-1" modelid="framemodel-score-checkboxes" pos="-26.7 0" />
					<frameinstance id="frame-score-checkboxes-team-2" modelid="framemodel-score-checkboxes" pos="26.7 0" />
				</frame>
			</frame>
			<frame id="frame-multi">
				{{{ML_MultiTeamsScores}}}
			</frame>
		</frame>
	</frame>
</frame>
""",
"""
#Include "TextLib" as TL
#Include "Libs/Nadeo/CMGame/Modes/Clans_Client.Script.txt" as Clans
#Include "Libs/Nadeo/TMGame/Modes/MV_Utils.Script.txt" as MV_Utils

#Struct K_Controls {
	CMlFrame Frame_Spectator;
	CMlFrame Frame_Versus;
	CMlFrame Frame_Multi;
	CMlLabel[Integer] Labels_TeamName;
	CMlLabel[Integer] Labels_TeamScore;
	CMlQuad[Integer] Quads_TeamColor;
	CMlQuad Quad_MatchLogo;
	CMlFrame[Integer] Frames_ScoreCheckboxes;
	Boolean TeamsUpdated;
}

#Const C_RefreshInterval 250
#Const C_DisplayTeamColor {{{dump(C_DisplayTeamColor)}}}
#Const C_UseBackgroundColor {{{dump(C_UseBackgroundColor)}}}
#Const C_UseScoreTextColor {{{dump(C_UseScoreTextColor)}}}
""",
"""
K_Controls UpdateVisibility(
	K_Controls _Controls,
	Boolean _IsSpectator,
	Boolean _WarmUpIsActive,
	Integer _ClansNb
) {
	declare K_Controls Controls = _Controls;

	if (
		Controls.Frame_Versus.Visible != (_ClansNb == 2) ||
		Controls.Frame_Multi.Visible != (_ClansNb == 4)
	) {
		Controls.TeamsUpdated = True;
	}

	Controls.Frame_Versus.Visible = (_ClansNb == 2);
	Controls.Frame_Multi.Visible = (_ClansNb == 4);
	Controls.Frame_Spectator.Visible = _IsSpectator && (Controls.Frame_Versus.Visible || Controls.Frame_Multi.Visible);

	if (Controls.Frame_Spectator.Visible) {
		if (_WarmUpIsActive) {
			Controls.Frame_Spectator.RelativePosition_V3.Y = -14.;
		} else {
			Controls.Frame_Spectator.RelativePosition_V3.Y = 0.;
		}
	}

	Controls.Labels_TeamName = [];
	Controls.Labels_TeamScore = [];
	Controls.Quads_TeamColor = [];
	Controls.Frames_ScoreCheckboxes = [];
	if (Controls.Frame_Versus.Visible) {
		Controls.Labels_TeamName[1] <=> (Controls.Frame_Versus.GetFirstChild("label-name-team-1") as CMlLabel);
		Controls.Labels_TeamName[2] <=> (Controls.Frame_Versus.GetFirstChild("label-name-team-2") as CMlLabel);
		Controls.Labels_TeamScore[1] <=> (Controls.Frame_Versus.GetFirstChild("label-score-team-1") as CMlLabel);
		Controls.Labels_TeamScore[2] <=> (Controls.Frame_Versus.GetFirstChild("label-score-team-2") as CMlLabel);
		Controls.Quads_TeamColor[1] <=> (Controls.Frame_Versus.GetFirstChild("quad-color-team-1") as CMlQuad);
		Controls.Quads_TeamColor[2] <=> (Controls.Frame_Versus.GetFirstChild("quad-color-team-2") as CMlQuad);
		Controls.Frames_ScoreCheckboxes[1] <=> (Controls.Frame_Versus.GetFirstChild("frame-score-checkboxes-team-1") as CMlFrame);
		Controls.Frames_ScoreCheckboxes[2] <=> (Controls.Frame_Versus.GetFirstChild("frame-score-checkboxes-team-2") as CMlFrame);
	} else if (Controls.Frame_Multi.Visible) {
		foreach (Key => Control in Controls.Frame_Multi.Controls) {
			declare CMlFrame Frame_Team <=> (Control as CMlFrame);
			declare Integer Clan = Key + 1;
			Controls.Labels_TeamName[Clan] = (Frame_Team.GetFirstChild("label-name-team") as CMlLabel);
			Controls.Labels_TeamScore[Clan] = (Frame_Team.GetFirstChild("label-score-team") as CMlLabel);
			Controls.Quads_TeamColor[Clan] = (Frame_Team.GetFirstChild("quad-color-team") as CMlQuad);
			Controls.Frames_ScoreCheckboxes[Clan] <=> (Frame_Team.GetFirstChild("frame-score-checkboxes") as CMlFrame);
		}
	}

	return Controls;
}

Void UpdateScoreCheckboxes(CMlFrame _Frame_ScoreCheckboxes, Boolean _IsEnabled, Integer _Points, Integer _MaxPoints) {
	declare CMlFrame Frame_Checkboxes <=> (_Frame_ScoreCheckboxes.GetFirstChild("frame-checkboxes") as CMlFrame);
	_Frame_ScoreCheckboxes.Visible = _IsEnabled && _MaxPoints > 0 && _MaxPoints <= Frame_Checkboxes.Controls.count;
	if (_Frame_ScoreCheckboxes.Visible) {
		Frame_Checkboxes.RelativePosition.X = (_MaxPoints * ({{{Size_ScoreCheckbox.X}}} + {{{SizeX_ScoreCheckboxMargin}}}) - {{{SizeX_ScoreCheckboxMargin}}}) * -0.5;
		foreach (Index => Control in Frame_Checkboxes.Controls) {
			if (Index + 1 <= _MaxPoints) {
				(Control as CMlFrame).GetFirstChild("quad-enabled").Visible = (Index + 1 <= _Points);
				Control.Visible = True;
			} else {
				Control.Visible = False;
			}
		}
	}
}

Void UpdateClansScores(
	K_Controls _Controls,
	Integer[Integer] _LocalClansScores,
	Integer[Integer] _CustomClansScores,
	Integer _QualificationsPoints,
	Boolean _IsFinal
) {
	foreach (Clan => Label_TeamScore in _Controls.Labels_TeamScore) {
		if (_CustomClansScores.existskey(Clan)) {
			if (!_IsFinal && _QualificationsPoints > 0 && _CustomClansScores[Clan] >= _QualificationsPoints) {
				Label_TeamScore.Value = "{{{Text_Qualified}}}";
			} else {
				Label_TeamScore.Value = ""^_CustomClansScores[Clan];
			}
		} else if (_LocalClansScores.existskey(Clan)) {
			if (!_IsFinal && _QualificationsPoints > 0 && _LocalClansScores[Clan] >= _QualificationsPoints) {
				Label_TeamScore.Value = "{{{Text_Qualified}}}";
			} else {
				Label_TeamScore.Value = ""^_LocalClansScores[Clan];
			}
		} else {
			Label_TeamScore.Value = "0";
		}
	}

	foreach (Clan => Frame_ScoreCheckboxes in _Controls.Frames_ScoreCheckboxes) {
		declare Integer Score = 0;
		if (_CustomClansScores.existskey(Clan)) {
			Score = _CustomClansScores[Clan];
		} else if (_LocalClansScores.existskey(Clan)) {
			Score = _LocalClansScores[Clan];
		}
		UpdateScoreCheckboxes(Frame_ScoreCheckboxes, True, Score, _QualificationsPoints);
	}
}

Void UdpateClansNames(K_Controls _Controls, Text[Integer] _LocalClansNames, Text[Integer] _CustomClansNames) {
	foreach (Clan => Label_TeamName in _Controls.Labels_TeamName) {
		if (_CustomClansNames.existskey(Clan)) {
			Label_TeamName.Value = TL::StripFormatting(_CustomClansNames[Clan]);
		} else if (_LocalClansNames.existskey(Clan)) {
			Label_TeamName.Value = TL::StripFormatting(_LocalClansNames[Clan]);
		} else if (Teams.existskey(Clan - 1)) {
			Label_TeamName.Value = Teams[Clan - 1].Name;
		} else {
			Label_TeamName.Value = "#"^Clan;
		}
	}
}

Void UpdateClansColors(K_Controls _Controls, Vec3[Integer] _CustomClansColors) {
	if (!C_DisplayTeamColor) return;

	foreach (Clan => Quad_TeamColor in _Controls.Quads_TeamColor) {
		if (_CustomClansColors.existskey(Clan)) {
			if (C_UseBackgroundColor) {
				Quad_TeamColor.Colorize = _CustomClansColors[Clan];
			} else {
				_Controls.Labels_TeamName[Clan].TextColor = _CustomClansColors[Clan];
			}
			if (C_UseScoreTextColor) {
				_Controls.Labels_TeamScore[Clan].TextColor = _CustomClansColors[Clan];
			} else {
				_Controls.Labels_TeamScore[Clan].TextColor = <0., 0., 0.>;
			}
		} else {
			if (C_UseBackgroundColor) {
				Quad_TeamColor.Colorize = <0., 0., 0.>;
			} else {
				_Controls.Labels_TeamName[Clan].TextColor = <1., 1., 1.>;
			}
			_Controls.Labels_TeamScore[Clan].TextColor = <0., 0., 0.>;
		}
		if (C_UseScoreTextColor) {
			_Controls.Labels_TeamScore[Clan].Opacity = 0.7;
		} else {
			_Controls.Labels_TeamScore[Clan].Opacity = 1.;
		}
	}
}

Void UpdateHeadToHead(K_Controls _Controls, Boolean _IsHeadToHead) {
	if (_IsHeadToHead) {
		_Controls.Quad_MatchLogo.ImageUrl = "{{{Img_HeadToHead}}}";
	} else {
		_Controls.Quad_MatchLogo.ImageUrl = "{{{Img_GrandFinal}}}";
	}
}

Boolean IsVisible() {
	return (
		(
			IsSpectatorClient ||
			(InputPlayer != Null && InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned)
		) &&
		!{{{UIModules_ScoresTable::P}}}IsDisplayed()
	);
}

***MainInit***
***
declare CMlFrame Frame_Global;

declare netread Boolean Net_ShareChampion_WarmUpIsActive for Teams[0];
declare netread Vec3[Integer] Net_FinalTMGL_ScoresHeaders_ClansColors for Teams[0];
declare netread Integer Net_FinalTMGL_ScoresHeaders_ClansColorsUpdate for Teams[0];
declare netread Text[Integer] Net_FinalTMGL_ScoresHeaders_ClansNames for Teams[0];
declare netread Integer Net_FinalTMGL_ScoresHeaders_ClansNamesUpdate for Teams[0];
declare netread Integer[Integer] Net_FinalTMGL_ScoresHeaders_ClansScores for Teams[0];
declare netread Integer Net_FinalTMGL_ScoresHeaders_ClansScoresUpdate for Teams[0];
declare netread Integer Net_FinalTMGL_ScoresHeaders_QualificationPoints for Teams[0];
declare netread Boolean Net_FinalTMGL_ScoresHeaders_IsFinal for Teams[0];
declare netread Boolean Net_FinalTMGL_ScoresHeaders_IsHeadToHead for Teams[0];

declare K_Controls Controls;
declare Boolean DisplayModule;
declare Boolean LocalIsVisible;
declare Boolean WarmUpIsActive;
declare Integer ClansNb;
declare Integer[Integer] LocalClansScores;
declare Text[Integer] LocalClansNames;
declare Integer NextRefreshTime;
declare Integer ClansColorsUpdate;
declare Integer ClansNamesUpdate;
declare Integer ClansScoresUpdate;
declare Integer QualificationsPoints;
declare Boolean IsFinal;
declare Boolean IsHeadToHead;
***

***MainStart***
***
Frame_Global <=> (Page.GetFirstChild("frame-global") as CMlFrame);

Controls.Frame_Spectator <=> (Frame_Global.GetFirstChild("frame-spectator") as CMlFrame);
Controls.Frame_Versus <=> (Controls.Frame_Spectator.GetFirstChild("frame-versus") as CMlFrame);
Controls.Frame_Multi <=> (Controls.Frame_Spectator.GetFirstChild("frame-multi") as CMlFrame);
Controls.Quad_MatchLogo <=> (Controls.Frame_Spectator.GetFirstChild("quad-match-logo") as CMlQuad);

DisplayModule = Frame_Global.Visible;
LocalIsVisible = IsVisible();
WarmUpIsActive = Net_ShareChampion_WarmUpIsActive;
ClansNb = Clans::GetClansNb();
NextRefreshTime = Now;
ClansColorsUpdate = Net_FinalTMGL_ScoresHeaders_ClansColorsUpdate;
ClansNamesUpdate = Net_FinalTMGL_ScoresHeaders_ClansNamesUpdate;
ClansScoresUpdate = Net_FinalTMGL_ScoresHeaders_ClansScoresUpdate;
QualificationsPoints = Net_FinalTMGL_ScoresHeaders_QualificationPoints;
IsFinal = Net_FinalTMGL_ScoresHeaders_IsFinal;
IsHeadToHead = Net_FinalTMGL_ScoresHeaders_IsHeadToHead;

Controls = UpdateVisibility(Controls, LocalIsVisible, WarmUpIsActive, ClansNb);
UpdateClansScores(Controls, LocalClansScores, Net_FinalTMGL_ScoresHeaders_ClansScores, QualificationsPoints, IsFinal);
UdpateClansNames(Controls, LocalClansNames, Net_FinalTMGL_ScoresHeaders_ClansNames);
UpdateClansColors(Controls, Net_FinalTMGL_ScoresHeaders_ClansColors);
UpdateHeadToHead(Controls, IsHeadToHead);
***

***MainLoop***
***
if (PageIsVisible) {
	declare Owner <=> MV_Utils::GetOwner(This);
	if (Owner != Null) {
		declare netread Boolean Net_FinalTMGL_ScoresHeader_IsVisible for Owner;
		if (DisplayModule != Net_FinalTMGL_ScoresHeader_IsVisible) {
			DisplayModule = Net_FinalTMGL_ScoresHeader_IsVisible;
			Frame_Global.Visible = Net_FinalTMGL_ScoresHeader_IsVisible;
		}
	}

	if (Owner == Null && DisplayModule) {
		DisplayModule = False;
		Frame_Global.Visible = DisplayModule;
	}

	if (Frame_Global.Visible) {
		if (LocalIsVisible != IsVisible()) {
			LocalIsVisible = IsVisible();
			Controls = UpdateVisibility(Controls, LocalIsVisible, WarmUpIsActive, ClansNb);
		}

		// Limit the refresh rate of the UI
		if (Now >= NextRefreshTime) {
			NextRefreshTime = Now + C_RefreshInterval;

			if (WarmUpIsActive != Net_ShareChampion_WarmUpIsActive) {
				WarmUpIsActive = Net_ShareChampion_WarmUpIsActive;
				Controls = UpdateVisibility(Controls, LocalIsVisible, WarmUpIsActive, ClansNb);
			}

			if (ClansNb != Clans::GetClansNb()) {
				ClansNb = Clans::GetClansNb();
				Controls = UpdateVisibility(Controls, LocalIsVisible, WarmUpIsActive, ClansNb);
			}

			if (Controls.Frame_Spectator.Visible) {
				foreach (Clan => Points in ClanScores) {
					if (!LocalClansScores.existskey(Clan) || LocalClansScores[Clan] != Points) {
						LocalClansScores[Clan] = Points;
						UpdateClansScores(Controls, LocalClansScores, Net_FinalTMGL_ScoresHeaders_ClansScores, QualificationsPoints, IsFinal);
					}
				}
				foreach (TeamIndex => Team in Teams) {
					if (!LocalClansNames.existskey(TeamIndex + 1) || LocalClansNames[TeamIndex + 1] != Team.ColorizedName) {
						LocalClansNames[TeamIndex + 1] = Team.ColorizedName;
						UdpateClansNames(Controls, LocalClansNames, Net_FinalTMGL_ScoresHeaders_ClansNames);
					}
				}

				if (ClansColorsUpdate != Net_FinalTMGL_ScoresHeaders_ClansColorsUpdate) {
					ClansColorsUpdate = Net_FinalTMGL_ScoresHeaders_ClansColorsUpdate;
					UpdateClansColors(Controls, Net_FinalTMGL_ScoresHeaders_ClansColors);
				}

				if (ClansNamesUpdate != Net_FinalTMGL_ScoresHeaders_ClansNamesUpdate) {
					ClansNamesUpdate = Net_FinalTMGL_ScoresHeaders_ClansNamesUpdate;
					UdpateClansNames(Controls, LocalClansNames, Net_FinalTMGL_ScoresHeaders_ClansNames);
				}

				if (
					ClansScoresUpdate != Net_FinalTMGL_ScoresHeaders_ClansScoresUpdate ||
					QualificationsPoints != Net_FinalTMGL_ScoresHeaders_QualificationPoints
				) {
					ClansScoresUpdate = Net_FinalTMGL_ScoresHeaders_ClansScoresUpdate;
					QualificationsPoints = Net_FinalTMGL_ScoresHeaders_QualificationPoints;
					UpdateClansScores(Controls, LocalClansScores, Net_FinalTMGL_ScoresHeaders_ClansScores, QualificationsPoints, IsFinal);
				}

				if (IsFinal != Net_FinalTMGL_ScoresHeaders_IsFinal) {
					IsFinal = Net_FinalTMGL_ScoresHeaders_IsFinal;
					UpdateClansScores(Controls, LocalClansScores, Net_FinalTMGL_ScoresHeaders_ClansScores, QualificationsPoints, IsFinal);
				}

				if (IsHeadToHead != Net_FinalTMGL_ScoresHeaders_IsHeadToHead) {
					IsHeadToHead = Net_FinalTMGL_ScoresHeaders_IsHeadToHead;
					UpdateHeadToHead(Controls, IsHeadToHead);
				}

				if (Controls.TeamsUpdated) {
					Controls.TeamsUpdated = False;
					UpdateClansColors(Controls, Net_FinalTMGL_ScoresHeaders_ClansColors);
					UdpateClansNames(Controls, LocalClansNames, Net_FinalTMGL_ScoresHeaders_ClansNames);
					UpdateClansScores(Controls, LocalClansScores, Net_FinalTMGL_ScoresHeaders_ClansScores, QualificationsPoints, IsFinal);
				}
			}
		}
	}
}
***
""",
[
	UIModules::Component(),
	UIModules_ScoresTable::Component()
],
[]
	);
}