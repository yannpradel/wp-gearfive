/**
 *	UI module: SegmentProgression client side
 */
#Const Version		"3.4.2"
#Const ScriptName	"Libs/Nadeo/Trackmania/Modes/RoyalStars/UIModules/SegmentProgression_Client.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/CMGame/Modes/UIModules_Client.Script.txt" as UIModules
#Include "Libs/Nadeo/CMGame/Utils/Icons.Script.txt" as Icons
#Include "Libs/Nadeo/CMGame/Utils/MLHelpers.Script.txt" as MLHelpers
#Include "Libs/Nadeo/CMGame/Utils/ManiaView2.Script.txt" as MV
#Include "Libs/Nadeo/CMGame/Utils/Stylesheet.Script.txt" as Stylesheet
#Include "Libs/Nadeo/Trackmania/Modes/Royal/UIModules/ZIndex.Script.txt" as ZIndex
#Include "Libs/Nadeo/Trackmania/Modes/RoyalStars/Constants.Script.txt" as Const
#Include "Libs/Nadeo/Trackmania/Modes/RoyalStars/UIModules/SegmentProgression_Common.Script.txt" as UIModules_SegmentProgression_Common

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const Const::C_SegmentProgression_Margin_Star as C_Margin_Star
#Const Const::C_SegmentProgression_Size_Star as C_Size_Star
#Const Const::C_MaximumStars as C_MaximumStars

#Const C_Size_DisplayClip <170., 15.>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the id of the UI module
Text GetId() {
	return UIModules_SegmentProgression_Common::C_Id;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the type of layer of the UI module
CUILayer::EUILayerType GetLayerType() {
	return UIModules_SegmentProgression_Common::C_LayerType;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the module manialink
Text GetML() {
	declare Real StarsClipOverflow = 9.;
	declare Vec2 Size_StarsClip = <C_MaximumStars*(C_Size_Star.X + C_Margin_Star) - C_Margin_Star + 2*StarsClipOverflow, C_Size_DisplayClip.Y>;
	declare Vec2 Pos_CurrentSegmentFlag = <-0.5*Size_StarsClip.X, 0.>;
	declare Vec2 Pos_CurrentSegmentLoop = <Pos_CurrentSegmentFlag.X - 12, Pos_CurrentSegmentFlag.Y>;
	declare Vec2 Pos_NextSegmentFlag = <0.5*Size_StarsClip.X, 0.>;
	declare Vec2 Pos_NextSegmentLoop = <Pos_NextSegmentFlag.X + 12, Pos_NextSegmentFlag.Y>;
	declare Vec2 Pos_TeamChevron = <0., -0.5*C_Size_Star.Y + 0.5>;

	declare Text ML_StarsEmpty;
	declare Text ML_StarsFull;
	for (Index, 0, C_MaximumStars-1) {
		ML_StarsEmpty ^= """
			<quad id="quad-star-full-{{{Index}}}" pos="{{{Index * (C_Size_Star.X + C_Margin_Star)}}} 0" size="{{{C_Size_Star.X}}} {{{C_Size_Star.Y}}}" image="{{{Const::C_ImageUrl_StarEmpty}}}" colorize="{{{Stylesheet::GetColorHex6(Stylesheet::C_Color_BGDark)}}}" halign="center" valign="center" opacity="0.6" z-index="0"/>
		""";
		ML_StarsFull ^= """
			<quad id="quad-star-{{{Index}}}" pos="{{{Index * (C_Size_Star.X + C_Margin_Star)}}} 0" size="{{{C_Size_Star.X}}} {{{C_Size_Star.Y}}}" image="{{{Const::C_ImageUrl_StarFull}}}" colorize="{{{Stylesheet::GetColorHex6(Stylesheet::C_Color_MedalAuthorLight)}}}" halign="center" valign="center" opacity="0" z-index="0"/>
		""";
	}

	return MV::Create(
GetId(), 3,
"""
<stylesheet>
	<style class="text-common" halign="center" valign="center2" textprefix="$i$t" textcolor="FFFFFF"/>
</stylesheet>

<!-- Frame models -->
<framemodel id="framemodel-segment">
	<quad id="quad-segment-bg" size="{{{MLHelpers::MLKeepRatioFromY(124., 104., 10.5)}}}" image="{{{Const::C_ImageUrl_Segment_Bg}}}" colorize="{{{Stylesheet::GetColorHex6(Stylesheet::C_Color_BGDark)}}}" halign="center" valign="center" opacity="0.6" z-index="0"/>
	<quad id="quad-segment-flag" pos="-0.5 -0.25" size="{{{MLHelpers::MLKeepRatioFromY(124., 104., 9.5)}}}" image="{{{Icons::C_Icon_128x128_Flag}}}" halign="center" valign="center" z-index="1"/>
</framemodel>
<framemodel id="framemodel-segment-loop">
	<quad id="quad-loop-bg" size="{{{MLHelpers::MLKeepRatioFromY(124., 104., 10.5)}}}" image="{{{Const::C_ImageUrl_Segment_Bg}}}" colorize="{{{Stylesheet::GetColorHex6(Stylesheet::C_Color_BGDark)}}}" halign="center" valign="center" opacity="0." z-index="0"/>
	<label id="label-old-loop" pos="0 -0.5" size="10 10" class="text-common" textsize="5" textfont="{{{Stylesheet::GetFont(Stylesheet::C_Font_Weight_ExtraBold)}}}" text="8" opacity="0" z-index="1"/>
	<label id="label-new-loop" pos="0 -0.5" size="10 10" class="text-common" textsize="5" textfont="{{{Stylesheet::GetFont(Stylesheet::C_Font_Weight_ExtraBold)}}}" text="8" opacity="0" z-index="1"/>
	<label id="label-loop-icon" size="10 10" class="text-common" textsize="6" text="ï€ž" textprefix="$t" opacity="0" z-index="1"/>
</framemodel>

<!-- Frame global -->
<frame id="frame-global" z-index="{{{ZIndex::C_ZIndex_SegmentProgression}}}">
	<frame {{{UIModules::CustomizableUIModule(UIModules_SegmentProgression_Common::C_UIModuleConfig)}}}>
		<frame {{{MLHelpers::Size(C_Size_DisplayClip)}}} halign="center" valign="center">
			<frame id="frame-display-animation" pos="0 {{{C_Size_DisplayClip.Y}}}" hidden="1">
				<frameinstance id="frame-current-segment-loop" modelid="framemodel-segment-loop" pos="{{{Pos_CurrentSegmentLoop.X}}} {{{Pos_CurrentSegmentLoop.Y}}}" z-index="0"/>
				<frameinstance id="frame-next-segment-loop" modelid="framemodel-segment-loop" pos="{{{Pos_NextSegmentFlag.X}}} {{{Pos_NextSegmentFlag.Y}}}" z-index="0"/>
				<frameinstance id="frame-current-segment" modelid="framemodel-segment" pos="{{{Pos_CurrentSegmentFlag.X}}} {{{Pos_CurrentSegmentFlag.Y}}}" z-index="1"/>
				<frameinstance id="frame-next-segment" modelid="framemodel-segment" pos="{{{Pos_NextSegmentFlag.X}}} {{{Pos_NextSegmentFlag.Y}}}" z-index="1"/>
				<frameinstance id="frame-segment-anim" modelid="framemodel-segment" pos="{{{Pos_NextSegmentFlag.X}}} {{{Pos_NextSegmentFlag.Y}}}" z-index="2" hidden="1"/>
				<frame id="frame-all-stars" pos="{{{-(C_Size_Star.X + C_Margin_Star)*(0.5*C_MaximumStars - 0.5)}}} 0" z-index="0">
					<quad id="quad-team-chevron" pos="{{{Pos_TeamChevron.X}}} {{{Pos_TeamChevron.Y}}}" size="{{{MLHelpers::MLKeepRatioFromX(88., 48., 0.6*C_Size_Star.X)}}}" image="{{{Const::C_ImageUrl_TeamChevron}}}" halign="center" valign="top" opacity="0" z-index="0"/>
					<frame id="frame-stars-full-clip" size="{{{Size_StarsClip.X}}} {{{Size_StarsClip.Y}}}" pos="{{{-0.5*C_Size_Star.X - StarsClipOverflow}}} 0" valign="center" z-index="1">
						<frame id="frame-stars-full" pos="{{{0.5*C_Size_Star.X + StarsClipOverflow}}} 0">
							{{{ML_StarsFull}}}
						</frame>
					</frame>
					{{{ML_StarsEmpty}}}
				</frame>
			</frame>
		</frame>
	</frame>
</frame>
""",
"""
#Include "Libs/Nadeo/CMGame/Modes/Clans_Client.Script.txt" as Clans
#Include "Libs/Nadeo/CMGame/Utils/MLHelpers.Script.txt" as MLHelpers
#Include "Libs/Nadeo/CMGame/Utils/Stylesheet.Script.txt" as Stylesheet
#Include "Libs/Nadeo/TMGame/Utils/Difficulty.Script.txt" as Difficulty
#Include "Libs/Nadeo/Trackmania/Modes/RoyalStars/PlayerData.Script.txt" as PlayerData
#Include "Libs/Nadeo/Trackmania/Modes/RoyalStars/RaceData.Script.txt" as RaceData
#Include "Libs/Nadeo/Trackmania/Modes/RoyalStars/UIModules/SegmentProgression_Common.Script.txt" as UIModules_SegmentProgression_Common
#Include "AnimLib" as AL
#Include "ColorLib" as CL
#Include "MathLib" as ML

#Struct K_Controls {
	CMlFrame Frame_CurrentSegment;
	CMlFrame Frame_CurrentSegmentLoop;
	CMlFrame Frame_DisplayAnimation;
	CMlFrame Frame_Global;
	CMlFrame Frame_NextSegment;
	CMlFrame Frame_NextSegmentLoop;
	CMlFrame Frame_SegmentAnim;
	CMlFrame Frame_StarsFull;
	CMlFrame Frame_StarsFullClip;
	CMlQuad Quad_CurrentSegmentFlag;
	CMlQuad Quad_NextSegmentFlag;
	CMlQuad Quad_SegmentAnimFlag;
	CMlQuad Quad_TeamChevron;
}
#Struct K_AnimStep {
	Integer Time;
	Integer Step;
}
#Struct K_Target {
	Ident Id;
	Integer Clan;
	Integer[] Stars;
	PlayerData::K_Segment Segment;
	RaceData::K_TeamProgress TeamProgress;
}
#Struct K_State {
	K_Controls Controls;
	Boolean IsVisible;
	Boolean PageIsVisible;
	Boolean DisplayModule;
	Integer PlayerSynchronizationPoint;
	Integer RaceFinishEventUpdate;
	K_AnimStep[] AnimSteps;
	PlayerData::K_RaceFinishEvent AnimValues;
	Integer SegmentStarTimesUpdate;
	RaceData::K_StarTimes[Integer] SegmentStarTimes;
	Integer StarRewardsUpdate;
	RaceData::K_StarRewards StarRewards;
	Integer TeamsProgressUpdate;
	RaceData::K_TeamProgress[Integer] TeamsProgress;
	Integer StarsPreviewUpdateTimestamp;
	Integer PossibleStarTimeIndex;
	Integer[] PossibleStarTimes;
	K_Target Target;
}

#Const C_Size_DisplayClip {{{dump(C_Size_DisplayClip)}}}
#Const C_MaximumStars {{{dump(C_MaximumStars)}}}
#Const C_Margin_Star {{{dump(C_Margin_Star)}}}
#Const C_Size_Star {{{dump(C_Size_Star)}}}

#Const C_AnimDuration_ShowHideModule 250
#Const C_AnimDuration_SlidingFlag 500
#Const C_AnimDuration_DisappearingStars 500
#Const C_AnimDuration_ShowBlackSegmentLoop 250
#Const C_AnimDuration_NewBlackSegmentLoop 1250
#Const C_AnimDuration_StarsPreview 250
#Const C_AnimDuration_TeamChevron 500

#Const C_AnimStep_Initialize 0
#Const C_AnimStep_AddStars 1
#Const C_AnimStep_UpdateSegment 2
#Const C_AnimStep_Stop 3

#Const C_State_Null K_State {
	Controls = K_Controls {},
	IsVisible = False,
	PageIsVisible = False,
	DisplayModule = False,
	PlayerSynchronizationPoint = 0,
	RaceFinishEventUpdate = 0,
	AnimSteps = [],
	AnimValues = PlayerData::K_RaceFinishEvent {},
	SegmentStarTimesUpdate = 0,
	SegmentStarTimes = [],
	StarRewardsUpdate = 0,
	StarRewards = RaceData::K_StarRewards {},
	TeamsProgressUpdate = 0,
	TeamsProgress = [],
	StarsPreviewUpdateTimestamp = -1,
	PossibleStarTimeIndex = -1,
	PossibleStarTimes = [],
	Target = K_Target {
		Id = NullId,
		Clan = -1,
		Stars = [],
		Segment = PlayerData::K_Segment {},
		TeamProgress = RaceData::K_TeamProgress {}
	}
}
""",
"""
// Update the visibility of the whole manialink UI
K_State SetVisibility(K_State _State, Boolean _PageIsVisible, Boolean _DisplayModule) {
	declare K_State State = _State;
	State.PageIsVisible = _PageIsVisible;
	State.DisplayModule = _DisplayModule;
	State.IsVisible = State.PageIsVisible && State.DisplayModule && State.Target.Id != NullId;

	AnimMgr.Flush(State.Controls.Frame_DisplayAnimation);
	if (State.IsVisible) {
		AnimMgr.Add(State.Controls.Frame_DisplayAnimation, "<anim pos=\"0 0\" hidden=\"0\" />", C_AnimDuration_ShowHideModule, CAnimManager::EAnimManagerEasing::QuadOut);
	} else {
		AnimMgr.Add(State.Controls.Frame_DisplayAnimation, "<anim pos=\"0 "^C_Size_DisplayClip.Y^"\" hidden=\"1\" />", C_AnimDuration_ShowHideModule, CAnimManager::EAnimManagerEasing::QuadOut);
	}

	return State;
}
K_State UpdateVisibility(K_State _State) {
	return SetVisibility(_State, _State.PageIsVisible, _State.DisplayModule);
}

// Get the index of the possible record corresponding to the current race time
Integer GetPossibleStarTimeIndex(K_State _State, Integer _CurrentRaceTime) {
	for (Index => Time in _State.PossibleStarTimes) {
		if (_CurrentRaceTime <= Time) return Index;
	}
	return _State.PossibleStarTimes.count;
}

// Get the color of the star depending on the star level
Vec3 GetStarColorRGB(Integer _StarLevel) {
	switch (_StarLevel) {
		case PlayerData::C_StarLevel_Gold: return Stylesheet::GetColorRGB(Stylesheet::C_Color_MedalGold);
		case PlayerData::C_StarLevel_Silver: return Stylesheet::GetColorRGB(Stylesheet::C_Color_MedalSilver);
		case PlayerData::C_StarLevel_Bronze: return Stylesheet::GetColorRGB(Stylesheet::C_Color_MedalBronze);
	}
	return Stylesheet::GetColorRGB(Stylesheet::C_Color_MedalAuthorLight);
}
Text GetStarColorHex6(Integer _StarLevel) {
	switch (_StarLevel) {
		case PlayerData::C_StarLevel_Gold: return Stylesheet::GetColorHex6(Stylesheet::C_Color_MedalGold);
		case PlayerData::C_StarLevel_Silver: return Stylesheet::GetColorHex6(Stylesheet::C_Color_MedalSilver);
		case PlayerData::C_StarLevel_Bronze: return Stylesheet::GetColorHex6(Stylesheet::C_Color_MedalBronze);
	}
	return Stylesheet::GetColorHex6(Stylesheet::C_Color_MedalAuthorLight);
}

// Get the position of the segment loop frame
Vec2 GetFrameSegmentLoopPosition(K_State _State, CMlFrame _Frame_SegmentLoop) {
	switch (_Frame_SegmentLoop.Id) {
		case _State.Controls.Frame_CurrentSegmentLoop.Id: return {{{Pos_CurrentSegmentLoop}}};
		case _State.Controls.Frame_NextSegmentLoop.Id: return {{{Pos_NextSegmentLoop}}};
	}
	return <0., 0.>;
}

// Get the text of the segment loop frame
Text GetFrameSegmentLoopText(K_State _State, CMlFrame _Frame_SegmentLoop, PlayerData::K_Segment _Segment) {
	switch (_Frame_SegmentLoop.Id) {
		case _State.Controls.Frame_CurrentSegmentLoop.Id: return ""^_Segment.Loop;
		case _State.Controls.Frame_NextSegmentLoop.Id: return ""^_Segment.Loop+1;
	}
	return "";
}

// Update the preview of the stars the player can earn
K_State UpdateStarsPreview(K_State _State, Integer _CurrentRaceTime) {
	declare K_State State = _State;
	State.PossibleStarTimes.clear();

	if (State.SegmentStarTimes.existskey(State.Target.Segment.Current)) {
		declare RaceData::K_StarTimes StarTimes = State.SegmentStarTimes[State.Target.Segment.Current];

		// Store possible star times
		State.PossibleStarTimes = [StarTimes.Record, StarTimes.Gold, StarTimes.Silver];

		// Update stars
		for (Index, State.Target.Stars.count, C_MaximumStars-1) {
			declare CMlQuad Quad_Star = State.Controls.Frame_StarsFull.Controls[Index] as CMlQuad;
			declare Integer StarRewardsIndex = Index - State.Target.Stars.count;
			declare Text StarColor = GetStarColorHex6(PlayerData::C_StarLevel_Bronze);
			declare Real Opacity = 0.4;

			if (StarRewardsIndex < State.StarRewards.Record && _CurrentRaceTime <= StarTimes.Record) {
				StarColor = GetStarColorHex6(PlayerData::C_StarLevel_Record);
			} else if (StarRewardsIndex < State.StarRewards.Gold && _CurrentRaceTime <= StarTimes.Gold) {
				StarColor = GetStarColorHex6(PlayerData::C_StarLevel_Gold);
			} else if (StarRewardsIndex < State.StarRewards.Silver && _CurrentRaceTime <= StarTimes.Silver) {
				StarColor = GetStarColorHex6(PlayerData::C_StarLevel_Silver);
			} else if (StarRewardsIndex < State.StarRewards.Bronze) {
				StarColor = GetStarColorHex6(PlayerData::C_StarLevel_Bronze);
			} else {
				Opacity = 0.;
			}

			AnimMgr.Add(Quad_Star, "<anim opacity=\""^Opacity^"\" colorize=\""^StarColor^"\"/>", C_AnimDuration_StarsPreview, CAnimManager::EAnimManagerEasing::QuadOut);
		}
	}

	return State;
}

// Update the team progression chevron
K_State UpdateTeamProgressionChevron(K_State _State) {
	declare K_State State = _State;

	AnimMgr.Flush(State.Controls.Quad_TeamChevron);
	AnimMgr.Add(State.Controls.Quad_TeamChevron, "<anim pos=\""^State.Controls.Quad_TeamChevron.RelativePosition_V3.X^" "^{{{Pos_TeamChevron.Y-1.}}}^"\" opacity=\"0.\"/>", C_AnimDuration_TeamChevron/2, CAnimManager::EAnimManagerEasing::QuadOut);
	if (State.TeamsProgress.existskey(State.Target.Clan)) {
		declare RaceData::K_TeamProgress TeamProgress = State.TeamsProgress[State.Target.Clan];
		if (State.Target.Segment.Current + State.Target.Segment.Loop == TeamProgress.Segment && TeamProgress.StarsNb > 0) {
			declare Vec2 Pos_TeamChevron = <(TeamProgress.StarsNb-1) * (C_Margin_Star + C_Size_Star.X), {{{Pos_TeamChevron.Y}}}>;
			AnimMgr.AddChain(State.Controls.Quad_TeamChevron, "<anim pos=\""^Pos_TeamChevron.X^" "^Pos_TeamChevron.Y-1^"\"/>", 0, CAnimManager::EAnimManagerEasing::QuadOut);
			AnimMgr.AddChain(State.Controls.Quad_TeamChevron, "<anim pos=\""^Pos_TeamChevron.X^" "^Pos_TeamChevron.Y^"\" opacity=\"1.\"/>", C_AnimDuration_TeamChevron/2, CAnimManager::EAnimManagerEasing::QuadOut);
		}
	}

	return State;
}

// Flush all animations
Void FlushAllAnimations(K_State _State) {
	AnimMgr.Flush(_State.Controls.Frame_CurrentSegmentLoop);
	AnimMgr.Flush(_State.Controls.Frame_NextSegmentLoop);
	AnimMgr.Flush(_State.Controls.Frame_SegmentAnim);
	AnimMgr.Flush(_State.Controls.Quad_CurrentSegmentFlag);
	foreach (Index => Control in _State.Controls.Frame_CurrentSegmentLoop.Controls) {
		AnimMgr.Flush(Control);
	}
	foreach (Index => Control in _State.Controls.Frame_NextSegmentLoop.Controls) {
		AnimMgr.Flush(Control);
	}
	foreach (Index => Control in _State.Controls.Frame_StarsFull.Controls) {
		AnimMgr.Flush(Control);
	}
}

// Initialize the animation
K_State PlayAnimationStep_Initialize(K_State _State) {
	declare K_State State = _State;
	State.StarsPreviewUpdateTimestamp = -1;

	// Flush all animations
	FlushAllAnimations(State);

	// Initialize stars animation
	for (Index, State.AnimValues.OldStars.count, C_MaximumStars-1) {
		declare CMlQuad Quad_Star = State.Controls.Frame_StarsFull.Controls[Index] as CMlQuad;
		AnimMgr.Add(Quad_Star, "<anim opacity=\"0.\"/>", C_AnimDuration_ShowHideModule, CAnimManager::EAnimManagerEasing::QuadOut);
		if (State.AnimValues.EarnedStars.existskey(Index-State.AnimValues.OldStars.count)) {
			AnimMgr.AddChain(Quad_Star, "<anim colorize=\""^GetStarColorHex6(State.AnimValues.EarnedStars[Index-State.AnimValues.OldStars.count])^"\"/>", 0, CAnimManager::EAnimManagerEasing::QuadOut);
		}
	}

	// Initialize flag animation
	if (State.AnimValues.OldSegment.Current != State.AnimValues.NewSegment.Current) {
		State.Controls.Frame_SegmentAnim.RelativePosition_V3 = {{{Pos_NextSegmentFlag}}};
		State.Controls.Quad_SegmentAnimFlag.Colorize = State.Controls.Quad_NextSegmentFlag.Colorize;
	}

	// Initialize loop animations for the current black segment's loop and the next black segment's loop
	if (State.AnimValues.NewSegment.Current > Difficulty::C_Difficulty_Black) {
		foreach (Frame_SegmentLoop in [State.Controls.Frame_CurrentSegmentLoop, State.Controls.Frame_NextSegmentLoop]) {
			if (Frame_SegmentLoop.Id == State.Controls.Frame_CurrentSegmentLoop.Id && State.AnimValues.NewSegment.Loop < 1) continue;
			if (Frame_SegmentLoop.Id == State.Controls.Frame_NextSegmentLoop.Id && State.AnimValues.NewSegment.Loop < 0) continue;
			declare CMlLabel Label_LoopIcon <=> (Frame_SegmentLoop.GetFirstChild("label-loop-icon") as CMlLabel);
			declare CMlLabel Label_NewLoop <=> (Frame_SegmentLoop.GetFirstChild("label-new-loop") as CMlLabel);
			declare CMlLabel Label_OldLoop <=> (Frame_SegmentLoop.GetFirstChild("label-old-loop") as CMlLabel);

			Label_NewLoop.Opacity = 0.;
			Label_NewLoop.RelativePosition_V3.X = -1.;
			Label_NewLoop.SetText(GetFrameSegmentLoopText(State, Frame_SegmentLoop, State.AnimValues.NewSegment));
			if (!Frame_SegmentLoop.Visible && State.AnimValues.NewSegment.Loop < 2) {
				switch (Frame_SegmentLoop.Id) {
					case _State.Controls.Frame_CurrentSegmentLoop.Id: Frame_SegmentLoop.RelativePosition_V3 = {{{Pos_CurrentSegmentFlag}}};
					case _State.Controls.Frame_NextSegmentLoop.Id: Frame_SegmentLoop.RelativePosition_V3 = {{{Pos_NextSegmentFlag}}};
				}
			} else {
				Label_LoopIcon.Opacity = Label_LoopIcon.Opacity;
				Label_LoopIcon.RelativeRotation = 0.;
				Label_OldLoop.Opacity = 1.;
				Label_OldLoop.RelativePosition_V3.X = 0.;
				Label_OldLoop.SetText(GetFrameSegmentLoopText(State, Frame_SegmentLoop, State.AnimValues.OldSegment));
			}
		}
	}

	return State;
}

// Add the stars
K_State PlayAnimationStep_AddStars(K_State _State) {
	declare K_State State = _State;

	for (Index, State.AnimValues.OldStars.count, ML::Min(State.AnimValues.OldStars.count + State.AnimValues.EarnedStars.count, C_MaximumStars)-1) {
		declare CMlQuad Quad_Star = State.Controls.Frame_StarsFull.Controls[Index] as CMlQuad;
		declare Integer StarRewardsIndex = Index - State.AnimValues.OldStars.count;
		AnimMgr.Add(Quad_Star, "<anim opacity=\"1.\"/>", Now + StarRewardsIndex*100, C_AnimDuration_ShowHideModule, CAnimManager::EAnimManagerEasing::QuadOut);
	}

	return State;
}

// Update the segment
K_State PlayAnimationStep_UpdateSegment(K_State _State) {
	declare K_State State = _State;

	// Sliding flag animation
	if (State.AnimValues.OldSegment.Current != State.AnimValues.NewSegment.Current) {
		AnimMgr.Add(State.Controls.Quad_CurrentSegmentFlag, "<anim colorize=\""^Difficulty::GetRoyalSegmentColorHex6(State.AnimValues.NewSegment.Current)^"\"/>", Now + C_AnimDuration_SlidingFlag, 0, CAnimManager::EAnimManagerEasing::QuadOut);
		AnimMgr.Add(State.Controls.Quad_NextSegmentFlag, "<anim colorize=\""^Difficulty::GetRoyalSegmentColorHex6(State.AnimValues.NewSegment.Next)^"\"/>", 0, CAnimManager::EAnimManagerEasing::QuadOut);
		AnimMgr.Add(State.Controls.Frame_SegmentAnim, "<anim pos=\""^{{{Pos_CurrentSegmentFlag.X}}}^" "^{{{Pos_CurrentSegmentFlag.Y}}}^"\" hidden=\"0\"/>", C_AnimDuration_SlidingFlag, CAnimManager::EAnimManagerEasing::QuadOut);
		AnimMgr.AddChain(State.Controls.Frame_SegmentAnim, "<anim hidden=\"1\"/>", 0, CAnimManager::EAnimManagerEasing::QuadOut);
		AnimMgr.Add(State.Controls.Frame_StarsFullClip, "<anim size=\"0 "^{{{Size_StarsClip.Y}}}^"\"/>", C_AnimDuration_SlidingFlag, CAnimManager::EAnimManagerEasing::QuadOut);
		AnimMgr.AddChain(State.Controls.Frame_StarsFullClip, "<anim size=\""^{{{Size_StarsClip.X}}}^" "^{{{Size_StarsClip.Y}}}^"\"/>", 0, CAnimManager::EAnimManagerEasing::QuadOut);
		foreach (Index => Control in State.Controls.Frame_StarsFull.Controls) {
			AnimMgr.Add(Control as CMlQuad, "<anim opacity=\"0.\"/>", Now + C_AnimDuration_SlidingFlag, 0, CAnimManager::EAnimManagerEasing::QuadOut);
		}
	}

	// Disappearing stars animation for black segment
	if (State.AnimValues.NewSegment.Current > Difficulty::C_Difficulty_Black && State.AnimValues.NewSegment.Loop > 0) {
		foreach (Index => Control in State.Controls.Frame_StarsFull.Controls) {
			declare Integer StartTime = ML::NearestInteger(AL::EaseOutQuad(Index*C_AnimDuration_DisappearingStars/10, 0., ML::ToReal(C_AnimDuration_DisappearingStars), C_AnimDuration_DisappearingStars));
			AnimMgr.Add(Control as CMlQuad, "<anim opacity=\"0.\"/>", Now + C_AnimDuration_DisappearingStars - StartTime, C_AnimDuration_DisappearingStars/3, CAnimManager::EAnimManagerEasing::QuadOut);
		}
	}

	// Loop animation for black segment
	if (State.AnimValues.NewSegment.Current > Difficulty::C_Difficulty_Black) {
		foreach (Frame_SegmentLoop in [State.Controls.Frame_CurrentSegmentLoop, State.Controls.Frame_NextSegmentLoop]) {
			if (Frame_SegmentLoop.Id == State.Controls.Frame_CurrentSegmentLoop.Id && State.AnimValues.NewSegment.Loop < 1) continue;
			if (Frame_SegmentLoop.Id == State.Controls.Frame_NextSegmentLoop.Id && State.AnimValues.NewSegment.Loop < 0) continue;
			declare CMlLabel Label_LoopIcon <=> (Frame_SegmentLoop.GetFirstChild("label-loop-icon") as CMlLabel);
			declare CMlLabel Label_NewLoop <=> (Frame_SegmentLoop.GetFirstChild("label-new-loop") as CMlLabel);
			declare CMlLabel Label_OldLoop <=> (Frame_SegmentLoop.GetFirstChild("label-old-loop") as CMlLabel);
			declare CMlQuad Quad_LoopBackground <=> (Frame_SegmentLoop.GetFirstChild("quad-loop-bg") as CMlQuad);
			declare Integer StartNewLoopEnteringAnimation = ML::NearestInteger(Now + 0.6*C_AnimDuration_NewBlackSegmentLoop);

			if (!Frame_SegmentLoop.Visible && State.AnimValues.NewSegment.Loop < 2) {
				declare Vec2 Pos_FrameSegmentLoop = GetFrameSegmentLoopPosition(State, Frame_SegmentLoop);
				AnimMgr.Add(Frame_SegmentLoop, "<anim pos=\""^Pos_FrameSegmentLoop.X^" "^Pos_FrameSegmentLoop.Y^"\" hidden=\"0\"/>", C_AnimDuration_ShowBlackSegmentLoop, CAnimManager::EAnimManagerEasing::QuadOut);
				AnimMgr.Add(Quad_LoopBackground, "<anim opacity=\"0.6\"/>", C_AnimDuration_ShowBlackSegmentLoop, CAnimManager::EAnimManagerEasing::QuadOut);
				StartNewLoopEnteringAnimation = Now;
			} else {
				AnimMgr.Add(Label_OldLoop, "<anim pos=\"1 "^Label_NewLoop.RelativePosition_V3.Y^"\" opacity=\"0\"/>", C_AnimDuration_NewBlackSegmentLoop/5, CAnimManager::EAnimManagerEasing::QuadOut);
				AnimMgr.Add(Label_LoopIcon, "<anim rot=\"120\" opacity=\"1\"/>", Now + C_AnimDuration_NewBlackSegmentLoop/10, C_AnimDuration_NewBlackSegmentLoop/5, CAnimManager::EAnimManagerEasing::Linear);
				AnimMgr.AddChain(Label_LoopIcon, "<anim rot=\"240\" opacity=\"1\"/>", C_AnimDuration_NewBlackSegmentLoop/5, CAnimManager::EAnimManagerEasing::Linear);
				AnimMgr.AddChain(Label_LoopIcon, "<anim rot=\"360\" opacity=\"0\"/>", C_AnimDuration_NewBlackSegmentLoop/5, CAnimManager::EAnimManagerEasing::Linear);
			}
			AnimMgr.Add(Label_NewLoop, "<anim pos=\"0 "^Label_NewLoop.RelativePosition_V3.Y^"\" opacity=\"1\"/>", StartNewLoopEnteringAnimation, C_AnimDuration_NewBlackSegmentLoop/5, CAnimManager::EAnimManagerEasing::QuadOut);
		}
	}

	return State;
}

// End the animation
K_State PlayAnimationStep_Stop(K_State _State) {
	declare K_State State = _State;

	if (State.AnimValues.OldSegment != State.AnimValues.NewSegment) {
		State = UpdateTeamProgressionChevron(State);
	}

	return State;
}

// Play the next animation step available
K_State PlayNextAnimationStep(K_State _State) {
	if (_State.AnimSteps.count <= 0) return _State;

	declare K_State State = _State;

	switch(State.AnimSteps[0].Step) {
		case C_AnimStep_Initialize: State = PlayAnimationStep_Initialize(State);
		case C_AnimStep_AddStars: State = PlayAnimationStep_AddStars(State);
		case C_AnimStep_UpdateSegment: State = PlayAnimationStep_UpdateSegment(State);
		case C_AnimStep_Stop: State = PlayAnimationStep_Stop(State);
	}
	State.AnimSteps.removekey(0);

	return State;
}

// Update player's segment and stars immediatly (stop any ongoing animation)
K_State SetSegmentAndStars(K_State _State, PlayerData::K_Segment _Segment, Integer[] _Stars) {
	declare K_State State = _State;

	// Stop any ongoing animation
	FlushAllAnimations(State);
	State.AnimSteps = [];

	// Update team progression chevron
	State = UpdateTeamProgressionChevron(State);

	// Update stars
	foreach (Index => Control in State.Controls.Frame_StarsFull.Controls) {
		declare CMlQuad Quad_Star = Control as CMlQuad;
		if (_Stars.existskey(Index)) {
			Quad_Star.Colorize = GetStarColorRGB(_Stars[Index]);
			Quad_Star.Opacity = 1.;
		} else {
			Quad_Star.Opacity = 0.;
		}
	}

	// Update current and next segment flags
	State.Controls.Frame_SegmentAnim.Hide();
	State.Controls.Quad_CurrentSegmentFlag.Colorize = Difficulty::GetRoyalSegmentColorRGB(_Segment.Current);
	State.Controls.Quad_NextSegmentFlag.Colorize = Difficulty::GetRoyalSegmentColorRGB(_Segment.Next);
	State.Controls.Frame_CurrentSegmentLoop.Visible = _Segment.Current > Difficulty::C_Difficulty_Black && _Segment.Loop >= 1;
	State.Controls.Frame_NextSegmentLoop.Visible = _Segment.Current > Difficulty::C_Difficulty_Black && _Segment.Loop >= 0;
	foreach (Frame_SegmentLoop in [State.Controls.Frame_CurrentSegmentLoop, State.Controls.Frame_NextSegmentLoop]) {
		if (Frame_SegmentLoop.Visible) {
			declare CMlLabel Label_LoopIcon <=> (Frame_SegmentLoop.GetFirstChild("label-loop-icon") as CMlLabel);
			declare CMlLabel Label_NewLoop <=> (Frame_SegmentLoop.GetFirstChild("label-new-loop") as CMlLabel);
			declare CMlLabel Label_OldLoop <=> (Frame_SegmentLoop.GetFirstChild("label-old-loop") as CMlLabel);
			declare CMlQuad Quad_LoopBackground <=> (Frame_SegmentLoop.GetFirstChild("quad-loop-bg") as CMlQuad);

			Label_LoopIcon.Opacity = 0.;
			Label_NewLoop.Opacity = 1.;
			Label_NewLoop.RelativePosition_V3.X = 0.;
			Label_OldLoop.Opacity = 0.;
			Label_OldLoop.SetText("");
			Quad_LoopBackground.Opacity = 0.6;
			Label_NewLoop.SetText(GetFrameSegmentLoopText(State, Frame_SegmentLoop, _Segment));
			Frame_SegmentLoop.RelativePosition_V3 = GetFrameSegmentLoopPosition(State, Frame_SegmentLoop);
		}
	}

	return State;
}

// Synchronize the player data with the server data
K_State SynchronizePlayerData(
	K_State _State,
	Integer _PlayerSynchronizationPoint,
	Integer _RaceFinishEventUpdate,
	PlayerData::K_Segment _Segment,
	Integer[] _Stars
) {
	declare K_State State = _State;

	State.PlayerSynchronizationPoint = _PlayerSynchronizationPoint;
	State.RaceFinishEventUpdate = _RaceFinishEventUpdate;
	State = SetSegmentAndStars(State, _Segment, _Stars);

	return State;
}

// Set the player currently followed by the camera
K_State SetTarget(K_State _State, CSmPlayer _Target) {
	declare K_State State = _State;

	// Update target data
	if (_Target == Null) {
		State.Target = K_Target {
			Id = NullId,
			Clan = -1,
			Stars = [],
			Segment = PlayerData::K_Segment {},
			TeamProgress = RaceData::K_TeamProgress {}
		};
	} else {
		State.Target.Id = _Target.Id;
		State.Target.Clan = _Target.CurrentClan;
		State.Target.Stars = PlayerData::GetPlayerStars(_Target);
		State.Target.Segment = PlayerData::GetPlayerSegment(_Target);
		State.Target.TeamProgress = State.TeamsProgress.get(State.Target.Clan, RaceData::K_TeamProgress {});
		State = SynchronizePlayerData(
			State,
			PlayerData::GetPlayerSynchronizationPoint(_Target),
			PlayerData::GetPlayerRaceFinishEventUpdate(_Target),
			PlayerData::GetPlayerSegment(_Target),
			PlayerData::GetPlayerStars(_Target)
		);
	}

	// Update team chevron color
	if (State.Target.Clan != -1) {
		State.Controls.Quad_TeamChevron.Colorize = Clans::GetClanColor(State.Target.Clan);
	} else {
		State.Controls.Quad_TeamChevron.Colorize = Stylesheet::GetColorRGB(Stylesheet::C_Color_IconLight);
	}

	// Refresh UI
	State.StarsPreviewUpdateTimestamp = Now;
	State = UpdateVisibility(State);

	return State;
}

// Trigger the finish race animation
K_State TriggerPlayerRaceFinishEvent(K_State _State, Integer _RaceFinishEventUpdate, PlayerData::K_RaceFinishEvent _RaceFinishEvent) {
	declare K_State State = _State;

	State.RaceFinishEventUpdate = _RaceFinishEventUpdate;
	State.AnimSteps = [];
	State.AnimValues = _RaceFinishEvent;
	declare Integer StepTime = Now;

	State.AnimSteps.add(
		K_AnimStep {
			Step = C_AnimStep_Initialize,
			Time = StepTime
		}
	);
	StepTime += PlayerData::C_AnimDuration_ShowStars;

	State.AnimSteps.add(
		K_AnimStep {
			Step = C_AnimStep_AddStars,
			Time = StepTime
		}
	);
	StepTime += PlayerData::C_AnimDuration_AddStars;

	if (State.AnimValues.OldSegment != State.AnimValues.NewSegment) {
		State.AnimSteps.add(
			K_AnimStep {
				Step = C_AnimStep_UpdateSegment,
				Time = StepTime
			}
		);
		StepTime += PlayerData::C_AnimDuration_UpdateSegment;
	}

	State.AnimSteps.add(
		K_AnimStep {
			Step = C_AnimStep_Stop,
			Time = StepTime
		}
	);

	return State;
}

// Set the times to beat on each segment to get stars
K_State SetSegmentStarTimes(K_State _State, Integer _SegmentStarTimesUpdate, RaceData::K_StarTimes[Integer] _SegmentStarTimes) {
	declare K_State State = _State;

	State.SegmentStarTimesUpdate = _SegmentStarTimesUpdate;
	State.SegmentStarTimes = _SegmentStarTimes;
	State.StarsPreviewUpdateTimestamp = Now;

	return State;
}

// Set the number of stars earned when finish a race
K_State SetStarRewards(K_State _State, Integer _StarRewardsUpdate, RaceData::K_StarRewards _StarRewards) {
	declare K_State State = _State;

	State.StarRewardsUpdate = _StarRewardsUpdate;
	State.StarRewards = _StarRewards;

	return State;
}

// Set the progress of the teams in the race
K_State SetTeamsProgress(K_State _State, Integer _TeamsProgressUpdate, RaceData::K_TeamProgress[Integer] _TeamsProgress) {
	declare K_State State = _State;
	declare RaceData::K_TeamProgress OldTargetTeamProgress = State.Target.TeamProgress;

	State.TeamsProgressUpdate = _TeamsProgressUpdate;
	State.TeamsProgress = _TeamsProgress;
	State.Target.TeamProgress = State.TeamsProgress.get(State.Target.Clan, RaceData::K_TeamProgress {});

	// Update chevron if the player's team is progressing
	if (State.Target.TeamProgress != OldTargetTeamProgress) {
		State = UpdateTeamProgressionChevron(State);
	}

	return State;
}

***MainInit***
***
declare netread Boolean Net_RoyalStars_SegmentProgression_DisplayModule for UI = UIModules_SegmentProgression_Common::C_Default_Visibility;

declare K_State State = C_State_Null;
declare Integer PossibleStarTimeIndex;
***

***MainStart***
***
State.Controls.Frame_Global <=> (Page.GetFirstChild("frame-global") as CMlFrame);
State.Controls.Frame_CurrentSegment <=> (State.Controls.Frame_Global.GetFirstChild("frame-current-segment") as CMlFrame);
State.Controls.Frame_CurrentSegmentLoop <=> (State.Controls.Frame_Global.GetFirstChild("frame-current-segment-loop") as CMlFrame);
State.Controls.Frame_DisplayAnimation <=> (State.Controls.Frame_Global.GetFirstChild("frame-display-animation") as CMlFrame);
State.Controls.Frame_NextSegment <=> (State.Controls.Frame_Global.GetFirstChild("frame-next-segment") as CMlFrame);
State.Controls.Frame_NextSegmentLoop <=> (State.Controls.Frame_Global.GetFirstChild("frame-next-segment-loop") as CMlFrame);
State.Controls.Frame_SegmentAnim <=> (State.Controls.Frame_Global.GetFirstChild("frame-segment-anim") as CMlFrame);
State.Controls.Frame_StarsFull <=> (State.Controls.Frame_Global.GetFirstChild("frame-stars-full") as CMlFrame);
State.Controls.Frame_StarsFullClip <=> (State.Controls.Frame_Global.GetFirstChild("frame-stars-full-clip") as CMlFrame);
State.Controls.Quad_CurrentSegmentFlag <=> (State.Controls.Frame_CurrentSegment.GetFirstChild("quad-segment-flag") as CMlQuad);
State.Controls.Quad_NextSegmentFlag <=> (State.Controls.Frame_NextSegment.GetFirstChild("quad-segment-flag") as CMlQuad);
State.Controls.Quad_SegmentAnimFlag <=> (State.Controls.Frame_SegmentAnim.GetFirstChild("quad-segment-flag") as CMlQuad);
State.Controls.Quad_TeamChevron <=> (State.Controls.Frame_Global.GetFirstChild("quad-team-chevron") as CMlQuad);

State = SetVisibility(State, PageIsVisible, Net_RoyalStars_SegmentProgression_DisplayModule);
State = SetTarget(State, Null);
State = SetSegmentStarTimes(State, RaceData::GetSegmentStarTimesUpdate(Teams[0]), RaceData::GetSegmentStarTimes(Teams[0]));
State = SetStarRewards(State, RaceData::GetStarRewardsUpdate(Teams[0]), RaceData::GetStarRewards(Teams[0]));
State = SetTeamsProgress(State, RaceData::GetTeamsProgressUpdate(Teams[0]), RaceData::GetTeamsProgress(Teams[0]));
***

***MainLoop***
***
if (State.PageIsVisible != PageIsVisible) {
	State = SetVisibility(State, PageIsVisible, State.DisplayModule);
}

if (State.PageIsVisible) {
	if (State.DisplayModule != Net_RoyalStars_SegmentProgression_DisplayModule) {
		State = SetVisibility(State, PageIsVisible, Net_RoyalStars_SegmentProgression_DisplayModule);
	}

	if (State.DisplayModule) {
		if (
			State.AnimSteps.count <= 0 &&
			(
				(GUIPlayer != Null && State.Target.Id != GUIPlayer.Id) ||
				(GUIPlayer == Null && State.Target.Id != NullId)
			)
		) {
			State = SetTarget(State, GUIPlayer);
		}

		if (State.IsVisible) {
			if (GUIPlayer != Null && State.AnimSteps.count <= 0) {
				if (State.PlayerSynchronizationPoint != PlayerData::GetPlayerSynchronizationPoint(GUIPlayer)) {
					State = SynchronizePlayerData(
						State,
						PlayerData::GetPlayerSynchronizationPoint(GUIPlayer),
						PlayerData::GetPlayerRaceFinishEventUpdate(GUIPlayer),
						PlayerData::GetPlayerSegment(GUIPlayer),
						PlayerData::GetPlayerStars(GUIPlayer)
					);
				}
				if (State.RaceFinishEventUpdate != PlayerData::GetPlayerRaceFinishEventUpdate(GUIPlayer)) {
					State.Target.Segment = PlayerData::GetPlayerSegment(GUIPlayer);
					State.Target.Stars = PlayerData::GetPlayerStars(GUIPlayer);
					State = TriggerPlayerRaceFinishEvent(
						State,
						PlayerData::GetPlayerRaceFinishEventUpdate(GUIPlayer),
						PlayerData::GetPlayerRaceFinishEvent(GUIPlayer)
					);
				}

				// Update stars preview
				PossibleStarTimeIndex = GetPossibleStarTimeIndex(State, GUIPlayer.CurrentRaceTime);
				if (State.PossibleStarTimeIndex != PossibleStarTimeIndex) {
					State.PossibleStarTimeIndex = PossibleStarTimeIndex;
					State.StarsPreviewUpdateTimestamp = Now;
				}
				if (State.StarsPreviewUpdateTimestamp != -1 && State.StarsPreviewUpdateTimestamp <= Now) {
					State = UpdateStarsPreview(State, GUIPlayer.CurrentRaceTime);
					State.StarsPreviewUpdateTimestamp = -1;
				}
			}
			if (State.AnimSteps.count > 0 && State.AnimSteps[0].Time <= Now) {
				State = PlayNextAnimationStep(State);
			}
			if (State.SegmentStarTimesUpdate != RaceData::GetSegmentStarTimesUpdate(Teams[0])) {
				State = SetSegmentStarTimes(
					State,
					RaceData::GetSegmentStarTimesUpdate(Teams[0]),
					RaceData::GetSegmentStarTimes(Teams[0])
				);
			}
			if (State.StarRewardsUpdate != RaceData::GetStarRewardsUpdate(Teams[0])) {
				State = SetStarRewards(
					State,
					RaceData::GetStarRewardsUpdate(Teams[0]),
					RaceData::GetStarRewards(Teams[0])
				);
			}
			if (State.TeamsProgressUpdate != RaceData::GetTeamsProgressUpdate(Teams[0])) {
				State = SetTeamsProgress(
					State,
					RaceData::GetTeamsProgressUpdate(Teams[0]),
					RaceData::GetTeamsProgress(Teams[0])
				);
			}
		}
	}
}
***
""",
[
	UIModules::Component()
],
[]
	);
}