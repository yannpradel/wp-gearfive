/**
 *	State manager for the TrackmaniaBase mode
 */
#Const Version		"1.0.0"
#Const ScriptName	"Libs/Nadeo/Trackmania/Modes/StateManager.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/CMGame/Modes/UIModules_Server.Script.txt" as UIModules
#Include "Libs/Nadeo/Trackmania/Modes/UIModules/ConnectionError_Server.Script.txt" as UIModules_ConnectionError

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/*	Enabling this setting will have
 *	a big impact on the script performances
 *	in crowded server. The library
 *	will do a check on every player
 *	of the server on every frame.
 *	If the script respect the convention
 *	to always use MB_Yield() instead of yield;
 *	then it should not have to enforce
 *	the state at each frame. Any new
 *	player will be initialized when
 *	they join the server
 */
#Const C_ForceStatesEveryFrame False

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Globales
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
declare Integer[] G_ForcedStates;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Apply the given states to the given player
 *
 *	@param	_Player										The player to update
 *	@param	_States										The states to apply
 */
Void Private_Apply(CPlayer _Player, Integer[] _States) {
	if (_Player == Null) return;

	UIModules_ConnectionError::SetVisibility(_Player, True);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Add a state to a player
 *
 *	@param	_Player										The player to update
 *	@param	_State										The state to add
 */
Void Add(CPlayer _Player, Integer _State) {
	if (_Player == Null) return;
	declare Integer[] Trackmania_StateMgr_States for _Player = [];
	if (!Trackmania_StateMgr_States.exists(_State)) {
		Trackmania_StateMgr_States.add(_State);
		if (G_ForcedStates.count <= 0) {
			Private_Apply(_Player, Trackmania_StateMgr_States);
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Remove a state from a player
 *
 *	@param	_Player										The player to update
 *	@param	_State										The state to remove
 */
Void Remove(CPlayer _Player, Integer _State) {
	if (_Player == Null) return;
	declare Integer[] Trackmania_StateMgr_States for _Player = [];
	if (Trackmania_StateMgr_States.exists(_State)) {
		Trackmania_StateMgr_States.remove(_State);
		if (G_ForcedStates.count <= 0) {
			Private_Apply(_Player, Trackmania_StateMgr_States);
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Remove all state from a player
 *
 *	@param	_Player										The player to reset
 */
Void Reset(CPlayer _Player) {
	if (_Player == Null) return;
	declare Integer[] Trackmania_StateMgr_States for _Player = [];
	Trackmania_StateMgr_States = [];
	if (G_ForcedStates.count <= 0) {
		Private_Apply(_Player, Trackmania_StateMgr_States);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Check if the player has the given state
 *
 *	@param	_Player										The player to check
 *	@param	_State										The state to find
 *
 *	@return														True if the player has the state
 *																		False otherwise
 */
Boolean HasState(CPlayer _Player, Integer _State) {
	if (_Player == Null) return False;

	declare Integer[] Trackmania_StateMgr_States for _Player = [];
	return Trackmania_StateMgr_States.exists(_State) || G_ForcedStates.exists(_State);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Force the states applied to all players
 *	To disable the forced states use an empty array
 *
 *	@param	_States									The states to force
 */
Void ForcePlayersStates(Integer[] _States) {
	G_ForcedStates = _States;

	foreach (Player in AllPlayers) {
		declare Boolean Trackmania_StateMgr_IsForcedStates for Player = False;
		// Enable
		if (G_ForcedStates.count > 0) {
			Trackmania_StateMgr_IsForcedStates = True;
			Private_Apply(Player, G_ForcedStates);
		}
		// Disable
		else {
			Trackmania_StateMgr_IsForcedStates = False;
			declare Integer[] Trackmania_StateMgr_States for Player = [];
			Private_Apply(Player, Trackmania_StateMgr_States);
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the library
Void Yield() {
	if (C_ForceStatesEveryFrame && G_ForcedStates.count > 0) {
		foreach (Player in AllPlayers) {
			declare Boolean Trackmania_StateMgr_IsForcedStates for Player = False;
			if (!Trackmania_StateMgr_IsForcedStates) {
				Trackmania_StateMgr_IsForcedStates = True;
				Private_Apply(Player, G_ForcedStates);
			}
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Initialize a player
 *
 *	@param	_Player										The player to initialize
 */
Void InitializePlayer(CPlayer _Player) {
	if (_Player == Null) return;

	UIModules_ConnectionError::InitializePlayer(_Player);

	Reset(_Player);

	if (G_ForcedStates.count > 0) {
		declare Boolean Trackmania_StateMgr_IsForcedStates for _Player = False;
		Trackmania_StateMgr_IsForcedStates = True;
		Private_Apply(_Player, G_ForcedStates);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Unload the library
Void Unload() {
	foreach (Player in AllPlayers) {
		InitializePlayer(Player);
	}

	UIModules_ConnectionError::Unload();
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Load the library
Void Load() {
	Unload();

	UIModules_ConnectionError::Load();

	/* @scaffolding ui_module_customizable */

	UIModules::LoadModules([
		UIModules_ConnectionError::C_Id
	]);
}