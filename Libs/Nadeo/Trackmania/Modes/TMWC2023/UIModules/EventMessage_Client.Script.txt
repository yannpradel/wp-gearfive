/**
 *	UI module: EventMessage client side
 */
#Const Version		"1.0.0"
#Const ScriptName	"Libs/Nadeo/Trackmania/Modes/TMWC2023/UIModules/EventMessage_Client.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/CMGame/Utils/ManiaView2.Script.txt" as MV
#Include "Libs/Nadeo/CMGame/Utils/MLHelpers.Script.txt" as MLHelpers
#Include "Libs/Nadeo/CMGame/Modes/UIModules_Client.Script.txt" as UIModules
#Include "Libs/Nadeo/Trackmania/Modes/TMWTCommon/Shared.Script.txt" as Shared
#Include "Libs/Nadeo/Trackmania/Modes/TMWC2023/Stylesheet.Script.txt" as Stylesheet
#Include "Libs/Nadeo/Trackmania/Modes/TMWC2023/UIModules/EventMessage_Common.Script.txt" as UIModules_EventMessage_Common

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_Text_Draw "Draw"
#Const C_Text_Overtime "Overtime"
#Const C_Text_TrackPoint "Track point"
#Const C_Text_MatchPoint "Match point"
#Const C_Text_Ace "Ace"
#Const C_Text_Victory "Victory"
#Const C_Text_TrackWin " wins the Track"
#Const C_Text_MatchWin " wins the Match"

#Const C_TextMessageAnimDuration 250

#Const C_Size_Message <170., 36.>

#Const C_TextSize_TextMessage 10.

#Const C_Id_FrameGlobal "frame-global"
#Const C_Id_LabelMessage "label-message"

#Const C_Event_PlaySound "TMWC2023_EventMessage_PlaySound"
#Const C_Event_StopSound "TMWC2023_EventMessage_StopSound"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Globales
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
declare Ident[Text] G_SoundIdsCache;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the id of the UI module
Text GetId() {
	return UIModules_EventMessage_Common::C_Id;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the type of layer of the UI module
CUILayer::EUILayerType GetLayerType() {
	return UIModules_EventMessage_Common::C_LayerType;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the module manialink
 *
 *  @return                           The module manialink
 */
Text GetML() {
	return MV::Create(
GetId(), 3,
"""
{{{Stylesheet::Get()}}}
<frame id="{{{C_Id_FrameGlobal}}}" z-index="{{{Shared::C_ZIndex_EventMessage}}}" hidden="1">
	<frame {{{UIModules::CustomizableUIModule(UIModules_EventMessage_Common::C_UIModuleConfig)}}}>
		<label id="{{{C_Id_LabelMessage}}}" class="{{{Stylesheet::C_Class_Text_Default}}}" z-index="4" {{{MLHelpers::Size(C_Size_Message)}}} halign="center" textsize="{{{C_TextSize_TextMessage}}}" maxline="3" hidden="1" />
	</frame>
</frame>
""",
"""
#Include "MathLib" as ML
#Include "Libs/Nadeo/Trackmania/Modes/TMWTCommon/Teams.Script.txt" as Teams
#Include "Libs/Nadeo/Trackmania/Modes/TMWC2023/UIModules/EventMessage_Common.Script.txt" as UIModules_EventMessage_Common

#Struct K_Controls {
	CMlLabel Label_Message;
}
#Struct K_Sound {
	Text Url;
	Integer Duration;
	Integer Delay;
	Ident Id;
}
#Struct K_Text {
	Text Value;
	Integer Duration;
	Integer Delay;
}
#Struct K_Message {
	K_Sound Sound;
	K_Text Message;
}
#Struct K_State {
	K_Controls Controls;
	Boolean DisplayModule;
	Integer EventUpdate;
	// The `XXXEndTime` values use the server timer `GameTime`
	Integer MessageEndTime;
	Integer TextEndTime;
	Integer SoundEndTime;
	// The `XXXStartTime` values use the client timer `Now`
	Integer SoundStartTime;
	K_Message[Integer] DefaultMessages;
	K_Message[Integer][Integer] ClansMessages;
	Ident PlayingSoundId;
	Integer TeamsUpdate;
}

#Const C_Sound_Null K_Sound {}
#Const C_Text_Null K_Text {}
#Const C_Message_Null K_Message {}
#Const C_State_Null K_State {
	Controls = K_Controls {},
	DisplayModule = False,
	EventUpdate = 0,
	MessageEndTime = -1,
	TextEndTime = -1,
	SoundEndTime = -1,
	SoundStartTime = -1,
	DefaultMessages = [],
	ClansMessages = [1 => [], 2 => []],
	PlayingSoundId = NullId,
	TeamsUpdate = -1
}

#Const C_TextMessageAnimDuration {{{dump(C_TextMessageAnimDuration)}}}

#Const C_Text_Draw {{{dump(C_Text_Draw)}}}

#Const C_Id_FrameGlobal {{{dump(C_Id_FrameGlobal)}}}

#Const C_Id_LabelMessage {{{dump(C_Id_LabelMessage)}}}

#Const C_Event_PlaySound {{{dump(C_Event_PlaySound)}}}
#Const C_Event_StopSound {{{dump(C_Event_StopSound)}}}

#Const UIModules_EventMessage_Common::C_Type_Reset as C_Type_Reset
#Const UIModules_EventMessage_Common::C_Type_Ace as C_Type_Ace
#Const UIModules_EventMessage_Common::C_Type_Victory as C_Type_Victory
#Const UIModules_EventMessage_Common::C_Type_Draw as C_Type_Draw
#Const UIModules_EventMessage_Common::C_Type_Overtime as C_Type_Overtime
#Const UIModules_EventMessage_Common::C_Type_TrackPoint as C_Type_TrackPoint
#Const UIModules_EventMessage_Common::C_Type_MatchPoint as C_Type_MatchPoint
#Const UIModules_EventMessage_Common::C_Type_TrackWin as C_Type_TrackWin
#Const UIModules_EventMessage_Common::C_Type_MatchWin as C_Type_MatchWin
#Const UIModules_EventMessage_Common::C_Types as C_Types

#Const C_Messages [
	{{{UIModules_EventMessage_Common::C_Type_Ace}}} => K_Message {
		Sound = K_Sound {
			Url = "file://Media/Manialinks/Nadeo/Trackmania/Modes/TMWT/EventMessage/Ace/Ace.wav"
		},
		Message = K_Text {
			Value = {{{dump(C_Text_Ace)}}},
			Duration = 5000
		}
	},
	{{{UIModules_EventMessage_Common::C_Type_Victory}}} => K_Message {
		Sound = K_Sound {
			Url = "file://Media/Manialinks/Nadeo/Trackmania/Modes/TMWT/EventMessage/Victory/Victory.wav"
		},
		Message = K_Text {
			Value = {{{dump(C_Text_Victory)}}},
			Duration = 5000
		}
	},
	{{{UIModules_EventMessage_Common::C_Type_Draw}}} => K_Message {
		Sound = K_Sound {
			Url = "file://Media/Manialinks/Nadeo/Trackmania/Modes/TMWT/EventMessage/Draw/Draw.wav"
		},
		Message = K_Text {
			Value = {{{dump(C_Text_Draw)}}},
			Duration = 5000
		}
	},
	{{{UIModules_EventMessage_Common::C_Type_Overtime}}} => K_Message {
		Sound = K_Sound {
			Url = "file://Media/Manialinks/Nadeo/Trackmania/Modes/TMWT/EventMessage/Overtime/Overtime.wav"
		},
		Message = K_Text {
			Value = {{{dump(C_Text_Overtime)}}},
			Duration = 5000,
			Delay = 200
		}
	},
	{{{UIModules_EventMessage_Common::C_Type_TrackPoint}}} => K_Message {
		Message = K_Text {
			Value = {{{dump(C_Text_TrackPoint)}}},
			Duration = 5000
		}
	},
	{{{UIModules_EventMessage_Common::C_Type_MatchPoint}}} => K_Message {
		Message = K_Text {
			Value = {{{dump(C_Text_MatchPoint)}}},
			Duration = 5000
		}
	},
	{{{UIModules_EventMessage_Common::C_Type_TrackWin}}} => K_Message {
		Message = K_Text {
			Value = {{{dump(C_Text_TrackWin)}}},
			Duration = 5000,
			Delay = 200
		}
	},
	{{{UIModules_EventMessage_Common::C_Type_MatchWin}}} => K_Message {
		Sound = K_Sound {
			Url = "file://Media/Manialinks/Nadeo/Trackmania/Modes/TMWT/EventMessage/MatchWin/MatchWin.wav"
		},
		Message = K_Text {
			Value = {{{dump(C_Text_MatchWin)}}},
			Duration = 5000
		}
	}
]
""",
"""
// If a manialink is hidden (by pressing `*` to hide the whole interface for example)
// then sounds played by its script will be disabled. We have to go through the ManiaApp
// to be sure that the sounds will be played in this case.
Void Private_PlaySound(CAudioSource _Sound) {
	if (PageIsVisible) {
		_Sound.Play();
	} else {
		SendCustomEvent(C_Event_PlaySound, [""^_Sound.Id]);
	}
}
Void Private_StopSound(CAudioSource _Sound) {
	if (PageIsVisible) {
		_Sound.Stop();
	} else {
		SendCustomEvent(C_Event_StopSound, [""^_Sound.Id]);
	}
}

K_State Private_PlaySound(K_State _State, K_Sound _SoundStruct) {
	declare K_State State = _State;

	State.SoundStartTime = -1;
	State.SoundEndTime = GameTime;

	if (
		_SoundStruct.Id != NullId &&
		ParentApp.Audio.Sounds.existskey(_SoundStruct.Id)
	) {
		declare CAudioSource SoundObj = ParentApp.Audio.Sounds[_SoundStruct.Id];

		if (_SoundStruct.Delay > 0) {
			State.SoundStartTime = Now + _SoundStruct.Delay;
		} else {
			State.SoundStartTime = -1;
			Private_PlaySound(SoundObj);
		}

		State.SoundEndTime = GameTime + _SoundStruct.Delay + _SoundStruct.Duration;
		State.PlayingSoundId = SoundObj.Id;
	}

	return State;
}

K_State Private_PlayText(K_State _State, K_Text _TextStruct) {
	declare K_State State = _State;

	State.TextEndTime = GameTime + _TextStruct.Delay + _TextStruct.Duration;

	AnimMgr.Flush(State.Controls.Label_Message);
	if (_TextStruct.Value != "") {
		State.Controls.Label_Message.Value = _TextStruct.Value;
		State.Controls.Label_Message.RelativeScale = 1.4;
		State.Controls.Label_Message.Opacity = 0.;
		State.Controls.Label_Message.Visible = True;
		declare Integer AnimStartTime = Now +  _TextStruct.Delay;
		AnimMgr.Add(State.Controls.Label_Message, "<label scale=\"1\" opacity=\"1\" />", AnimStartTime, C_TextMessageAnimDuration, CAnimManager::EAnimManagerEasing::QuadOut);
		AnimMgr.Add(State.Controls.Label_Message, "<label scale=\"0.6\" opacity=\"0\" hidden=\"1\" />", AnimStartTime + (State.TextEndTime - GameTime), C_TextMessageAnimDuration, CAnimManager::EAnimManagerEasing::QuadOut);
	} else {
		AnimMgr.Add(State.Controls.Label_Message, "<label scale=\"0.6\" opacity=\"0\" hidden=\"1\" />", C_TextMessageAnimDuration, CAnimManager::EAnimManagerEasing::QuadOut);
	}

	return State;
}

K_State HideMessage(K_State _State) {
	declare K_State State = _State;

	if (State.PlayingSoundId != NullId && ParentApp.Audio.Sounds.existskey(State.PlayingSoundId)) {
		Private_StopSound(ParentApp.Audio.Sounds[State.PlayingSoundId]);
	}

	State.MessageEndTime = -1;
	State.TextEndTime = -1;
	State.SoundEndTime = -1;
	State.SoundStartTime = -1;
	State.PlayingSoundId = NullId;

	AnimMgr.Flush(State.Controls.Label_Message);
	AnimMgr.Add(State.Controls.Label_Message, "<label scale=\"0.6\" opacity=\"0\" hidden=\"1\" />", C_TextMessageAnimDuration, CAnimManager::EAnimManagerEasing::QuadOut);

	return State;
}

K_State ShowMessage(K_State _State, Integer _MessageType, Integer _Clan, Integer _ForcedEndTime) {
	declare K_State State = HideMessage(_State);

	declare K_Message MessageStruct = C_Message_Null;
	if (State.ClansMessages.existskey(_Clan) && State.ClansMessages[_Clan].existskey(_MessageType)) {
		MessageStruct = State.ClansMessages[_Clan][_MessageType];
	} else if (State.DefaultMessages.existskey(_MessageType)) {
		MessageStruct = State.DefaultMessages[_MessageType];
	}

	if (_MessageType == C_Type_TrackWin || _MessageType == C_Type_MatchWin) {
		MessageStruct.Message.Value = Teams::GetClanName(This, Teams::GetTeamsInfo(This), _Clan) ^ MessageStruct.Message.Value;
	}

	State = Private_PlaySound(State, MessageStruct.Sound);
	State = Private_PlayText(State, MessageStruct.Message);

	declare Integer[] EndTimes = [State.SoundEndTime, State.TextEndTime];
	State.MessageEndTime = EndTimes.sortreverse()[0];

	if (_ForcedEndTime > 0) {
		State.MessageEndTime = ML::Min(State.MessageEndTime, _ForcedEndTime);
	}

	return State;
}

K_State TriggerEvent(K_State _State, Integer _EventUpdate, Int3 _EventData) {
	declare K_State State = _State;

	State.EventUpdate = _EventUpdate;

	declare Integer Type = _EventData.X;
	declare Integer Clan = _EventData.Y;
	declare Integer ForcedEndTime = _EventData.Z;

	if (Type == C_Type_Reset) {
		State = HideMessage(State);
	} else {
		State = ShowMessage(State, Type, Clan, ForcedEndTime);
	}

	return State;
}

K_Sound LoadSound(K_Sound _SoundStruct) {
	declare K_Sound SoundStruct = _SoundStruct;

	if (SoundStruct.Url != "" && Http.IsValidUrl(SoundStruct.Url)) {
		declare CAudioSource SoundObj <=> ParentApp.Audio.CreateSound(SoundStruct.Url, 0., False, False, False);
		if (SoundObj != Null) {
			Private_StopSound(SoundObj);
			SoundStruct.Duration = ML::FloorInteger(SoundObj.PlayLength * 1000);
			SoundStruct.Id = SoundObj.Id;
		}
	}

	return SoundStruct;
}
Void UnloadSound(K_Sound _SoundStruct) {
	if (_SoundStruct.Id != NullId && ParentApp.Audio.Sounds.existskey(_SoundStruct.Id)) {
		ParentApp.Audio.DestroySound(ParentApp.Audio.Sounds[_SoundStruct.Id]);
	}
}

K_Message LoadMessage(K_Message _MessageStruct) {
	return K_Message {
		Sound = LoadSound(_MessageStruct.Sound),
		Message = _MessageStruct.Message
	};
}

K_State LoadDefaultMessage(K_State _State, Integer _MessageType, K_Message _MessageStruct) {
	assert(!_State.DefaultMessages.existskey(_MessageType), "Default message already loaded for this type");
	declare K_State State = _State;
	State.DefaultMessages[_MessageType] = LoadMessage(_MessageStruct);
	return State;
}

K_State LoadClanMessage(K_State _State, Integer _MessageType, Integer _Clan, K_Message _MessageStruct) {
	assert(
		!_State.ClansMessages.existskey(_Clan) || !_State.ClansMessages[_Clan].existskey(_MessageType),
		"Clan message already loaded for this type"
	);
	declare K_State State = _State;

	if (State.ClansMessages.existskey(_Clan)) {
		State.ClansMessages[_Clan][_MessageType] = LoadMessage(_MessageStruct);
	} else {
		State.ClansMessages[_Clan] = [_MessageType => LoadMessage(_MessageStruct)];
	}

	return State;
}

K_State UnloadClanMessage(K_State _State, Integer _MessageType, Integer _Clan) {
	declare K_State State = _State;

	if (State.ClansMessages.existskey(_Clan) && State.ClansMessages[_Clan].existskey(_MessageType)) {
		declare K_Message ClanMessage = State.ClansMessages[_Clan][_MessageType];
		UnloadSound(ClanMessage.Sound);
		State.ClansMessages[_Clan].removekey(_MessageType);
	}

	return State;
}

Boolean MessagesAreDifferent(Teams::K_Message _NewMessage, K_Message _CurrentMessage) {
	return (
		(_NewMessage.Customize.exists(Teams::C_Property_SoundUrl) && _CurrentMessage.Sound.Url != _NewMessage.SoundUrl) ||
		(_NewMessage.Customize.exists(Teams::C_Property_SoundDelay) && _CurrentMessage.Sound.Delay != _NewMessage.SoundDelay) ||
		(_NewMessage.Customize.exists(Teams::C_Property_Message) && _CurrentMessage.Message.Value != _NewMessage.Message) ||
		(_NewMessage.Customize.exists(Teams::C_Property_MessageDuration) && _CurrentMessage.Message.Duration != _NewMessage.MessageDuration) ||
		(_NewMessage.Customize.exists(Teams::C_Property_MessageDelay) && _CurrentMessage.Message.Delay != _NewMessage.MessageDelay)
	);
}

K_Message MergeClanMessageWithDefaultMessage(Teams::K_Message _ClanMessage, K_Message _DefaultMessage) {
	declare K_Message Message = _DefaultMessage;

	if (_ClanMessage.Customize.exists(Teams::C_Property_SoundUrl)) {
		Message.Sound.Url = _ClanMessage.SoundUrl;
	}
	if (_ClanMessage.Customize.exists(Teams::C_Property_SoundDelay)) {
		Message.Sound.Delay = _ClanMessage.SoundDelay;
	}
	if (_ClanMessage.Customize.exists(Teams::C_Property_Message)) {
		Message.Message.Value = _ClanMessage.Message;
	}
	if (_ClanMessage.Customize.exists(Teams::C_Property_MessageDuration)) {
		Message.Message.Duration = _ClanMessage.MessageDuration;
	}
	if (_ClanMessage.Customize.exists(Teams::C_Property_MessageDelay)) {
		Message.Message.Delay = _ClanMessage.MessageDelay;
	}

	return Message;
}

K_State UpdateTeams(K_State _State, Integer _TeamsUpdate, Teams::K_Team[Integer] _TeamsInfo) {
	declare K_State State = _State;

	State.TeamsUpdate = _TeamsUpdate;

	for (Clan, 1, 2) {
		declare Teams::K_Team Team = _TeamsInfo.get(Clan, Teams::C_Team_Null);
		if (Team.Id == Teams::C_Team_NullId) {
			// The clan has no team info
			// Unload previously loaded data if any
			if (State.ClansMessages.existskey(Clan)) {
				declare K_Message[Integer] ClanMessages = State.ClansMessages[Clan];
				foreach (MessageType => Message in ClanMessages) {
					State = UnloadClanMessage(State, MessageType, Clan);
				}
			}
		} else {
			foreach (MessageType in C_Types) {
				declare Teams::K_Message MessageStruct;
				switch (MessageType) {
					case C_Type_Ace: MessageStruct = Team.Messages.Ace;
					case C_Type_Victory: MessageStruct = Team.Messages.Victory;
					case C_Type_Draw: MessageStruct = Team.Messages.Draw;
					case C_Type_Overtime: MessageStruct = Team.Messages.Overtime;
					case C_Type_TrackPoint: MessageStruct = Team.Messages.TrackPoint;
					case C_Type_MatchPoint: MessageStruct = Team.Messages.MatchPoint;
					case C_Type_TrackWin: MessageStruct = Team.Messages.TrackWin;
					case C_Type_MatchWin: MessageStruct = Team.Messages.MatchWin;
				}
				if (MessageStruct.Customize.count > 0 && MessagesAreDifferent(MessageStruct, State.ClansMessages.get(Clan, []).get(MessageType, C_Message_Null))) {
					State = UnloadClanMessage(State, MessageType, Clan);
					State = LoadClanMessage(
						State,
						MessageType,
						Clan,
						MergeClanMessageWithDefaultMessage(MessageStruct, State.DefaultMessages.get(MessageType, C_Message_Null))
					);
				} else if (MessageStruct.Customize.count <= 0) {
					State = UnloadClanMessage(State, MessageType, Clan);
				}
			}
		}
	}

	return State;
}

***MainInit***
***
declare CMlFrame Frame_Global;

declare netread Boolean Net_TMWC2023_EventMessage_IsVisible for UI;
declare netread Integer Net_TMWC2023_EventMessage_EventUpdate for Teams[0] = 0;
declare netread Int3 Net_TMWC2023_EventMessage_EventData for Teams[0] = <0, 0, 0>;

declare K_State State = C_State_Null;
declare Integer TMWC2023_EventMessage_LastEventUpdate for UI = Net_TMWC2023_EventMessage_EventUpdate;
***

***MainStart***
***
Frame_Global <=> (Page.GetFirstChild(C_Id_FrameGlobal) as CMlFrame);
State.Controls.Label_Message <=> (Frame_Global.GetFirstChild(C_Id_LabelMessage) as CMlLabel);

// Do not trigger the last message when joining the server or restarting the scripts
State.EventUpdate = TMWC2023_EventMessage_LastEventUpdate;

foreach (MessageType => Message in C_Messages) {
	State = LoadDefaultMessage(State, MessageType, Message);
}
State = UpdateTeams(State, Teams::GetTeamsUpdate(This), Teams::GetTeamsInfo(This));

State.DisplayModule = Frame_Global.Visible;
***

***MainLoop***
***
// The loop must not be in an `if (PageIsVisible)` condition
// We want to play messages even if they are not visible
// because they also play sound. Playing the last triggered
// message once the UI become visible again would also not make sense.
if (State.DisplayModule != Net_TMWC2023_EventMessage_IsVisible) {
	State.DisplayModule = Net_TMWC2023_EventMessage_IsVisible;
	Frame_Global.Visible = State.DisplayModule;
}

if (State.DisplayModule) {
	// Teams info should be updated first so that messages that depends on these info are played with the correct data
	if (State.TeamsUpdate != Teams::GetTeamsUpdate(This)) {
		State = UpdateTeams(State, Teams::GetTeamsUpdate(This), Teams::GetTeamsInfo(This));
	}
	if (State.EventUpdate != Net_TMWC2023_EventMessage_EventUpdate) {
		State = TriggerEvent(State, Net_TMWC2023_EventMessage_EventUpdate, Net_TMWC2023_EventMessage_EventData);
		TMWC2023_EventMessage_LastEventUpdate = State.EventUpdate;
	}
	if (State.MessageEndTime > 0 && GameTime >= State.MessageEndTime) {
		State = HideMessage(State);
	}
	if (State.SoundStartTime > 0 && Now >= State.SoundStartTime) {
		if (State.PlayingSoundId != NullId && ParentApp.Audio.Sounds.existskey(State.PlayingSoundId)) {
			Private_PlaySound(ParentApp.Audio.Sounds[State.PlayingSoundId]);
		}
		State.SoundStartTime = -1;
	}
}
***
""",
[
	UIModules::Component()
],
[]
	);
}

// Events can only send Text data
// We must convert the sound id from Text to Ident to retrieve the sound
CAudioSource GetSound(Text _SoundId) {
	declare Ident SoundId = G_SoundIdsCache.get(_SoundId, NullId);
	if (SoundId == NullId || !Audio.Sounds.existskey(SoundId)) {
		G_SoundIdsCache.removekey(_SoundId);
		foreach (Sound in Audio.Sounds) {
			if (""^Sound.Id == _SoundId) {
				G_SoundIdsCache[_SoundId] = Sound.Id;
				SoundId = Sound.Id;
				break;
			}
		}
	}
	if (SoundId != NullId && Audio.Sounds.existskey(SoundId)) {
		return Audio.Sounds[SoundId];
	}
	return Null;
}

Void Yield() {
	foreach (Event in PendingEvents) {
		if (Event.PlaygroundType == CManiaAppPlaygroundEvent::Type::LayerCustomEvent) {
			// If a manialink is hidden (by pressing `*` to hide the whole interface for example)
			// then sounds played by its script will be disabled. We have to go through the ManiaApp
			// to be sure that the sounds will be played no matter what.
			if (Event.CustomEventType == C_Event_PlaySound && Event.CustomEventData.count > 0) {
				declare CAudioSource Sound = GetSound(Event.CustomEventData[0]);
				if (Sound != Null) {
					Sound.Play();
				}
			} else if (Event.CustomEventType == C_Event_StopSound && Event.CustomEventData.count > 0) {
				declare CAudioSource Sound = GetSound(Event.CustomEventData[0]);
				if (Sound != Null) {
					Sound.Stop();
				}
			}
		}
	}
}