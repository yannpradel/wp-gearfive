/**
 *	UI module: ScoresHeader client side
 */
#Const Version		"1.0.0"
#Const ScriptName	"Libs/Nadeo/Trackmania/Modes/ChampionSpring2022/UIModules/ScoresHeader_Client.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/CMGame/Utils/ManiaView2.Script.txt" as MV
#Include "Libs/Nadeo/CMGame/Utils/MLHelpers.Script.txt" as MLHelpers
#Include "Libs/Nadeo/CMGame/Utils/Stylesheet.Script.txt" as Stylesheet
#Include "Libs/Nadeo/CMGame/Modes/UIModules_Client.Script.txt" as UIModules
#Include "Libs/Nadeo/Trackmania/Modes/ChampionCommon/PlayerProfiles.Script.txt" as PlayerProfiles
#Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/ScoresTable_Client.Script.txt" as UIModules_ScoresTable
#Include "Libs/Nadeo/Trackmania/Modes/ChampionSpring2022/UIModules/ScoresHeader_Common.Script.txt" as UIModules_ScoresHeader_Common
#Include "Libs/Nadeo/Trackmania/Modes/ChampionCommon/Shared_Client.Script.txt" as Shared
#Include "Libs/Nadeo/Trackmania/Modes/ChampionCommon/ZIndex.Script.txt" as ZIndex

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_ImgFolder "file://Media/Manialinks/Nadeo/Trackmania/Modes/FinalTMGL"
#Const C_ImgFolder2 "file://Media/Manialinks/Nadeo/Trackmania/Modes/Champion"
#Const C_TeamsLogoFolder "file://Media/Manialinks/Nadeo/Trackmania/Modes/Champion/TeamsLogo"
#Const C_MaxTeams 10
#Const C_MaxTeamsPerLine 5
#Const C_MaxPoints 20
#Const C_DisplayTeamLogo False
#Const C_DisplayTeamColor True

#Const UIModules_ScoresHeader_Common::C_MatchType_Regular as C_MatchType_Regular
#Const UIModules_ScoresHeader_Common::C_MatchType_HeadToHead as C_MatchType_HeadToHead
#Const UIModules_ScoresHeader_Common::C_MatchType_GrandFinal as C_MatchType_GrandFinal

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Public
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the id of the UI module
Text GetId() {
	return UIModules_ScoresHeader_Common::C_Id;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the type of layer of the UI module
CUILayer::EUILayerType GetLayerType() {
	return UIModules_ScoresHeader_Common::C_LayerType;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the module manialink
 *
 *  @return                           The module manialink
 */
Text GetML() {
	declare Text Img_GrandFinal = C_ImgFolder^"/grand_final_logo.dds";
	declare Text Img_HeadToHead = C_ImgFolder^"/head_to_head_logo.dds";
	declare Text Img_CornerTeamLeft = C_ImgFolder2^"/Mode_TMGL_TeamLogo_Left.dds";
	declare Text Img_CornerTeamRight = C_ImgFolder2^"/Mode_TMGL_TeamLogo_Right.dds";
	declare Text Img_CornerScoreLeft = C_ImgFolder2^"/Mode_TMGL_TrackPoints_Left.dds";
	declare Text Img_CornerScoreRight = C_ImgFolder2^"/Mode_TMGL_TrackPoints_Right.dds";
	declare Text Img_CornerScore = C_ImgFolder^"/grand_final_score.dds";

	declare Vec2 Size_CheckboxCorner = MLHelpers::KeepRatioFromY(<8., 20.>, 2.);
	declare Vec2 Size_ScoreCheckboxes = <24.9, Size_CheckboxCorner.Y>;
	declare Real SizeX_ScoreCheckboxMargin = 0.5;
	declare Text ML_ScoreCheckboxes = "";
	for (I, 0, C_MaxPoints - 1) {
		ML_ScoreCheckboxes ^= """<frameinstance modelid="framemodel-score-checkbox" />""";
	}

	declare Text ML_TeamScores = "";
	declare Vec2 Size_TeamScore = <36., 10.>;
	declare Vec2 Size_TeamScoreMargin = <2., 2. + Size_ScoreCheckboxes.Y>;
	for (I, 0, C_MaxTeams - 1) {
		ML_TeamScores ^= """<frameinstance modelid="framemodel-team-score" />""";
	}

	return MV::Create(
GetId(), 3,
"""
<stylesheet>
	<style class="text-default" textsize="5" textfont="{{{Stylesheet::GetFont(Stylesheet::C_Font_Weight_ExtraBold)}}}" textcolor="{{{Stylesheet::GetColorHex6(Stylesheet::C_Color_TextLight)}}}" textprefix="$i$t" />
</stylesheet>
<framemodel id="framemodel-score-checkbox">
	<quad id="quad-left" size="{{{Size_CheckboxCorner.X}}} {{{Size_CheckboxCorner.Y}}}" bgcolor="ffffff" opacity="0.7" />
	<quad id="quad-center" size="0 {{{Size_ScoreCheckboxes.Y}}}" bgcolor="ffffff" opacity="0.7" />
	<quad id="quad-right" size="{{{Size_CheckboxCorner.X}}} {{{Size_CheckboxCorner.Y}}}" bgcolor="ffffff" opacity="0.7" />
</framemodel>
<framemodel id="framemodel-score-checkboxes">
	<frame id="frame-checkboxes">
		{{{ML_ScoreCheckboxes}}}
	</frame>
</framemodel>
<framemodel id="framemodel-team-score">
	<frame z-index="0">
		<quad id="quad-color-team" size="25.3 10" valign="center" opacity="0.7" colorize="{{{Stylesheet::GetColorHex6(Stylesheet::C_Color_BGDark)}}}" image="{{{Img_CornerTeamLeft}}}" />
		<quad id="quad-color-points" pos="25.3 0" size="10.66 10" valign="center" opacity="0.7" colorize="ffffff" image="{{{Img_CornerScore}}}" />
	</frame>
	<frame pos="0 -0.6" z-index="1">
		<label id="label-name-team" pos="12.7 0" size="24 9" halign="center" valign="center2" class="text-default" />
		<quad id="quad-logo-team" pos="12.7 0.6" size="24 8" halign="center" valign="center" keepratio="fit" hidden="1" />
		<label id="label-score-team" pos="30.3 0" size="10 9" halign="center" valign="center2" textcolor="000000" class="text-default" />
	</frame>
	<frameinstance id="frame-score-checkboxes" modelid="framemodel-score-checkboxes" pos="{{{25.3 - Size_ScoreCheckboxes.X}}} -5.5" z-index="2" />
</framemodel>
<frame id="frame-global" z-index="{{{ZIndex::C_ZIndex_ScoresHeader}}}" hidden="1">
	<frame {{{UIModules::CustomizableUIModule(UIModules_ScoresHeader_Common::C_UIModuleConfig)}}}>
		<frame id="frame-spectator">
			<frame id="frame-versus" hidden="1">
				<frame z-index="0">
					<quad z-index="0" size="42 10" halign="center" valign="center" bgcolor="{{{Stylesheet::GetColorHex6(Stylesheet::C_Color_BGDark)}}}" opacity="0.7" />
					<quad id="quad-match-logo" z-index="1" size="38 10" halign="center" valign="center" keepratio="fit" colorize="ffffff" image="{{{Img_GrandFinal}}}" />
					<quad id="quad-color-points-1" pos="-21.7 0" z-index="2" size="10 10" halign="right" valign="center" bgcolor="ffffff" opacity="0.7" />
					<quad id="quad-color-points-2" pos="21.7 0" z-index="2" size="10 10" halign="left" valign="center" bgcolor="ffffff" opacity="0.7" />
					<quad id="quad-color-team-1" pos="-31.7 0" z-index="3" size="25.3 10" halign="right" valign="center" opacity="0.7" colorize="{{{Stylesheet::GetColorHex6(Stylesheet::C_Color_BGDark)}}}" image="{{{Img_CornerTeamLeft}}}" />
					<quad id="quad-color-team-2" pos="31.7 0" z-index="3" size="25.3 10" valign="center" opacity="0.7" colorize="{{{Stylesheet::GetColorHex6(Stylesheet::C_Color_BGDark)}}}" image="{{{Img_CornerTeamRight}}}" />
				</frame>
				<frame pos="0 -0.6" z-index="1">
					<label id="label-score-team-1" pos="-26.7 0" size="9 9" halign="center" valign="center2" textcolor="000000" class="text-default" />
					<label id="label-score-team-2" pos="26.7 0" size="9 9" halign="center" valign="center2" textcolor="000000" class="text-default" />
					<label id="label-name-team-1" pos="-44 0" size="24 9" halign="center" valign="center2" class="text-default" />
					<label id="label-name-team-2" pos="44 0" size="24 9" halign="center" valign="center2" class="text-default" />
					<quad id="quad-logo-team-1" pos="-44 0.6" size="24 8" halign="center" valign="center" keepratio="fit" hidden="1" />
					<quad id="quad-logo-team-2" pos="44 0.6" size="24 8" halign="center" valign="center" keepratio="fit" hidden="1" />
				</frame>
				<frame id="frame-score-checkboxes" pos="0 -5.5" z-index="2">
					<frameinstance id="frame-score-checkboxes-team-1" modelid="framemodel-score-checkboxes" pos="{{{-31.7 - Size_ScoreCheckboxes.X}}} 0" />
					<frameinstance id="frame-score-checkboxes-team-2" modelid="framemodel-score-checkboxes" pos="31.7 0" />
				</frame>
			</frame>
			<frame id="frame-multi">
				{{{ML_TeamScores}}}
			</frame>
		</frame>
	</frame>
</frame>
""",
"""
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/CMGame/Utils/Tools.Script.txt" as Tools
#Include "Libs/Nadeo/TMGame/Modes/Base/UIModules/WarmupHelpers_Client.Script.txt" as WarmupHelpers

#Struct K_Controls {
	CMlFrame Frame_Spectator;
	CMlFrame Frame_Versus;
	CMlFrame Frame_Multi;
	CMlLabel[] Labels_TeamName;
	CMlQuad[] Quads_TeamLogo;
	CMlLabel[] Labels_TeamScore;
	CMlQuad[] Quads_TeamColor;
	CMlQuad[] Quads_PointsColor;
	CMlQuad Quad_MatchLogo;
	CMlFrame[] Frames_ScoreCheckboxes;
}
#Struct K_State {
	K_Controls Controls;
	Boolean IsVisible;
	Integer TeamsNb;
	Boolean DisplayScoreCheckboxes;
}
#Struct K_Score {
	Integer MatchPoints;
	Integer CupPoints;
	Text Logo;
	Text Name;
	Text Trigram;
	Text AccountId;
}

#Const C_RefreshInterval 500
#Const C_MaxTeamsPerLine {{{dump(C_MaxTeamsPerLine)}}}
#Const C_Size_TeamScore {{{dump(Size_TeamScore)}}}
#Const C_Size_TeamScoreMargin {{{dump(Size_TeamScoreMargin)}}}
#Const C_Size_ScoreCheckboxes {{{dump(Size_ScoreCheckboxes)}}}
#Const C_SizeX_ScoreCheckboxMargin {{{dump(SizeX_ScoreCheckboxMargin)}}}
#Const C_TeamsLogoFolder {{{dump(C_TeamsLogoFolder)}}}
#Const C_DisplayTeamLogo {{{dump(C_DisplayTeamLogo)}}}
#Const C_DisplayTeamColor {{{dump(C_DisplayTeamColor)}}}

#Const C_MatchType_Regular {{{dump(C_MatchType_Regular)}}}
#Const C_MatchType_HeadToHead {{{dump(C_MatchType_HeadToHead)}}}
#Const C_MatchType_GrandFinal {{{dump(C_MatchType_GrandFinal)}}}
""",
"""
K_State UpdateVisibility(
	K_State _State,
	Boolean _IsVisible,
	Boolean _WarmUpIsActive,
	Boolean _PauseIsActive,
	Boolean _ScoresHeaderEnabled
) {
	declare K_State State = _State;

	State.IsVisible = _IsVisible && _ScoresHeaderEnabled;
	State.Controls.Frame_Spectator.Visible = State.IsVisible;

	if (State.Controls.Frame_Spectator.Visible) {
		if (_WarmUpIsActive || _PauseIsActive) {
			State.Controls.Frame_Spectator.RelativePosition_V3.Y = -14.;
		} else {
			State.Controls.Frame_Spectator.RelativePosition_V3.Y = 0.;
		}
	}

	return State;
}

K_State UpdateTeamsNb(
	K_State _State,
	Integer _TeamsNb,
	Boolean _DisplayScoreCheckboxes
) {
	declare K_State State = _State;

	State.TeamsNb = _TeamsNb;
	State.DisplayScoreCheckboxes = _DisplayScoreCheckboxes;

	State.Controls.Labels_TeamName = [];
	State.Controls.Quads_TeamLogo = [];
	State.Controls.Labels_TeamScore = [];
	State.Controls.Quads_TeamColor = [];
	State.Controls.Quads_PointsColor = [];
	State.Controls.Frames_ScoreCheckboxes = [];

	State.Controls.Frame_Versus.Visible = (State.TeamsNb == 2);
	State.Controls.Frame_Multi.Visible = !State.Controls.Frame_Versus.Visible;

	if (State.Controls.Frame_Versus.Visible) {
		State.Controls.Labels_TeamName.add(State.Controls.Frame_Versus.GetFirstChild("label-name-team-1") as CMlLabel);
		State.Controls.Labels_TeamName.add(State.Controls.Frame_Versus.GetFirstChild("label-name-team-2") as CMlLabel);
		State.Controls.Quads_TeamLogo.add(State.Controls.Frame_Versus.GetFirstChild("quad-logo-team-1") as CMlQuad);
		State.Controls.Quads_TeamLogo.add(State.Controls.Frame_Versus.GetFirstChild("quad-logo-team-2") as CMlQuad);
		State.Controls.Labels_TeamScore.add(State.Controls.Frame_Versus.GetFirstChild("label-score-team-1") as CMlLabel);
		State.Controls.Labels_TeamScore.add(State.Controls.Frame_Versus.GetFirstChild("label-score-team-2") as CMlLabel);
		State.Controls.Quads_TeamColor.add(State.Controls.Frame_Versus.GetFirstChild("quad-color-team-1") as CMlQuad);
		State.Controls.Quads_TeamColor.add(State.Controls.Frame_Versus.GetFirstChild("quad-color-team-2") as CMlQuad);
		State.Controls.Quads_PointsColor.add(State.Controls.Frame_Versus.GetFirstChild("quad-color-points-1") as CMlQuad);
		State.Controls.Quads_PointsColor.add(State.Controls.Frame_Versus.GetFirstChild("quad-color-points-2") as CMlQuad);
		declare CMlFrame Frame_ScoreCheckboxes <=> (State.Controls.Frame_Versus.GetFirstChild("frame-score-checkboxes") as CMlFrame);
		if (State.DisplayScoreCheckboxes) {
			Frame_ScoreCheckboxes.Visible = True;
			State.Controls.Frames_ScoreCheckboxes.add(State.Controls.Frame_Versus.GetFirstChild("frame-score-checkboxes-team-1") as CMlFrame);
			State.Controls.Frames_ScoreCheckboxes.add(State.Controls.Frame_Versus.GetFirstChild("frame-score-checkboxes-team-2") as CMlFrame);
		} else {
			Frame_ScoreCheckboxes.Visible = False;
		}
	} else if (State.Controls.Frame_Multi.Visible) {
		foreach (Key => Control in State.Controls.Frame_Multi.Controls) {
			declare CMlFrame Frame_Team <=> (Control as CMlFrame);
			if (Key > State.TeamsNb - 1) {
				Frame_Team.Visible = False;
			} else {
				declare Integer Column = Key % C_MaxTeamsPerLine;
				declare Integer Line = Key / C_MaxTeamsPerLine;
				declare Integer TeamsOnLine = ML::Min(State.TeamsNb - (Line * C_MaxTeamsPerLine), C_MaxTeamsPerLine);
				declare Real SizeY_Line = C_Size_TeamScore.Y + C_Size_TeamScoreMargin.Y;
				if (!State.DisplayScoreCheckboxes) {
					SizeY_Line -= C_Size_ScoreCheckboxes.Y;
				}

				Frame_Team.RelativePosition_V3 = <
					((((C_Size_TeamScore.X + C_Size_TeamScoreMargin.X) * TeamsOnLine) - C_Size_TeamScoreMargin.X) * -0.5) + (Column * (C_Size_TeamScore.X + C_Size_TeamScoreMargin.X)),
					Line * -SizeY_Line
				>;
				Frame_Team.Visible = True;

				State.Controls.Labels_TeamName.add(Frame_Team.GetFirstChild("label-name-team") as CMlLabel);
				State.Controls.Quads_TeamLogo.add(Frame_Team.GetFirstChild("quad-logo-team") as CMlQuad);
				State.Controls.Labels_TeamScore.add(Frame_Team.GetFirstChild("label-score-team") as CMlLabel);
				State.Controls.Quads_TeamColor.add(Frame_Team.GetFirstChild("quad-color-team") as CMlQuad);
				State.Controls.Quads_PointsColor.add(Frame_Team.GetFirstChild("quad-color-points") as CMlQuad);
				declare CMlFrame Frame_ScoreCheckboxes <=> (Frame_Team.GetFirstChild("frame-score-checkboxes") as CMlFrame);
				if (State.DisplayScoreCheckboxes) {
					Frame_ScoreCheckboxes.Visible = True;
					State.Controls.Frames_ScoreCheckboxes.add(Frame_ScoreCheckboxes);
				} else {
					Frame_ScoreCheckboxes.Visible = False;
				}
			}
		}
	}

	return State;
}

Void UpdateScoreCheckboxes(CMlFrame _Frame_ScoreCheckboxes, Integer _Points, Integer _MaxPoints) {
	declare CMlFrame Frame_Checkboxes <=> (_Frame_ScoreCheckboxes.GetFirstChild("frame-checkboxes") as CMlFrame);
	declare Integer MaxPoints = ML::Clamp(_MaxPoints, 0, Frame_Checkboxes.Controls.count);
	_Frame_ScoreCheckboxes.Visible = MaxPoints > 0;
	if (_Frame_ScoreCheckboxes.Visible) {
		declare Real SizeX_Checkbox = (C_Size_ScoreCheckboxes.X - ((MaxPoints - 1) * C_SizeX_ScoreCheckboxMargin)) / MaxPoints;
		foreach (Index => Control in Frame_Checkboxes.Controls) {
			if (Index <= MaxPoints - 1) {
				declare CMlFrame Frame_Checkbox <=> (Control as CMlFrame);
				declare CMlQuad Quad_Left <=> (Frame_Checkbox.GetFirstChild("quad-left") as CMlQuad);
				declare CMlQuad Quad_Center <=> (Frame_Checkbox.GetFirstChild("quad-center") as CMlQuad);
				declare CMlQuad Quad_Right <=> (Frame_Checkbox.GetFirstChild("quad-right") as CMlQuad);
				Frame_Checkbox.RelativePosition_V3.X = Index * (SizeX_Checkbox + C_SizeX_ScoreCheckboxMargin);
				if (Index == 0) {
					Quad_Left.ImageUrl = "{{{Img_CornerScoreLeft}}}";
				} else {
					Quad_Left.ImageUrl = "";
				}
				if (Index == MaxPoints - 1) {
					Quad_Right.ImageUrl = "{{{Img_CornerScoreRight}}}";
				} else {
					Quad_Right.ImageUrl = "";
				}
				if (Index <= _Points - 1) {
					if (Quad_Left.ImageUrl != "") Quad_Left.Colorize = {{{Stylesheet::GetColorRGB(Stylesheet::C_Color_AccentOne)}}};
					else Quad_Left.BgColor = {{{Stylesheet::GetColorRGB(Stylesheet::C_Color_AccentOne)}}};
					Quad_Center.BgColor = {{{Stylesheet::GetColorRGB(Stylesheet::C_Color_AccentOne)}}};
					if (Quad_Right.ImageUrl != "") Quad_Right.Colorize = {{{Stylesheet::GetColorRGB(Stylesheet::C_Color_AccentOne)}}};
					else Quad_Right.BgColor = {{{Stylesheet::GetColorRGB(Stylesheet::C_Color_AccentOne)}}};
				} else {
					if (Quad_Left.ImageUrl != "") Quad_Left.Colorize = <1., 1., 1.>;
					else Quad_Left.BgColor = <1., 1., 1.>;
					Quad_Center.BgColor = <1., 1., 1.>;
					if (Quad_Right.ImageUrl != "") Quad_Right.Colorize = <1., 1., 1.>;
					else Quad_Right.BgColor = <1., 1., 1.>;
				}
				Quad_Center.Size.X = SizeX_Checkbox - Quad_Left.Size.X - Quad_Right.Size.X;
				Quad_Center.RelativePosition_V3.X = Quad_Left.Size.X;
				Quad_Right.RelativePosition_V3.X = Quad_Center.RelativePosition_V3.X + Quad_Center.Size.X;
				Frame_Checkbox.Visible = True;
			} else {
				Control.Visible = False;
			}
		}
	}
}

K_State UpdatePoints(
	K_State _State,
	Integer[Text] _MatchPoints,
	Integer _MatchPointsLimit,
	Integer[Text] _CupPoints,
	Integer _CupPointsLimit,
	Text[] _MatchWinners,
	Boolean _MatchComplete
) {
	declare K_State State = _State;

	// Find points
	declare K_Score[Text] AccountIdToTeamScores;
	foreach (AccountId => MatchPoints in _MatchPoints) {
		AccountIdToTeamScores[AccountId] = K_Score { MatchPoints = MatchPoints };
	}
	foreach (AccountId => CupPoints in _CupPoints) {
		if (AccountIdToTeamScores.existskey(AccountId)) {
			AccountIdToTeamScores[AccountId].CupPoints = CupPoints;
		} else {
			AccountIdToTeamScores[AccountId] = K_Score { CupPoints = CupPoints };
		}
	}

	// Add players info
	declare Text[] AccountIdsWithoutInfo;
	declare {{{PlayerProfiles::P}}}K_PlayerProfile[Text] PlayerProfiles = {{{PlayerProfiles::P}}}GetPlayerProfiles();
	foreach (AccountId => TeamScore in AccountIdToTeamScores) {
		AccountIdToTeamScores[AccountId].AccountId = AccountId;

		if (PlayerProfiles.existskey(AccountId)) {
			declare {{{PlayerProfiles::P}}}K_PlayerProfile PlayerProfile = PlayerProfiles[AccountId];
			AccountIdToTeamScores[AccountId].Logo = PlayerProfile.TeamLogoWhite;
			AccountIdToTeamScores[AccountId].Name = PlayerProfile.Nickname;
			AccountIdToTeamScores[AccountId].Trigram = PlayerProfile.TeamTrigram;
		} else {
			AccountIdsWithoutInfo.add(AccountId);
		}
	}
	if (AccountIdsWithoutInfo.count > 0) {
		foreach (Score in Scores) {
			if (Score.User != Null && AccountIdsWithoutInfo.exists(Score.User.WebServicesUserId)) {
				AccountIdToTeamScores[Score.User.WebServicesUserId].Name = Score.User.Name;
				AccountIdsWithoutInfo.remove(Score.User.WebServicesUserId);
			}
		}
	}

	// Display winners first if there are more than 2 teams
	// (otherwise it's strange to see the team on the left go right
	// or the right team go left when they win)
	// and then sort the remaining teams in alphabetical order
	declare K_Score[] TeamScores;
	if (AccountIdToTeamScores.count > 2) {
		foreach (AccountId in _MatchWinners) {
			if (AccountIdToTeamScores.existskey(AccountId)) {
				TeamScores.add(AccountIdToTeamScores[AccountId]);
				AccountIdToTeamScores.removekey(AccountId);
			}
		}
	}
	AccountIdToTeamScores = AccountIdToTeamScores.sortkey();
	foreach (TeamScore in AccountIdToTeamScores) {
		TeamScores.add(TeamScore);
	}

	declare Boolean DisplayScoreCheckboxes = _MatchPointsLimit > 1;
	if (
		State.TeamsNb != TeamScores.count ||
		State.DisplayScoreCheckboxes != DisplayScoreCheckboxes
	) {
		State = UpdateTeamsNb(State, TeamScores.count, DisplayScoreCheckboxes);
	}

	foreach (Key => TeamScore in TeamScores) {
		if (State.DisplayScoreCheckboxes && State.Controls.Frames_ScoreCheckboxes.existskey(Key)) {
			UpdateScoreCheckboxes(State.Controls.Frames_ScoreCheckboxes[Key], TeamScore.MatchPoints, _MatchPointsLimit);
		}
		if (State.Controls.Labels_TeamScore.existskey(Key)) {
			State.Controls.Labels_TeamScore[Key].Value = {{{Shared::P}}}FormatPoints(TeamScore.CupPoints, _CupPointsLimit, _MatchWinners, TeamScore.AccountId, True, _MatchComplete);
			Tools::FitLabelValue(State.Controls.Labels_TeamScore[Key], 5., 1., 0.5);
		}
		if (State.Controls.Quads_TeamLogo.existskey(Key)) {
			if (C_DisplayTeamLogo && TeamScore.Logo != "") {
				State.Controls.Quads_TeamLogo[Key].Visible = True;
				State.Controls.Quads_TeamLogo[Key].ImageUrl = C_TeamsLogoFolder^"/"^TeamScore.Logo;
			} else {
				State.Controls.Quads_TeamLogo[Key].Visible = False;
			}
		}
		if (State.Controls.Labels_TeamName.existskey(Key)) {
			if (
				(!C_DisplayTeamLogo || TeamScore.Logo == "") &&
				(TeamScore.Trigram != "" || TeamScore.Name != "")
			) {
				declare CMlLabel Label_TeamName <=> State.Controls.Labels_TeamName[Key];
				if (TeamScore.Trigram != "") {
					if (C_DisplayTeamColor) {
						Label_TeamName.Value = TeamScore.Trigram;
					} else {
						Label_TeamName.Value = TL::StripFormatting(TeamScore.Trigram);
					}
				} else {
					Label_TeamName.Value = TeamScore.Name;
				}
				Label_TeamName.Visible = True;
				Tools::FitLabelValue(Label_TeamName, 5., 1., 0.5);
			} else {
				State.Controls.Labels_TeamName[Key].Visible = False;
			}
		}
		if (State.Controls.Quads_PointsColor.existskey(Key)) {
			// Need both `Colorize` and `BgColor` because the quads from the 2 players and
			// the ones from the 3+ players variants use different modes of colorization.
			if (_MatchWinners.exists(TeamScore.AccountId)) {
				State.Controls.Quads_PointsColor[Key].Colorize = {{{Stylesheet::GetColorRGB(Stylesheet::C_Color_AccentOne)}}};
				State.Controls.Quads_PointsColor[Key].BgColor = {{{Stylesheet::GetColorRGB(Stylesheet::C_Color_AccentOne)}}};
			} else {
				State.Controls.Quads_PointsColor[Key].Colorize = <1., 1., 1.>;
				State.Controls.Quads_PointsColor[Key].BgColor = <1., 1., 1.>;
			}
		}
	}

	return State;
}

Void UpdateMatchType(K_State _State, Integer _MatchType) {
	switch (_MatchType) {
		case C_MatchType_HeadToHead: {
			_State.Controls.Quad_MatchLogo.ImageUrl = "{{{Img_HeadToHead}}}";
			_State.Controls.Quad_MatchLogo.Visible = True;
		}
		case C_MatchType_GrandFinal: {
			_State.Controls.Quad_MatchLogo.ImageUrl = "{{{Img_GrandFinal}}}";
			_State.Controls.Quad_MatchLogo.Visible = True;
		}
		default: {
			_State.Controls.Quad_MatchLogo.Visible = False;
		}
	}
}

Boolean LocalIsVisible() {
	return (
		(
			IsSpectatorClient ||
			(InputPlayer != Null && InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned)
		) &&
		!{{{UIModules_ScoresTable::P}}}IsDisplayed()
	);
}

***MainInit***
***
declare CMlFrame Frame_Global;

declare netread Boolean Net_ChampionSpring2022_ScoresHeader_IsVisible for UI;
declare netread Integer[Text] Net_ChampionSpring2022_ScoresHeader_MatchPoints for Teams[0];
declare netread Integer[Text] Net_ChampionSpring2022_ScoresHeader_CupPoints for Teams[0];
declare netread Integer Net_ChampionSpring2022_ScoresHeader_PointsUpdate for Teams[0];
declare netread Boolean Net_ChampionSpring2022_ScoresHeader_MatchComplete for Teams[0];
declare netread Integer Net_ChampionSpring2022_ScoresHeader_MatchType for Teams[0];
declare netread Boolean Net_ChampionSpring2022_ScoresHeader_Enabled for Teams[0];

declare K_State State;
declare Boolean DisplayModule;
declare Boolean WarmUpIsActive;
declare Boolean PauseIsActive;
declare Boolean LocalIsVisible;
declare Integer NextRefreshTime;
declare Integer MatchPointsLimit;
declare Integer CupPointsLimit;
declare Integer PointsUpdate;
declare Boolean MatchComplete;
declare Integer MatchWinnersUpdate;
declare Integer MatchType;
declare Boolean ScoresHeaderEnabled;
***

***MainStart***
***
Frame_Global <=> (Page.GetFirstChild("frame-global") as CMlFrame);

State.Controls.Frame_Spectator <=> (Frame_Global.GetFirstChild("frame-spectator") as CMlFrame);
State.Controls.Frame_Versus <=> (State.Controls.Frame_Spectator.GetFirstChild("frame-versus") as CMlFrame);
State.Controls.Frame_Multi <=> (State.Controls.Frame_Spectator.GetFirstChild("frame-multi") as CMlFrame);
State.Controls.Quad_MatchLogo <=> (State.Controls.Frame_Spectator.GetFirstChild("quad-match-logo") as CMlQuad);

DisplayModule = Frame_Global.Visible;
WarmUpIsActive = WarmupHelpers::IsWarmupActive(Teams[0]);
PauseIsActive = {{{Shared::P}}}IsPause();
LocalIsVisible = LocalIsVisible();
NextRefreshTime = Now;
MatchPointsLimit = {{{Shared::P}}}GetMatchPointsLimit();
CupPointsLimit = {{{Shared::P}}}GetCupPointsLimit();
PointsUpdate = Net_ChampionSpring2022_ScoresHeader_PointsUpdate;
MatchComplete = Net_ChampionSpring2022_ScoresHeader_MatchComplete;
MatchWinnersUpdate = {{{Shared::P}}}GetMatchWinnersUpdate();
MatchType = Net_ChampionSpring2022_ScoresHeader_MatchType;
ScoresHeaderEnabled = Net_ChampionSpring2022_ScoresHeader_Enabled;

State = UpdateVisibility(State, LocalIsVisible, WarmUpIsActive, PauseIsActive, ScoresHeaderEnabled);
State = UpdatePoints(
	State,
	Net_ChampionSpring2022_ScoresHeader_MatchPoints,
	MatchPointsLimit,
	Net_ChampionSpring2022_ScoresHeader_CupPoints,
	CupPointsLimit,
	{{{Shared::P}}}GetMatchWinners(),
	MatchComplete
);
UpdateMatchType(State, MatchType);
***

***MainLoop***
***
if (PageIsVisible) {
	if (DisplayModule != Net_ChampionSpring2022_ScoresHeader_IsVisible) {
		DisplayModule = Net_ChampionSpring2022_ScoresHeader_IsVisible;
		Frame_Global.Visible = DisplayModule;
	}

	if (Frame_Global.Visible) {
		if (
			WarmUpIsActive != WarmupHelpers::IsWarmupActive(Teams[0]) ||
			PauseIsActive != {{{Shared::P}}}IsPause() ||
			LocalIsVisible != LocalIsVisible() ||
			ScoresHeaderEnabled != Net_ChampionSpring2022_ScoresHeader_Enabled
		) {
			WarmUpIsActive = WarmupHelpers::IsWarmupActive(Teams[0]);
			PauseIsActive = {{{Shared::P}}}IsPause();
			LocalIsVisible = LocalIsVisible();
			ScoresHeaderEnabled = Net_ChampionSpring2022_ScoresHeader_Enabled;
			State = UpdateVisibility(State, LocalIsVisible, WarmUpIsActive, PauseIsActive, ScoresHeaderEnabled);
		}

		if (State.IsVisible && Now >= NextRefreshTime) {
			NextRefreshTime = Now + C_RefreshInterval;

			if (
				MatchPointsLimit != {{{Shared::P}}}GetMatchPointsLimit() ||
				CupPointsLimit != {{{Shared::P}}}GetCupPointsLimit() ||
				PointsUpdate != Net_ChampionSpring2022_ScoresHeader_PointsUpdate ||
				MatchComplete != Net_ChampionSpring2022_ScoresHeader_MatchComplete ||
				MatchWinnersUpdate != {{{Shared::P}}}GetMatchWinnersUpdate()
			) {
				MatchPointsLimit = {{{Shared::P}}}GetMatchPointsLimit();
				CupPointsLimit = {{{Shared::P}}}GetCupPointsLimit();
				PointsUpdate = Net_ChampionSpring2022_ScoresHeader_PointsUpdate;
				MatchComplete = Net_ChampionSpring2022_ScoresHeader_MatchComplete;
				MatchWinnersUpdate = {{{Shared::P}}}GetMatchWinnersUpdate();
				State = UpdatePoints(
					State,
					Net_ChampionSpring2022_ScoresHeader_MatchPoints,
					MatchPointsLimit,
					Net_ChampionSpring2022_ScoresHeader_CupPoints,
					CupPointsLimit,
					{{{Shared::P}}}GetMatchWinners(),
					MatchComplete
				);
			}

			if (MatchType != Net_ChampionSpring2022_ScoresHeader_MatchType) {
				MatchType = Net_ChampionSpring2022_ScoresHeader_MatchType;
				UpdateMatchType(State, MatchType);
			}
		}
	}
}
***
""",
[
	UIModules::Component(),
	UIModules_ScoresTable::Component(),
	PlayerProfiles::Component(),
	Shared::Component()
],
[]
	);
}