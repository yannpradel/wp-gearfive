/**
 *	UI module: LiveRanking client side
 */
#Const Version		"1.0.0"
#Const ScriptName "Libs/Nadeo/Trackmania/Modes/Teams_Matchmaking/UIModules/LiveRanking_Client.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/CMGame/Utils/ManiaView2.Script.txt" as MV
#Include "Libs/Nadeo/CMGame/Utils/Stylesheet.Script.txt" as Stylesheet
#Include "Libs/Nadeo/CMGame/Components/PlayerName.Script.txt" as PlayerName
#Include "Libs/Nadeo/Trackmania/MainMenu/Constants.Script.txt" as Constants
#Include "Libs/Nadeo/Trackmania/Modes/Teams_Matchmaking/Constants.Script.txt" as MM_Const
#Include "Libs/Nadeo/Trackmania/Modes/Teams_Matchmaking/UIModules/LiveRanking_Common.Script.txt" as UIModules_LiveRanking_Common
#Include "Libs/Nadeo/CMGame/Modes/UIModules_Client.Script.txt" as UIModules
#Include "Libs/Nadeo/Trackmania/Modes/Teams_Matchmaking/Components/RoundWinningTeam.Script.txt" as RoundWinningTeam

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_Id "UIModule_Teams_Matchmaking_LiveRanking"
#Const C_Type CUILayer::EUILayerType::Normal
#Const C_PlaceLostDeltaTime 3000
#Const C_PlayersNb 16 //< Number of players displayed in the ranking, should be the same in mode main script

#Const C_RankingMode_BestRace 0
#Const C_RankingMode_CurrentRace 1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Public
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the id of the UI module
Text GetId() {
	return UIModules_LiveRanking_Common::C_Id;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the type of layer of the UI module
CUILayer::EUILayerType GetLayerType() {
	return UIModules_LiveRanking_Common::C_LayerType;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the module manialink
 *
 *	@return														The module manialink
 */
Text GetML() {
	// Colors used in layer
	declare Text Color_WarmUp = Stylesheet::GetColorHex6(Stylesheet::C_Color_WarmUp);

	//L16N [Teams Matchmaking] Text displayed beside players that retired from the race
	declare Text Text_DNF = _("|DidNotFinish|DNF");
	//L16N [Teams Matchmaking] Text displayed before the name of the MVP
	declare Text Text_MVP = _("Most valuable player");

	declare Real PlayerMarginY = 4.66;
	declare Real PlayerLineSizeY = 4.66;
	declare Vec2 FramePlayersPos = <-159.3, 60.5>;
	declare Real ButtonNameFocusOpacity = 0.90;
	declare Text ML_Players = "";
	for (I, 0, C_PlayersNb - 1) {
		declare Real PosY = I * -PlayerMarginY;
		ML_Players ^= """<frameinstance pos="0 {{{PosY}}}" modelid="framemodel-player" />""";
	}

	return MV::Create(
C_Id, 3,
"""
<stylesheet>
	<style class="text-default" textsize="1" textcolor="ffffff" textfont="{{{Stylesheet::GetFont(Stylesheet::C_Font_Weight_ExtraBold)}}}" textprefix="$t$i" italicslope="0.2"/>
	<style class="text-number" textsize="1" textcolor="ffffff" textfont="{{{Stylesheet::GetFont(Stylesheet::C_Font_Weight_ExtraBold)}}}"/>
</stylesheet>
<framemodel id="framemodel-player">
	<frame z-index="1" id="frame-data">
		<label id="label-rank" pos="2.5 -0.25" size="6 4" halign="center" valign="center2" textsize="1.25" class="text-number"/>
		<quad id="quad-flag" pos="5.25 0" size="4 3" valign="center" opacity="1."/>
		<frameinstance id="playername-name" modelid="{{{PlayerName::C_Name}}}" pos="11 0" data-size="30 4" data-valign="center" data-textprefix="$t$i" data-textfont="{{{Stylesheet::GetFont(Stylesheet::C_Font_Weight_ExtraBold)}}}" data-textsize="1.25" />
		<label id="label-score" pos="47 -0.12" size="4.5 4" halign="right" valign="center2" textsize="1.25" class="text-number" textprefix="$t$i" italicslope="0.2"/>
		<label id="label-time" pos="61.66 0" size="12.5 4" halign="right" valign="center2" textsize="1.12" class="text-number" textprefix="$i" italicslope="0.2"/>
	</frame>
	<frame z-index="0" id="frame-background">
		<quad id="button-name" pos="-0.7 0" size="48.33 {{{PlayerLineSizeY}}}" valign="center" opacity="0" bgcolor="000" scriptevents="1" />
		<quad id="quad-time" pos="47.66 0" size="14.66 {{{PlayerLineSizeY}}}" valign="center" opacity="0.5" bgcolor="000"/>
		<quad id="quad-bg" pos="-0.7 0" size="48.33 {{{PlayerLineSizeY}}}" valign="center" opacity="0.7" bgcolor="000"/>
	</frame>
</framemodel>
<frame z-index="1" id="frame-global">
	<frame {{{UIModules::CustomizableUIModule(UIModules_LiveRanking_Common::C_UIModuleConfig)}}}>
		<frame size="320 180" halign="center" valign="center">
			<frame id="frame-cplive" pos="9.5 -25.66" scale="1.06">
				<frame pos="-160 74" z-index="0" id="frame-content">
					<frame id="frame-mvp">
						<quad id="quad-mvp-bg" size="48.33 {{{PlayerLineSizeY*2.}}}" bgcolor="000" opacity="0.7" z-index="-1"/>
						<quad pos="2 {{{-PlayerLineSizeY/2. - 0.5}}}" size="{{{PlayerLineSizeY}}} {{{PlayerLineSizeY}}}" colorize="{{{Stylesheet::GetColorHex6(Stylesheet::C_Color_AccentOne)}}}" halign="left" valign="center" image="{{{Constants::C_ImageUrl_Matchmaking_MVP_Icon}}}"/>
						<label pos="{{{3 + PlayerLineSizeY}}} {{{-PlayerLineSizeY/2. - 0.5}}}" size="39.25 {{{PlayerLineSizeY}}}" class="text-default" textcolor="{{{Stylesheet::GetColorHex6(Stylesheet::C_Color_AccentOne)}}}" text="{{{Text_MVP}}}" halign="left" valign="center"/>
						<frameinstance id="playername-mvp-name" modelid="{{{PlayerName::C_Name}}}" pos="2.25 {{{-PlayerLineSizeY - 2}}}" data-size="31 {{{PlayerLineSizeY}}}" data-valign="center" data-textprefix="$t$i" data-textfont="{{{Stylesheet::GetFont(Stylesheet::C_Font_Weight_ExtraBold)}}}" data-textsize="1.25" />
						<label id="label-mvp-points" pos="46.75 {{{-PlayerLineSizeY - 1.5}}}" size="12 {{{PlayerLineSizeY}}}" class="text-default" textcolor="fff" halign="right" valign="center"/>
					</frame>
					<frame id="frame-total-points" pos="24 -30" size="48.33 {{{PlayerLineSizeY*1.25}}}" halign="center" valign="center">
						<quad id="quad-total-points" size="{{{48.33 * 2.}}} {{{PlayerLineSizeY*1.25}}}" image="{{{Constants::C_ImageUrl_Matchmaking_Score_Matchpoint_LiveRanking}}}" opacity="0.75" z-index="-1" halign="center" valign="center"/>
						<label id="label-red-total-points" size="{{{48.33*0.2}}} {{{PlayerLineSizeY*1.25}}}" textcolor="fff" halign="center" valign="center2" class="text-number" textsize="3"/>
						<label id="label-blue-total-points" size="{{{48.33*0.2}}} {{{PlayerLineSizeY*1.25}}}" textcolor="fff" halign="center" valign="center2" class="text-number" textsize="3"/>
					</frame>
				</frame>
				<frame id="frame-players" pos="{{{FramePlayersPos.X}}} {{{FramePlayersPos.Y}}}" z-index="2">
					{{{ML_Players}}}
				</frame>
			</frame>
		</frame>
	</frame>
</frame>
""",
"""
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "ColorLib" as CL
#Include "Libs/Nadeo/CMGame/Utils/Platform.Script.txt" as Platform
#Include "Libs/Nadeo/CMGame/Utils/Tools.Script.txt" as Tools
#Include "Libs/Nadeo/CMGame/Modes/Bot.Script.txt" as Bot
#Include "Libs/Nadeo/TMGame/Modes/MV_Utils.Script.txt" as MV_Utils

#Const C_UpdateMaxFrequency 250
#Const C_Winners -1

#Const C_RankingMode_BestRace {{{dump(C_RankingMode_BestRace)}}}
#Const C_RankingMode_CurrentRace {{{dump(C_RankingMode_CurrentRace)}}}

#Const C_MvpUpdateFrequency 250
#Const C_CheckRacingPlayersFrequency 250

#Struct K_PlayerInfo {
	Text Login;
	Text WebServicesUserId;
	{{{PlayerName::P}}}K_UserInfo UserInfo;
	Integer Points;
	Integer RoundPoints;
	Integer Interval;
	Boolean Eliminated;
	Boolean FinishRace;
	Integer PrevRank;
	Integer CurRank;
	Integer TeamNum;
	Ident ScoreId;
	Boolean HasCrossedCp;
	Boolean IsFakeUser;
}
""",
"""
declare CMlFrame G_Frame_Players;

Text TimeToText(Integer _Time, Boolean _Full) {
	if (_Full) {
		return TL::TimeToText(_Time, True, True);
	}

	declare TimeInSeconds = _Time / 1000.;
	if (TimeInSeconds <= 10.) {
		return TL::FormatReal(TimeInSeconds, 3, False, False);
	} else if (TimeInSeconds <= 100.) {
		return TL::FormatReal(TimeInSeconds, 2, False, False);
	}
	return TL::ToText(ML::FloorInteger(TimeInSeconds));
}

Real GetRankPosY(Integer _Rank, Boolean _WarmUpIsActive) {
	return ((ML::Clamp(_Rank, 1, {{{C_PlayersNb}}}) - 1) * -{{{PlayerMarginY}}});
}

Void UpdateMvp(CMlFrame _Frame_Mvp, Text _MvpAccountId, Boolean _PlayAnim) {
	declare Quad_Bg <=> (_Frame_Mvp.GetFirstChild("quad-mvp-bg") as CMlQuad);
	declare PlayerName_Name <=> (_Frame_Mvp.GetFirstChild("playername-mvp-name") as CMlFrame);
	declare Label_Points <=> (_Frame_Mvp.GetFirstChild("label-mvp-points") as CMlLabel);

	declare TeamColor = <0.,0.,0.>;
	if (_MvpAccountId != "") {
		_Frame_Mvp.Show();
		foreach (Score in Scores) {
			if (Score != Null && Score.User != Null && Score.User.WebServicesUserId == _MvpAccountId) {
				{{{PlayerName::P}}}SetUser(This, PlayerName_Name, Score.User, False);
				PlayerName_Name.Visible = True;
				if (Score.Points < 0) Label_Points.Value = "";
				else if (Score.Points == 0) Label_Points.Value = _("0 points");
				else if (Score.Points == 1) Label_Points.Value = _("1 point");
				else Label_Points.Value = TL::Compose(_("%1 points"), ""^Score.Points);
				if (Score.TeamNum == 1) TeamColor = CL::Hex6ToRgb("{{{MM_Const::C_Color_Team_Blue_Bg}}}");
				else if (Score.TeamNum == 2) TeamColor = CL::Hex6ToRgb("{{{MM_Const::C_Color_Team_Red_Bg}}}");
				break;
			}
		}
		if (_PlayAnim) {
			_Frame_Mvp.RelativePosition_V3.X = -60.;
			AnimMgr.Flush(_Frame_Mvp);
			AnimMgr.Add(_Frame_Mvp, "<anim pos=\"0 "^_Frame_Mvp.RelativePosition_V3.Y^"\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
		}
	} else {
		_Frame_Mvp.Hide();
		PlayerName_Name.Visible = False;
		Label_Points.Value = "";
	}
	Quad_Bg.BgColor = TeamColor;
}

Void UpdateTeamsTotalPoints(Integer _RedTeamPoints, Integer _BlueTeamPoints) {
	declare Quad_Background <=> (Page.GetFirstChild("quad-total-points") as CMlQuad);
	declare Label_Red <=> (Page.GetFirstChild("label-red-total-points") as CMlLabel);
	declare Label_Blue <=> (Page.GetFirstChild("label-blue-total-points") as CMlLabel);

	declare TotalLength = 48.33;
	declare RedProportion = -1.;
	declare BlueProportion = -1.;
	if (_RedTeamPoints + _BlueTeamPoints > 0) {
		RedProportion = 1.*_RedTeamPoints / (1.*_RedTeamPoints + 1.*_BlueTeamPoints);
		BlueProportion = 1.*_BlueTeamPoints / (1.*_RedTeamPoints + 1.*_BlueTeamPoints);
		if (RedProportion < 0.2) {
			RedProportion = 0.2;
			BlueProportion = 0.8;
		} else if (BlueProportion < 0.2) {
			BlueProportion = 0.2;
			RedProportion = 0.8;
		}
		Label_Red.Value = ""^_RedTeamPoints;
		Label_Blue.Value = ""^_BlueTeamPoints;
		Label_Red.RelativePosition_V3.X = TotalLength * (RedProportion/2. - 0.5);
		Label_Blue.RelativePosition_V3.X = TotalLength * (RedProportion + BlueProportion/2. - 0.5);
		Quad_Background.Show();
	} else {
		Label_Red.Value = "";
		Label_Blue.Value = "";
		Quad_Background.Hide();
	}
	AnimMgr.Flush(Quad_Background);
	AnimMgr.Add(Quad_Background, "<frame pos=\""^TotalLength * (RedProportion - 0.5)^" "^Quad_Background.RelativePosition_V3.Y^"\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
}

Void UpdateLayout(Boolean _WarmUpIsActive) {
	foreach (Key => Control in G_Frame_Players.Controls) {
		declare Frame_Player <=> (Control as CMlFrame);
		declare Frame_Background <=> (Frame_Player.GetFirstChild("frame-background") as CMlFrame);
		declare Quad_Time <=> (Frame_Background.GetFirstChild("quad-time") as CMlQuad);

		if (_WarmUpIsActive) {
			Quad_Time.BgColor = CL::HexToRgb("{{{Color_WarmUp}}}");
		} else {
			Quad_Time.BgColor = <0.,0.,0.>;
		}
	}
}

Void UpdateRankings(
	Integer _RankingMode,
	Text[] _RaceFinished,
	Boolean _WarmUpIsActive,
	Integer[] _PointsRepartition
) {
	// Save current progress in the score
	foreach (Player in Players) {
		if (Player.Score != Null) {
			declare Boolean Teams_Matchmaking_LiveRanking_PlayerIsRacing for Player.Score = False;
			Teams_Matchmaking_LiveRanking_PlayerIsRacing = (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) && Player.StartTime > 0;

			declare Boolean Teams_Matchmaking_LiveRanking_IsSpectator for Player.Score = False;
			Teams_Matchmaking_LiveRanking_IsSpectator = Player.RequestsSpectate;
		}
	}

	// Add the winners at the top of the ranking in cup mode
	declare Integer[Ident][Integer] TmpRanking;

	// Create ranking
	declare Integer LatestCPTime = 0;
	declare Ident[Ident] ScoreIdToPlayerId;
	declare Integer MaxCheckpointIndex = 0;

	switch (_RankingMode) {
		case C_RankingMode_BestRace: {
			foreach (Score in Scores) {
				if (Score != Null) {
					declare Boolean Teams_Matchmaking_LiveRanking_IsSpectator for Score = False;
					if (Teams_Matchmaking_LiveRanking_IsSpectator) continue;

					if (Score.BestRaceTimes.count > 0) {
						if (!TmpRanking.existskey(Score.BestRaceTimes.count)) {
							TmpRanking[Score.BestRaceTimes.count] = [];
						}

						declare CheckpointTime = -1;
						if (Score.BestRaceTimes.count > 0) {
							CheckpointTime = Score.BestRaceTimes[Score.BestRaceTimes.count - 1];
						}
						TmpRanking[Score.BestRaceTimes.count][Score.Id] = CheckpointTime;

						if (CheckpointTime > LatestCPTime) LatestCPTime = CheckpointTime;
						if (Score.BestRaceTimes.count > MaxCheckpointIndex) MaxCheckpointIndex = Score.BestRaceTimes.count;
					} else {
						if (!TmpRanking.existskey(0)) {
							TmpRanking[0] = [];
						}
						TmpRanking[0][Score.Id] = -1;
					}
				}
			}
		}
		case C_RankingMode_CurrentRace: {
			//NB: in this case TmpRanking is a table containing every player's last CP time, sorted by CP number, then CP time.
			foreach (Player in Players) {
				if (Player.Score != Null) {
					declare Boolean Teams_Matchmaking_LiveRanking_IsSpectator for Player.Score = False;
					if (Teams_Matchmaking_LiveRanking_IsSpectator) continue;

					if (Player.RaceWaypointTimes.count > 0) {
						if (!TmpRanking.existskey(Player.RaceWaypointTimes.count)) {
							TmpRanking[Player.RaceWaypointTimes.count] = [];
						}

						declare CheckpointTime = -1;
						if (Player.RaceWaypointTimes.count > 0) {
							CheckpointTime = Player.RaceWaypointTimes[Player.RaceWaypointTimes.count - 1];
						}
						TmpRanking[Player.RaceWaypointTimes.count][Player.Score.Id] = CheckpointTime;

						if (CheckpointTime > LatestCPTime) LatestCPTime = CheckpointTime;
						if (Player.RaceWaypointTimes.count > MaxCheckpointIndex) MaxCheckpointIndex = Player.RaceWaypointTimes.count;
					} else {
						if (!TmpRanking.existskey(0)) {
							TmpRanking[0] = [];
						}
						TmpRanking[0][Player.Score.Id] = -1;
					}
					ScoreIdToPlayerId[Player.Score.Id] = Player.Id;
				}
			}
		}
	}

	TmpRanking = TmpRanking.sortkeyreverse();

	declare K_PlayerInfo[] Ranking;
	declare K_PlayerInfo[] DnfRanking;
	declare Boolean IsLeader = True;
	declare Ident LeaderId = NullId;
	declare Integer MinTimeDiff = 0;
	declare Ident[][] SpecialRankings;
	foreach (CheckpointKey => CheckpointTimes in TmpRanking) {
		declare SortedCheckpointTimes = CheckpointTimes.sort();
		declare Ident[] MissingInfo_ScoreIds;

		foreach (ScoreId => CheckpointTime in SortedCheckpointTimes) {
			declare Score <=> Scores[ScoreId];
			declare Boolean Teams_Matchmaking_LiveRanking_PlayerIsRacing for Score = False;
			declare Integer Teams_Matchmaking_LiveRanking_PrevRank for Score = 0;
			declare Integer NewRank = Ranking.count + 1;
			declare Integer TimeDiff = 0;
			declare HasCrossedCp = CheckpointKey != 0 || CheckpointTime >= 0;

			if (!_WarmUpIsActive) {
				// Save the checkpoint times of the leader
				if (IsLeader) {
					LeaderId = ScoreId;
					MinTimeDiff = 0;
					if (CheckpointTime >= 0) {
						TimeDiff = CheckpointTime;
					}
				}
				// Compute the time diff
				else {
					switch (_RankingMode) {
						case C_RankingMode_BestRace: {
							if (LeaderId != NullId && Scores[LeaderId].BestRaceTimes.existskey(CheckpointKey-1)) {
								declare CSmScore LeaderScore <=> Scores[LeaderId];
								declare Integer LeaderTimeAtCheckpoint = LeaderScore.BestRaceTimes[CheckpointKey-1];
								if (LeaderScore.BestRaceTimes.existskey(CheckpointKey)) {
									TimeDiff = ML::Max(CheckpointTime - LeaderTimeAtCheckpoint, LatestCPTime - LeaderScore.BestRaceTimes[CheckpointKey]);
								} else {
									TimeDiff = CheckpointTime - LeaderTimeAtCheckpoint;
								}
							} else {
								TimeDiff = 0;
							}
						}
						case C_RankingMode_CurrentRace: {
							if (
								LeaderId != NullId &&
								ScoreIdToPlayerId.existskey(LeaderId) &&
								Players.existskey(ScoreIdToPlayerId[LeaderId]) &&
								Players[ScoreIdToPlayerId[LeaderId]].RaceWaypointTimes.existskey(CheckpointKey - 1)
							) {
								declare CSmPlayer LeaderPlayer <=> Players[ScoreIdToPlayerId[LeaderId]];
								declare Integer LeaderTimeAtCheckpoint = LeaderPlayer.RaceWaypointTimes[CheckpointKey-1];
								if (LeaderPlayer.RaceWaypointTimes.existskey(CheckpointKey)) {
									TimeDiff = ML::Max(CheckpointTime - LeaderTimeAtCheckpoint, LatestCPTime - LeaderPlayer.RaceWaypointTimes[CheckpointKey]);
									if ((CheckpointTime - LeaderTimeAtCheckpoint) < 0) MissingInfo_ScoreIds.add(ScoreId);
								} else {
									TimeDiff = CheckpointTime - LeaderTimeAtCheckpoint;
									if (MissingInfo_ScoreIds.count > 1) SpecialRankings.add(MissingInfo_ScoreIds);
									MissingInfo_ScoreIds = [];
								}
							} else {
								TimeDiff = 0;
							}
						}
					}

					if (TimeDiff > MinTimeDiff) {
						MinTimeDiff = TimeDiff;
					} else {
						TimeDiff = MinTimeDiff;
					}
				}
			}

			declare Text Login = "";
			declare Text WebServicesUserId = "";
			declare {{{PlayerName::P}}}K_UserInfo UserInfo = {{{PlayerName::P}}}C_UserInfo_Null;
			declare Boolean FinishRace = False;
			declare Boolean IsFakeUser = False;
			if (Score.User != Null) {
				Login = Score.User.Login;
				WebServicesUserId = Score.User.WebServicesUserId;
				UserInfo = {{{PlayerName::P}}}GetUserInfo(Score.User, True);
				FinishRace = _RaceFinished.exists(Score.User.Login);
				IsFakeUser = Tools::IsFakeUser(Score.User);
			}

			// Add the player to the ranking
			if ( // Player is eliminated
				!Teams_Matchmaking_LiveRanking_PlayerIsRacing &&
				!FinishRace
			) {
				DnfRanking.add(K_PlayerInfo {
					Login = Login,
					WebServicesUserId = WebServicesUserId,
					UserInfo = UserInfo,
					Points = Score.RoundPoints,
					RoundPoints = Score.RoundPoints,
					Interval = TimeDiff,
					Eliminated = True,
					FinishRace = FinishRace,
					PrevRank = Teams_Matchmaking_LiveRanking_PrevRank,
					CurRank = -1,
					TeamNum = Score.TeamNum,
					ScoreId = ScoreId,
					HasCrossedCp = HasCrossedCp,
					IsFakeUser = IsFakeUser
				});
				Teams_Matchmaking_LiveRanking_PrevRank = -1;
			} else {
				Ranking.add(K_PlayerInfo {
					Login = Login,
					WebServicesUserId = WebServicesUserId,
					UserInfo = UserInfo,
					Points = Score.RoundPoints,
					RoundPoints = Score.RoundPoints,
					Interval = TimeDiff,
					Eliminated = False,
					FinishRace = FinishRace,
					PrevRank = Teams_Matchmaking_LiveRanking_PrevRank,
					CurRank = NewRank,
					TeamNum = Score.TeamNum,
					ScoreId = ScoreId,
					HasCrossedCp = HasCrossedCp,
					IsFakeUser = IsFakeUser
				});
				Teams_Matchmaking_LiveRanking_PrevRank = NewRank;
			}

			IsLeader = False;
		}

		if (MissingInfo_ScoreIds.count > 1) SpecialRankings.add(MissingInfo_ScoreIds);
		MissingInfo_ScoreIds = [];
	}

	/* Special Ranking to handle the case "A, B, C in this order at CPn-1, then C crosses CPn",
	 * before A or B crosses CPn we want to display
	 * "A: +[MinTimeDiff]",
	 * "B: +[MinTimeDiff + time between A and B at CPn-1]"
	 */
	if (SpecialRankings.count > 0) {
		declare Integer[Text] NewTimeDiffs; //AccountId => TimeDiff
		foreach (ScoreIds in SpecialRankings) {
			declare PreviousPlayerId = NullId;
			declare TimeDiffWithLeader = MinTimeDiff; // Cumulates time diff calculated between 2 players at each step
			foreach (ScoreId in ScoreIds) {
				if (ScoreIdToPlayerId.existskey(ScoreId) && Players.existskey(ScoreIdToPlayerId[ScoreId])) {
					declare Player <=> Players[ScoreIdToPlayerId[ScoreId]];
					if (PreviousPlayerId != NullId && Players.existskey(PreviousPlayerId)) {
						// Search for latest common CP
						declare PreviousPlayer <=> Players[PreviousPlayerId];
						declare LatestCommonCp = ML::Min(PreviousPlayer.RaceWaypointTimes.count, Player.RaceWaypointTimes.count) - 1;
						if (LatestCommonCp >= 0) {
							declare TimeDiffBetweenPlayers = Player.RaceWaypointTimes[LatestCommonCp] - PreviousPlayer.RaceWaypointTimes[LatestCommonCp];
							if (TimeDiffBetweenPlayers > 0) TimeDiffWithLeader += TimeDiffBetweenPlayers;
						}
						if (Player.User != Null) {
							NewTimeDiffs[Player.User.WebServicesUserId] = TimeDiffWithLeader;
						} else {
							NewTimeDiffs[""] = TimeDiffWithLeader;
						}
					}
					PreviousPlayerId = ScoreIdToPlayerId[ScoreId];
				}
			}
		}

		// The previous step may lead to unconsistencies in time diff, resolved here
		for (Index, 0, Ranking.count-1) {
			declare ReverseIndex = Ranking.count-1 - Index;
			declare RankingEntry = Ranking[ReverseIndex];
			if (NewTimeDiffs.existskey(RankingEntry.WebServicesUserId)) {
				declare NewInterval = NewTimeDiffs[RankingEntry.WebServicesUserId];
				if (
					Ranking.existskey(ReverseIndex + 1) &&
					Ranking[ReverseIndex + 1].Interval < NewInterval
				) {
					NewInterval = Ranking[ReverseIndex + 1].Interval;
				}
				Ranking[ReverseIndex].Interval = NewInterval;
			}
		}
	}

	// Put DNF players at the end of the ranking
	foreach (PlayerInfoReadOnly in DnfRanking) {
		declare PlayerInfo = PlayerInfoReadOnly;
		declare Integer NewRank = Ranking.count + 1;
		declare Score <=> Scores[PlayerInfoReadOnly.ScoreId];
		declare Integer Teams_Matchmaking_LiveRanking_PrevRank for Score = 0;
		Teams_Matchmaking_LiveRanking_PrevRank = NewRank;
		PlayerInfo.CurRank = NewRank;
		Ranking.add(PlayerInfo);
	}

	declare Integer TmpBlueRoundPoints = 0;
	declare Integer TmpRedRoundPoints = 0;
	// Update players list
	foreach (Key => Control in G_Frame_Players.Controls) {
		declare Frame_Player <=> (Control as CMlFrame);
		declare Frame_Background <=> (Frame_Player.GetFirstChild("frame-background") as CMlFrame);
		declare Button_Name <=> (Frame_Background.GetFirstChild("button-name") as CMlQuad);

		declare Text Teams_Matchmaking_LiveRanking_Login for Button_Name = "";

		if (Ranking.existskey(Key)) {
			declare PlayerInfo = Ranking[Key];
			declare Frame_Data <=> (Frame_Player.GetFirstChild("frame-data") as CMlFrame);
			declare Label_Rank <=> (Frame_Data.GetFirstChild("label-rank") as CMlLabel);
			declare Quad_Flag <=> (Frame_Data.GetFirstChild("quad-flag") as CMlQuad);
			declare PlayerName_Name <=> (Frame_Data.GetFirstChild("playername-name") as CMlFrame);
			declare Label_Score <=> (Frame_Data.GetFirstChild("label-score") as CMlLabel);
			declare Label_Time <=> (Frame_Data.GetFirstChild("label-time") as CMlLabel);
			declare Frame_PlayerBg <=> (Frame_Background.GetFirstChild("quad-bg") as CMlQuad);
			declare Button_Name <=> (Frame_Background.GetFirstChild("button-name") as CMlQuad);

			Label_Rank.Value = TL::ToText(Key + 1);
			if (PlayerInfo.IsFakeUser) {
				Quad_Flag.ImageUrl = Bot::GetCountryFlagUrl(PlayerInfo.UserInfo.Name);
			} else {
				Quad_Flag.ImageUrl = "file://ZoneFlags/Login/" ^ PlayerInfo.Login ^ "/country";
			}

			{{{PlayerName::P}}}SetUserInfo(This, PlayerName_Name, PlayerInfo.UserInfo);
			declare TeamColor = <0.,0.,0.>;
			declare PlayerPoints = 0;
			if (_PointsRepartition.count > 0) {
				if (_PointsRepartition.existskey(Key)) {
					PlayerPoints = _PointsRepartition[Key];
				} else {
					PlayerPoints = _PointsRepartition[_PointsRepartition.count - 1];
				}
			}
			if (PlayerInfo.TeamNum == 1) {
				TeamColor = CL::Hex6ToRgb("{{{MM_Const::C_Color_Team_Blue_Bg}}}");
				if (!PlayerInfo.Eliminated && PlayerInfo.Interval != 0) TmpBlueRoundPoints += PlayerPoints;
			}	else if (PlayerInfo.TeamNum == 2) {
				TeamColor = CL::Hex6ToRgb("{{{MM_Const::C_Color_Team_Red_Bg}}}");
				if (!PlayerInfo.Eliminated && PlayerInfo.Interval != 0) TmpRedRoundPoints += PlayerPoints;
			}
			Button_Name.BgColor = TeamColor;
			Frame_PlayerBg.BgColor = TeamColor;

			if (PlayerInfo.FinishRace && PlayerInfo.Points >= 0) {
				Label_Score.Value = "+"^TL::ToText(PlayerInfo.Points);
				Label_Score.TextColor = <1., 1., 1.>;
			} else {
				Label_Score.Value = "";
			}

			Tools::FitLabelValue(Label_Score, 2., 1.5, .25);

			if (_WarmUpIsActive) {
				Label_Time.Value = "";
			} else if (PlayerInfo.Eliminated) {
				Label_Time.Value = "{{{Text_DNF}}}";
			} else if (!PlayerInfo.HasCrossedCp) {
				Label_Time.Value = "-";
			} else if (Key == 0) {
				Label_Time.Value = TimeToText(PlayerInfo.Interval, True);
			} else if (Key > 0) {
				Label_Time.Value = "+"^TimeToText(PlayerInfo.Interval, False);
			} else {
				Label_Time.Value = "";
			}

			if (PlayerInfo.PrevRank > 0 && PlayerInfo.PrevRank != PlayerInfo.CurRank) {
				Frame_Player.RelativePosition_V3.Y = GetRankPosY(PlayerInfo.PrevRank, _WarmUpIsActive);
				declare Real PosY = GetRankPosY(PlayerInfo.CurRank, _WarmUpIsActive);
				AnimMgr.Flush(Frame_Player);
				AnimMgr.Add(Frame_Player, "<frame pos=\"0 "^PosY^"\" />", 200, CAnimManager::EAnimManagerEasing::QuadOut);
			} else {
				Frame_Player.RelativePosition_V3.Y = GetRankPosY(PlayerInfo.CurRank, _WarmUpIsActive);
			}

			Teams_Matchmaking_LiveRanking_Login = PlayerInfo.Login;

			Frame_Player.Visible = True;
		} else {
			Teams_Matchmaking_LiveRanking_Login = "";
			Frame_Player.Visible = False;
		}
	}

	// Update Points total
	declare Integer[Integer] TeamPoints;
	foreach (PlayerInfo in Ranking) {
		if (!TeamPoints.existskey(PlayerInfo.TeamNum)) TeamPoints[PlayerInfo.TeamNum] = 0;
		TeamPoints[PlayerInfo.TeamNum] += PlayerInfo.RoundPoints;
	}
	declare RedTeamPoints = 0;
	if (TeamPoints.existskey(1)) RedTeamPoints = TeamPoints[1];
	declare BlueTeamPoints = 0;
	if (TeamPoints.existskey(2)) BlueTeamPoints = TeamPoints[2];
	UpdateTeamsTotalPoints(RedTeamPoints, BlueTeamPoints);
	declare Frame_TotalPoints <=> (Page.GetFirstChild("frame-total-points") as CMlFrame);
	Frame_TotalPoints.RelativePosition_V3.Y = -2. - {{{PlayerLineSizeY}}} * (Ranking.count + 3);

	// Update round potential winning team
	declare Integer RoundCurrentWinningTeamId = -1;
	if (TmpBlueRoundPoints > TmpRedRoundPoints) RoundCurrentWinningTeamId = 0;
	else if (TmpRedRoundPoints > TmpBlueRoundPoints) RoundCurrentWinningTeamId = 1;
	{{{RoundWinningTeam::P}}}SetRoundWinningTeamId(RoundCurrentWinningTeamId);
}

Void SetSpecTarget(CSmPlayer _Target) {
	foreach (Key => Control in G_Frame_Players.Controls) {
		declare Frame_Player <=> (Control as CMlFrame);
		declare Frame_Data <=> (Frame_Player.GetFirstChild("frame-data") as CMlFrame);
		declare PlayerName_Name <=> (Frame_Data.GetFirstChild("playername-name") as CMlFrame);
		declare Frame_Background <=> (Frame_Player.GetFirstChild("frame-background") as CMlFrame);
		declare Button_Name <=> (Frame_Background.GetFirstChild("button-name") as CMlQuad);

		declare Text Teams_Matchmaking_LiveRanking_Login for Button_Name = "";
		if (_Target != Null && _Target.User != Null && Teams_Matchmaking_LiveRanking_Login == _Target.User.Login) {
			AnimMgr.Flush(Button_Name);
			AnimMgr.Add(Button_Name, "<quad opacity=\"{{{ButtonNameFocusOpacity}}}\" />", Now, 200, CAnimManager::EAnimManagerEasing::QuadOut);
			{{{PlayerName::P}}}SetTextColor(This, PlayerName_Name, {{{Stylesheet::GetColorRGB(Stylesheet::C_Color_AccentOne)}}});
		} else {
			AnimMgr.Flush(Button_Name);
			AnimMgr.Add(Button_Name, "<quad opacity=\"0.\" />", Now, 200, CAnimManager::EAnimManagerEasing::QuadOut);
			{{{PlayerName::P}}}SetTextColor(This, PlayerName_Name, {{{Stylesheet::GetColorRGB(Stylesheet::C_Color_TextLight)}}});
		}
	}
}

Boolean GetVisibility() {
	declare Boolean Teams_Matchmaking_LiveRanking_IsVisible for This = True;
	return Teams_Matchmaking_LiveRanking_IsVisible;
}

Void HideDuringIntro(CMlFrame _Frame) {
	if (_Frame == Null) return;

	declare IsIntro = (
		UI.UISequence == CUIConfig::EUISequence::Intro ||
		UI.UISequence == CUIConfig::EUISequence::RollingBackgroundIntro ||
		UI.UISequence == CUIConfig::EUISequence::Outro
	);

	if (_Frame.Visible && IsIntro) {
		_Frame.Visible = False;
	} else if (!_Frame.Visible && !IsIntro) {
		_Frame.Visible = True;
	}
}

***MainInit***
***
declare CMlFrame Frame_Global;
declare CMlFrame Frame_CpLive;
declare CMlFrame Frame_Content;
declare CMlFrame Frame_Mvp;

declare netread Integer Net_Teams_Matchmaking_LiveRanking_TriggerUIUpdate for Teams[0] = 0;
declare netread Integer Net_Teams_Matchmaking_LiveRanking_StartNewRace for Teams[0] = 0;
declare netread Boolean Net_Teams_Matchmaking_LiveRanking_WarmUpIsActive for Teams[0] = False;
declare netread Text Net_Teams_Matchmaking_LiveRanking_MvpAccountId for Teams[0];
declare netread Integer Net_Teams_Matchmaking_LiveRanking_RankingMode for Teams[0];
declare netread Text[] Net_Teams_Matchmaking_LiveRanking_PlayerFinishedRace for Teams[0];
declare netread Integer Net_Teams_Matchmaking_LiveRanking_PlayerFinishedRaceUpdate for Teams[0];

declare netread Integer[] Net_Teams_Matchmaking_LiveRanking_PointsRepartition for Teams[0];

declare Boolean DisplayModule;
declare Integer TriggerUIUpdate;
declare Integer NextRankingUpdate;
declare Integer StartNewRace;
declare Boolean WarmUpIsActive;
declare Ident SpecTargetId;
declare Text MvpAccountId;
declare Integer UpdateMvpPointsTime;
declare Text[] RaceFinished;
declare Integer PlayerFinishedRaceUpdate;
declare Integer CheckRacingPlayersTime;

declare Integer[Text] PrevBestRaceTimesCounts;
***

***MainStart***
***
Frame_Global <=> (Page.GetFirstChild("frame-global") as CMlFrame);
Frame_CpLive <=> (Frame_Global.GetFirstChild("frame-cplive") as CMlFrame);
Frame_Content <=> (Frame_Global.GetFirstChild("frame-content") as CMlFrame);
Frame_Mvp <=> (Frame_Global.GetFirstChild("frame-mvp") as CMlFrame);
G_Frame_Players <=> (Frame_Global.GetFirstChild("frame-players") as CMlFrame);

DisplayModule = Frame_Global.Visible;
TriggerUIUpdate = -123;
NextRankingUpdate = -1;
StartNewRace = -123;
WarmUpIsActive = False;
SpecTargetId = NullId;
MvpAccountId = Net_Teams_Matchmaking_LiveRanking_MvpAccountId;
UpdateMvpPointsTime = Now;
RaceFinished = [];
PlayerFinishedRaceUpdate = -123;

SetSpecTarget(Null);

// On Sony consoles every player names must be in the safe area
// see: /trackmania-next/tmnext/-/issues/4660
if (Platform::IsSony(System)) {
	Frame_Global.GetFirstChild("{{{UIModules::GetCustomizableUIModuleFrameId(UIModules_LiveRanking_Common::C_UIModuleConfig)}}}").RelativePosition_V3 = <16., 0.>;
}
***

***MainLoop***
***
declare Owner <=> MV_Utils::GetOwner(This);
if (Owner != Null) {
	declare netread Boolean Net_Teams_Matchmaking_LiveRanking_IsVisible for Owner;
	if (DisplayModule != Net_Teams_Matchmaking_LiveRanking_IsVisible) {
		DisplayModule = Net_Teams_Matchmaking_LiveRanking_IsVisible;
		Frame_Global.Visible = Net_Teams_Matchmaking_LiveRanking_IsVisible;
		if (Frame_Global.Visible) CheckRacingPlayersTime = Now;
	}
}

if (PageIsVisible && Frame_Global.Visible) {
	HideDuringIntro(Frame_CpLive);

	if (UpdateMvpPointsTime <= Now || MvpAccountId != Net_Teams_Matchmaking_LiveRanking_MvpAccountId) {
		UpdateMvpPointsTime = Now + C_MvpUpdateFrequency;
		UpdateMvp(Frame_Mvp, Net_Teams_Matchmaking_LiveRanking_MvpAccountId, (MvpAccountId == "" && Net_Teams_Matchmaking_LiveRanking_MvpAccountId != ""));
		MvpAccountId = Net_Teams_Matchmaking_LiveRanking_MvpAccountId;
	}

	if (WarmUpIsActive != Net_Teams_Matchmaking_LiveRanking_WarmUpIsActive) {
		WarmUpIsActive = Net_Teams_Matchmaking_LiveRanking_WarmUpIsActive;

		UpdateLayout(WarmUpIsActive);
		if (NextRankingUpdate < 0) NextRankingUpdate = Now + C_UpdateMaxFrequency;
	}

	if (TriggerUIUpdate != Net_Teams_Matchmaking_LiveRanking_TriggerUIUpdate) {
		TriggerUIUpdate = Net_Teams_Matchmaking_LiveRanking_TriggerUIUpdate;
		if (NextRankingUpdate < 0) NextRankingUpdate = Now + C_UpdateMaxFrequency;
	}

	// Check player spawn status and start time to update LiveRanking more frequently
	if (CheckRacingPlayersTime <= Now) {
		declare Boolean UpdateInPlayersRacing = False;
		foreach (Player in Players) {
			if (Player.Score != Null) {
				declare Boolean Teams_Matchmaking_LiveRanking_PlayerIsRacing for Player.Score = False;
				if (Teams_Matchmaking_LiveRanking_PlayerIsRacing != (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned && Player.StartTime > 0)) {
					Teams_Matchmaking_LiveRanking_PlayerIsRacing = (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned && Player.StartTime > 0);
					UpdateInPlayersRacing = True;
				}
			}
		}
		if (UpdateInPlayersRacing && NextRankingUpdate < 0) {
			NextRankingUpdate = Now + C_UpdateMaxFrequency;
		}
		CheckRacingPlayersTime = Now + C_CheckRacingPlayersFrequency;
	}

	if (GUIPlayer == Null && SpecTargetId != NullId) {
		SpecTargetId = NullId;
		SetSpecTarget(Null);
	} else if (GUIPlayer != Null && SpecTargetId != GUIPlayer.Id) {
		SpecTargetId = GUIPlayer.Id;
		SetSpecTarget(GUIPlayer);
	}

	foreach (Event in PendingEvents) {
		switch (Event.Type) {
			case CMlScriptEvent::Type::MouseClick : {
				if (Event.ControlId == "button-name") {
					declare Text Teams_Matchmaking_LiveRanking_Login for Event.Control = "";
					if (Teams_Matchmaking_LiveRanking_Login != "") {
						ClientUI.Spectator_SetForcedTarget_Clear();
						SetSpectateTarget(Teams_Matchmaking_LiveRanking_Login);
						Playground.SetWantedSpectatorCameraType(CPlaygroundClient::ESpectatorCameraType::Replay);
					}
				}
			}
			case CMlScriptEvent::Type::MouseOver: {
				if (Event.ControlId == "button-name") {
					declare Text Teams_Matchmaking_LiveRanking_Login for Event.Control = "";
					if (Teams_Matchmaking_LiveRanking_Login != "") (Event.Control as CMlQuad).Opacity = {{{ButtonNameFocusOpacity}}};
				}
			}
			case CMlScriptEvent::Type::MouseOut: {
				if (Event.ControlId == "button-name") {
					declare Text Teams_Matchmaking_LiveRanking_Login for Event.Control = "";
					if (
						Teams_Matchmaking_LiveRanking_Login == "" ||
						GUIPlayer == Null ||
						GUIPlayer.User == Null ||
						GUIPlayer.User.Login != Teams_Matchmaking_LiveRanking_Login
					) {
						(Event.Control as CMlQuad).Opacity = 0.;
					}
				}
			}
		}
	}

	if (G_Frame_Players.Visible && NextRankingUpdate > 0 && Now >= NextRankingUpdate) {
		UpdateRankings(
			Net_Teams_Matchmaking_LiveRanking_RankingMode,
			RaceFinished,
			WarmUpIsActive,
			Net_Teams_Matchmaking_LiveRanking_PointsRepartition
		);
		SetSpecTarget(GUIPlayer); //< We need to update the spec target if they moved up or down the ranking
		NextRankingUpdate = -1;
	}
}

if (StartNewRace != Net_Teams_Matchmaking_LiveRanking_StartNewRace) {
	StartNewRace = Net_Teams_Matchmaking_LiveRanking_StartNewRace;
	RaceFinished = [];
	PrevBestRaceTimesCounts = [];
	if (NextRankingUpdate < 0) NextRankingUpdate = Now + C_UpdateMaxFrequency;
}

if (PlayerFinishedRaceUpdate != Net_Teams_Matchmaking_LiveRanking_PlayerFinishedRaceUpdate) {
	PlayerFinishedRaceUpdate = Net_Teams_Matchmaking_LiveRanking_PlayerFinishedRaceUpdate;
	RaceFinished = Net_Teams_Matchmaking_LiveRanking_PlayerFinishedRace;
	if (NextRankingUpdate < 0) NextRankingUpdate = Now + C_UpdateMaxFrequency;
}

switch (Net_Teams_Matchmaking_LiveRanking_RankingMode) {
	case C_RankingMode_BestRace: {
		foreach (Score in Scores) {
			if (Score == Null || Score.User == Null) continue;
			if (!PrevBestRaceTimesCounts.existskey(Score.User.Login)) {
				PrevBestRaceTimesCounts[Score.User.Login] = 0;
				if (NextRankingUpdate < 0) NextRankingUpdate = Now + C_UpdateMaxFrequency;
			}
			if (PrevBestRaceTimesCounts[Score.User.Login] != Score.BestRaceTimes.count) {
				PrevBestRaceTimesCounts[Score.User.Login] = Score.BestRaceTimes.count;
				if (NextRankingUpdate < 0) NextRankingUpdate = Now + C_UpdateMaxFrequency;
			}
		}
	}
	case C_RankingMode_CurrentRace: {
		foreach (Player in Players) {
			if (Player.User == Null) continue;
			if (!PrevBestRaceTimesCounts.existskey(Player.User.Login)) {
				PrevBestRaceTimesCounts[Player.User.Login] = 0;
				if (NextRankingUpdate < 0) NextRankingUpdate = Now + C_UpdateMaxFrequency;
			}
			if (PrevBestRaceTimesCounts[Player.User.Login] != Player.RaceWaypointTimes.count) {
				PrevBestRaceTimesCounts[Player.User.Login] = Player.RaceWaypointTimes.count;
				if (NextRankingUpdate < 0) NextRankingUpdate = Now + C_UpdateMaxFrequency;
			}
		}
	}
}

***
""",
[
	UIModules::Component(),
	RoundWinningTeam::Component(),
	PlayerName::ComponentV2()
],
[]
	);
}