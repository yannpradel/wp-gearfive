/**
 * Manialink effects
 */
#Const Version		"1.0.0"
#Const ScriptName	"MLEffects.Script.txt"

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_LibPrefix			"LibMLEffects_"	///< Prefix for the library functions
#Const C_LibMLClass 		"lib-ml-effects"	///< Class used to detect the controls used by the library
/// Data properties
#Const C_Data_Triggers	"data-lib-ml-effects-triggers"
#Const C_Data_Effects		"data-lib-ml-effects-effects"
#Const C_Data_Group			"data-lib-ml-effects-group"
#Const C_DataShort_Triggers	"lib-ml-effects-triggers"
#Const C_DataShort_Effects	"lib-ml-effects-effects"
#Const C_DataShort_Group		"lib-ml-effects-group"
/// Effects
#Const C_Effect_QuadHover	0 // Sets opacity to 1. From TM2020. Used to be "LabelHover", from Turbo.
#Const C_Effect_QuadHover2	1 // Sets opacity to 0.85. Simulates two juxtaposed 0.6 values

// ---------------------------------- //
// Globales
// ---------------------------------- //

// ---------------------------------- //
// Functions
// ---------------------------------- //
// ---------------------------------- //
/// Get the data constants
Text Data_Triggers() { return C_Data_Triggers; }
Text Data_Effects() { return C_Data_Effects; }
Text Data_Group() { return C_Data_Group; }

// ---------------------------------- //
/// Get the effect constants
Integer Effect_QuadHover() { return C_Effect_QuadHover; }
Integer Effect_QuadHover2() { return C_Effect_QuadHover2; }

// ---------------------------------- //
/** Inject the necessary libraries into the manialink
 *
 *	@return													The libraries
 */
Text ML_Includes() {
	return """#Include "TextLib" as LibMLE_TL""";
}

// ---------------------------------- //
/** Inject the code of the library in the manialink
 *
 *	@return													The code of the library
 */
Text ML_Functions(Text _LibPrefix) {
	return """
declare Integer[][CMlControl][Text] {{{_LibPrefix}}}G_Effects;

Void {{{_LibPrefix}}}Effect_{{{C_Effect_QuadHover}}}(CMlControl _Control, CMlScriptEvent::Type _EventType) {
	if (!(_Control is CMlQuad)) return;
	declare Quad <=> (_Control as CMlQuad);

	declare {{{_LibPrefix}}}_OriginalOpacity for Quad = -1.;
	if ({{{_LibPrefix}}}_OriginalOpacity == -1.) {
		{{{_LibPrefix}}}_OriginalOpacity = Quad.Opacity;
	}

	switch (_EventType) {
		case CMlScriptEvent::Type::MouseOver: {
			Quad.Opacity = 1.;
		}
		case CMlScriptEvent::Type::MouseOut: {
			Quad.Opacity = {{{_LibPrefix}}}_OriginalOpacity;
			{{{_LibPrefix}}}_OriginalOpacity = -1.;
		}
	}
}
Void {{{_LibPrefix}}}Effect_{{{C_Effect_QuadHover2}}}(CMlControl _Control, CMlScriptEvent::Type _EventType) {
	if (!(_Control is CMlQuad)) return;
	declare Quad <=> (_Control as CMlQuad);

	declare {{{_LibPrefix}}}_OriginalOpacity for Quad = -1.;
	if ({{{_LibPrefix}}}_OriginalOpacity == -1.) {
		{{{_LibPrefix}}}_OriginalOpacity = Quad.Opacity;
	}

	switch (_EventType) {
		case CMlScriptEvent::Type::MouseOver: {
			Quad.Opacity = .85;
		}
		case CMlScriptEvent::Type::MouseOut: {
			Quad.Opacity = {{{_LibPrefix}}}_OriginalOpacity;
			{{{_LibPrefix}}}_OriginalOpacity = -1.;
		}
	}
}

Void {{{_LibPrefix}}}Private_CancelEffect(CMlControl _Control, Integer _Effect) {
	switch (_Effect) {
		case {{{C_Effect_QuadHover}}}: {
			{{{_LibPrefix}}}Effect_{{{C_Effect_QuadHover}}}(_Control, CMlScriptEvent::Type::MouseOut);
		}
		case {{{C_Effect_QuadHover2}}}: {
			{{{_LibPrefix}}}Effect_{{{C_Effect_QuadHover2}}}(_Control, CMlScriptEvent::Type::MouseOut);
		}
	}
}

Void {{{_LibPrefix}}}Private_ActiveEffect(CMlControl _Control, Integer _Effect, CMlScriptEvent::Type _EventType) {
	if (_Control == Null) return;
	declare {{{_LibPrefix}}}_EffectsEnabled for _Control = True;
	if (!{{{_LibPrefix}}}_EffectsEnabled) return;

	switch (_Effect) {
		case {{{C_Effect_QuadHover}}}: {
			{{{_LibPrefix}}}Effect_{{{C_Effect_QuadHover}}}(_Control, _EventType);
		}
		case {{{C_Effect_QuadHover2}}}: {
			{{{_LibPrefix}}}Effect_{{{C_Effect_QuadHover2}}}(_Control, _EventType);
		}
	}
}

Void {{{_LibPrefix}}}Private_ActiveTrigger(CMlScriptEvent::Type _EventType, Text _TriggerId) {
	if (!{{{_LibPrefix}}}G_Effects.existskey(_TriggerId)) return;
	declare Controls = {{{_LibPrefix}}}G_Effects[_TriggerId];
	foreach (Control => Effects in Controls) {
		foreach (Effect in Effects) {
			{{{_LibPrefix}}}Private_ActiveEffect(Control, Effect, _EventType);
		}
	}
}

Void {{{_LibPrefix}}}Init() {
	Page.GetClassChildren("{{{C_LibMLClass}}}", Page.MainFrame, True);
	declare CMlFrame[] Frames_Group;
	foreach (Control in Page.GetClassChildren_Result) {
		declare NotAReference = Control;
		if (NotAReference is CMlFrame) {
			declare GroupId = NotAReference.DataAttributeGet("{{{C_DataShort_Group}}}");
			if (GroupId != "") {
				Frames_Group.add((NotAReference as CMlFrame));
			}
		}
	}
	foreach (Frame_Group in Frames_Group) {
		declare GroupId = Frame_Group.DataAttributeGet("{{{C_DataShort_Group}}}");
		Page.GetClassChildren("{{{C_LibMLClass}}}", Frame_Group, True);
		foreach (Control in Page.GetClassChildren_Result) {
			declare Effects = Control.DataAttributeGet("{{{C_DataShort_Effects}}}");
			if (Effects != "") {
				declare NewEffects = "";
				declare EffectsArray = LibMLE_TL::Split(",", Effects);
				foreach (TriggerEffect in EffectsArray) {
					declare TriggerEffectArray = LibMLE_TL::Split(":", TriggerEffect);
					if (TriggerEffectArray.count < 2) continue;
					NewEffects ^= TriggerEffectArray[0]^GroupId^":"^TriggerEffectArray[1];
				}
				Control.DataAttributeSet("{{{C_DataShort_Effects}}}", NewEffects);
			}
			declare Triggers = Control.DataAttributeGet("{{{C_DataShort_Triggers}}}");
			if (Triggers != "") {
				declare NewTriggers = "";
				declare TriggersArray = LibMLE_TL::Split(",", Triggers);
				foreach (Trigger in TriggersArray) {
					if (NewTriggers != "") NewTriggers ^= ",";
					NewTriggers ^= Trigger^GroupId;
				}
				Control.DataAttributeSet("{{{C_DataShort_Triggers}}}", NewTriggers);
			}
		}
	}

	Page.GetClassChildren("{{{C_LibMLClass}}}", Page.MainFrame, True);
	foreach (Control in Page.GetClassChildren_Result) {
		declare NotAReference = Control;
		declare Effects = NotAReference.DataAttributeGet("{{{C_DataShort_Effects}}}");
		if (Effects != "") {
			declare EffectsArray = LibMLE_TL::Split(",", Effects);
			foreach (TriggerEffect in EffectsArray) {
				declare TriggerEffectArray = LibMLE_TL::Split(":", TriggerEffect);
				if (TriggerEffectArray.count < 2) continue;
				declare Trigger = TriggerEffectArray[0];
				declare Effect = LibMLE_TL::ToInteger(TriggerEffectArray[1]);
				if (!{{{_LibPrefix}}}G_Effects.existskey(Trigger)) {
					{{{_LibPrefix}}}G_Effects[Trigger] = Integer[][CMlControl];
				}
				if (!{{{_LibPrefix}}}G_Effects[Trigger].existskey(NotAReference)) {
					{{{_LibPrefix}}}G_Effects[Trigger][NotAReference] = Integer[];
				}
				if (!{{{_LibPrefix}}}G_Effects[Trigger][NotAReference].exists(Effect)) {
					{{{_LibPrefix}}}G_Effects[Trigger][NotAReference].add(Effect);
				}
			}
		}
		declare Triggers = NotAReference.DataAttributeGet("{{{C_DataShort_Triggers}}}");
		if (Triggers != "") {
			declare {{{_LibPrefix}}}TriggersArray for NotAReference = Text[];
			{{{_LibPrefix}}}TriggersArray = LibMLE_TL::Split(",", Triggers);
		}
	}
}

Void {{{_LibPrefix}}}Loop() {
	declare Text[][CMlScriptEvent::Type] Triggered;
	foreach (Event in PendingEvents) {
		if (Event.Control == Null || !Event.Control.HasClass("{{{C_LibMLClass}}}")) continue;
		declare {{{_LibPrefix}}}_TriggersEnabled for Event.Control = True;
		if ({{{_LibPrefix}}}_TriggersEnabled) {
			declare Triggers = Event.Control.DataAttributeGet("{{{C_DataShort_Triggers}}}");
			if (Triggers != "") {
				declare TriggersArray = LibMLE_TL::Split(",", Triggers);
				foreach (Trigger in TriggersArray) {
					if (!Triggered.existskey(Event.Type)) Triggered[Event.Type] = Text[];
					if (!Triggered[Event.Type].exists(Trigger)) Triggered[Event.Type].add(Trigger);
				}
			}
		}
	}
	foreach (EventType => Triggers in Triggered) {
		foreach (Trigger in Triggers) {
			{{{_LibPrefix}}}Private_ActiveTrigger(EventType, Trigger);
		}
	}
}

Void {{{_LibPrefix}}}EnableEffects(CMlControl _Control, Boolean _Enable) {
	if (_Control == Null) return;
	declare {{{_LibPrefix}}}_EffectsEnabled for _Control = True;
	{{{_LibPrefix}}}_EffectsEnabled = _Enable;

	if (!_Enable) {
		foreach (Trigger => Controls in {{{_LibPrefix}}}G_Effects) {
			if (!Controls.existskey(_Control)) continue;
			foreach (Control => Effects in Controls) {
				foreach (Effect in Effects) {
					{{{_LibPrefix}}}Private_CancelEffect(Control, Effect);
				}
			}
		}
	}
}

Void {{{_LibPrefix}}}EnableEffects(CMlControl _Control) {
	{{{_LibPrefix}}}EnableEffects(_Control, True);
}

Void {{{_LibPrefix}}}DisableEffects(CMlControl _Control) {
	{{{_LibPrefix}}}EnableEffects(_Control, False);
}

Void {{{_LibPrefix}}}EnableTriggers(CMlControl _Control, Boolean _Enable) {
	if (_Control == Null) return;
	declare {{{_LibPrefix}}}_TriggersEnabled for _Control = True;
	{{{_LibPrefix}}}_TriggersEnabled = _Enable;

	if (!_Enable) {
		declare {{{_LibPrefix}}}TriggersArray for _Control = Text[];
		foreach (TriggerToDisable in {{{_LibPrefix}}}TriggersArray) {
			if (!{{{_LibPrefix}}}G_Effects.existskey(TriggerToDisable)) continue;
			declare Controls = {{{_LibPrefix}}}G_Effects[TriggerToDisable];
			foreach (Control => Effects in Controls) {
				foreach (Effect in Effects) {
					{{{_LibPrefix}}}Private_CancelEffect(Control, Effect);
				}
			}
		}
	}
}

Void {{{_LibPrefix}}}EnableTriggers(CMlControl _Control) {
	{{{_LibPrefix}}}EnableTriggers(_Control, True);
}

Void {{{_LibPrefix}}}DisableTriggers(CMlControl _Control) {
	{{{_LibPrefix}}}EnableTriggers(_Control, False);
}
""";
}

// ---------------------------------- //
/** Inject the code of the library in the manialink
 *
 *	@return													The code of the library
 */
Text ML_Functions() {
	return ML_Functions(C_LibPrefix);
}

// ---------------------------------- //
/** Get the class used to mark the controls affected by the library
 *
 *	@return													The class
 */
Text ML_Class() {
	return C_LibMLClass;
}

// ---------------------------------- //
/// Unload the library
Void Unload() {

}

// ---------------------------------- //
/// Load the library
Void Load() {
	Unload();
}