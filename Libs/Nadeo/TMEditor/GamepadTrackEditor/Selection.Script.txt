/**
 * Selection library
 */

#Const Version		"1.0.0"
#Const ScriptName	"Selection.Script.txt"

#Include "MathLib" as ML
#Include "Libs/Nadeo/TMEditor/GamepadTrackEditor/UI/MouseControl.Script.txt" as UI_MouseControl

declare Boolean G_LibSelection_Selecting;
declare Int3 G_LibSelection_StartCoord;
declare Int3 G_LibSelection_EndCoord;

Void Private_Draw() {
	declare Int3 Max;
	declare Int3 Min;

	Max = <
		ML::Max(G_LibSelection_StartCoord.X, G_LibSelection_EndCoord.X),
		ML::Max(G_LibSelection_StartCoord.Y, G_LibSelection_EndCoord.Y),
		ML::Max(G_LibSelection_StartCoord.Z, G_LibSelection_EndCoord.Z)
	>;

	Min = <
		ML::Min(G_LibSelection_StartCoord.X, G_LibSelection_EndCoord.X),
		ML::Min(G_LibSelection_StartCoord.Y, G_LibSelection_EndCoord.Y),
		ML::Min(G_LibSelection_StartCoord.Z, G_LibSelection_EndCoord.Z)
	>;

	// Add relief to the selection
	for (X, Min.X, Max.X) {
		for (Z, Min.Z, Max.Z) {
			declare Height = GetGroundHeight(X, Z);
			if (Height < Min.Y) Min.Y = Height;
			else if (Height > Max.Y) Max.Y = Height;
		}
	}

	CustomSelectionCoords.clear();
	for (X, Min.X, Max.X) {
		for (Y, Min.Y, Max.Y) {
			for (Z, Min.Z, Max.Z) {
				CustomSelectionCoords.add(<X, Y, Z>);
			}
		}
	}
}

Text GetScriptVersion() { return Version; }
Text GetScriptName() { return ScriptName; }

Void Unload() {}

Void Load() {
	Unload();
}

// Check if a selection is currently being created
Boolean IsSelecting() {
	return G_LibSelection_Selecting;
}

// Check if the event is moving the selection
Boolean IsMoveEvent(Text _Event) {
	if (
		_Event == UI_MouseControl::Event_SelectionUpdate()
	) {
		return True;
	}

	return False;
}

// Check if the input is moving the selection
Boolean IsMoveInput(CMapEditorPluginEvent::EInput _Input) {
	if (
		_Input == CMapEditorPluginEvent::EInput::IconUp ||
		_Input == CMapEditorPluginEvent::EInput::IconRight ||
		_Input == CMapEditorPluginEvent::EInput::IconDown ||
		_Input == CMapEditorPluginEvent::EInput::IconLeft ||
		_Input == CMapEditorPluginEvent::EInput::CursorRaise ||
		_Input == CMapEditorPluginEvent::EInput::CursorLower
	) {
		return True;
	}

	return False;
}

// Start a new selection
Void Start(Int3 _Coord) {
	CustomSelectionCoords.clear();
	G_LibSelection_Selecting = True;
	G_LibSelection_StartCoord = _Coord;
	G_LibSelection_EndCoord = _Coord;
	Private_Draw();
}

// Update an ongoing selection
Void Update(Int3 _Coord) {
	if (!IsSelecting()) return;

	G_LibSelection_EndCoord = _Coord;
	Private_Draw();
}

// Stop an ongoing selection
Void Stop(Int3 _Coord) {
	if (!IsSelecting()) return;

	G_LibSelection_Selecting = False;
	G_LibSelection_EndCoord = _Coord;
	Private_Draw();
}

// Create a selection
Void Create(Int3 _StartCoord, Int3 _StopCoord) {
	G_LibSelection_StartCoord = _StartCoord;
	G_LibSelection_EndCoord = _StopCoord;
	Private_Draw();
}

// Destroy a selection
Void Destroy() {
	CustomSelectionCoords.clear();
}

Void Show() {
	ShowCustomSelection();
}

Void Hide() {
	HideCustomSelection();
}

// Get the starting and end point of the latest selection if any
Int3[] Get() {
	return [G_LibSelection_StartCoord, G_LibSelection_EndCoord];
}


Int3 GetStart() {
	return G_LibSelection_StartCoord;
}

Int3 GetEnd() {
	return G_LibSelection_EndCoord;
}

// Set the color of the selection overlay
Void SetColor(Vec3 _Color) {
	CustomSelectionRGB = _Color;
}

// Get the color of the selection overlay
Vec3 GetColor() {
	return CustomSelectionRGB;
}