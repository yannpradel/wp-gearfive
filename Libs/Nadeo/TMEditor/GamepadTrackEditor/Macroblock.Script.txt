/**
 * Macroblock library
 */

#Const C_MacroblocksVersion	"2022-10-21"
#Const Version		"1.0.2"
#Const ScriptName	"Macroblock.Script.txt"

#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "MapUnits" as MU
#Include "Libs/Nadeo/TMEditor/GamepadTrackEditor/Utils.Script.txt" as Utils

// Constants
#Const C_NullDir			CMapEditorPlugin::CardinalDirections::North	///< Null value for dir
#Const C_VariantNull		-1	///< Null
#Const C_VariantGround		0	///< Ground variant identifier
#Const C_VariantAir			1	///< Air variant identifier
#Const C_VariantForest		2	///< Forest (Valley) variant identifier
#Const C_VariantForestEdge	3	///< Forest edge (Valley) variant identifier
#Const C_VariantDirt		4	///< Dirt (Stadium) variant identifier
#Const C_VariantWater		5	///< Water (Lagoon) variant identifier

#Const C_UpdateUidBlock		"DecoExpert\\Flying\\Helico" ///< Full name of the macroblock model to use to udpate the track uid

#Const C_DecoStyles [
	"Stadium" => [
		"Screens",
		"DecoHillGrass",
		"DecoHillDirt",
		"DecoHillIce",
		"Structures",
		"TrackWall",
		"DecoWall",
		"Stage",
		"Show",
		"Nature"
	]
]

// List of macroblocks ground offsets
#Const C_GroundOffsets [
	"Canyon" => [
		"CliffLow\\" => 13,
		"CliffHigh\\" => 13,
		"Tunnel\\Transitions\\WaterCliff" => 13,
		"Tunnel\\Transitions\\MainToTunnel" => 5,
		"Tunnel\\Transitions\\DirtCliff" => 1,
		"RoadRace\\Bridges\\WaterCliff" => 13,
		"RoadMain\\Bridges\\WaterCliff" => 13,
		"Deco\\Desert\\WaterCliff" => 13
	],
	"Valley" => [
		"Tunnel\\Transitions\\GrassFlat" => 2,
		"Tunnel\\Transitions\\4WayGrassFlat" => 2,
		"RoadDirt\\Turns\\GTCurve2Pond" => 1,
		"RoadDirt\\Turns\\GTCurve2Lake" => 1,
		"RoadDirt\\Roads\\RiverCross" => 1,
		"RoadDirt\\Roads\\Diag2x2Pond" => 1,
		"RoadDirt\\Roads\\Diag2x2PondMirror" => 1,
		"RoadDirt\\Roads\\Diag2x2Lake" => 1,
		"RoadDirt\\Roads\\Diag2x2Mirror" => 1,
		"RoadDirt\\Obstacles\\LakeJump" => 1,
		"RoadDirt\\Obstacles\\CrossRive" => 1, //< Missing "r" is wanted
		"Offroad\\Roads\\Bridge" => 1,
		"Deco\\Natural\\TreesRiver" => 1,
		"Deco\\Natural\\TreesLake" => 1,
		"Castle\\Transitions\\" => 1
	],
	"Stadium" => [
		"Trench\\" => 1
	],
	"Lagoon" => [
		"Tunnel\\Transitions\\TunnelToRoadMainSlope" => 1,
		"Tunnel\\Transitions\\TunnelToHighway" => 2,
		"Tunnel\\Checkpoints\\StartHelicoMedium" => 2
	]
]

// List of authorized free clips
#Const C_AuthorizedFreeClips [
	"Canyon" => [
		"RoadCaveDoubleFreeClip",
		"ArenaBankFreeClipLeft",
		"ArenaBankFreeClipRight",
		"ArenaBiSlopeEndFreeClipLeft",
		"ArenaBiSlopeEndFreeClipRight",
		"ArenaBiSlopeStartFreeClipLeft",
		"ArenaBiSlopeStartFreeClipRight",
		"ArenaBiSlopeStraightFreeClipLeft",
		"ArenaBiSlopeStraightFreeClipRight",
		"ArenaFreeClip",
		"ArenaHalfBaseFreeClipEst",
		"ArenaHalfBaseFreeClipWest",
		"ArenaHallwayFreeClip",
		"ArenaSlopeBase2FreeClipLeft",
		"ArenaSlopeBase2FreeClipRight",
		"ArenaSlopeBase4FreeClipLeft",
		"ArenaSlopeBase4FreeClipRight",
		"ArenaSlopeBaseFreeClipLeft",
		"ArenaSlopeBaseFreeClipRight",
		"ArenaSlopeEndFreeClipLeft",
		"ArenaSlopeEndFreeClipRight",
		"ArenaSlopeStartFreeClipLeft",
		"ArenaSlopeStartFreeClipRight",
		"ArenaSlopeStraightFreeClipLeft",
		"ArenaSlopeStraightFreeClipRight",
		"ArenaTunnelFreeClip",
		"ArenaTunnelOpen1SideFreeClipLeft",
		"ArenaTunnelOpen1SideFreeClipRight",
		"ArenaTunnelOpen2SidesFreeClip",
		"ArenaTunnelOpenFreeClip",
		"ArenaWallRideLoopEndFreeClip",
		"ArenaWallRideLoopEndFreeClipLeft",
		"ArenaWallRideLoopEndFreeClipRight",
		"ArenaWallRideLoopStartFreeClipLeft",
		"ArenaWallRideLoopStartFreeClipRight",
		"ArenaWallRideStartCornerFreeClipLeft",
		"ArenaWallRideStartCornerFreeClipRight",
		"ArenaWallRideStraightFreeClipLeft",
		"ArenaWallRideStraightFreeClipRight",
		"ArenaWallRideTopFreeClipLeft",
		"ArenaWallRideTopFreeClipRight"
	],
	"Valley" => [
		"ArenaBaseFreeClip",
		"ArenaBaseSlopeBaseLeftFreeClip",
		"ArenaBaseSlopeBaseRightFreeClip",
		"ArenaBaseSlopeEndLeftFreeClip",
		"ArenaBaseSlopeEndRightFreeClip",
		"ArenaBaseSlopeLeftFreeClip",
		"ArenaBaseSlopeRightFreeClip",
		"ArenaBaseSlopeStartLeftFreeClip",
		"ArenaBaseSlopeStartRightFreeClip",
		"ArenaBorderSmallFreeClipLoopFlipLeft",
		"ArenaBorderSmallFreeClipLoopFlipRight",
		"ArenaBorderSmallFreeClipOpenLeft",
		"ArenaBorderSmallFreeClipOpenRight",
		"ArenaBorderSmallLoopEndFreeClipLeft",
		"ArenaBorderSmallLoopEndFreeClipRight",
		"ArenaBorderSmallLoopSmallEndFreeClipLeft",
		"ArenaBorderSmallLoopSmallEndFreeClipRight",
		"ArenaBorderSmallLoopSmallStartFreeClipLeft",
		"ArenaBorderSmallLoopSmallStartFreeClipRight",
		"ArenaBorderSmallLoopStartFreeClipLeft",
		"ArenaBorderSmallLoopStartFreeClipRight",
		"ArenaBorderSmallLoopStraightTopFreeClipLeft",
		"ArenaBorderSmallLoopStraightTopFreeClipRight",
		"ArenaGT2FreeClipLeft",
		"ArenaGT2FreeClipRight",
		"ArenaParkBorderFreeClipLeft",
		"ArenaParkBorderFreeClipRight",
		"ArenaParkFreeClip",
		"ArenaParkRoofBaseFreeClip",
		"ArenaParkRoofLoopFreeClipFlip",
		"ArenaParkRoofLoopFreeClipVLeft",
		"ArenaParkRoofLoopFreeClipVRight",
		"ArenaParkRoofSlopeBaseFreeClipLeft",
		"ArenaParkRoofSlopeBaseFreeClipRight",
		"ArenaParkRoofSlopeEndFreeClipLeft",
		"ArenaParkRoofSlopeEndFreeClipRight",
		"ArenaParkRoofSlopeStartFreeClipLeft",
		"ArenaParkRoofSlopeStartFreeClipRight",
		"ArenaParkRoofSlopeStraightFreeClipLeft",
		"ArenaParkRoofSlopeStraightFreeClipRight",
		"CastleBorderLakeFreeClipLeft",
		"CastleBorderLakeFreeClipRight",
		"CastleBridgeLakeFreeClip",
		"CastleCenterLakeFreeClip",
		"CastleGardenLakeFreeClip",
		"RoadForestLargeFreeClip",
		"RoadForestLargeGrassFreeClip"
	],
	"Stadium" => [
	],
	"Lagoon" => [
		"ArenaBaseFreeClip",
		"ArenaBorderFreeClipLeft",
		"ArenaBorderFreeClipRight",
		"ArenaLoopEndFreeClipLeft",
		"ArenaLoopEndFreeClipRight",
		"ArenaLoopFreeClipLeft",
		"ArenaLoopFreeClipRight",
		"ArenaLoopStartFreeClipLeft",
		"ArenaLoopStartFreeClipRight",
		"ArenaSlope2End_FreeClipLeft",
		"ArenaSlope2End_FreeClipRight",
		"ArenaSlope2FreeClipDown",
		"ArenaSlope2FreeClipUp",
		"ArenaSlope2Start_FreeClipLeft",
		"ArenaSlope2Start_FreeClipRight",
		"ArenaSlope2Straight_FreeClipLeft",
		"ArenaSlope2Straight_FreeClipRight",
		"ArenaSlope2Twist3_FreeClipLeft",
		"ArenaSlope2Twist3_FreeClipRight",
		"ArenaSlope2TwistEnd_FreeClipLeft",
		"ArenaSlope2TwistEnd_FreeClipRight",
		"ArenaSlope2TwistStart_FreeClipLeft",
		"ArenaSlope2TwistStart_FreeClipRight",
		"ArenaSlopeBase_FreeClipLeft",
		"ArenaSlopeBase_FreeClipRight",
		"CE_ShipFreeClipLeft",
		"CE_ShipFreeClipLeft_Land",
		"CE_ShipFreeClipRight",
		"CE_ShipFreeClipRight_Land",
		"DecoCityFloor-FreeClip",
		"DecoCityFloor-FreeClipSmall",
		"DecoCityFloorSlope-FreeClipLeft",
		"DecoCityFloorSlope-FreeClipRight",
		"DecoCityGarden-FreeClip",
		"DecoCityGardenSlope-FreeClipLeft",
		"DecoCityGardenSlope-FreeClipRight",
		"HighWaySlope2FreeClipLeft",
		"HighWaySlope2FreeClipRight",
		"HighWaySlope2LoopFreeClipLeft",
		"HighWaySlope2LoopFreeClipRight",
		"HighWaySlope2LoopRightFreeClipLeft",
		"HighWaySlope2LoopRightFreeClipRight",
		"RoadMainToCityFreeClipLeft",
		"RoadMainToCityFreeClipRight",
		"RoadThemeParkWall-FreeClipLeft",
		"RoadThemeParkWall-FreeClipRight",
		"TunnelFreeClip"
	]
]
// List of forbidden clips
#Const C_ForbiddenClips [
	"Canyon" => [
		"RoadMain2Clip"
	],
	"Valley" => [],
	"Stadium" => [
		"RoadIceWallFCRight",
		"RoadIceWallFCLeft",
		"TrackWallVFC",
		"TrackWallVFCSlopeUp",
		"DecoWallBaseVFC",
		"DecoWallSimpleVFC",
		"DecoWallSlope2StraightVFCLeft",
		"DecoWallSlope2StraightVFCRight",
		"PlatformSpecialSlope2UpFCLeft",
		"PlatformSpecialSlope2UpFCRight",
		"PlatformSpecialTilt2RightFCRight",
		"PlatformSpecialTilt2RightFCLeft",
		"PlatformSpecialFCLeft",
		"PlatformSpecialFCRight",
		"DecoWallSlope2StartVFCLeft",
		"DecoWallSlope2EndVFCLeft",
		"DecoWallSlope2StartVFCRight",
		"DecoWallSlope2EndVFCRight",
		"DecoWallSlope2StraightVFCRight",
		"DecoWallSlope2StraightVFCLeft",
		"PlatformTiltTransition2UpLeftFCSlope2End",
		"PlatformTiltTransition2UpLeftFCSlope2Start",
		"PlatformTiltTransition2UpRightFCSlope2End",
		"PlatformTiltTransition2UpRightFCSlope2Start",
		"PlatformTiltTransition2DownLeftFCSlope2End",
		"PlatformTiltTransition2DownLeftFCSlope2Start",
		"PlatformTiltTransition2DownRightFCSlope2End",
		"PlatformTiltTransition2DownRightFCSlope2Start",
		"PlatformTiltTransition2UpLeftFCSmall_1",
		"PlatformTiltTransition2UpLeftFCSmall_2",
		"PlatformTiltTransition2UpRightFCSmall_1",
		"PlatformTiltTransition2UpRightFCSmall_2",
		"DecoPlatformFCSmall",
		"DecoPlatformSlope2BaseFCRightSmall",
		"DecoPlatformSlope2BaseFCLeftSmall",
		"DecoPlatformSlope2StraightFCRightSmall",
		"DecoPlatformSlope2StraightFCLeftSmall",
		"PlatformWaterHFCInsideShort",
		"DecoWallSlope2BaseVFCLeft",
		"DecoWallSlope2BaseVFCRight",
		"PlatformSlope2UTopVFC",
		"PlatformSlope2UBottomFCSmall",
		"DecoWallSlope2UBottomVFC",
		"DecoWallSlope2UBottomFCInGround",
		"PlatformSpecialTilt2LeftFCRight",
		"PlatformSpecialTilt2LeftFCLeft",
		"PlatformSpecialSlope2DownFCRight",
		"PlatformSpecialSlope2DownFCLeft",
		"DecoWallSlopeBaseVFCLeft",
		"DecoWallSlopeBaseVFCRight",
		"DecoPlatformSlope2UBottomFCSmall",
		"DecoPlatformSlope2UTopVFC",
		"PlatformWaterHFCDiagInsideShortLeft",
		"PlatformWaterHFCDiagInsideShortRight",
		"DecoWallWaterHFCDiagInsideShortLeft",
		"DecoWallWaterHFCDiagInsideShortRight",
		"DecoPlatformSlope2StartFCLeftSmall",
		"DecoPlatformSlope2StartFCRightSmall",
		"DecoPlatformSlope2EndFCLeftSmall",
		"DecoPlatformSlope2EndFCRightSmall",
		"DecoPlatformSlopeBaseFCLeftSmall",
		"DecoPlatformSlopeBaseFCRightSmall",
		"PlatformTiltTransition2DownRightFCSmall_1",
		"PlatformTiltTransition2DownRightFCSmall_2",
		"PlatformTiltTransition2DownLeftFCSmall_1",
		"PlatformTiltTransition2DownLeftFCSmall_2"
	],
	"Lagoon" => []
]
// List of clips suffixes
#Const C_ClipsSuffixes [
	"RightUp" => "LeftDown",
	"RightDown" => "LeftUp",
	"LeftUp" => "RightDown",
	"LeftDown" => "RightUp",
	"Right" => "Left",
	"Left" => "Right",
	"Up" => "Down",
	"Down" => "Up",
	"Est" => "West",
	"West" => "Est",
	"LeftFreeClip" => "RightFreeClip",
	"RightFreeClip" => "LeftFreeClip"
]
#Const C_MacroblocksFolder	"GamepadEditor"	///< Folder containing the macroblocks
#Const C_TerrainsFolder		"Terrain"		///< Folder containing the terrains macroblocks

/// Structure for the MacroblockModels metadata
#Struct K_GamepadEditorMetadata {
	Text 		Id;
	Text 		Name;
	Text 		Family;
	Text 		Type;
	Boolean 	IsShifting;
	Boolean 	IsTurning;
	Boolean 	IsRising;
	Text[Integer] Variants;
	Boolean[] 	ClipCustoms;
	Text[] 		DisabledClipsNames;
	Int3[] 		DisabledClipsOffsets;
	Integer[] 	DisabledClipsDirs;
	Text[] 		ClipNames;
	Int3[] 		ClipOffsets;
	Int3[] 		ClipConnections;
	Integer[] 	ClipDirs;
	Vec3 		ClipsCenter;
	Int3[] 		CollisionsOffsets;
	Integer 	SignatureKey;
	Real 		Length;
	Integer 	GroundOffset;
	Text 		Version;
	Boolean 	Valid;
}

// Globales
declare Text[Integer] 			 G_LibMacroblock_SignaturesPool;
declare Text[] 					 G_LibMacroblock_ClipNamesPool;
declare Text[][Text] 			 G_LibMacroblock_ConnectableClips;
declare CMacroblockModel[Text] 	 G_LibMacroblock_MacroblockModelsIds;		///< Cache macroblock models ids
declare CMacroblockModel[][Text] G_LibMacroblock_MacroblockModelsFullNames; ///< Cache macroblock models names
declare Text[] 					 G_LibMacroblock_OutClips; 					///< List of out clips names
declare CMacroblockModel 		 G_LibMacroblock_UpdateUidBlock; 			///< Macroblock model to use to update the uid of the track
declare CMacroblockModel[][Integer][Text] G_LibMacroblock_Variants; ///< Temp list of variants by macroblock path

declare K_GamepadEditorMetadata[Ident] G_MetadataCache; 			 ///< We will be working with this instead of metadata for perf issues
declare K_GamepadEditorMetadata		 G_LatestMetadataCache; 	 ///< Instead of searching in the G_MetadataCache table, if the last one we got didnt change, just use this one
declare Ident						 G_LatestMetadataCacheIdent; ///< Ident of the G_LatestMetadataCache
declare CMacroblockModel	G_PodiumMacroblockModel; 			///< First podium mb model found, can be null

Text GetScriptVersion() { return Version; }
Text GetScriptName() { return ScriptName; }

/// Clear the pool of macroblocks signatures
Void ClearSignaturesPool() {
	G_LibMacroblock_SignaturesPool.clear();
}

// Find an available signature key in the signature pool
Integer GetAvailableSignatureKey() {
	G_LibMacroblock_SignaturesPool = G_LibMacroblock_SignaturesPool.sortkey();

	declare Key = 0;
	while (True) {
		if (!G_LibMacroblock_SignaturesPool.existskey(Key)) return Key;
		else Key += 1;
	}

	return Key;
}

// Clear the pool of clip names
Void ClearClipNamesPool() {
	G_LibMacroblock_ClipNamesPool.clear();
}

// Get the clip id for signature from its name
Integer GetClipId(Text _Name) {
	declare Key = G_LibMacroblock_ClipNamesPool.keyof(_Name);

	if (Key < 0) {
		Key = G_LibMacroblock_ClipNamesPool.count;
		G_LibMacroblock_ClipNamesPool.add(_Name);
	}

	return Key;
}

// Get variant identifiers
Integer VariantNull() 			{ return C_VariantNull; }
Integer VariantGround() 		{ return C_VariantGround; }
Integer VariantAir() 			{ return C_VariantAir; }
Integer VariantForest() 		{	return C_VariantForest; }
Integer VariantForestEdge() { return C_VariantForestEdge; }
Integer VariantDirt() 			{	return C_VariantDirt; }
Integer VariantWater() 		{	return C_VariantWater; }

Boolean VariantExists(Integer _Variant) {
	return (
		_Variant == C_VariantNull ||
		_Variant == C_VariantGround ||
		_Variant == C_VariantAir ||
		_Variant == C_VariantForest ||
		_Variant == C_VariantForestEdge ||
		_Variant == C_VariantDirt ||
		_Variant == C_VariantWater
	);
}

Boolean VariantIsNotNull(Integer _Variant) {
	return (VariantExists(_Variant) && _Variant != C_VariantNull);
}

CMacroblockModel GetMacroblockModelFromId(Ident _MacroblockModelId) {
	if (MacroblockModels.existskey(_MacroblockModelId)) return MacroblockModels[_MacroblockModelId];
	return Null;
}

// Get the information in cache of a macroblock model
K_GamepadEditorMetadata GetMetadata(Ident _Id) {
	tuningmark("GetMetadata");
	if (_Id != G_LatestMetadataCacheIdent) {
		G_LatestMetadataCache = G_MetadataCache[_Id];
		G_LatestMetadataCacheIdent = _Id;
	}
	return G_LatestMetadataCache;
}

// Overload GetMetadata()
K_GamepadEditorMetadata GetMetadata(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return K_GamepadEditorMetadata{};
	return GetMetadata(_MacroblockModel.Id);
}

// Saves the local cached metadata to the actual Macroblock model's metadata
Void UpdateMetadata(Ident _Id) {
	tuningmark("UpdateMetadata");
	declare MacroblockModel = MacroblockModels[_Id];
	if (MacroblockModel == Null) return;
	declare metadata K_GamepadEditorMetadata GamepadEditor for MacroblockModel;
	GamepadEditor = GetMetadata(_Id);
}

/// Overload UpdateMetadata()
Void UpdateMetadata(CMacroblockModel _MacroblockModel) {
	return UpdateMetadata(_MacroblockModel.Id);
}

// Sets the macroblock's cache to the value we've sent, and then update it
Void SetMetadata(Ident _Id, K_GamepadEditorMetadata _Metadata) {
	tuningmark("SetMetadata");
	G_MetadataCache[_Id] = _Metadata;
	if (_Id == G_LatestMetadataCacheIdent)	G_LatestMetadataCache = _Metadata;
	UpdateMetadata(_Id);
}

/// Overload SetMetadata()
Void SetMetadata(CMacroblockModel _MacroblockModel, K_GamepadEditorMetadata _Metadata) {
	SetMetadata(_MacroblockModel.Id, _Metadata);
}

// Get a macroblock model from its custom id
CMacroblockModel GetMacroblockModelFromId(Text _MacroblockModelId) {
	tuningmark("GetMacroblockModelFromId");
	// Get from cache
	if (G_LibMacroblock_MacroblockModelsIds.existskey(_MacroblockModelId)) return G_LibMacroblock_MacroblockModelsIds[_MacroblockModelId];

	declare MacroblockModel = GetMacroblockModelFromFilePath(_MacroblockModelId);
	if (MacroblockModel != Null) G_LibMacroblock_MacroblockModelsIds[_MacroblockModelId] = MacroblockModel;
	return MacroblockModel;
}

// Get the full name of a macroblock
Text GetFullName(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return "";
	tuningmark("GetFullName");
	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);
	return MacroblockMetadata.Family^"\\"^MacroblockMetadata.Type^"\\"^MacroblockMetadata.Name;
	/*declare MacroblockId = TL::Split("\\", ""^_MacroblockModel.Id); // Alternate method. Thought it'd be faster but not really.
	declare IdCount = MacroblockId.count;
	if (IdCount >= 5)
		return MacroblockId[IdCount-4]^"\\"^MacroblockId[IdCount-3]^"\\"^MacroblockId[IdCount-2];

	return "";*/
}

// Get macroblock models from their full name
CMacroblockModel[] GetMacroblockModelsFromFullName(Text _FullName) {
	// Get from cache
	if (G_LibMacroblock_MacroblockModelsFullNames.existskey(_FullName)) return G_LibMacroblock_MacroblockModelsFullNames[_FullName];

	log("Warning: No macroblocks found for "^_FullName^". This might be caused by a mistake in the XML config.");

	declare CMacroblockModel[] NoMacroblockModelsFound;
	return NoMacroblockModelsFound;
}

// Loads the metadata of the macroblock files and puts it in cache. Converts it from the old metadata to the new if needed, and wipes the old data
Void Private_ConvertOrLoadMetadataToCache(CMacroblockModel _MacroblockModel) {
	if (G_MetadataCache.existskey(_MacroblockModel.Id)) return;
	tuningmark("Private_ConvertMetadataToCache");

	declare metadata K_GamepadEditorMetadata GamepadEditor for _MacroblockModel = K_GamepadEditorMetadata{SignatureKey = -1};

	if (GamepadEditor.SignatureKey == -1) { // Convert Old metadata to new if new doesn't exist
		tuningmark("Private_ConvertMetadataToCache 1");
		declare metadata Integer GamepadEditor_SignatureKey for _MacroblockModel = -1;
		if (GamepadEditor_SignatureKey == -1) { // If the old metadata somehow does not exist either...
			//log("Neither old or new metadata exists ? for "^_MacroblockModel.Id);
			G_MetadataCache[_MacroblockModel.Id] = GamepadEditor; // The metadata for this block will be empty
			return;
		}

		declare metadata Text GamepadEditor_Id for _MacroblockModel;
		declare metadata Text GamepadEditor_Name for _MacroblockModel;
		declare metadata Text GamepadEditor_Family for _MacroblockModel;
		declare metadata Text GamepadEditor_Type for _MacroblockModel;
		declare metadata Boolean GamepadEditor_IsShifting for _MacroblockModel;
		declare metadata Boolean GamepadEditor_IsTurning for _MacroblockModel;
		declare metadata Boolean GamepadEditor_IsRising for _MacroblockModel;
		declare metadata Text[Integer] GamepadEditor_Variants for _MacroblockModel;
		declare metadata Boolean[] GamepadEditor_ClipCustoms for _MacroblockModel;
		declare metadata Text[] GamepadEditor_DisabledClipsNames for _MacroblockModel;
		declare metadata Int3[] GamepadEditor_DisabledClipsOffsets for _MacroblockModel;
		declare metadata Integer[] GamepadEditor_DisabledClipsDirs for _MacroblockModel;
		declare metadata Text[] GamepadEditor_ClipNames for _MacroblockModel;
		declare metadata Int3[] GamepadEditor_ClipOffsets for _MacroblockModel;
		declare metadata Int3[] GamepadEditor_ClipConnections for _MacroblockModel;
		declare metadata Integer[] GamepadEditor_ClipDirs for _MacroblockModel;
		declare metadata Vec3 GamepadEditor_ClipsCenter for _MacroblockModel;
		declare metadata Int3[] GamepadEditor_CollisionsOffsets for _MacroblockModel;
		declare metadata Real GamepadEditor_Length for _MacroblockModel;
		declare metadata Integer GamepadEditor_GroundOffset for _MacroblockModel;
		declare metadata Text GamepadEditor_Version for _MacroblockModel;
		declare metadata Boolean GamepadEditor_Valid for _MacroblockModel;

		declare K_GamepadEditorMetadata NewMetadata;

		NewMetadata.Id                      = GamepadEditor_Id;
		NewMetadata.Name                    = GamepadEditor_Name;
		NewMetadata.Family                  = GamepadEditor_Family;
		NewMetadata.Type                    = GamepadEditor_Type;
		NewMetadata.IsShifting              = GamepadEditor_IsShifting;
		NewMetadata.IsTurning               = GamepadEditor_IsTurning;
		NewMetadata.IsRising                = GamepadEditor_IsRising;
		NewMetadata.Variants                = GamepadEditor_Variants;
		NewMetadata.ClipCustoms             = GamepadEditor_ClipCustoms;
		NewMetadata.DisabledClipsNames      = GamepadEditor_DisabledClipsNames;
		NewMetadata.DisabledClipsOffsets    = GamepadEditor_DisabledClipsOffsets;
		NewMetadata.DisabledClipsDirs       = GamepadEditor_DisabledClipsDirs;
		NewMetadata.ClipNames               = GamepadEditor_ClipNames;
		NewMetadata.ClipOffsets             = GamepadEditor_ClipOffsets;
		NewMetadata.ClipConnections         = GamepadEditor_ClipConnections;
		NewMetadata.ClipDirs                = GamepadEditor_ClipDirs;
		NewMetadata.ClipsCenter             = GamepadEditor_ClipsCenter;
		NewMetadata.CollisionsOffsets       = GamepadEditor_CollisionsOffsets;
		NewMetadata.SignatureKey            = GamepadEditor_SignatureKey;
		NewMetadata.Length                  = GamepadEditor_Length;
		NewMetadata.GroundOffset            = GamepadEditor_GroundOffset;
		NewMetadata.Version                 = GamepadEditor_Version;
		NewMetadata.Valid	                	 = GamepadEditor_Valid;

		log("ClearScriptMetadata");
		_MacroblockModel.ClearScriptMetadata(); // This clears the old metadatas
		SetMetadata(_MacroblockModel.Id, NewMetadata);
	} else { // Load
		tuningmark("Private_ConvertMetadataToCache 2");
		G_MetadataCache[_MacroblockModel.Id] = GamepadEditor;
		//_MacroblockModel.ClearScriptMetadata(); // This clears the old metadatas. Theorically, if the new data exists, the old doesn't anymore because it's cleared when it's converted
		UpdateMetadata(_MacroblockModel.Id);
	}
}

Void Private_GenerateMacroblockVariants() {
	tuningmark("Private_GenerateMacroblockVariants");
	declare CMacroblockModel[][Integer] EmptyVariants = [
		C_VariantGround => [],
		C_VariantAir => [],
		C_VariantForest => [],
		C_VariantForestEdge => [],
		C_VariantDirt => [],
		C_VariantWater => []
	];

	foreach (MacroblockModel in MacroblockModels) {
		tuningmark("Private_GenerateMacroblockVariants Loop");
		declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(MacroblockModel.Id);
		declare Path = MacroblockMetadata.Family^"/"^MacroblockMetadata.Type^"/"^MacroblockMetadata.Name; // note: Metadata name != MacroblockModel.Name

		if (!G_LibMacroblock_Variants.existskey(Path)) {
			G_LibMacroblock_Variants[Path] = EmptyVariants;
		}

		switch (MacroblockModel.Name) {
			case "Ground"		: G_LibMacroblock_Variants[Path][C_VariantGround].add(MacroblockModel);
			case "Air"			: G_LibMacroblock_Variants[Path][C_VariantAir].add(MacroblockModel);
			case "Forest"		: G_LibMacroblock_Variants[Path][C_VariantForest].add(MacroblockModel);
			case "ForestEdge"	: G_LibMacroblock_Variants[Path][C_VariantForestEdge].add(MacroblockModel);
			case "Dirt"			: G_LibMacroblock_Variants[Path][C_VariantDirt].add(MacroblockModel);
			case "Water"		: G_LibMacroblock_Variants[Path][C_VariantWater].add(MacroblockModel);
		}
		yield(2);
	}
}

// you can clear up RAM after using it
Void Private_ClearMacroblockVariants() {
	G_LibMacroblock_Variants.clear();
}

CMacroblockModel[][Integer] Private_GetMacroblockModelVariants(CMacroblockModel _MacroblockModel) {
	assert(G_LibMacroblock_Variants.count > 0); /// Call Private_GenerateMacroblockVariants first.
	tuningmark("Private_GetMacroblockModelVariants");
	declare CMacroblockModel[][Integer] EmptyResult = [
		C_VariantGround => [],
		C_VariantAir => [],
		C_VariantForest => [],
		C_VariantForestEdge => [],
		C_VariantDirt => [],
		C_VariantWater => []
	];

	if (_MacroblockModel == Null) return EmptyResult;

	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);
	declare Path = MacroblockMetadata.Family^"/"^MacroblockMetadata.Type^"/"^MacroblockMetadata.Name; // note: Metadata name != MacroblockModel.Name

	if (G_LibMacroblock_Variants.existskey(Path)) {
		return G_LibMacroblock_Variants[Path];
	}

	return EmptyResult;
}

// Get a defined variant of a macroblockmodel
CMacroblockModel GetMacroblockModel(Text _MacroblockModelFamily, Text _MacroblockModelType, Text _MacroblockModelName, Integer _VariantIdentifier) {
	tuningmark("GetMacroblockModel");
	foreach (MacroblockModel in MacroblockModels) {
		declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(MacroblockModel.Id);
		if (MacroblockMetadata.Family == _MacroblockModelFamily && MacroblockMetadata.Type == _MacroblockModelType && MacroblockMetadata.Name == _MacroblockModelName) {
			if (_VariantIdentifier == C_VariantGround && MacroblockModel.Name == "Ground") {
				return MacroblockModel;
			} else if (_VariantIdentifier == C_VariantAir && MacroblockModel.Name == "Air") {
				return MacroblockModel;
			} else if (_VariantIdentifier == C_VariantForest && MacroblockModel.Name == "Forest") {
				return MacroblockModel;
			} else if (_VariantIdentifier == C_VariantForestEdge && MacroblockModel.Name == "ForestEdge") {
				return MacroblockModel;
			} else if (_VariantIdentifier == C_VariantDirt && MacroblockModel.Name == "Dirt") {
				return MacroblockModel;
			} else if (_VariantIdentifier == C_VariantWater && MacroblockModel.Name == "Water") {
				return MacroblockModel;
			}
		}
	}
	return Null;
}

// Get the macroblockmodels with the corresponding name
CMacroblockModel[] GetMacroblockModelsFromName(Text _MacroblockModelName) {
	declare CMacroblockModel[] TmpMacroblockModels;
	foreach (MacroblockModel in TmpMacroblockModels) {
		declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(MacroblockModel.Id);
		if (MacroblockMetadata.Name == _MacroblockModelName) TmpMacroblockModels.add(MacroblockModel);
	}
	return TmpMacroblockModels;
}

// Get the right variant (air or ground) for a macroblock model
CBlockModelVariant GetBlockModelVariant(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return Null;
	tuningmark("GetBlockModelVariant");

	if (_MacroblockModel.GeneratedBlockModel.VariantGround != Null) {
		return _MacroblockModel.GeneratedBlockModel.VariantGround;
	} else {
		return _MacroblockModel.GeneratedBlockModel.VariantAir;
	}
	return Null;
}

// Check if a clip is disabled
Boolean ClipIsDisabled(CMacroblockModel _MacroblockModel, Text _ClipName, Int3 _ClipOffset, Integer _ClipDir) {
	if (_MacroblockModel == Null) return False;
	tuningmark("ClipIsDisabled");
	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);
	foreach (Key => DisabledClipName in MacroblockMetadata.DisabledClipsNames) {
		if (DisabledClipName != _ClipName) continue;
		if (MacroblockMetadata.DisabledClipsOffsets[Key] != _ClipOffset) continue;
		if (MacroblockMetadata.DisabledClipsDirs[Key] != _ClipDir) continue;
		return True;
	}

	return False;
}

// Generate the macroblock model signature for a given direction
Text GenerateSignature(CMacroblockModel _MacroblockModel, Integer _Dir) {
	declare Variant <=> GetBlockModelVariant(_MacroblockModel);
	if (Variant == Null) return "";

	declare DirOffset = Utils::IntToDir(_Dir);

	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);

	declare Integer[][Int3] FakeBlockUnitModels;
	foreach (BlockUnitModel in Variant.BlockUnitModels) {
		if (!FakeBlockUnitModels.existskey(BlockUnitModel.RelativeOffset)) FakeBlockUnitModels[BlockUnitModel.RelativeOffset] = [];
	}
	foreach (ClipId => BlockUnitOffset in MacroblockMetadata.ClipConnections) {
		if (!FakeBlockUnitModels.existskey(BlockUnitOffset)) FakeBlockUnitModels[BlockUnitOffset] = [];
		FakeBlockUnitModels[BlockUnitOffset].add(ClipId);
	}

	declare Signature = "";
	declare VariantSize = Variant.Size;
	foreach (BlockUnitOffset => ClipsIds in FakeBlockUnitModels) {
		if (Signature != "") Signature ^= ",";

		declare RotatedOffset = MU::GetRotatedOffsetPositive(BlockUnitOffset, DirOffset, VariantSize);

		Signature ^= "<"^RotatedOffset.X^","^RotatedOffset.Y^","^RotatedOffset.Z^">";
		declare Integer[Integer] ClipsDirsIds;
		foreach (ClipId in ClipsIds) {
			declare ClipName = MacroblockMetadata.ClipNames[ClipId];
			declare ClipDir = MacroblockMetadata.ClipDirs[ClipId];
			declare RotatedDir = Utils::DirToInt(MU::AddDirs(Utils::IntToDir(ClipDir), DirOffset));
			ClipsDirsIds[RotatedDir] = GetClipId(ClipName);
		}
		declare ClipsSignature = "";
		ClipsDirsIds = ClipsDirsIds.sort();
		foreach (ClipDir => ClipId in ClipsDirsIds) {
			if (ClipsSignature != "") ClipsSignature ^= ",";
			ClipsSignature ^= "["^ClipId^","^ClipDir^"]";
		}
		Signature ^= "["^ClipsSignature^"]";
	}

	return Signature;
}

/// Reload the signatures pool from the existing macroblocks
Void ReloadSignaturesPool() {
	ClearSignaturesPool();
	ClearClipNamesPool();

	foreach (MacroblockModel in MacroblockModels) {
		declare Variant <=> GetBlockModelVariant(MacroblockModel);
		if (Variant == Null) continue;

		declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(MacroblockModel.Id);
		if (G_LibMacroblock_SignaturesPool.existskey(MacroblockMetadata.SignatureKey) || MacroblockMetadata.SignatureKey == -1) continue;

		declare Signature = GenerateSignature(MacroblockModel, 0);
		G_LibMacroblock_SignaturesPool[MacroblockMetadata.SignatureKey] = Signature;

		yield(5);
	}
}

Void ResetMetadataAndCustomClips(CMacroblockModel _MacroblockModel) {
	SetMetadata(_MacroblockModel.Id, K_GamepadEditorMetadata{SignatureKey = -1});
}

// Reset the metadata of the specified macroblock model
Void ResetMetadata(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return;

	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);

	MacroblockMetadata.Id = "";
	MacroblockMetadata.Name = "";
	MacroblockMetadata.Family = "";
	MacroblockMetadata.Type = "";
	MacroblockMetadata.IsShifting = False;
	MacroblockMetadata.IsTurning = False;
	MacroblockMetadata.IsRising = False;
	MacroblockMetadata.Variants.clear();
	MacroblockMetadata.ClipsCenter = <0., 0., 0.>;
	MacroblockMetadata.SignatureKey = -1;
	MacroblockMetadata.Length = 0.;
	MacroblockMetadata.GroundOffset = 0;
	MacroblockMetadata.Version = "";
	MacroblockMetadata.Valid = False;

	while (MacroblockMetadata.ClipCustoms.exists(False)) {
		declare Removed = False;
		declare Key = MacroblockMetadata.ClipCustoms.keyof(False);
		Removed = MacroblockMetadata.ClipCustoms.removekey(Key);
		Removed = MacroblockMetadata.ClipNames.removekey(Key);
		Removed = MacroblockMetadata.ClipOffsets.removekey(Key);
		Removed = MacroblockMetadata.ClipConnections.removekey(Key);
		Removed = MacroblockMetadata.ClipDirs.removekey(Key);
	}

	// Incoherent state, some clips are not flagged correctly, remove them
	while (MacroblockMetadata.ClipCustoms.count != MacroblockMetadata.ClipNames.count) {
		declare Key = -1;
		// Remove unnecessary custom clips
		if (MacroblockMetadata.ClipCustoms.count > MacroblockMetadata.ClipNames.count) {
			Key = MacroblockMetadata.ClipCustoms.count - 1;
		}
		// Remove unnecessary default clips
		else if (MacroblockMetadata.ClipNames.count > MacroblockMetadata.ClipCustoms.count) {
			Key = MacroblockMetadata.ClipNames.count - 1;
		}

		if (Key >= 0) {
			declare Removed = False;
			Removed = MacroblockMetadata.ClipCustoms.removekey(Key);
			Removed = MacroblockMetadata.ClipNames.removekey(Key);
			Removed = MacroblockMetadata.ClipOffsets.removekey(Key);
			Removed = MacroblockMetadata.ClipConnections.removekey(Key);
			Removed = MacroblockMetadata.ClipDirs.removekey(Key);
		} else {
			break;
		}
	}
	SetMetadata(_MacroblockModel.Id, MacroblockMetadata);
}

// Save the metadata of the specified macroblock model
Void SaveMetadata(CMacroblockModel _MacroblockModel) {
	tuningmark("SaveMetadata");
	declare metadata K_GamepadEditorMetadata GamepadEditor for _MacroblockModel;
	GamepadEditor = GetMetadata(_MacroblockModel.Id); // Make sure that we're saving the last cached metadata
	SaveMacroblock(_MacroblockModel);
}

Void GenerateVariants(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return;

	declare Variants = Private_GetMacroblockModelVariants(_MacroblockModel);

	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);

	if (Variants.existskey(C_VariantGround) && Variants[C_VariantGround].count > 0) {
		MacroblockMetadata.Variants[C_VariantGround] = G_MetadataCache[Variants[C_VariantGround][0].Id].Id;
	}

	if (Variants.existskey(C_VariantAir) && Variants[C_VariantAir].count > 0) {
		MacroblockMetadata.Variants[C_VariantAir] = G_MetadataCache[Variants[C_VariantAir][0].Id].Id;
	}

	if (Variants.existskey(C_VariantForest) && Variants[C_VariantForest].count > 0) {
		MacroblockMetadata.Variants[C_VariantForest] = G_MetadataCache[Variants[C_VariantForest][0].Id].Id;
	}

	if (Variants.existskey(C_VariantForestEdge) && Variants[C_VariantForestEdge].count > 0) {
		MacroblockMetadata.Variants[C_VariantForestEdge] = G_MetadataCache[Variants[C_VariantForestEdge][0].Id].Id;
	}

	if (Variants.existskey(C_VariantDirt) && Variants[C_VariantDirt].count > 0) {
		MacroblockMetadata.Variants[C_VariantDirt] = G_MetadataCache[Variants[C_VariantDirt][0].Id].Id;
	}

	if (Variants.existskey(C_VariantWater) && Variants[C_VariantWater].count > 0) {
		MacroblockMetadata.Variants[C_VariantWater] = G_MetadataCache[Variants[C_VariantWater][0].Id].Id;
	}

	SetMetadata(_MacroblockModel.Id, MacroblockMetadata);
}

// Generate the metadata for a macroblock
Void GenerateMetadata(CMacroblockModel _MacroblockModel, Boolean _SaveMacroblock) {
	if (_MacroblockModel == Null) return;

	// Extract the root folder, family and type of the macroblock from its id
	declare RootFolder = "";
	declare Family = "";
	declare Type = "";
	declare Name = "";
	declare MacroblockId = TL::Split("\\", ""^_MacroblockModel.Id);
	if (MacroblockId.count >= 5) {
		RootFolder = MacroblockId[MacroblockId.count-5];
		Family = MacroblockId[MacroblockId.count-4];
		Type = MacroblockId[MacroblockId.count-3];
		Name = MacroblockId[MacroblockId.count-2];
	}

	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);

	MacroblockMetadata.Version = C_MacroblocksVersion;

	// Only macroblocks in the GamepadEditor folder are valid
	MacroblockMetadata.Valid = False;

	if (RootFolder != C_MacroblocksFolder) {
		if (_SaveMacroblock) {
			SaveMetadata(_MacroblockModel);
		}
		return;
	}
	ResetMetadata(_MacroblockModel);
	MacroblockMetadata = GetMetadata(_MacroblockModel.Id); //il faut refresh apres un reset

	MacroblockMetadata.Id = ""^_MacroblockModel.Id;
	MacroblockMetadata.Family = Family;
	MacroblockMetadata.Type = Type;
	MacroblockMetadata.Name = Name;
	MacroblockMetadata.Version = C_MacroblocksVersion;
	MacroblockMetadata.Valid = True;

	// Get the right variant
	declare Variant <=> GetBlockModelVariant(_MacroblockModel);

	// Find clips info
	declare ClipCount = 0;
	if (Family != C_TerrainsFolder) {
		foreach (BlockUnitModel in Variant.BlockUnitModels) {
			foreach (Dir => Clip in BlockUnitModel.Clips) {
				if (Clip == Null) continue;
				// Skip forbidden clip
				if (C_ForbiddenClips[Map.CollectionName].exists(Clip.Name)) continue;
				// Skip free clip
				if (TL::Find("FreeClip", Clip.Name, False, False) && !C_AuthorizedFreeClips[Map.CollectionName].exists(Clip.Name)) continue;
				// Skip disable clip
				declare ClipOffset = MU::GetNeighbourCoord(BlockUnitModel.RelativeOffset, Utils::IntToDir(Dir));
				if (ClipIsDisabled(_MacroblockModel, Clip.Name, ClipOffset, Dir)) continue;

				ClipCount += 1;

				MacroblockMetadata.ClipCustoms.add(False);
				MacroblockMetadata.ClipNames.add(Clip.Name);
				MacroblockMetadata.ClipOffsets.add(ClipOffset);
				MacroblockMetadata.ClipConnections.add(BlockUnitModel.RelativeOffset);
				MacroblockMetadata.ClipDirs.add(Dir);
			}
		}

		// Center of clips if there are clips
		declare Int3[] UniqueClipsConnections;
		foreach (ClipConnection in MacroblockMetadata.ClipConnections) {
			if (!UniqueClipsConnections.exists(ClipConnection)) UniqueClipsConnections.add(ClipConnection);
		}
		if (UniqueClipsConnections.count > 0) {
			MacroblockMetadata.ClipsCenter = <0., 0., 0.>;
			foreach (ClipOffset in UniqueClipsConnections) {
				MacroblockMetadata.ClipsCenter += (ClipOffset * 1.);
			}
			MacroblockMetadata.ClipsCenter = <
				(CollectionSquareSize * 0.5) + ((MacroblockMetadata.ClipsCenter.X / UniqueClipsConnections.count) * CollectionSquareSize),
				(MacroblockMetadata.ClipsCenter.Y / UniqueClipsConnections.count) * CollectionSquareHeight,
				(CollectionSquareSize * 0.5) + ((MacroblockMetadata.ClipsCenter.Z / UniqueClipsConnections.count) * CollectionSquareSize)
			>;
		}
		// Center of macroblock if there is no clip
		else {
			MacroblockMetadata.ClipsCenter = <
				ML::Abs(Variant.Size.X) * 0.5 * CollectionSquareSize,
				ML::Abs(Variant.Size.Y) * 0.5 * CollectionSquareHeight,
				ML::Abs(Variant.Size.Z) * 0.5 * CollectionSquareSize
			>;
		}
	}


	// Generate signature
	declare Signature = "";
	declare SignatureFirst = "";
	declare SignatureExists = False;
	for (I, 0, 3) {
		Signature = GenerateSignature(_MacroblockModel, I);

		if (SignatureFirst == "") SignatureFirst = Signature;

		if (G_LibMacroblock_SignaturesPool.exists(Signature)) {
			SignatureExists = True;
			break;
		}
	}

	if (!SignatureExists) {
		declare Key = GetAvailableSignatureKey();
		G_LibMacroblock_SignaturesPool[Key] = SignatureFirst;
		//MacroblockMetadata.Signature = SignatureFirst;
		MacroblockMetadata.SignatureKey = Key;
	} else {
		//MacroblockMetadata.Signature = Signature;
		MacroblockMetadata.SignatureKey = G_LibMacroblock_SignaturesPool.keyof(Signature);
	}

	// Check if the macroblock is shifting, turning or rising
	MacroblockMetadata.IsShifting = False;
	MacroblockMetadata.IsTurning = False;
	MacroblockMetadata.IsRising = False;


	if (Family != C_TerrainsFolder) {
		declare EntryOffset = <0, 0, 0>;
		declare EntryDir = 0;
		declare Vec3[] ClipPositions;
		foreach (Key => ClipOffset in MacroblockMetadata.ClipOffsets) {
			if (Key == 0) {
				EntryOffset = ClipOffset;
				EntryDir = MacroblockMetadata.ClipDirs[Key];
			} else {
				if (!MacroblockMetadata.IsRising && EntryOffset.Y != ClipOffset.Y) {
					MacroblockMetadata.IsRising = True;
				}
				if (!MacroblockMetadata.IsShifting && !MacroblockMetadata.IsTurning) {
					if (EntryOffset.X != ClipOffset.X && EntryOffset.Z != ClipOffset.Z) {
						if (MU::GetOpposedDir(Utils::IntToDir(EntryDir)) == Utils::IntToDir(MacroblockMetadata.ClipDirs[Key])) {
							MacroblockMetadata.IsShifting = True;
						} else {
							MacroblockMetadata.IsTurning = True;
						}
					}
				}
			}

			// Save clip position
			declare Dir = Utils::IntToDir(MacroblockMetadata.ClipDirs[Key]);
			declare Position = <ClipOffset.X * CollectionSquareSize, ClipOffset.Y * CollectionSquareHeight, ClipOffset.Z * CollectionSquareSize>;
			switch (Dir) {
				case CMapEditorPlugin::CardinalDirections::North: {
					Position.Z -= CollectionSquareSize * 0.5;
				}
				case CMapEditorPlugin::CardinalDirections::West: {
					Position.X -= CollectionSquareSize * 0.5;
				}
				case CMapEditorPlugin::CardinalDirections::South: {
					Position.Z += CollectionSquareSize * 0.5;
				}
				case CMapEditorPlugin::CardinalDirections::East: {
					Position.X += CollectionSquareSize * 0.5;
				}
			}
			ClipPositions.add(Position);
		}

		// Compute macroblock length between clips
		declare Real[] Lengths;
		while (ClipPositions.count > 1) {
			declare ClipPositionA = ClipPositions[0];
			declare Removed = ClipPositions.removekey(0);

			foreach (ClipPositionB in ClipPositions) {
				Lengths.add(ML::Distance(ClipPositionA, ClipPositionB));
			}
		}
		declare Length = 0.;
		if (Lengths.count > 0) {
			foreach (TmpLength in Lengths) {
				Length += TmpLength;
			}
			Length /= Lengths.count;
		} else {
			Length = ML::Distance(
				<0., 0., 0.>,
				<Variant.Size.X * CollectionSquareSize, (Variant.Size.Y - 1) * CollectionSquareHeight, Variant.Size.Z * CollectionSquareSize>
			);
		}
		MacroblockMetadata.Length = Length;
	} else {
		MacroblockMetadata.Length = 1.;
	}

	MacroblockMetadata.GroundOffset = 0;
	declare FullName = GetFullName(_MacroblockModel);
	if (
		_MacroblockModel.GeneratedBlockModel.VariantGround != Null
		&& C_GroundOffsets.existskey(Map.CollectionName)
	) {
		declare TextsToFind = C_GroundOffsets[Map.CollectionName];
		foreach (TextToFind => GroundOffset in TextsToFind) {
			if (TL::Find(TextToFind, FullName, True, True)) {
				MacroblockMetadata.GroundOffset = GroundOffset;
				break;
			}
		}
	}

	SetMetadata(_MacroblockModel.Id, MacroblockMetadata);

	if (_SaveMacroblock) SaveMetadata(_MacroblockModel);
}

// Log the metadata from a macroblock model
Void LogMetadata(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return;

	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);

	Utils::Log("---- BEGIN MACROBLOCK MODEL ----");
	Utils::Log("Id								: "^_MacroblockModel.Id);
	Utils::Log("MacroblockMetadata.Id					: "^MacroblockMetadata.Id);
	Utils::Log("MacroblockMetadata.Name					: "^MacroblockMetadata.Name);
	Utils::Log("MacroblockMetadata.Family				: "^MacroblockMetadata.Family);
	Utils::Log("MacroblockMetadata.Type					: "^MacroblockMetadata.Type);
	Utils::Log("MacroblockMetadata.IsShifting			: "^MacroblockMetadata.IsShifting);
	Utils::Log("MacroblockMetadata.IsTurning			: "^MacroblockMetadata.IsTurning);
	Utils::Log("MacroblockMetadata.IsRising				: "^MacroblockMetadata.IsRising);
	Utils::Log("MacroblockMetadata.Variants				: "^MacroblockMetadata.Variants);
	Utils::Log("MacroblockMetadata.ClipCustoms			: "^MacroblockMetadata.ClipCustoms);
	Utils::Log("MacroblockMetadata.DisabledClipsNames	: "^MacroblockMetadata.DisabledClipsNames);
	Utils::Log("MacroblockMetadata.DisabledClipsOffsets	: "^MacroblockMetadata.DisabledClipsOffsets);
	Utils::Log("MacroblockMetadata.DisabledClipsDirs	: "^MacroblockMetadata.DisabledClipsDirs);
	Utils::Log("MacroblockMetadata.ClipNames			: "^MacroblockMetadata.ClipNames);
	Utils::Log("MacroblockMetadata.ClipOffsets			: "^MacroblockMetadata.ClipOffsets);
	Utils::Log("MacroblockMetadata.ClipConnections		: "^MacroblockMetadata.ClipConnections);
	Utils::Log("MacroblockMetadata.ClipDirs				: "^MacroblockMetadata.ClipDirs);
	Utils::Log("MacroblockMetadata.ClipsCenter			: "^MacroblockMetadata.ClipsCenter);
	Utils::Log("MacroblockMetadata.CollisionsOffsets	: "^MacroblockMetadata.CollisionsOffsets);
	Utils::Log("MacroblockMetadata.SignatureKey			: "^MacroblockMetadata.SignatureKey);
	Utils::Log("MacroblockMetadata.Length				: "^MacroblockMetadata.Length);
	Utils::Log("MacroblockMetadata.GroundOffset			: "^MacroblockMetadata.GroundOffset);
	Utils::Log("MacroblockMetadata.Version				: "^MacroblockMetadata.Version);
	Utils::Log("MacroblockMetadata.Valid				: "^MacroblockMetadata.Valid);
	Utils::Log("---- END MACROBLOCK MODEL ----");
}

// Export the metadata of a macroblock model into XML
Text ExportMetadata(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return "";

	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);
	declare IsShifting = "0";
	if (MacroblockMetadata.IsShifting) IsShifting = "1";
	declare IsTurning = "0";
	if (MacroblockMetadata.IsTurning) IsTurning = "1";
	declare IsRising = "0";
	if (MacroblockMetadata.IsRising) IsRising = "1";

	declare Variants = "";
	if (MacroblockMetadata.Variants.count > 0) {
		foreach (VariantId => VariantName in MacroblockMetadata.Variants) {
			Variants ^= """
		<variant id="{{{VariantId}}}" name="{{{TL::MLEncode(VariantName)}}}" />""";
		}
		Variants = """<variants>{{{Variants}}}
	</variants>""";
	}

	declare Clips = "";
	if (MacroblockMetadata.ClipCustoms.count > 0) {
		foreach (ClipKey => ClipCustom in MacroblockMetadata.ClipCustoms) {
			declare IsCustom = "0";
			if (ClipCustom) IsCustom = "1";
			declare ClipOffset = MacroblockMetadata.ClipOffsets[ClipKey];
			declare Offset = ClipOffset.X^","^ClipOffset.Y^","^ClipOffset.Z;
			declare ClipConnection = MacroblockMetadata.ClipConnections[ClipKey];
			declare Connection = ClipConnection.X^","^ClipConnection.Y^","^ClipConnection.Z;
			declare Dir = MacroblockMetadata.ClipDirs[ClipKey];
			Clips ^= """
		<clip custom="{{{IsCustom}}}" name="{{{TL::MLEncode(MacroblockMetadata.ClipNames[ClipKey])}}}" offset="{{{Offset}}}" connection="{{{Connection}}}" dir="{{{Dir}}}" />""";
		}
		Clips = """<clips>{{{Clips}}}
	</clips>""";
	}

	declare Collisions = "";
	if (MacroblockMetadata.CollisionsOffsets.count > 0) {
		foreach (CollisionKey => CollisionOffset in MacroblockMetadata.CollisionsOffsets) {
			declare Offset = CollisionOffset.X^","^CollisionOffset.Y^","^CollisionOffset.X;
			Collisions ^= """<collision offset="{{{Offset}}}" />""";
		}
		Collisions = """<collisions>{{{Collisions}}}</collisions>""";
	}

	declare DisabledClips = "";
	if (MacroblockMetadata.DisabledClipsNames.count > 0) {
		foreach (ClipKey => ClipName in MacroblockMetadata.DisabledClipsNames) {
			declare ClipOffset = MacroblockMetadata.DisabledClipsOffsets[ClipKey];
			declare Offset = ClipOffset.X^","^ClipOffset.Y^","^ClipOffset.Z;
			declare Dir = MacroblockMetadata.DisabledClipsDirs[ClipKey];
			DisabledClips ^= """
		<clip name="{{{TL::MLEncode(ClipName)}}}" offset="{{{Offset}}}" dir="{{{Dir}}}" />""";
		}
		DisabledClips = """<disabledclips>{{{DisabledClips}}}
	</disabledclips>""";
	}

	declare ClipsCenter = MacroblockMetadata.ClipsCenter.X^","^MacroblockMetadata.ClipsCenter.Y^","^MacroblockMetadata.ClipsCenter.Z;

	declare Valid = "0";
	if (MacroblockMetadata.Valid) Valid = "1";

	return """
<macroblockmodel id="{{{TL::MLEncode(""^_MacroblockModel.Id)}}}">
	<id>{{{TL::MLEncode(MacroblockMetadata.Id)}}}</id>
	<name>{{{TL::MLEncode(MacroblockMetadata.Name)}}}</name>
	<family>{{{TL::MLEncode(MacroblockMetadata.Family)}}}</family>
	<type>{{{TL::MLEncode(MacroblockMetadata.Type)}}}</type>
	<isshifting>{{{IsShifting}}}</isshifting>
	<isturning>{{{IsTurning}}}</isturning>
	<isrising>{{{IsRising}}}</isrising>
	{{{Variants}}}
	{{{Clips}}}
	<clipscenter>{{{ClipsCenter}}}</clipscenter>
	{{{Collisions}}}
	<signaturekey>{{{MacroblockMetadata.SignatureKey}}}</signaturekey>
	<length>{{{MacroblockMetadata.Length}}}</length>
	<groundoffset>{{{MacroblockMetadata.GroundOffset}}}</groundoffset>
	<version>{{{TL::MLEncode(MacroblockMetadata.Version)}}}</version>
	<valid>{{{Valid}}}</valid>
</macroblockmodel>
""";
}

Text GetVersion(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return "";

	return GetMetadata(_MacroblockModel.Id).Version;
}

Boolean IsLatestVersion(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	return (GetMetadata(_MacroblockModel.Id).Version == C_MacroblocksVersion);
}

Boolean GetValidity(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	return GetMetadata(_MacroblockModel.Id).Valid;
}

// Get the custom id of a macroblock
Text GetId(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return "";

	return GetMetadata(_MacroblockModel.Id).Id;
}

Text GetName(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return "";

	return GetMetadata(_MacroblockModel.Id).Name;
}

// Get all of the variants of a macroblock
Text[Integer] GetVariants(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return [];

	return GetMetadata(_MacroblockModel.Id).Variants;
}

// Get the variant identifier of a macroblock
Integer GetVariant(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return C_VariantNull;

	switch (_MacroblockModel.Name) {
		case "Ground"		: return C_VariantGround;
		case "Air"			: return C_VariantAir;
		case "Forest"		: return C_VariantForest;
		case "ForestEdge"	: return C_VariantForestEdge;
		case "Dirt"			: return C_VariantDirt;
		case "Water"		: return C_VariantWater;
	}

	return C_VariantNull;
}

// Get if a macroblock model has a given variant
Boolean HasVariant(CMacroblockModel _MacroblockModel, Integer _Variant) {
	if (_MacroblockModel == Null) return False;

	return GetMetadata(_MacroblockModel.Id).Variants.existskey(_Variant);
}

Text GetFamily(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return "";

	return GetMetadata(_MacroblockModel.Id).Family;
}

Text GetType(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return "";

	return GetMetadata(_MacroblockModel.Id).Type;
}

// Check if a macroblock model has an orientation (eg: a checkpoint can't be placed in any way)
Boolean IsOriented(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	return (
		_MacroblockModel.HasCheckpoint ||
		GetMetadata(_MacroblockModel.Id).Type == "Checkpoints" ||
		GetMetadata(_MacroblockModel.Id).Type == "Turbos"
	);
}

// Check if a macroblock is shifting
Boolean IsShifting(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	return GetMetadata(_MacroblockModel.Id).IsShifting;
}

// Check if a macroblock is turning
Boolean IsTurning(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	return GetMetadata(_MacroblockModel.Id).IsTurning;
}

// Check if a macroblock is rising
Boolean IsRising(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	return GetMetadata(_MacroblockModel.Id).IsRising;
}

// Check if a macroblock is a transition between different types of clips
Boolean IsTransfert(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	declare PrevClipName = "";
	foreach (ClipName in GetMetadata(_MacroblockModel.Id).ClipNames) {
		if (PrevClipName != "" && PrevClipName != ClipName) return True;
		PrevClipName = ClipName;
	}

	return False;
}

// Disable a default clip
Void DisableClip(CMacroblockModel _MacroblockModel, Text _Name, Int3 _Offset, CMapEditorPlugin::CardinalDirections _Dir) {
	if (_MacroblockModel == Null) return;

	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);

	MacroblockMetadata.DisabledClipsNames.add(_Name);
	MacroblockMetadata.DisabledClipsOffsets.add(_Offset);
	MacroblockMetadata.DisabledClipsDirs.add(Utils::DirToInt(_Dir));

	SetMetadata(_MacroblockModel.Id, MacroblockMetadata);
}

// Enable a default clip
Void EnableClip(CMacroblockModel _MacroblockModel, Text _Name, Int3 _Offset, CMapEditorPlugin::CardinalDirections _Dir) {
	if (_MacroblockModel == Null) return;

	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);
	declare Integer[] ToRemove;

	foreach (Key => Name in MacroblockMetadata.DisabledClipsNames) {
		if (Name != _Name) continue;
		if (MacroblockMetadata.DisabledClipsOffsets[Key] != _Offset) continue;
		if (MacroblockMetadata.DisabledClipsDirs[Key] != Utils::DirToInt(_Dir)) continue;
		ToRemove.add(Key);
	}

	declare Shift = 0;
	foreach (Key in ToRemove) {
		declare Removed = False;
		Removed = MacroblockMetadata.DisabledClipsNames.removekey(Key - Shift);
		Removed = MacroblockMetadata.DisabledClipsOffsets.removekey(Key - Shift);
		Removed = MacroblockMetadata.DisabledClipsDirs.removekey(Key - Shift);
		Shift += 1;
	}

	SetMetadata(_MacroblockModel.Id, MacroblockMetadata);
}

// Check if a clip is custom
Boolean IsCustomClip(CMacroblockModel _MacroblockModel, Integer _ClipId) {
	if (_MacroblockModel == Null) return False;

	if (!GetMetadata(_MacroblockModel.Id).ClipCustoms.existskey(_ClipId)) return False;
	return GetMetadata(_MacroblockModel.Id).ClipCustoms[_ClipId];
}

// Check if a macroblock has a custom clip
Boolean HasCustomClips(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	return GetMetadata(_MacroblockModel.Id).ClipCustoms.exists(True);
}

// Get the names of a macroblock clips
Boolean[] GetClipCustoms(CMacroblockModel _MacroblockModel) { // Is this function used ? Correct ? Description does not fit
	if (_MacroblockModel == Null) return [];

	return GetMetadata(_MacroblockModel.Id).ClipCustoms;
}

// Add a new custom clip
Void AddClipCustom(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return;

	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);

	MacroblockMetadata.ClipCustoms.add(True);
	MacroblockMetadata.ClipNames.add("");
	MacroblockMetadata.ClipOffsets.add(<0, 0, 0>);
	MacroblockMetadata.ClipConnections.add(MU::GetNeighbourCoord(<0, 0, 0>, MU::GetOpposedDir(CMapEditorPlugin::CardinalDirections::North)));
	MacroblockMetadata.ClipDirs.add(Utils::DirToInt(CMapEditorPlugin::CardinalDirections::North));

	SetMetadata(_MacroblockModel.Id, MacroblockMetadata);
}

// Remove a custom clip
Void RemoveClipCustom(CMacroblockModel _MacroblockModel, Integer _ClipId) {
	if (_MacroblockModel == Null) return;

	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);

	if (!MacroblockMetadata.ClipCustoms.existskey(_ClipId)) return;
	if (!MacroblockMetadata.ClipCustoms[_ClipId]) return;
	declare Removed = MacroblockMetadata.ClipCustoms.removekey(_ClipId);

	Removed = MacroblockMetadata.ClipNames.removekey(_ClipId);
	Removed = MacroblockMetadata.ClipOffsets.removekey(_ClipId);
	Removed = MacroblockMetadata.ClipConnections.removekey(_ClipId);
	Removed = MacroblockMetadata.ClipDirs.removekey(_ClipId);

	SetMetadata(_MacroblockModel.Id, MacroblockMetadata);
}

// Edit a custom clip
Void EditClipCustom(CMacroblockModel _MacroblockModel, Integer _ClipId, Text _Name, Int3 _Offset, CMapEditorPlugin::CardinalDirections _Dir) {
	if (_MacroblockModel == Null) return;
	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);
	if (!MacroblockMetadata.ClipCustoms.existskey(_ClipId)) return;
	if (!MacroblockMetadata.ClipCustoms[_ClipId]) return;

	MacroblockMetadata.ClipNames[_ClipId] = _Name;
	MacroblockMetadata.ClipOffsets[_ClipId] = _Offset;
	MacroblockMetadata.ClipConnections[_ClipId] = MU::GetNeighbourCoord(_Offset, MU::GetOpposedDir(_Dir));
	MacroblockMetadata.ClipDirs[_ClipId] = Utils::DirToInt(_Dir);

	SetMetadata(_MacroblockModel.Id, MacroblockMetadata);
}

// Get the name of a macroblock clip from its id
Text GetClipName(CMacroblockModel _MacroblockModel, Integer _ClipId) {
	if (_MacroblockModel == Null) return "";

	declare CBlockClipList ClipList for _MacroblockModel;
	if (ClipList == Null) return "";
	if (!ClipList.Clips.existskey(_ClipId)) return "";
	return ClipList.Clips[_ClipId].Name;
}

// Get the names of a macroblock clips
Text[] GetClipNames(CMacroblockModel _MacroblockModel) {
	declare Text[] ClipNames;
	if (_MacroblockModel == Null) return ClipNames;

	declare CBlockClipList ClipList for _MacroblockModel;
	if (ClipList == Null) return ClipNames;

	foreach (Clip in ClipList.Clips) {
		ClipNames.add(Clip.Name);
	}

	return ClipNames;
}

// Get the names of a macroblock disabled clips
Text[] GetDisabledClipNames(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return [];

	return GetMetadata(_MacroblockModel.Id).DisabledClipsNames;
}

// Get the number of clips of a macroblock
Integer GetClipCount(CMacroblockModel _MacroblockModel) {
	declare CBlockClipList ClipList for _MacroblockModel;
	if (ClipList == Null) return 0;
	return ClipList.Clips.count;
}

// Get the offset of a macroblock clip from its id
Int3 GetClipOffset(CMacroblockModel _MacroblockModel, Integer _ClipId) {
	if (_MacroblockModel == Null) return Utils::NullCoord();

	declare CBlockClipList ClipList for _MacroblockModel;
	if (ClipList == Null) return Utils::NullCoord();
	if (!ClipList.Clips.existskey(_ClipId)) return Utils::NullCoord();

	return ClipList.Clips[_ClipId].Offset;
}

// Get the offsets of a macroblock clips
Int3[] GetClipOffsets(CMacroblockModel _MacroblockModel) {
	declare Int3[] Offsets;
	if (_MacroblockModel == Null) return Offsets;

	declare CBlockClipList ClipList for _MacroblockModel;
	if (ClipList == Null) return Offsets;
	if (ClipList.Clips.count == 0) return Offsets;

	foreach (Clip in ClipList.Clips) {
		Offsets.add(Clip.Offset);
	}
	return Offsets;
}

// Get the offsets of a macroblock disabled clips
Int3[] GetDisabledClipOffsets(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return [];

	return GetMetadata(_MacroblockModel.Id).DisabledClipsOffsets;
}

// Check if the macroblock model is a terrain macroblock
Boolean IsTerrain(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	return (GetMetadata(_MacroblockModel.Id).Family == C_TerrainsFolder);
}

// Check if the macroblock model is a decoration macroblock
Boolean IsDeco(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;
	if (!C_DecoStyles.existskey(Map.CollectionName)) return False;
	return C_DecoStyles[Map.CollectionName].exists(GetMetadata(_MacroblockModel.Id).Family);
}

// Get a generic cliplist that has already has been instantiated before, for external use mostly
CBlockClipList GetCreatedClipList(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return Null;
	declare CBlockClipList ClipList for _MacroblockModel;
	return ClipList;
}

// Get the Clip informations of a block as a CBlockClipList
CBlockClipList GetPlacedClipList(CMacroblockModel _MacroblockModel, Int3 _MacroblockCoord, CMapEditorPlugin::CardinalDirections _MacroblockDir) {
	if (_MacroblockModel == Null) return Null;
	tuningmark("GetPlacedClipList");

	declare CBlockClipList ClipList for _MacroblockModel;
	if (ClipList == Null) return Null;
	declare CBlockClipList PlacedClipList = CreateFrameClipList();
	PlacedClipList.SetFromClipList(ClipList, _MacroblockCoord, _MacroblockDir);

	return PlacedClipList;
}

// Get the Clip informations of a Macroblock as a CBlockClipList
CBlockClipList GetGenericClipList(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return Null;
	if (IsTerrain(_MacroblockModel) || IsDeco(_MacroblockModel)) return Null; // we don't care about their clips
	tuningmark("GetGenericClipList");
	declare CBlockClipList GenericMacroblockClipList = CreateFixedClipList();
	GenericMacroblockClipList.SetClipListFromMacroblock(_MacroblockModel);
	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);

	declare Integer I = 0;

	//Check if macroblock has disabled clips, if so remove them from the CBlockClipList
	if (MacroblockMetadata.DisabledClipsOffsets.count > 0 && !HasCustomClips(_MacroblockModel)) {
		I = 0;
		//Remove the disabled clips
		while (GenericMacroblockClipList.Clips.existskey(I)) {
			declare CBlockClip Clip <=> GenericMacroblockClipList.Clips[I];
			if (Clip == Null || ClipIsDisabled(_MacroblockModel, Clip.Name, Clip.Offset, Utils::DirToInt(Clip.Dir))) {
				GenericMacroblockClipList.RemoveClip(Clip);
			} else {
				I += 1;
			}
		}
	}

	// Check if macroblock has custom clips, if so add them to the CBlockClipList the "heavy way"
	if (HasCustomClips(_MacroblockModel)) {
		GenericMacroblockClipList.ClearClips(); //Clear ClipList first because of ClipId order issues

		declare Variant <=> GetBlockModelVariant(_MacroblockModel);
		if (Variant != Null) {
			declare VariantSize = Variant.Size;
			foreach (ClipId => ClipName in MacroblockMetadata.ClipNames) {
				declare ClipOffset = MacroblockMetadata.ClipOffsets[ClipId];
				declare IsClipCustom = MacroblockMetadata.ClipCustoms[ClipId];
				declare ClipDir = MacroblockMetadata.ClipDirs[ClipId];

				if (!IsClipCustom) {
					if (ClipIsDisabled(_MacroblockModel, ClipName, ClipOffset, ClipDir)) {
						continue;
					}
				}

				declare ClipCoords = <0, 0, 0> + MU::GetRotatedOffsetPositive(ClipOffset, CMapEditorPlugin::CardinalDirections::North, VariantSize);
				GenericMacroblockClipList.CreateAndAddClip(ClipName, ClipCoords, ClipOffset, Utils::IntToDir(ClipDir), ClipId);
			}
		}
	}

	//Filter forbidden clips/authorized freeclips in Script for now, maybe in c++ later
	while (GenericMacroblockClipList.Clips.existskey(I)) {
		declare CBlockClip Clip <=> GenericMacroblockClipList.Clips[I];
		if (Clip == Null || C_ForbiddenClips[Map.CollectionName].exists(Clip.Name) ||(TL::Find("FreeClip", Clip.Name, False, False) && !C_AuthorizedFreeClips[Map.CollectionName].exists(Clip.Name)) ) {
			GenericMacroblockClipList.RemoveClip(Clip);
		} else {
			I += 1;
		}
	}
	//Make sure there are no gaps in the clipIds (ex: MainToArenaTunnel had clips 0 and 2 because 1 and 3 were removed above > change them to clips 0 & 1)
	I = 0;
	foreach (Clip in GenericMacroblockClipList.Clips) {
		Clip.ClipId = I;
		I +=1 ;
	}
	return GenericMacroblockClipList;
}

//  Get the connections of a macroblock clips
//	@return							The connections of the clips if found, an empty array otherwise
Int3[] GetClipConnections(CMacroblockModel _MacroblockModel) {
	declare Int3[] ConnectableCoords;
	if (_MacroblockModel == Null) return ConnectableCoords;

	declare CBlockClipList ClipList for _MacroblockModel;
	if (ClipList == Null) return ConnectableCoords;
	if (ClipList.Clips.count == 0) return ConnectableCoords;

	foreach (Clip in ClipList.Clips) {
		ConnectableCoords.add(Clip.GetConnectableCoord());
	}

	return ConnectableCoords;
}

// Get the position of a macroblock clip connection
// @return							The position of the clip connection if found, Utils::NullCoord() otherwise
Int3 GetClipConnection(CMacroblockModel _MacroblockModel, Int3 _Coord, CMapEditorPlugin::CardinalDirections _Dir, Integer _ClipId) {
	if (_MacroblockModel == Null) return Utils::NullCoord();
	declare Variant <=> GetBlockModelVariant(_MacroblockModel);
	if (Variant == Null) return Utils::NullCoord();


	declare CBlockClipList TestedMacroblockClipList = GetPlacedClipList(_MacroblockModel, _Coord, _Dir);
	declare ConnectableCoord = TestedMacroblockClipList.Clips[_ClipId].GetConnectableCoord();
	return ConnectableCoord;
}

// Get the position of a macroblock clip
// @return							The position of the clip if found, Utils::NullCoord() otherwise
Int3 GetClipCoord(CMacroblockModel _MacroblockModel, Int3 _Coord, CMapEditorPlugin::CardinalDirections _Dir, Integer _ClipId) {
	if (_MacroblockModel == Null) return Utils::NullCoord();
	declare Variant <=> GetBlockModelVariant(_MacroblockModel);
	if (Variant == Null) return Utils::NullCoord();

	declare CBlockClipList TestedMacroblockClipList = GetPlacedClipList(_MacroblockModel, _Coord, _Dir);
	declare ClipCoord = TestedMacroblockClipList.Clips[_ClipId].Coord;
	return ClipCoord;
}

// Get the position of a macroblock clip
// @return							The position of the clip if found, Utils::NullCoord() otherwise
Int3 GetClipCoord(CMacroblockModel _MacroblockModel, Int3 _BlockCoord, CMapEditorPlugin::CardinalDirections _BlockDir, Int3 _ClipOffset) {
	if (_MacroblockModel == Null) return Utils::NullCoord();
	declare Variant <=> GetBlockModelVariant(_MacroblockModel);
	if (Variant == Null) return Utils::NullCoord();

	return _BlockCoord + MU::GetRotatedOffsetPositive(_ClipOffset, _BlockDir, Variant.Size);
}

// Get the position of a macroblock clips offsets or connections
// @param	_ConnectableCoords			True get the _ConnectableCoords, False get the Coords
// @return							The position of the clips if found, an empty array otherwise
Int3[] GetClipCoords(CMacroblockModel _MacroblockModel, Int3 _Coord, CMapEditorPlugin::CardinalDirections _Dir, Boolean _ConnectableCoords) {
	declare Int3[] ClipPositions;
	if (_MacroblockModel == Null) return ClipPositions;

	declare CBlockClipList TestedMacroblockClipList = GetPlacedClipList(_MacroblockModel, _Coord, _Dir);

	foreach (ListClip in TestedMacroblockClipList.Clips) {
		if (_ConnectableCoords) {
			ClipPositions.add(ListClip.GetConnectableCoord());
		} else {
			ClipPositions.add(ListClip.Coord);
		}
	}

	return ClipPositions;
}

// Get the position of a macroblock clips offsets
// @return							The position of the clips if found, an empty array otherwise
Int3[] GetClipCoords(CMacroblockModel _MacroblockModel, Int3 _Coord, CMapEditorPlugin::CardinalDirections _Dir) {
	return GetClipCoords(_MacroblockModel, _Coord, _Dir, False);
}

// Get the dir of a macroblock clip from its id
// @return							The dir of the clip if found, C_NullDir otherwise
CMapEditorPlugin::CardinalDirections GetClipDir(CMacroblockModel _MacroblockModel, Integer _ClipId) {
	if (_MacroblockModel == Null) return C_NullDir;

	declare CBlockClipList ClipList for _MacroblockModel;
	if (ClipList == Null) return C_NullDir;
	if (!ClipList.Clips.existskey(_ClipId)) return C_NullDir;
	return ClipList.Clips[_ClipId].Dir;
}

// Get the direction of a macroblock clip with a rotation
// @return							The dirs of the clips if found, an empty array otherwise
CMapEditorPlugin::CardinalDirections GetClipDir(CMacroblockModel _MacroblockModel, CMapEditorPlugin::CardinalDirections _Dir, Integer _ClipId) {
	if (_MacroblockModel == Null) return C_NullDir;

	declare CBlockClipList TestedMacroblockClipList = GetPlacedClipList(_MacroblockModel, <0,0,0>, _Dir);
	declare ClipDir = TestedMacroblockClipList.Clips[_ClipId].Dir;
	return ClipDir;
}

// Get the dirs of a macroblock clips
// @return							The dirs of the clips if found, an empty array otherwise
CMapEditorPlugin::CardinalDirections[] GetClipDirs(CMacroblockModel _MacroblockModel) {
	declare CMapEditorPlugin::CardinalDirections[] ClipDirs;
	if (_MacroblockModel == Null) return ClipDirs;

	declare CBlockClipList ClipList for _MacroblockModel;
	if (ClipList == Null) return ClipDirs;
	foreach (Clip in ClipList.Clips) {
		ClipDirs.add(Clip.Dir);
	}
	return ClipDirs;
}

// Get the dirs of a macroblock disabled clips
// @return							The dirs of the clips if found, an empty array otherwise
CMapEditorPlugin::CardinalDirections[] GetDisabledClipDirs(CMacroblockModel _MacroblockModel) {
	declare CMapEditorPlugin::CardinalDirections[] ClipDirs;
	if (_MacroblockModel == Null) return ClipDirs;

	foreach (Dir in GetMetadata(_MacroblockModel.Id).DisabledClipsDirs) {
		ClipDirs.add(Utils::IntToDir(Dir));
	}
	return ClipDirs;
}

// Get the dirs of a macroblock clips with a rotation
// @return							The dirs of the clips if found, an empty array otherwise
CMapEditorPlugin::CardinalDirections[] GetClipDirs(CMacroblockModel _MacroblockModel, CMapEditorPlugin::CardinalDirections _Dir) {
	declare CMapEditorPlugin::CardinalDirections[] ClipDirs;
	if (_MacroblockModel == Null) return ClipDirs;

	declare CBlockClipList TestedMacroblockClipList = GetPlacedClipList(_MacroblockModel, <0,0,0>, _Dir);
	foreach (Clip in TestedMacroblockClipList.Clips) {
		ClipDirs.add(Clip.Dir);
	}

	return ClipDirs;
}

Vec3 GetClipsCenter(CMacroblockModel _MacroblockModel, CMapEditorPlugin::CardinalDirections _Dir) {
	if (_MacroblockModel == Null) return <0., 0., 0.>;

	declare Direction = MU::GetRotatedOffset(<1, 1, 1>, _Dir);
	if (Direction.X != Direction.Z) {
		return <
			ML::Abs(GetMetadata(_MacroblockModel.Id).ClipsCenter.Z * Direction.Z),
			ML::Abs(GetMetadata(_MacroblockModel.Id).ClipsCenter.Y * Direction.Y),
			ML::Abs(GetMetadata(_MacroblockModel.Id).ClipsCenter.X * Direction.X)
		>;
	}
	return GetMetadata(_MacroblockModel.Id).ClipsCenter;
}

// Check if a clip can only be used to go out (won't ever be shown as the "next" block entrance)
Boolean IsOutClip(Text _ClipName) {
	return G_LibMacroblock_OutClips.exists(_ClipName);
}

// Get the names of the clips that can be connected to the provided clip
Text[] GetConnectableClips(Text _ClipName) {
	// Get from cache
	if (G_LibMacroblock_ConnectableClips.existskey(_ClipName)) return G_LibMacroblock_ConnectableClips[_ClipName];

	declare Text[] Clips;
	declare ClipName = _ClipName;
	declare ClipNameSuffix = "";
	declare ClipNameLength = TL::Length(ClipName);
	declare ClipInOut = "";

	foreach (InOut in ["-In", "-Out"]) {
		declare InOutLength = TL::Length(InOut);
		declare Suffix = TL::SubString(ClipName, ClipNameLength - InOutLength, ClipNameLength);
		if (InOut == Suffix) {
			ClipName = TL::SubString(ClipName, 0, ClipNameLength - InOutLength);
			ClipInOut = Suffix;
			break;
		}
	}

	// "-In" clip can't be connected to anything
	if (ClipInOut == "-In") return [];

	if (ClipInOut == "") {
		// Check if the clip has a suffix
		foreach (SuffixLeft => SuffixRight in C_ClipsSuffixes) {
			declare SuffixLeftLength = TL::Length(SuffixLeft);
			declare Suffix = TL::SubString(ClipName, ClipNameLength - SuffixLeftLength, ClipNameLength);
			if (SuffixLeft == Suffix) {
				ClipName = TL::SubString(ClipName, 0, ClipNameLength - SuffixLeftLength);
				ClipNameSuffix = Suffix;
				break;
			}
		}
	}

	// Find connectable suffix
	if (C_ClipsSuffixes.existskey(ClipNameSuffix)) {
		ClipNameSuffix = C_ClipsSuffixes[ClipNameSuffix];
	}

	// Add connectable clips
	// Special cases
	if (Map.CollectionName == "Canyon" && ClipName == "ArenaHalfBaseFreeClip") {
		Clips.add("ArenaHalfBaseFreeClip"^ClipNameSuffix); ///< ArenaHalfBaseFreeClipEst - ArenaHalfBaseFreeClipWest
		Clips.add("ArenaFreeClip");
		Clips.add("ArenaHallwayFreeClip");
	} else if (Map.CollectionName == "Canyon" && (ClipName == "ArenaFreeClip" || ClipName == "ArenaHallwayFreeClip")) {
		Clips.add("ArenaHalfBaseFreeClipEst");
		Clips.add("ArenaHalfBaseFreeClipWest");
		Clips.add("ArenaFreeClip");
		Clips.add("ArenaHallwayFreeClip");
	} else if (Map.CollectionName == "Canyon" && (
		ClipName == "ArenaTunnelOpen2SidesFreeClip" ||
		ClipName == "ArenaTunnelOpen1SideFreeClip" ||
		ClipName == "ArenaTunnelOpenFreeClip" ||
		ClipName == "ArenaTunnelFreeClip"
	)) {
		Clips.add("ArenaTunnelFreeClip");
		Clips.add("ArenaTunnelOpen2SidesFreeClip");
		Clips.add("ArenaTunnelOpen1SideFreeClipLeft");
		Clips.add("ArenaTunnelOpen1SideFreeClipRight");
		Clips.add("ArenaTunnelOpenFreeClip");
	} else if (Map.CollectionName == "Canyon" && (ClipName == "RoadRaceClipRight" || ClipName == "RoadRaceClipLeft")) {
		// Up and down road race
		if (ClipName == "RoadRaceClipRight") Clips.add("RoadRaceClipLeft"^ClipNameSuffix);
		if (ClipName == "RoadRaceClipLeft") Clips.add("RoadRaceClipRight"^ClipNameSuffix);
	} else if (Map.CollectionName == "Valley" && ClipName == "CastleCenterLakeFreeClip") {
		Clips.add("CastleCenterLakeFreeClip");
		Clips.add("CastleGardenLakeFreeClip");
	} else if (Map.CollectionName == "Valley" && ClipName == "CastleBridgeLakeFreeClip") {
		Clips.add("CastleGardenLakeFreeClip");
		Clips.add("CastleBridgeLakeFreeClip");
	} else if (Map.CollectionName == "Valley" && ClipName == "CastleGardenLakeFreeClip") {
		Clips.add("CastleCenterLakeFreeClip");
		Clips.add("CastleGardenLakeFreeClip");
		Clips.add("CastleBridgeLakeFreeClip");
	} else if (Map.CollectionName == "Valley" && (ClipName == "ArenaParkFreeClip" || ClipName == "ArenaParkRoofBaseFreeClip")) {
		Clips.add("ArenaParkFreeClip");
		Clips.add("ArenaParkRoofBaseFreeClip");
	} else if (Map.CollectionName == "Valley" && (ClipName == "RoadForestLargeTechGrassClip" || ClipName == "RoadForestLargeGrassFreeClip" || ClipName == "RoadForestLargeSlopeGrassClip")) {
		Clips.add("RoadForestLargeTechGrassClip");
		Clips.add("RoadForestLargeGrassFreeClip");
		Clips.add("RoadForestLargeSlopeGrassClip");
	} else if (Map.CollectionName == "Valley" && (ClipName == "RoadForestLargeTechClip" || ClipName == "RoadForestLargeFreeClip" || ClipName == "RoadForestLargeSlopeClip")) {
		Clips.add("RoadForestLargeTechClip");
		Clips.add("RoadForestLargeFreeClip");
		Clips.add("RoadForestLargeSlopeClip");
	} else if (Map.CollectionName == "Stadium" && (ClipName == "StadiumCircuitFreeClip" || ClipName == "Platform")) {
		Clips.add("StadiumCircuitFreeClip");
		Clips.add("Platform");
	} else if (Map.CollectionName == "Stadium" && (ClipName == "ArenaSlope"/*+suffix*/ || ClipName == "PlatformSlope"/*+suffix*/)) {
		if (ClipNameSuffix == "Left" || ClipNameSuffix == "Right") {
			Clips.add("StadiumCircuitSlopeStraightFreeClip"^ClipNameSuffix);
			Clips.add("PlatformSlope"^ClipNameSuffix);
		} else {
			Clips.add("ArenaSlope"^ClipNameSuffix);
			Clips.add("PlatformSlope"^ClipNameSuffix);
		}
	} else if (Map.CollectionName == "Stadium" && (ClipName == "StadiumCircuitSlopeEndFreeClip"/*+suffix*/ || ClipName == "PlatformSlopeEnd"/*+suffix*/)) {
		Clips.add("StadiumCircuitSlopeEndFreeClip"^ClipNameSuffix);
		Clips.add("PlatformSlopeEnd"^ClipNameSuffix);
	} else if (Map.CollectionName == "Stadium" && (ClipName == "StadiumCircuitSlopeStartFreeClip"/*+suffix*/ || ClipName == "PlatformSlopeStart"/*+suffix*/)) {
		Clips.add("StadiumCircuitSlopeStartFreeClip"^ClipNameSuffix);
		Clips.add("PlatformSlopeStart"^ClipNameSuffix);
	} else if (Map.CollectionName == "Stadium" && (ClipName == "RoadWaterVFC" || ClipName == "RoadTechFC")) {
		Clips.add("RoadWaterVFC"^ClipNameSuffix);
		Clips.add("RoadTechFC"^ClipNameSuffix);
	} else if (Map.CollectionName == "Stadium" && ClipName == "PlatformWaterFCSmall") {
		Clips.add("PlatformWaterFCSmall"^ClipNameSuffix);
		Clips.add("PlatformWaterHFCInsideNoOut"^ClipNameSuffix);
	} else if (Map.CollectionName == "Stadium" && ClipName == "PlatformFCSmall") {
		Clips.add("PlatformFCSmall"^ClipNameSuffix);
		Clips.add("PlatformWaterHFCInsideNoOut"^ClipNameSuffix);
	} else if (Map.CollectionName == "Stadium" && ClipName == "PlatformWaterHFCInsideNoOut") {
		Clips.add("PlatformWaterHFCInsideNoOut"^ClipNameSuffix);
		Clips.add("PlatformWaterFCSmall"^ClipNameSuffix);
		Clips.add("PlatformFCSmall"^ClipNameSuffix);
	}
	// Default case
	else {
		Clips.add(ClipName^ClipNameSuffix);
	}

	// All clips can be connected to their "-In" counterpart
	declare TmpClips = Clips;
	foreach (Clip in TmpClips) {
		Clips.add(Clip^"-In");
		Clips.add(Clip^"-Out");
	}

	// Save in cache
	G_LibMacroblock_ConnectableClips[_ClipName] = Clips;

	return Clips;
}

// Check if a macroblock has a custom collision
Boolean HasCollision(CMacroblockModel _MacroblockModel) {
	return GetMetadata(_MacroblockModel.Id).CollisionsOffsets.count > 0;
}

// Get the custom collisions offsets of a macroblock
Int3[] GetCollisionsOffsets(CMacroblockModel _MacroblockModel) {
	return GetMetadata(_MacroblockModel.Id).CollisionsOffsets;
}

// Get the custom collisions coordinates of a macroblock
Int3[] GetCollisionsCoords(CMacroblockModel _MacroblockModel, Int3 _Coord, CMapEditorPlugin::CardinalDirections _Dir) {
	tuningmark("GetCollisionsCoords");
	declare Int3[] CollisionsPositions;
	if (_MacroblockModel == Null) return CollisionsPositions;
	declare Variant <=> GetBlockModelVariant(_MacroblockModel);
	if (Variant == Null) return CollisionsPositions;
	foreach (CollisionOffset in GetMetadata(_MacroblockModel.Id).CollisionsOffsets) {
		declare CollisionPosition = _Coord + MU::GetRotatedOffsetPositive(CollisionOffset, _Dir, Variant.Size);
		CollisionsPositions.add(CollisionPosition);
	}

	return CollisionsPositions;
}

// Add a new custom collision
Void AddCollision(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return;

	declare Metadata = GetMetadata(_MacroblockModel.Id);
	Metadata.CollisionsOffsets.add(<0, 0, 0>);
	SetMetadata(_MacroblockModel, Metadata);
}

// ---------------------------------- //
/** Remove a collision
 *
 *	@param	_MacroblockModel		The macroblock model to edit
 *	@param	_CollisionId			Id of the collision to remove
 */
Void RemoveCollision(CMacroblockModel _MacroblockModel, Integer _CollisionId) {
	if (_MacroblockModel == Null) return;

	declare Metadata = GetMetadata(_MacroblockModel.Id);
	Metadata.CollisionsOffsets.removekey(_CollisionId);
	SetMetadata(_MacroblockModel, Metadata);
}

// Edit a custom collision
Void EditCollision(CMacroblockModel _MacroblockModel, Integer _CollisionId, Int3 _Offset) {
	if (_MacroblockModel == Null) return;

	declare Metadata = GetMetadata(_MacroblockModel.Id);
	if (!Metadata.CollisionsOffsets.existskey(_CollisionId)) return;
	Metadata.CollisionsOffsets[_CollisionId] = _Offset;
	SetMetadata(_MacroblockModel, Metadata);
}

// Get the blocks contained in a macroblock
CBlock[] GetBlocks(CMacroblockModel _MacroblockModel, Int3 _Coord, CMapEditorPlugin::CardinalDirections _Dir, Boolean _WithTerrain) {
	declare CBlock[] MacroblockBlocks;
	declare Variant <=> GetBlockModelVariant(_MacroblockModel);
	if (Variant == Null) return MacroblockBlocks;

	declare VariantSize = Variant.Size;
	foreach (BlockUnit in Variant.BlockUnitModels) {
		declare Coord = _Coord + MU::GetRotatedOffsetPositive(BlockUnit.RelativeOffset, _Dir, VariantSize);
		declare Block <=> GetBlock(Coord);
		if (Block == Null) continue;
		if (!_WithTerrain && Block.BlockModel.IsTerrain) continue;
		if (!MacroblockBlocks.exists(Block)) MacroblockBlocks.add(Block);
	}

	return MacroblockBlocks;
}

// Get the coordinates occupied by a macroblock
Int3[] GetCoords(CMacroblockModel _MacroblockModel, Int3 _Coord, CMapEditorPlugin::CardinalDirections _Dir, Boolean _WithCollision) {
	tuningmark("GetCoords");
	declare Int3[] Coords;
	declare Variant <=> GetBlockModelVariant(_MacroblockModel);
	if (Variant == Null) return Coords;

	declare VariantSize = Variant.Size;

	tuningmark("GetCoords foreach 1");
	foreach (BlockUnit in Variant.BlockUnitModels) {
		Coords.add(_Coord + MU::GetRotatedOffsetPositive(BlockUnit.RelativeOffset, _Dir, VariantSize));
	}

	tuningmark("GetCoords foreach 2");
	// Add custom collisions
	if (_WithCollision) {
		foreach (CollisionOffset in GetMetadata(_MacroblockModel.Id).CollisionsOffsets) {
			Coords.add(_Coord + MU::GetRotatedOffsetPositive(CollisionOffset, _Dir, VariantSize));
		}
	}

	return Coords;
}

// Get the coordinates occupied by a macroblock
Int3[] GetCoords(CMacroblockModel _MacroblockModel, Int3 _Coord, CMapEditorPlugin::CardinalDirections _Dir) {
	return GetCoords(_MacroblockModel, _Coord, _Dir, True);
}

// Get the coordinates occupied by a macroblock instance. Faster than the Model counterpart but can only be used when a block is placed
Int3[] GetCoords(CMacroblockInstance _MacroblockInstance, Boolean _WithCollision) {
	tuningmark("GetCoords Instance");
	declare Int3[] Coords;
	if (_MacroblockInstance == Null) return Coords;

	foreach (Coord in _MacroblockInstance.UnitCoords) {
		Coords.add(Coord);
	}

	// Add custom collisions
	if (_WithCollision) {
		declare MBCoord = _MacroblockInstance.Coord;
		declare MBDir = _MacroblockInstance.Dir;
		declare MBSize = _MacroblockInstance.GetSize();
		foreach (CollisionOffset in GetMetadata(_MacroblockInstance.MacroblockModel.Id).CollisionsOffsets) {
			Coords.add(MBCoord + MU::GetRotatedOffsetPositive(CollisionOffset, MBDir, MBSize));
		}
	}

	return Coords;
}

// Get the coordinates of one block unit of a macroblockmodel
Int3 GetBlockUnitCoord(CMacroblockModel _MacroblockModel, Int3 _Coord, CMapEditorPlugin::CardinalDirections _Dir) {
	declare Variant <=> GetBlockModelVariant(_MacroblockModel);
	if (Variant == Null) return Utils::NullCoord();

	foreach (BlockUnit in Variant.BlockUnitModels) {
		return _Coord + MU::GetRotatedOffsetPositive(BlockUnit.RelativeOffset, _Dir, Variant.Size);
	}

	return Utils::NullCoord();
}

// Check if two macroblocks collide
Boolean Collide(
	CMacroblockModel _MacroblockModel1, Int3 _Coord1, CMapEditorPlugin::CardinalDirections _Dir1,
	CMacroblockModel _MacroblockModel2, Int3 _Coord2, CMapEditorPlugin::CardinalDirections _Dir2
) {
	declare Coords1 = GetCoords(_MacroblockModel1, _Coord1, _Dir1);
	declare Coords2 = GetCoords(_MacroblockModel2, _Coord2, _Dir2);

	return Coords1.containsoneof(Coords2);
}

// Get the signature key of a macroblock
Integer GetSignatureKey(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return -1;

	return GetMetadata(_MacroblockModel.Id).SignatureKey;
}

// Get the length of a macroblock
Real GetLength(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return 0.;

	return GetMetadata(_MacroblockModel.Id).Length;
}

// Get the ground offset of a macroblock
Integer GetGroundOffset(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return 0;

	return GetMetadata(_MacroblockModel.Id).GroundOffset;
}

// Remove a macroblock from the track
Boolean Remove(CMacroblockModel _MacroblockModel, Int3 _Coord, CMapEditorPlugin::CardinalDirections _Dir) {
	return RemoveMacroblock_NoTerrain(_MacroblockModel, _Coord, _Dir);

	// Old version
	declare Removed = False;

	if (!Removed && Map.CollectionName == "Stadium") {
		if (_MacroblockModel == Null) return False;
		declare Variant <=> GetBlockModelVariant(_MacroblockModel);
		if (Variant == Null) return False;

		foreach (BlockUnit in Variant.BlockUnitModels) {
			declare Coord = _Coord + MU::GetRotatedOffsetPositive(BlockUnit.RelativeOffset, _Dir, Variant.Size);
			declare BlockUnitRemoved = RemoveBlock(Coord);
			if (!Removed && BlockUnitRemoved) Removed = True;
		}
	}

	return Removed;
}

// Check if a macroblock can be used as a spawn
Boolean IsSpawnable(CMacroblockModel _MacroblockModel) {
	return (
		_MacroblockModel != Null &&
		(
			_MacroblockModel.HasCheckpoint ||
			_MacroblockModel.HasStart ||
			_MacroblockModel.HasMultilap
		)
	);
}

//	Get the block to use to udpate the uid of the track
CMacroblockModel GetUpdateUidBlock() {
	if (G_LibMacroblock_UpdateUidBlock == Null) {
		foreach (Key => MacroblockModel in MacroblockModels) {
			declare FullName = GetFullName(MacroblockModel);

			// Assign the block to use to update the uid of the track
			if (FullName == C_UpdateUidBlock && MacroblockModel.Name == "Air") {
				G_LibMacroblock_UpdateUidBlock <=> MacroblockModel;
			}
		}
	}
	return G_LibMacroblock_UpdateUidBlock;
}

Void GenerateRenameFreeClipsHack(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return;

	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);
	declare ClipCount = MacroblockMetadata.ClipCustoms.count;
	declare Text[Text] ClipNamesToRename = [
		"PlatformSlope2FCUpSmallRacing" => "PlatformSlope2FCUp",
		"PlatformSlope2FCDownSmallRacing" => "PlatformSlope2FCDown",
		"PlatformSlope2StraightFCRightSmallRacing" => "PlatformSlope2FCRight",
		"PlatformSlope2StraightFCLeftSmallRacing" => "PlatformSlope2FCLeft",
		"PlatformDiag1Slope2DownLeftFC" => "PlatformSlope2StraightFCRight",
		"PlatformDiag1Slope2DownLeftFCDown" => "PlatformSlope2FCUp",
		"PlatformDiag1Slope2DownRightFC" => "PlatformSlope2StraightFCLeft",
		"PlatformDiag1Slope2DownRightFCUp" => "PlatformSlope2FCDown",
		"PlatformDiag1Slope2UpLeftFC" => "PlatformSlope2StraightFCLeft",
		"PlatformDiag1Slope2UpLeftFCDown" => "PlatformSlope2FCUp",
		"PlatformDiag1Slope2UpRightFC" => "PlatformSlope2StraightFCRight",
		"PlatformDiag1Slope2UpRightFCUp" => "PlatformSlope2FCDown",
		"PlatformSlope2UTopFCDownSmall" => "PlatformSlope2FCDown",
		"PlatformSlope2UBottomFCUpSmall" => "PlatformSlope2FCUp",
		"PlatformSlopeBaseCurve1InFCRightSmall" => "PlatformSlopeBaseFCRight",
		"PlatformSlopeBaseCurve1InFCLeftSmall" => "PlatformSlopeBaseFCLeft",
		"PlatformSlopeBaseFCLeftSmall" => "PlatformSlopeBaseFCLeft",
		"PlatformSlopeBaseFCRightSmall" => "PlatformSlopeBaseFCRight",
		"PlatformSlopeBaseCurve1OutFCRightSmall" => "PlatformFCSmall",
		"PlatformSlopeBaseCurve1OutFCLeftSmall" => "PlatformFCSmall",
		"PlatformSlope2Curve1InFCLeftSmall" => "PlatformSlope2StraightFCLeft",
		"PlatformSlope2Curve2InFCLeftSmall" => "PlatformSlope2StraightFCLeft",
		"PlatformSlope2Curve1InFCRightSmall" => "PlatformSlope2StraightFCRight",
		"PlatformSlope2Curve2InFCRightSmall" => "PlatformSlope2StraightFCRight",
		"PlatformSlope2Curve1OutFCLeftSmall" => "PlatformSlope2StraightFCLeft",
		"PlatformSlope2Curve1OutFCRightSmall" => "PlatformSlope2StraightFCRight",
		"PlatformSlope2BaseCurve1InFCLeftSmall" => "PlatformSlope2BaseFCLeft",
		"PlatformSlope2BaseCurve1InFCRightSmall" => "PlatformSlope2BaseFCRight",
		"PlatformSlope2StraightFCLeftSmall" => "PlatformSlope2StraightFCLeft",
		"PlatformSlope2StraightFCRightSmall" => "PlatformSlope2StraightFCRight",
		"PlatformSlope2FCUpSmall" => "PlatformSlope2FCUp",
		"PlatformSlope2FCDownSmall" => "PlatformSlope2FCDown",
		"PlatformSlope2BaseFCLeftSmall" => "PlatformSlope2BaseFCLeft",
		"PlatformSlope2BaseFCRightSmall" => "PlatformSlope2BaseFCRight",
		"PlatformSlope2BaseCurve1OutFCLeftSmall" => "PlatformFCSmall",
		"PlatformTiltTransition1UpLeftFCSmall" => "PlatformTiltTransition1UpLeft",
		"PlatformTiltTransition1UpRightFCSmall" => "PlatformTiltTransition1UpRight",
		"PlatformTiltTransition1DownRightFCSmall" => "PlatformTiltTransition1DownRight",
		"PlatformTiltTransition1DownLeftFCSmall" => "PlatformTiltTransition1DownLeft",
		"PlatformLoopStartFCSmall" => "PlatformFCSmall",
		"PlatformFCSmallRacing" => "PlatformFCSmall",
		"PlatformSlope2EndFCRightSmall" => "PlatformSlope2EndFCRight",
		"PlatformSlope2EndFCLeftSmall" => "PlatformSlope2EndFCLeft",
		"PlatformSlope2StartFCRightSmall" => "PlatformSlope2StartFCRight",
		"PlatformSlope2StartFCLeftSmall" => "PlatformSlope2StartFCLeft",
		"PlatformTiltTransition1UpRightFCSlope2Base" => "PlatformSlope2BaseFCRight",
		"PlatformTiltTransition1DownRightFCSlope2Base" => "PlatformSlope2BaseFCRight",
		"PlatformTiltTransition1UpLeftFCSlope2Base" => "PlatformSlope2BaseFCLeft",
		"PlatformTiltTransition1DownLeftFCSlope2Base" => "PlatformSlope2BaseFCLeft",
		"PlatformTiltTransition1DownLeftFCSlope2Straight" => "PlatformSlope2StraightFCLeft",
		"PlatformTiltTransition1DownRightFCSlope2Straight" => "PlatformSlope2StraightFCRight",
		"PlatformSlope2StraightFCRight" => "PlatformSlope2FCRight",
		"PlatformSlope2StraightFCLeft" => "PlatformSlope2FCLeft"
	];

	declare MbName = MacroblockMetadata.Name;
	declare I = 0;
	while (I < ClipCount) {
		declare ExistingClipName = MacroblockMetadata.ClipNames[I];

		if (!ClipNamesToRename.existskey(ExistingClipName)) {
			I += 1;
			continue;
		}

		declare OnlyDisableClip = False;

		if ((TL::EndsWith("CheckpointSlope2Down", MbName) || TL::EndsWith("CheckpointSlope2Up", MbName))
			&& (ExistingClipName == "PlatformSlope2StraightFCRightSmallRacing" || ExistingClipName == "PlatformSlope2StraightFCLeftSmallRacing"))
		{
			OnlyDisableClip = True;
		}

		if ((TL::EndsWith("CheckpointSlope2Left", MbName) || TL::EndsWith("CheckpointSlope2Right", MbName))
			&& (ExistingClipName == "PlatformSlope2FCUpSmallRacing" || ExistingClipName == "PlatformSlope2FCDownSmallRacing"))
		{
			OnlyDisableClip = True;
		}

		declare ClipOffset = MacroblockMetadata.ClipOffsets[I];
		declare ClipConnection = MacroblockMetadata.ClipConnections[I];
		declare ClipDir = MacroblockMetadata.ClipDirs[I];

		if (!OnlyDisableClip) {
			declare NewClipName = ClipNamesToRename.get(ExistingClipName);

			MacroblockMetadata.ClipCustoms.add(True);
			MacroblockMetadata.ClipNames.add(NewClipName);
			MacroblockMetadata.ClipOffsets.add(ClipOffset);
			MacroblockMetadata.ClipConnections.add(ClipConnection);
			MacroblockMetadata.ClipDirs.add(ClipDir);

			SetMetadata(_MacroblockModel.Id, MacroblockMetadata);
		}

		declare ClipsCustoms = MacroblockMetadata.ClipCustoms;
		declare ClipIsCustom = ClipsCustoms[I];
		if (ClipIsCustom) {
			RemoveClipCustom(_MacroblockModel, I);
			I -= 1;
		} else {
			DisableClip(_MacroblockModel, ExistingClipName, ClipOffset, Utils::IntToDir(ClipDir));
		}

		I += 1;
		MacroblockMetadata = GetMetadata(_MacroblockModel.Id);
		ClipCount = MacroblockMetadata.ClipCustoms.count;
	}
}

Void GenerateWaterClipsHack(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return;

	declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(_MacroblockModel.Id);
	declare ClipCount = MacroblockMetadata.ClipCustoms.count;

	declare NewClipName = "";

	declare AcceptedClipNames = ["RoadWaterVFC", "TrackWallWaterVFC", "PlatformWaterFCSmall"]; // clips that we won't edit
	declare ClipsToDisable = ["TrackWallVFCSlopeUp"]; // don't create a custom clip for them

	for (I, 0, ClipCount - 1) {
		declare ExistingClipName = MacroblockMetadata.ClipNames[I];
		if (AcceptedClipNames.exists(ExistingClipName)) {
			continue;
		}

		if (TL::StartsWith("RoadWater", ExistingClipName)) {
			NewClipName = "RoadWaterVFC";
		} else if (TL::StartsWith("TrackWallWater",ExistingClipName)) {
			NewClipName = "TrackWallWaterVFC";
		}

		declare ClipOffset = MacroblockMetadata.ClipOffsets[I];
		declare ClipConnection = MacroblockMetadata.ClipConnections[I];
		declare ClipDir = MacroblockMetadata.ClipDirs[I];

		if (!ClipsToDisable.exists(ExistingClipName)) {
			MacroblockMetadata.ClipCustoms.add(True);
			MacroblockMetadata.ClipNames.add(NewClipName);
			MacroblockMetadata.ClipOffsets.add(ClipOffset);
			MacroblockMetadata.ClipConnections.add(ClipConnection);
			MacroblockMetadata.ClipDirs.add(ClipDir);

			SetMetadata(_MacroblockModel.Id, MacroblockMetadata);
		}

		DisableClip(_MacroblockModel, ExistingClipName, ClipOffset, Utils::IntToDir(ClipDir));

		MacroblockMetadata = GetMetadata(_MacroblockModel.Id);
	}
}


// Generate the metadata for all macroblocks
Void GenerateMetadata(Boolean _SaveMacroblock, Boolean _UseWaterClipsHack, Boolean _UseFreeClipsRenameHack) {
	declare ProgressionMax = MacroblockModels.count * 2.;
	declare Progression = 0;

	declare ProgressionLayer <=> UILayerCreate();
	declare LibMacroblock_MetadataProgression for ProgressionLayer.LocalPage = 0.;
	LibMacroblock_MetadataProgression = 0.;
	ProgressionLayer.ManialinkPage = """
<manialink version="3" name="GenerateMetadata">
<frame pos="0 0" z-index="10000">
	<quad pos="0 0" z-index="-1" size="320 180" halign="center" valign="center" style="Bgs1" substyle="BgDialogBlur" />
	<quad pos="0 0" z-index="-2" size="320 180" halign="center" valign="center" bgcolor="000" opacity="0.8" scriptevents="1" />
	<label pos="0 15" halign="center" textsize="8" text="Progression" />
	<gauge size="200 20" halign="center" style="BgCard" drawbg="1" drawblockbg="1" id="Gauge_Progression" />
</frame>
<script><!--
main() {
	declare Gauge_Progression <=> (Page.GetFirstChild("Gauge_Progression") as CMlGauge);
	declare LibMacroblock_MetadataProgression for Page = 0.;

	while (True) {
		yield;
		Gauge_Progression.Ratio = LibMacroblock_MetadataProgression / 100.;
	}
}
--></script>
</manialink>
	""";

	ReloadSignaturesPool();

	foreach (MacroblockModel in MacroblockModels) {
		if (_UseWaterClipsHack && !TL::Find("WaterRoad",MacroblockModel.Id^"", True, True)) {
			continue;
		}

		if (_UseWaterClipsHack) {
			ResetMetadataAndCustomClips(MacroblockModel);
		}

		GenerateMetadata(MacroblockModel, _SaveMacroblock);
		Progression += 1;
		LibMacroblock_MetadataProgression = Progression / ProgressionMax * 100.;
		yield(10);
	}

	Private_GenerateMacroblockVariants();
	foreach (MacroblockModel in MacroblockModels) {
		if (_UseWaterClipsHack && !TL::Find("WaterRoad",MacroblockModel.Id^"", True, True)) {
			continue;
		}
		GenerateVariants(MacroblockModel);

		if (_UseWaterClipsHack && TL::Find("WaterRoad",MacroblockModel.Id^"", True, True)) {
			GenerateWaterClipsHack(MacroblockModel);
		}

		if (_UseFreeClipsRenameHack) {
			GenerateRenameFreeClipsHack(MacroblockModel);
		}

		Progression += 1;
		LibMacroblock_MetadataProgression = Progression / ProgressionMax * 100.;
		yield(10);
	}
	Private_ClearMacroblockVariants();

	UILayerDestroy(ProgressionLayer);
}

Void GenerateNewMetadata() {

	ReloadSignaturesPool();

	foreach (MacroblockModel in MacroblockModels) {

		declare metadata K_GamepadEditorMetadata GamepadEditor for MacroblockModel = K_GamepadEditorMetadata{SignatureKey = -1};
		if (GamepadEditor.SignatureKey != -1) continue;

		log("Added metadata for "^MacroblockModel.Id);

		GenerateMetadata(MacroblockModel, False);
		yield(10);
	}

	Private_GenerateMacroblockVariants();
	foreach (MacroblockModel in MacroblockModels) {
		GenerateVariants(MacroblockModel);
		yield(10);
	}
	Private_ClearMacroblockVariants();
}


CMacroblockModel GetPodiumMacroblockModel() {
	return G_PodiumMacroblockModel;
}

/// Unload the library
Void Unload() {
	ClearSignaturesPool();
	ClearClipNamesPool();
	G_LibMacroblock_ConnectableClips.clear();
	G_LibMacroblock_MacroblockModelsIds.clear();
	G_LibMacroblock_MacroblockModelsFullNames.clear();
	G_PodiumMacroblockModel = Null;
}

/// Load the library
Void Load() {
	Unload();

	// Create macroblock models text ids cache
	declare Text[] ClipsDone;
	foreach (Key => MacroblockModel in MacroblockModels) {
		Private_ConvertOrLoadMetadataToCache(MacroblockModel);
		declare CBlockClipList ClipList for MacroblockModel;
		ClipList = GetGenericClipList(MacroblockModel);

		declare K_GamepadEditorMetadata MacroblockMetadata = GetMetadata(MacroblockModel.Id);
		G_LibMacroblock_MacroblockModelsIds[MacroblockMetadata.Id] = MacroblockModel;

		declare FullName = GetFullName(MacroblockModel);
		if (!G_LibMacroblock_MacroblockModelsFullNames.existskey(FullName)) G_LibMacroblock_MacroblockModelsFullNames[FullName] = [MacroblockModel];
		else G_LibMacroblock_MacroblockModelsFullNames[FullName].add(MacroblockModel);

		foreach (ClipName in MacroblockMetadata.ClipNames) {
			if (ClipsDone.exists(ClipName)) continue;

			declare ClipNameLength = TL::Length(ClipName);
			declare Suffix = TL::SubString(ClipName, ClipNameLength - 4, ClipNameLength);
			if (Suffix == "-Out") {
				G_LibMacroblock_OutClips.add(ClipName);
			}
			ClipsDone.add(ClipName);
		}

		if (G_PodiumMacroblockModel == Null && MacroblockMetadata.Type == "Podium") {
			G_PodiumMacroblockModel = MacroblockModel;
		}

		// Assign the block to use to update the uid of the track
		if (FullName == C_UpdateUidBlock && MacroblockModel.Name == "Air") {
			G_LibMacroblock_UpdateUidBlock <=> MacroblockModel;
		}

		yield(10);
	}
}