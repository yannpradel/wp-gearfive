/**
 * Theme pack library
 */

#Const Version		"1.0.2"
#Const ScriptName	"ThemePack.Script.txt"

#Include "TextLib" as TL
#Include "Libs/Nadeo/TMEditor/GamepadTrackEditor/Utils.Script.txt" as Utils
#Include "Libs/Nadeo/TMEditor/GamepadTrackEditor/Macroblock.Script.txt" as Macroblock

// ---------------------------------- //
// Constants
// ---------------------------------- //
/// Modes
#Const C_Mode_Track			0	///< Track mode
#Const C_Mode_Terrain		1	///< Terrain mode
#Const C_Mode_Decoration	2	///< Decoration mode

/// Translations
#Const C_Translations [
	/*"Canyon" => [
		"|BlockStyle|Grand Prix",
		"|BlockStyle|Road",
		"|BlockStyle|Arena",
		"|BlockStyle|Gallery",
		"|BlockStyle|Wall",
		"|BlockStyle|Cliff",
		"|BlockStyle|Tunnel",

		"|BlockStyle|Decoration",

		"|BlockCategory|Podium",
		"|BlockCategory|Wall",
		"|BlockCategory|Vegetation",
		"|BlockCategory|Cliff",
		"|BlockCategory|Structure",
		"|BlockCategory|Flying",
		"|BlockCategory|Sign",
		"|BlockCategory|Pipeline",

		"|Landscape|Plateau",
		"|Landscape|Water",
		"|Landscape|Rift",
		"|Landscape|Hills",
		"|Landscape|Empty",

		"|Decoration|Nature",
		"|Decoration|International Turbo",
		"|Decoration|Technology",
		"|Decoration|Desert"
	],
	"Valley" => [
		"|BlockStyle|Road",
		"|BlockStyle|Highway",
		"|BlockStyle|Dirt",
		"|BlockStyle|Cliff",
		"|BlockStyle|Tunnel",
		"|BlockStyle|Castle",
		"|BlockStyle|Arena",

		"|BlockStyle|Decoration",

		"|BlockCategory|Podium",
		"|BlockCategory|Cliff",
		"|BlockCategory|Vegetation",
		"|BlockCategory|Farm",
		"|BlockCategory|House",
		"|BlockCategory|Flying",
		"|BlockCategory|Sign",
		"|BlockCategory|Structure",

		"|Landscape|Mountains",
		"|Landscape|Water",
		"|Landscape|Forest",
		"|Landscape|Fields",
		"|Landscape|Empty",

		"|Decoration|Nature",
		"|Decoration|International Turbo",
		"|Decoration|Technology",
		"|Decoration|Village"
	],*/
	"Stadium" => [
		_("|BlockStyle|Tech Road"),
		_("|BlockStyle|Dirt Road"),
		_("|BlockStyle|Bump Road"),
		_("|BlockStyle|Ice Road"),
		_("|BlockStyle|Water Road"),
		_("|BlockStyle|Deep Water"),
		_("|BlockStyle|Tech Platform"),
		_("|BlockStyle|Tech Zone Platform"),
		_("|BlockStyle|Tech Wall Platform"),
		_("|BlockStyle|Dirt Platform"),
		_("|BlockStyle|Dirt Zone Platform"),
		_("|BlockStyle|Dirt Wall Platform"),
		_("|BlockStyle|Ice Platform"),
		_("|BlockStyle|Ice Zone Platform"),
		_("|BlockStyle|Ice Wall Platform"),
		_("|BlockStyle|Grass Platform"),
		_("|BlockStyle|Grass Zone Platform"),
		_("|BlockStyle|Grass Wall Platform"),
		_("|BlockStyle|Water Platform"),
		_("|BlockStyle|Water Zones"),
		_("|BlockStyle|Dirt + Water"),
		_("|BlockStyle|Grass + Water"),
		_("|BlockStyle|Ice + Water"),
		_("|BlockStyle|Platform"),
		_("|BlockStyle|Slope"),
		_("|BlockStyle|Tilt"),
		_("|BlockStyle|Simple"),
		_("|BlockStyle|Tech"),
		_("|BlockStyle|Ice"),
		_("|BlockStyle|Gate"),
		_("|BlockStyle|Bump"),
		_("|BlockStyle|Grass"),
		_("|BlockStyle|Dirt"),
		_("|BlockStyle|Tech Diagonals"),
		_("|BlockStyle|Dirt Diagonals"),
		_("|BlockStyle|Bump Diagonals"),
		_("|BlockStyle|Ice Diagonals"),
		_("|BlockStyle|Plastic Platform"),
		_("|BlockStyle|Plastic Wall Platform"),
		_("|BlockStyle|Screens"),
		_("|BlockStyle|Deco Grass"),
		_("|BlockStyle|Deco Dirt"),
		_("|BlockStyle|Deco Ice"),
		_("|BlockStyle|Structures"),
		_("|BlockStyle|Track Wall"),
		_("|BlockStyle|Deco Wall"),
		_("|BlockStyle|Stage"),
		_("|BlockStyle|Show"),
		_("|BlockStyle|Nature"),
		_("|BlockStyle|Tech Obstacles"),
		_("|BlockStyle|Dirt Obstacles"),
		_("|BlockStyle|Grass Obstacles"),
		_("|BlockStyle|Ice Obstacles"),
		_("|BlockStyle|Plastic Obstacles"),
		_("|BlockStyle|Bump Obstacles"),
		_("|BlockStyle|Water Obstacles"),
		_("|BlockStyle|Wood Road"),

		// Obstacles
		_("|BlockCategory|Specials"),
		_("|BlockCategory|Waterfall"),
		_("|BlockCategory|Dead End"),
		_("|BlockCategory|Looping"),
		_("|BlockCategory|Jumps"),
		_("|BlockCategory|Poles"),
		_("|BlockCategory|Holes"),
		_("|BlockCategory|Narrow"),
		_("|BlockCategory|Penalty"),
		_("|BlockCategory|Others"),

		// |BlockStyle|Screens
		_("|BlockCategory Screen ratio|1 x 1"),
		_("|BlockCategory Screen ratio|2 x 1"),
		_("|BlockCategory Screen ratio|4 x 1"),
		_("|BlockCategory Screen ratio|2 x 3"),
		_("|BlockCategory Screen ratio|16 x 9"),

		//|BlockStyle|Deco (grass, dirt, ice)
		_("|BlockCategory|Hills"),
		_("|BlockCategory|Flat"),
		_("|BlockCategory|Slope 1"),
		_("|BlockCategory|Slope 2"),
		_("|BlockCategory|Slope Base"),
		//_("|BlockCategory|Transition"), // exists in "All" already

		// |BlockStyle|Structures
		_("|BlockCategory|Main"),
		_("|BlockCategory|Supports"),
		_("|BlockCategory|Track Wall"),
		_("|BlockCategory|Curves"),
		_("|BlockCategory|Corners"),
		_("|BlockCategory|Technics"),
		_("|BlockCategory|Canopy"),

		// |BlockStyle|Track Wall, Deco Wall
		_("|BlockCategory|Slopes"),
		_("|BlockCategory|Tilt Straight"),
		_("|BlockCategory|Tilt Curves"),
		_("|BlockCategory|Diagonals"),
		_("|BlockCategory|Arch Top"),
		_("|BlockCategory|Arch Bottom"),
		_("|BlockCategory|U-Loops"),

		// |BlockStyle|Stage
		_("|BlockCategory|Stand"),
		_("|BlockCategory|Curves In"),
		_("|BlockCategory|Curves Out"),
		_("|BlockCategory|Double Curves"),
		_("|BlockCategory|Stand"),

		// |BlockStyle|Show, Nature
		_("|BlockCategory|Spring"),
		_("|BlockCategory|Summer"),
		_("|BlockCategory|Fall"),
		_("|BlockCategory|Winter"),
		_("|BlockCategory|Small Stands"),
		_("|BlockCategory|Medium Stands"),
		_("|BlockCategory|Large Stands"),
		_("|BlockCategory|Light Shapes"),

		// Wood (Snow) Roads specific

		_("|BlockCategory|Tilt"),
		_("|BlockCategory|Gate"),

		// Landscapes
		_("|Landscape|Hills"),
		_("|Landscape|Mountain"),
		_("|Landscape|Desert"),
		_("|Landscape|Pillars"),
		_("|Landscape|Empty"),

		// Filters
		_("|BlockMaterial|Tech"),
		_("|BlockMaterial|Dirt"),
		_("|BlockMaterial|Ice"),
		_("|BlockMaterial|Bump"),
		_("|BlockMaterial|Grass"),
		_("|BlockMaterial|Plastic"),
		_("|BlockMaterial|Water"),
		_("|BlockMaterial|Wood")

	],
	/*"Lagoon" => [
		"|BlockStyle|Highway",
		"|BlockStyle|Slope",
		"|BlockStyle|Road",
		"|BlockStyle|Tunnel",
		"|BlockStyle|Offroad",
		"|BlockStyle|Rollercoaster",
		"|BlockStyle|Arena",
		"|BlockStyle|City",
		"|BlockStyle|Garden",

		"|BlockStyle|Decoration",

		"|BlockCategory|Podium",
		"|BlockCategory|Ship",
		"|BlockCategory|Vegetation",
		"|BlockCategory|Building",
		"|BlockCategory|Structure",
		"|BlockCategory|Flying",
		"|BlockCategory|Sign",

		"|Landscape|Big island",
		"|Landscape|Mountains",
		"|Landscape|Beach",
		"|Landscape|Jungle",
		"|Landscape|Empty",

		"|Decoration|Nature",
		"|Decoration|International Turbo",
		"|Decoration|Technology",
		"|Decoration|Wood"
	],*/
	"All" => [
		_("|BlockCategory|Straight"),
		_("|BlockCategory|Turbo"),
		_("|BlockCategory|Boost"),
		_("|BlockCategory|Turn"),
		_("|BlockCategory|Slope"),
		_("|BlockCategory|Checkpoint"),
		_("|BlockCategory|Finish"),
		_("|BlockCategory|Transition"),
		_("|BlockCategory|Wallride"),
		_("|BlockCategory|Obstacle"),
		_("|BlockCategory|Stop Engine"),
		_("|BlockCategory|No Steering"),
		_("|BlockCategory|Slow Motion"),
		_("|BlockCategory|Fragile"),
		_("|BlockCategory|Reset"),
		_("|BlockCategory|Cruise"),
		_("|BlockCategory|No Brake"),
		_("|BlockInfo|Start"),
		_("|BlockInfo|Checkpoint"),
		_("|BlockInfo|Multilaps"),
		_("|BlockInfo|Finish")
	]
]

// Globales
declare Ident G_LoadRequestId;					///< Id of the config file load request
declare Boolean G_ConfigFileLoaded;				///< Config file load status
declare Text[Integer] G_TrackStyles;			///< The track styles
declare Text[Integer][Text] G_FilteredTrackStyles; ///< The track styles filtered by Ice, Grass, Tech, Dirt, Bump for stadium next, for now.
declare Text[] G_TrackStyleFilters;				///< List of filters for G_FilteredTrackStyles
declare Integer[Integer] G_FilterByStyle; ///< Reverse find the filter of a style
declare Text[Integer] G_StartStyles;			///< Track styles containing a start block
declare Text[Integer] G_LandStyles;				///< The land styles
declare Text[Integer] G_DecoStyles;				///< The deco styles
declare Integer G_TrackStyleFilter;					///< The current track style filter
declare Integer G_TrackStyle;					///< The current track style
declare Integer G_LandStyle;					///< The current land style
declare Integer G_DecoStyle;					///< The deco style
declare Text[][Integer] G_ClipsStyles;			///< Clips associeted with each track style
declare Text[][Integer] G_TrackCategories;		///< List all categories
declare Text[][Integer] G_DecoCategories;		///< List all deco categories
declare Text[][Integer] G_LayersTypes;			///< Type of each terrain layer
declare Real[][Integer] G_LayersFrequencies;	///< Frequency setting for each terrain layer
declare Real[][Integer] G_LayersOctaves;		///< Octave setting for each terrain layer
declare Text[Real][][Integer] G_TerrainsIds;	///< List of terrains ids and their height intervals
declare Real[Text][Integer] G_DecorationsIds;	///< List of decoration ids and their probability to be used
declare CMacroblockModel[Integer] G_Terrains;	///< Macroblock to use as terrain
declare Boolean G_UseRandomLandStyle;			///< Use random landscape generation
declare Boolean G_DisplayLog;					///< Display logs
declare Integer G_Mode;							///< Current mode
declare Real[Text] G_DecoRatios;				///< Default ratios for decoration
declare Vec3[Text] G_DecoColors;				///< Colors for the decoration
declare CMacroblockModel[][Integer][Integer] G_AvailableMacroblockModels; ///< List available macroblocks

Boolean Private_RequestExists() {
	return G_LoadRequestId != NullId && Http.Requests.existskey(G_LoadRequestId);
}

Vec3 Private_TextToVec3(Text _In) {
	declare In = TL::Split(",", TL::ReplaceChars(_In, " ", "")); //< Remove space
	declare Vec3 Out;
	if (In.existskey(0)) Out.X = TL::ToReal(In[0]);
	if (In.existskey(1)) Out.Y = TL::ToReal(In[1]);
	if (In.existskey(2)) Out.Z = TL::ToReal(In[2]);

	return Out;
}

Void Private_ReadConfig(Text _Config) {
	declare XmlFile <=> Xml.Create(_Config);
	declare AllMacroblockFound = True;

	if (XmlFile != Null && XmlFile.Root.Name == "themepacks") {
		foreach (NodeEnvironment in XmlFile.Root.Children) {
			if (Map.CollectionName != NodeEnvironment.GetAttributeText("name", "")) continue;

			foreach (NodeStyles in NodeEnvironment.Children) {
				if (NodeStyles.Name == "trackstyles") {
					foreach (NodeTrackStyle in NodeStyles.Children) {
						yield(2);

						declare HasStart = False;
						declare MacroblockModelOrder = 0;
						declare TrackStyleId = NodeTrackStyle.GetAttributeInteger("id", -1);
						declare TrackStyleFilter = NodeTrackStyle.GetAttributeText("filter", "");
						declare TrackStyleName = NodeTrackStyle.GetAttributeText("name", "");
						G_TrackStyles[TrackStyleId] = TrackStyleName;
						G_TrackCategories[TrackStyleId] = [];

						if (TrackStyleFilter != "") {
							G_TrackStyleFilter = 0;
							if (!G_FilteredTrackStyles.existskey(TrackStyleFilter)) {
								declare Text[Integer] NewArray;
								G_FilteredTrackStyles[TrackStyleFilter] = NewArray;
							}

							G_FilteredTrackStyles[TrackStyleFilter][TrackStyleId] = TrackStyleName;
							if (!G_TrackStyleFilters.exists(TrackStyleFilter)) {
								G_TrackStyleFilters.add(TrackStyleFilter);
							}

							G_FilterByStyle[TrackStyleId] = G_TrackStyleFilters.keyof(TrackStyleFilter);
						}

						declare Clips = NodeTrackStyle.GetAttributeText("clips", "");
						if (Clips != "") {
							G_ClipsStyles[TrackStyleId] = TL::Split(",", Clips);
						}

						declare TrackStyleRandomDisabled = NodeTrackStyle.GetAttributeInteger("randomdisabled", 0);

						foreach (NodeCategory in NodeTrackStyle.Children) {
							yield(2);
							declare CategoryName = NodeCategory.GetAttributeText("name", "");
							if (!G_TrackCategories[TrackStyleId].exists(CategoryName)) G_TrackCategories[TrackStyleId].add(CategoryName);

							declare CategoryRandomDisabled = NodeCategory.GetAttributeInteger("randomdisabled", -1);
							if (CategoryRandomDisabled < 0) CategoryRandomDisabled = TrackStyleRandomDisabled;

							foreach (NodeMacroblock in NodeCategory.Children) {
								declare MacroblockFullName = NodeMacroblock.GetAttributeText("id", "");
								if (MacroblockFullName == "") continue;

								declare MacroblockRandomDisabled = NodeMacroblock.GetAttributeInteger("randomdisabled", -1);
								if (MacroblockRandomDisabled < 0) MacroblockRandomDisabled = CategoryRandomDisabled;

								declare MacroblockRandomOnly = NodeMacroblock.GetAttributeBoolean("randomonly", False);

								declare MacroblockModelFound = False;
								declare MacroblockModelsFound = Macroblock::GetMacroblockModelsFromFullName(MacroblockFullName);
								foreach (MacroblockModel in MacroblockModelsFound) {
									MacroblockModelFound = True;
									if (!MacroblockRandomOnly && (MacroblockModel.HasStart || MacroblockModel.HasMultilap)) HasStart = True;

									declare LibThemePack_Loaded for MacroblockModel = False;
									LibThemePack_Loaded = True;

									declare Text[Integer] LibThemePack_TrackCategory for MacroblockModel;
									LibThemePack_TrackCategory[TrackStyleId] = CategoryName;

									declare LibThemePack_IsSymmetrical for MacroblockModel = False;
									LibThemePack_IsSymmetrical = NodeMacroblock.GetAttributeBoolean("symmetrical", False);

									declare Integer[Integer] LibThemePack_TrackOrder for MacroblockModel;
									LibThemePack_TrackOrder[TrackStyleId] = MacroblockModelOrder;
									MacroblockModelOrder += 1;

									declare LibThemePack_Name for MacroblockModel = "";
									LibThemePack_Name = NodeMacroblock.GetAttributeText("name", "");

									declare LibThemePack_IsSimple for MacroblockModel = False;
									LibThemePack_IsSimple = NodeMacroblock.GetAttributeBoolean("simple", False);

									declare LibThemePack_RandomDisabled for MacroblockModel = False;
									LibThemePack_RandomDisabled = (MacroblockRandomDisabled > 0);

									declare LibThemePack_IsListed for MacroblockModel = False;
									LibThemePack_IsListed = True;

									declare LibThemePack_IsRandomOnly for MacroblockModel = False;
									LibThemePack_IsRandomOnly = MacroblockRandomOnly;

									declare LibThemePack_FollowUp for MacroblockModel = "";
									LibThemePack_FollowUp = NodeMacroblock.GetAttributeText("followup", "");

									declare LibThemePack_Terraforming for MacroblockModel = False;
									LibThemePack_Terraforming = NodeMacroblock.GetAttributeBoolean("terraforming", False);

									declare LibThemePack_IsOriented for MacroblockModel = False;
									LibThemePack_IsOriented = NodeMacroblock.GetAttributeBoolean("oriented", False);

									declare LibThemePack_NoRespawn for MacroblockModel = False;
									LibThemePack_NoRespawn = NodeMacroblock.GetAttributeBoolean("norespawn", False);

									declare LibThemePack_RandomSkin for MacroblockModel = True;
									LibThemePack_RandomSkin = NodeMacroblock.GetAttributeBoolean("randomskin", True);
								}

								if (G_DisplayLog && !MacroblockModelFound) {
									Utils::Log("["^ScriptName^"] Can't find macroblock : "^MacroblockFullName);
									AllMacroblockFound = False;
								}
							}
						}

						if (HasStart) G_StartStyles[TrackStyleId] = G_TrackStyles[TrackStyleId];
					}
				} else if (G_UseRandomLandStyle && NodeStyles.Name == "landstyles") {
					foreach (NodeLandStyle in NodeStyles.Children) {
						yield(2);

						declare LandStyleId = NodeLandStyle.GetAttributeInteger("id", -1);
						G_LandStyles[LandStyleId] = NodeLandStyle.GetAttributeText("name", "");
						G_LayersTypes[LandStyleId] = [];
						G_LayersFrequencies[LandStyleId] = [];
						G_LayersOctaves[LandStyleId] = [];
						G_TerrainsIds[LandStyleId] = [];
						G_DecorationsIds[LandStyleId] = [];

						foreach (NodeType in NodeLandStyle.Children) {
							if (NodeType.Name == "terrain") {
								foreach (NodeLayer in NodeType.Children) {
									G_LayersTypes[LandStyleId].add(NodeLayer.GetAttributeText("type", ""));
									G_LayersFrequencies[LandStyleId].add(NodeLayer.GetAttributeReal("frequency", 0.4));
									G_LayersOctaves[LandStyleId].add(NodeLayer.GetAttributeReal("octaves", 10.));
									G_TerrainsIds[LandStyleId].add([]);

									foreach (NodeBlock in NodeLayer.Children) {
										declare BlockId = NodeBlock.GetAttributeText("id", "");
										declare BlockHeight = NodeBlock.GetAttributeReal("height", -1.);

										G_TerrainsIds[LandStyleId][G_TerrainsIds[LandStyleId].count-1][BlockHeight] = BlockId;
									}

									G_TerrainsIds[LandStyleId][G_TerrainsIds[LandStyleId].count-1] = G_TerrainsIds[LandStyleId][G_TerrainsIds[LandStyleId].count-1].sortkey();
								}
							} else if (NodeType.Name == "decoration") {
								foreach (NodeCategory in NodeType.Children) {
									declare CategoryId = NodeCategory.GetAttributeText("id", "");
									if (CategoryId == "") continue;
									declare CategoryRatio = NodeCategory.GetAttributeReal("ratio", 0.);
									G_DecorationsIds[LandStyleId][CategoryId] = CategoryRatio;
								}
							}
						}
					}
				} else if (NodeStyles.Name == "decostyles") {
					foreach (NodeDecoStyle in NodeStyles.Children) {
						yield(2);

						declare MacroblockModelOrder = 0;
						declare DecoStyleId = NodeDecoStyle.GetAttributeInteger("id", -1);
						G_DecoStyles[DecoStyleId] = NodeDecoStyle.GetAttributeText("name", "");
						G_DecoCategories[DecoStyleId] = [];

						foreach (NodeCategory in NodeDecoStyle.Children) {
							declare CategoryName = NodeCategory.GetAttributeText("name", "");
							if (!G_DecoCategories[DecoStyleId].exists(CategoryName)) G_DecoCategories[DecoStyleId].add(CategoryName);

							declare DecoRatio = NodeCategory.GetAttributeReal("ratio", 0.);
							G_DecoRatios[CategoryName] = DecoRatio;

							declare DecoColor = NodeCategory.GetAttributeText("color", "");
							G_DecoColors[CategoryName] = Private_TextToVec3(DecoColor);

							foreach (NodeMacroblock in NodeCategory.Children) {
								declare MacroblockFullName = NodeMacroblock.GetAttributeText("id", "");
								if (MacroblockFullName == "") continue;

								declare MacroblockRandomOnly = NodeMacroblock.GetAttributeBoolean("randomonly", False);

								declare MacroblockModelFound = False;
								declare MacroblockModelsFound = Macroblock::GetMacroblockModelsFromFullName(MacroblockFullName);
								foreach (MacroblockModel in MacroblockModelsFound) {
									declare LibThemePack_Loaded for MacroblockModel = False;
									LibThemePack_Loaded = True;

									declare Text[Integer] LibThemePack_DecoCategory for MacroblockModel;
									LibThemePack_DecoCategory[DecoStyleId] = CategoryName;
									MacroblockModelFound = True;

									declare Integer[Integer] LibThemePack_DecoOrder for MacroblockModel;
									LibThemePack_DecoOrder[DecoStyleId] = MacroblockModelOrder;
									MacroblockModelOrder += 1;

									declare LibThemePack_Name for MacroblockModel = "";
									LibThemePack_Name = NodeMacroblock.GetAttributeText("name", "");

									declare LibThemePack_IsListed for MacroblockModel = False;
									LibThemePack_IsListed = True;

									declare LibThemePack_IsRandomOnly for MacroblockModel = False;
									LibThemePack_IsRandomOnly = MacroblockRandomOnly;

									declare LibThemePack_Terraforming for MacroblockModel = False;
									LibThemePack_Terraforming = NodeMacroblock.GetAttributeBoolean("terraforming", False);

									declare LibThemePack_RandomSkin for MacroblockModel = True;
									LibThemePack_RandomSkin = NodeMacroblock.GetAttributeBoolean("randomskin", True);
								}

								if (G_DisplayLog && !MacroblockModelFound) {
									Utils::Log("["^ScriptName^"] Can't find macroblock : "^MacroblockFullName);
									AllMacroblockFound = False;
								}
							}
						}
					}
				} else if (!G_UseRandomLandStyle && NodeStyles.Name == "terrainstyles") {
					foreach (NodeTerrainStyle in NodeStyles.Children) {
						declare TerrainStyleId = NodeTerrainStyle.GetAttributeInteger("id", -1);
						G_LandStyles[TerrainStyleId] = NodeTerrainStyle.GetAttributeText("name", "");
						declare MacroblockFullName = NodeTerrainStyle.GetAttributeText("blockid", "");

						declare MacroblockModelFound = False;
						declare MacroblockModelsFound = Macroblock::GetMacroblockModelsFromFullName(MacroblockFullName);
						foreach (MacroblockModel in MacroblockModelsFound) {
							declare LibThemePack_Loaded for MacroblockModel = False;
							LibThemePack_Loaded = True;

							MacroblockModelFound = True;
							G_Terrains[TerrainStyleId] = MacroblockModel;
						}
						if (G_DisplayLog && !MacroblockModelFound) {
							Utils::Log("["^ScriptName^"] Can't find macroblock : "^MacroblockFullName);
							AllMacroblockFound = False;
						}
					}
				}
			}
		}

		G_ConfigFileLoaded = True;
	}
	Xml.Destroy(XmlFile);

	if (G_DisplayLog && AllMacroblockFound) {
		Utils::Log("["^ScriptName^"] All macroblocks found.");
	}
}

// Clear the data on the macroblock models
Void Private_ClearMacroblockModels(Boolean _Async) {
	foreach (MacroblockModel in MacroblockModels) {
		declare LibThemePack_Loaded for MacroblockModel = False;
		if (LibThemePack_Loaded) {
			LibThemePack_Loaded = False;

			declare Text[Integer] LibThemePack_TrackCategory for MacroblockModel;
			declare Text[Integer] LibThemePack_DecoCategory for MacroblockModel;
			declare LibThemePack_IsSymmetrical for MacroblockModel = False;
			declare Integer[Integer] LibThemePack_TrackOrder for MacroblockModel;
			declare Integer[Integer] LibThemePack_DecoOrder for MacroblockModel;
			declare LibThemePack_Name for MacroblockModel = "";
			declare LibThemePack_IsSimple for MacroblockModel = False;
			declare LibThemePack_RandomDisabled for MacroblockModel = False;
			declare LibThemePack_IsListed for MacroblockModel = False;
			declare LibThemePack_IsRandomOnly for MacroblockModel = False;
			declare LibThemePack_FollowUp for MacroblockModel = "";
			declare LibThemePack_Terraforming for MacroblockModel = False;
			declare LibThemePack_IsOriented for MacroblockModel = False;
			declare LibThemePack_NoRespawn for MacroblockModel = False;
			declare LibThemePack_RandomSkin for MacroblockModel = True;
			LibThemePack_TrackCategory.clear();
			LibThemePack_DecoCategory.clear();
			LibThemePack_IsSymmetrical = False;
			LibThemePack_TrackOrder.clear();
			LibThemePack_DecoOrder.clear();
			LibThemePack_Name = "";
			LibThemePack_IsSimple = False;
			LibThemePack_RandomDisabled = False;
			LibThemePack_IsListed = False;
			LibThemePack_IsRandomOnly = False;
			LibThemePack_FollowUp = "";
			LibThemePack_Terraforming = False;
			LibThemePack_IsOriented = False;
			LibThemePack_NoRespawn = False;
			LibThemePack_RandomSkin = True;
		}

		if (_Async) yield(2);
	}
}

Text GetScriptVersion() { return Version; }
Text GetScriptName() { return ScriptName; }

Boolean LoadConfig_IsLoaded() {
	return G_ConfigFileLoaded;
}

Void LoadConfig_Start(Text _ConfigPath) {
	if (Http.SlotsAvailable <= 0) return;

	G_ConfigFileLoaded = False;
	G_TrackCategories.clear();
	G_LayersTypes.clear();
	G_LayersFrequencies.clear();
	G_LayersOctaves.clear();
	G_TerrainsIds.clear();
	G_DecorationsIds.clear();

	Private_ClearMacroblockModels(False);

	declare Request <=> Http.CreateGet(_ConfigPath, False);
	if (Request != Null) G_LoadRequestId = Request.Id;
}

Boolean LoadConfig_IsLoading() {
	if (Private_RequestExists()) {
		return !Http.Requests[G_LoadRequestId].IsCompleted;
	}

	return False;
}

/// Configuration file loaded
Void Sync_LoadConfig_End() {
	if (!Private_RequestExists()) return;

	declare Request <=> Http.Requests[G_LoadRequestId];
	if (Request.IsCompleted) {
		Private_ReadConfig(Request.Result);
	}

	Http.Destroy(Request);
	G_LoadRequestId = NullId;
}

Integer GetTrackStyleFilterCount() {
	return G_TrackStyleFilters.count;
}

// Check if a macroblock model is listed in the theme pack xml
Boolean IsListed(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	declare LibThemePack_IsListed for _MacroblockModel = False;
	return LibThemePack_IsListed;
}

// Check if a macroblock model is available in the selected track style
Boolean IsAvailable(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	declare LibThemePack_IsRandomOnly for _MacroblockModel = False;
	if (LibThemePack_IsRandomOnly) return False;

	if (G_Mode == C_Mode_Decoration) {
		declare Text[Integer] LibThemePack_DecoCategory for _MacroblockModel;
		return (LibThemePack_DecoCategory.existskey(G_DecoStyle));
	}

	declare Text[Integer] LibThemePack_TrackCategory for _MacroblockModel;
	return (LibThemePack_TrackCategory.existskey(G_TrackStyle));
}

// Check if a macroblock model is used in the random generator only
Boolean IsRandomOnly(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	declare LibThemePack_IsRandomOnly for _MacroblockModel = False;
	return LibThemePack_IsRandomOnly;
}

// Check if a macroblock model is symmetrical
Boolean IsSymmetrical(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	declare LibThemePack_IsSymmetrical for _MacroblockModel = False;
	return LibThemePack_IsSymmetrical;
}

// Check if a macroblock model is simple (eg :straight line)
Boolean IsSimple(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	declare LibThemePack_IsSimple for _MacroblockModel = False;
	return LibThemePack_IsSimple;
}

// Check if a macroblock model is disabled in random generation
Boolean IsRandomDisabled(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	declare LibThemePack_RandomDisabled for _MacroblockModel = False;
	return LibThemePack_RandomDisabled;
}

// Get the order of a macroblock model
Integer GetOrder(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return 0;
	if (G_Mode == C_Mode_Decoration) {
		declare Integer[Integer] LibThemePack_DecoOrder for _MacroblockModel;
		if (!LibThemePack_DecoOrder.existskey(G_DecoStyle)) return 0;
		return LibThemePack_DecoOrder[G_DecoStyle];
	}

	declare Integer[Integer] LibThemePack_TrackOrder for _MacroblockModel;
	if (!LibThemePack_TrackOrder.existskey(G_TrackStyle)) return 0;
	return LibThemePack_TrackOrder[G_TrackStyle];
}

// Get the name of a macroblock model
Text GetName(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return "";

	declare LibThemePack_Name for _MacroblockModel = "";
	return LibThemePack_Name;
}

// Get the macroblock that should be placed after the provided macroblock
Text GetFollowUp(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return "";

	declare LibThemePack_FollowUp for _MacroblockModel = "";
	return LibThemePack_FollowUp;
}

// Check if the macroblock is allowed to place terraforming
Boolean CanPlaceTerrain(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	declare LibThemePack_Terraforming for _MacroblockModel = False;
	return LibThemePack_Terraforming;
}

//  Check if a macroblock model is oriented
Boolean IsOriented(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	declare LibThemePack_IsOriented for _MacroblockModel = False;
	return LibThemePack_IsOriented;
}

// Check if a macroblock model is not respawnable
Boolean NoRespawn(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	declare LibThemePack_NoRespawn for _MacroblockModel = False;
	return LibThemePack_NoRespawn;
}

// Check if a macroblock model can be skinned randomly
Boolean CanSkin(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return False;

	declare LibThemePack_RandomSkin for _MacroblockModel = True;
	return LibThemePack_RandomSkin;
}

// Get the styles of a macroblock model
Integer[] GetStyles(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return [];

	declare Integer[] StylesIds;

	if (G_Mode == C_Mode_Decoration) {
		declare Text[Integer] LibThemePack_DecoCategory for _MacroblockModel;
		foreach (DecoStyleId => Category in LibThemePack_DecoCategory) {
			StylesIds.add(DecoStyleId);
		}
	} else {
		declare Text[Integer] LibThemePack_TrackCategory for _MacroblockModel;
		foreach (TrackStyleId => Category in LibThemePack_TrackCategory) {
			StylesIds.add(TrackStyleId);
		}
	}

	return StylesIds;
}

// Get the styles names of a macroblock model
Text[] GetStylesNames(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return [];

	declare Text[] StylesNames;

	if (G_Mode == C_Mode_Decoration) {
		declare Text[Integer] LibThemePack_DecoCategory for _MacroblockModel;
		foreach (DecoStyleId => Category in LibThemePack_DecoCategory) {
			StylesNames.add(G_DecoStyles[DecoStyleId]);
		}
	} else {
		declare Text[Integer] LibThemePack_TrackCategory for _MacroblockModel;
		foreach (TrackStyleId => Category in LibThemePack_TrackCategory) {
			StylesNames.add(G_TrackStyles[TrackStyleId]);
		}
	}

	return StylesNames;
}

Integer GetFilterForMacroblockModel(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return -1;

	declare Styles = GetStyles(_MacroblockModel);
	if (Styles.count == 0) return -1;

	return G_FilterByStyle.get(Styles[0], -1);
}

// Get the number of terrain layers
Integer GetLayersCount() {
	if (!G_LayersFrequencies.existskey(G_LandStyle)) return 0;
	return G_LayersFrequencies[G_LandStyle].count;
}

// Get the type of a given terrain layer
Text GetType(Integer _Layer) {
	if (!G_LayersTypes.existskey(G_LandStyle)) return "";
	if (!G_LayersTypes[G_LandStyle].existskey(_Layer)) return "";
	return G_LayersTypes[G_LandStyle][_Layer];
}

// Get the frequency of a given terrain layer
Real GetFrequency(Integer _Layer) {
	if (!G_LayersFrequencies.existskey(G_LandStyle)) return 0.;
	if (!G_LayersFrequencies[G_LandStyle].existskey(_Layer)) return 0.;
	return G_LayersFrequencies[G_LandStyle][_Layer];
}

//  Get the octaves of a given terrain layer
Real GetOctaves(Integer _Layer) {
	if (!G_LayersOctaves.existskey(G_LandStyle)) return 0.;
	if (!G_LayersOctaves[G_LandStyle].existskey(_Layer)) return 0.;
	return G_LayersOctaves[G_LandStyle][_Layer];
}

// Get the terrains height intervals of a given terrain layer
Text[Real] GetTerrainsIntervals(Integer _Layer) {
	if (!G_TerrainsIds.existskey(G_LandStyle)) return [];
	if (!G_TerrainsIds[G_LandStyle].existskey(_Layer)) return [];
	return G_TerrainsIds[G_LandStyle][_Layer];
}

// Check if a ratio exists for a given decoration category
Boolean ExistsDecorationRatio(Text _Category) {
	if (!G_DecorationsIds.existskey(G_LandStyle)) return False;
	return G_DecorationsIds[G_LandStyle].existskey(_Category);
}

// Get the ratio of a given decoration category
Real GetDecorationRatio(Text _Category) {
	if (!G_DecorationsIds.existskey(G_LandStyle)) return 0.;
	if (!G_DecorationsIds[G_LandStyle].existskey(_Category)) return 0.;
	return G_DecorationsIds[G_LandStyle][_Category];
}

// Get the currently selected style filter
Integer GetTrackStyleFilter() {
	return G_TrackStyleFilter;
}

// Get the currently selected style filter
Text GetTrackStyleFilterName() {
	if (G_TrackStyleFilter == -1) {
		return "";
	}
	return G_TrackStyleFilters[G_TrackStyleFilter];
}

Text GetTrackStylePrevFilterName() {
	if (G_TrackStyleFilter == -1) {
		return "";
	}

	if (G_TrackStyleFilter > 0) {
		return G_TrackStyleFilters[G_TrackStyleFilter - 1];
	}

	return G_TrackStyleFilters[G_TrackStyleFilters.count - 1];
}

Text GetTrackStyleNextFilterName() {
	if (G_TrackStyleFilter == -1) {
		return "";
	}
	if (G_TrackStyleFilter < G_TrackStyleFilters.count - 1) {
		return G_TrackStyleFilters[G_TrackStyleFilter + 1];
	}

	return G_TrackStyleFilters[0];
}

Void ShiftTrackStyleFilter(Integer _Shift) {
	G_TrackStyleFilter += _Shift;
	if (G_TrackStyleFilter >= GetTrackStyleFilterCount()) {
		G_TrackStyleFilter = 0;
	}

	if (G_TrackStyleFilter < 0) {
		G_TrackStyleFilter = GetTrackStyleFilterCount() - 1;
	}
}

// Get the currently selected style
Integer GetTrackStyle() {
	return G_TrackStyle;
}

//  Get the currently selected land style
Integer GetLandStyle() {
	return G_LandStyle;
}

// Get the currently selected deco style
Integer GetDecoStyle() {
	return G_DecoStyle;
}

// Get the page number (index + 1) of the currently selected start style
Integer GetStartStylePage() {
	declare Page = 1;
	foreach (StartStyleId => StartStyleName in G_StartStyles) {
		if (StartStyleId == G_TrackStyle) break;
		Page += 1;
	}
	return Page;
}

// Get the currently selected track style name
Text GetTrackStyleName() {
	if (!G_TrackStyles.existskey(G_TrackStyle)) return "";
	return G_TrackStyles[G_TrackStyle];
}

// Get the currently selected land style name
Text GetLandStyleName() {
	if (!G_LandStyles.existskey(G_LandStyle)) return "";
	return G_LandStyles[G_LandStyle];
}

// Get the currently selected decoration style name
Text GetDecoStyleName() {
	if (!G_DecoStyles.existskey(G_DecoStyle)) return "";
	return G_DecoStyles[G_DecoStyle];
}

// Get the category of a macroblock model
Text GetCategory(CMacroblockModel _MacroblockModel) {
	if (_MacroblockModel == Null) return "";

	if (G_Mode == C_Mode_Decoration) {
		declare Text[Integer] LibThemePack_DecoCategory for _MacroblockModel;
		if (!LibThemePack_DecoCategory.existskey(G_DecoStyle)) return "";
		return LibThemePack_DecoCategory[G_DecoStyle];
	}

	declare Text[Integer] LibThemePack_TrackCategory for _MacroblockModel;
	if (!LibThemePack_TrackCategory.existskey(G_TrackStyle)) return "";
	return LibThemePack_TrackCategory[G_TrackStyle];
}

//  Get the name of all categories available in the theme pack
Text[] GetAllCategories() {
	if (G_Mode == C_Mode_Decoration) {
		if (!G_DecoCategories.existskey(G_DecoStyle)) return [];
		return G_DecoCategories[G_DecoStyle];
	}

	if (!G_TrackCategories.existskey(G_TrackStyle)) return [];
	return G_TrackCategories[G_TrackStyle];
}

//  Get the indexes and names of all styles
Text[Integer] GetTrackStyles() {
	// depend on filters
	if (GetTrackStyleFilterCount() != 0 && G_TrackStyleFilter != -1) {
		return G_FilteredTrackStyles[G_TrackStyleFilters[G_TrackStyleFilter]];
	}

	return G_TrackStyles;
}

Text[Integer] GetStartStyles() { return G_StartStyles; }
Text[Integer] GetLandStyles() { return G_LandStyles; }
Text[Integer] GetDecoStyles() { return G_DecoStyles; }

// Get the page number (index + 1) of the currently selected track style
Integer GetTrackStylePage() {
	declare Page = 1;

	declare Text[Integer] TrackStyles = GetTrackStyles();

	foreach (TrackStyleId => TrackStyleName in TrackStyles) {
		if (TrackStyleId == G_TrackStyle) break;
		Page += 1;
	}
	return Page;
}

Integer GetDecoStylePage() {
	declare Page = 1;

	declare Text[Integer] DecoStyles = GetDecoStyles();

	foreach (DecoStyleId => DecoStyleName in DecoStyles) {
		if (DecoStyleId == G_DecoStyle) break;
		Page += 1;
	}
	return Page;
}

// Get the number of styles
Integer GetTrackStylesCount() {
	// depend on filters
	if (GetTrackStyleFilterCount() != 0 && G_TrackStyleFilter != -1) {
		return G_FilteredTrackStyles[G_TrackStyleFilters[G_TrackStyleFilter]].count;
	}

	return G_TrackStyles.count;
}

Integer GetStartStylesCount() { return G_StartStyles.count; }
Integer GetDecoStylesCount() {return G_DecoStyles.count; }

// Get the names of the styles
Text[] GetTrackStylesNames() {
	declare Text[] TrackStyles;
	foreach (TrackStyle in G_TrackStyles) {
		TrackStyles.add(TrackStyle);
	}
	return TrackStyles;
}

Text[] GetLandStylesNames() {
	declare Text[] LandStyles;
	foreach (LandStyle in G_LandStyles) {
		LandStyles.add(LandStyle);
	}
	return LandStyles;
}

Text GetTrackStyleNameFromId(Integer _TrackStyleId) {
	if (!G_TrackStyles.existskey(_TrackStyleId)) return "";
	return G_TrackStyles[_TrackStyleId];
}

Text GetDecoStyleNameFromId(Integer _DecoStyleId) {
	if (!G_DecoStyles.existskey(_DecoStyleId)) return "";
	return G_DecoStyles[_DecoStyleId];
}

Integer GetClipTrackStyle(Text _ClipName) {
	foreach (TrackStyleId => ClipsNames in G_ClipsStyles) {
		if (ClipsNames.exists(_ClipName)) return TrackStyleId;
	}
	return -1;
}

Void Select(Integer _TrackStyle, Integer _LandStyle, Integer _DecoStyle) {
	G_TrackStyle = _TrackStyle;
	G_LandStyle = _LandStyle;
	G_DecoStyle = _DecoStyle;

	if (_TrackStyle < G_FilterByStyle.count) {
		G_TrackStyleFilter = G_FilterByStyle[_TrackStyle];
	} else {
		G_TrackStyleFilter = -1;
	}
}

/// Get the mode constants
Integer Mode_Track() { return C_Mode_Track; }
Integer Mode_Terrain() { return C_Mode_Terrain; }
Integer Mode_Decoration() { return C_Mode_Decoration; }

Void SetMode(Integer _Mode) {
	G_Mode = _Mode;
}

// Get a terrain macroblock from given ID
CMacroblockModel GetTerrain(Text _TerrainId) {
	if (!G_LandStyles.exists(_TerrainId)) return Null;
	declare LandStyle = G_LandStyles.keyof(_TerrainId);
	if (!G_Terrains.existskey(LandStyle)) return Null;
	return G_Terrains[LandStyle];
}

// Get the currently selected terrain
CMacroblockModel GetTerrain() {
	if (!G_Terrains.existskey(G_LandStyle)) return Null;
	return G_Terrains[G_LandStyle];
}


Void UseRandomLandscapeGeneration(Boolean _UseRandom) {
	G_UseRandomLandStyle = _UseRandom;
}

//  Get the ratio of each decoration category
Real[Text] GetDecoRatios() {
	return G_DecoRatios;
}

// Get the color of each decoration category
Vec3[Text] GetDecoColors() {
	return G_DecoColors;
}

/// Generate the list of available macroblock models
Void Sync_GenerateMacroblockModelsList() {
	tuningmark("Sync_GenerateMacroblockModelsList");
	G_AvailableMacroblockModels = [
		C_Mode_Track => [],
		C_Mode_Decoration => []
	];

	declare CMacroblockModel[][Integer][Integer] OrderedMacroblockModels;
	OrderedMacroblockModels = G_AvailableMacroblockModels;

	foreach (MacroblockModel in MacroblockModels) {
		yield(2);

		if (  !Macroblock::GetValidity(MacroblockModel)
			||!IsListed(MacroblockModel)) continue;

		declare Text[Integer] LibThemePack_DecoCategory for MacroblockModel;
		foreach (DecoStyleId => CategoryName in LibThemePack_DecoCategory) {
			if (!G_AvailableMacroblockModels[C_Mode_Decoration].existskey(DecoStyleId)) {
				G_AvailableMacroblockModels[C_Mode_Decoration][DecoStyleId] = [];
			}
			G_AvailableMacroblockModels[C_Mode_Decoration][DecoStyleId].add(MacroblockModel);
		}
		declare Text[Integer] LibThemePack_TrackCategory for MacroblockModel;
		foreach (TrackStyleId => CategoryName in LibThemePack_TrackCategory) {
			if (!G_AvailableMacroblockModels[C_Mode_Track].existskey(TrackStyleId)) {
				G_AvailableMacroblockModels[C_Mode_Track][TrackStyleId] = [];
			}
			G_AvailableMacroblockModels[C_Mode_Track][TrackStyleId].add(MacroblockModel);
		}
	}

	tuningmark("Sync_GenerateMacroblockModelsList Order");
	// We're putting the blocks in their correct order once so SortMacroblocks2 doesn't have to do it every time
	declare Integer[Integer] OrderedIndexes;
	foreach (ModeId => ModeBlocks in G_AvailableMacroblockModels) {
		yield(2);
		SetMode(ModeId);
		foreach (StyleId => StyleBlocks in ModeBlocks) {
			if (StyleBlocks.count <= 0) continue;

			Select(StyleId, GetLandStyle(), GetDecoStyle());

			if (!OrderedMacroblockModels[ModeId].existskey(StyleId)) {
				OrderedMacroblockModels[ModeId][StyleId] = [];
			}

			OrderedIndexes.clear();

			foreach (Index => MacroblockModel in StyleBlocks) {
				OrderedIndexes[Index] = GetOrder(MacroblockModel);
			}

			OrderedIndexes = OrderedIndexes.sort();

			foreach (Index => Order in OrderedIndexes) {
				declare MacroblockToAdd <=> StyleBlocks[Index]; // TODO : While we do not have a FastPtrPool, use alias so we don't use a NameIndex. Later on we should probs use an =
				OrderedMacroblockModels[ModeId][StyleId].add(MacroblockToAdd);
			}
		}
	}
	G_AvailableMacroblockModels = OrderedMacroblockModels;
}

// Get the available macroblock models
CMacroblockModel[] GetMacroblockModels() {
	declare Mode = -1;
	declare Category = -1;
	if (G_Mode == C_Mode_Decoration) {
		Mode = C_Mode_Decoration;
		Category = G_DecoStyle;
	} else {
		Mode = C_Mode_Track;
		Category = G_TrackStyle;
	}

	if (
		G_AvailableMacroblockModels.existskey(Mode) &&
		G_AvailableMacroblockModels[Mode].existskey(Category)
	) {
		return G_AvailableMacroblockModels[Mode][Category];
	}

	return [];
}

Void Unload() {
	if (Private_RequestExists()) {
		Http.Destroy(Http.Requests[G_LoadRequestId]);
	}

	G_LoadRequestId = NullId;
	G_ConfigFileLoaded = False;
	G_TrackStyles.clear();
	G_StartStyles.clear();
	G_LandStyles.clear();
	G_DecoStyles.clear();
	G_TrackStyleFilter = -1;
	G_TrackStyle = -1;
	G_LandStyle = -1;
	G_DecoStyle = -1;
	G_ClipsStyles.clear();
	G_TrackCategories.clear();
	G_DecoCategories.clear();
	G_LayersFrequencies.clear();
	G_LayersOctaves.clear();
	G_TerrainsIds.clear();
	G_DecorationsIds.clear();
	G_Terrains.clear();
	G_DisplayLog = False;
	G_Mode = C_Mode_Track;
	G_Terrains.clear();
	G_UseRandomLandStyle = False;
	G_DecoRatios.clear();
	G_DecoColors.clear();
	G_AvailableMacroblockModels.clear();

	Private_ClearMacroblockModels(True);
}

Void Load(Boolean _DisplayLog) {
	Unload();

	G_DisplayLog = _DisplayLog;
	SetMode(C_Mode_Track);
}