/** 
 *	Component: ButtonIcon
 *
 *	Available data parameters are :
 *	data-bind
 *	data-size
 *	data-max-length
 *	data-color
 *	data-halign
 *	data-valign
 *	data-scriptevents
 *	data-hideformouse
 *
 *	Available binds are:
 *	Left, Right, Up, Down, 
 *	A, B, X, Y, (Cross, Circle, Square, Triangle)
 *	L1, R1, LeftStick, RightStick, (LB, RB)
 *	Menu, View, LeftStick_Left, LeftStick_Right, 
 *	LeftStick_Up, LeftStick_Down, RightStick_Left, RightStick_Right, 
 *	RightStick_Up, RightStick_Down, L2, R2 (LT, RT)
 */
#Const Version		"2023-04-03"
#Const ScriptName	"Libs/Nadeo/MenuLibs/Common/Menu/Components/ButtonIcon.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/ManiaView2.Script.txt" as MV

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_Name "component-button-icon" //< Component name
#Const P "ButtonIcon_" //< Prefix use to differentiate functions/variables in the script

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Public
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the component
 *
 *	@return														The component id
 */
Text Component() {
	//L16N [ButtonIcon] Text displayed when an action is not binded to a button
	declare Text_NoBind = _("|Input|No binding");
	
	return MV::Component(
		C_Name,
		"""
<frame class="{{{C_Name}}}-container">
	<frame id="{{{P}}}frame-button-icon">
		<quad size="10 10" halign="center" valign="center" bgcolor="00ff00" scriptevents="1" id="{{{P}}}quad-button-icon" />
	</frame>
	<frame scale="0.8" id="{{{P}}}frame-button-name">
		<label z-index="2" size="8.5 8.5" halign="center" valign="center2" textsize="10" textcolor="eeeeee" id="{{{P}}}label-button-name" />
		<quad size="10 10" z-index="1" halign="center" valign="center" opacity="0" bgcolor="eeeeee" scriptevents="1" id="{{{P}}}quad-button-click" />
		<frame z-index="0" id="{{{P}}}frame-outline">
			<quad pos="-5 0" size="0.5 10" halign="left" valign="center" bgcolor="eeeeee" id="{{{P}}}quad-left" />
			<quad pos="5 0" size="0.5 10" halign="right" valign="center" bgcolor="eeeeee" id="{{{P}}}quad-right" />
			<quad pos="0 5" size="10 0.5" halign="center" valign="top" bgcolor="eeeeee" id="{{{P}}}quad-top" />
			<quad pos="0 -5" size="10 0.5" halign="center" valign="bottom" bgcolor="eeeeee" id="{{{P}}}quad-bottom" />
		</frame>
	</frame>
</frame>
		""",
		"""
#Include "TextLib" as {{{P}}}TL
#Include "ColorLib" as {{{P}}}Color
#Include "Libs/Nadeo/CommonLibs/Common/Platform.Script.txt" as {{{P}}}Platform
#Include "Libs/Nadeo/MenuLibs/Common/Components/Tools.Script.txt" as {{{P}}}Tools

#Const {{{P}}}C_ButtonIcons_PlayStation [
	CInputManager::EButton::Left => "file://Media/Manialinks/Common/PadButtons/PS4/DPadLeft.dds",
	CInputManager::EButton::Right => "file://Media/Manialinks/Common/PadButtons/PS4/DPadRight.dds",
	CInputManager::EButton::Up => "file://Media/Manialinks/Common/PadButtons/PS4/DPadUp.dds",
	CInputManager::EButton::Down => "file://Media/Manialinks/Common/PadButtons/PS4/DPadDown.dds",
	CInputManager::EButton::A => "file://Media/Manialinks/Common/PadButtons/PS4/Cross.dds",
	CInputManager::EButton::B => "file://Media/Manialinks/Common/PadButtons/PS4/Circle.dds",
	CInputManager::EButton::X => "file://Media/Manialinks/Common/PadButtons/PS4/Square.dds",
	CInputManager::EButton::Y => "file://Media/Manialinks/Common/PadButtons/PS4/Triangle.dds",
	CInputManager::EButton::L1 => "file://Media/Manialinks/Common/PadButtons/PS4/L1.dds",
	CInputManager::EButton::R1 => "file://Media/Manialinks/Common/PadButtons/PS4/R1.dds",
	CInputManager::EButton::LeftStick => "file://Media/Manialinks/Common/PadButtons/PS4/LStickClick.dds",
	CInputManager::EButton::RightStick => "file://Media/Manialinks/Common/PadButtons/PS4/RStickClick.dds",
	CInputManager::EButton::Menu => "file://Media/Manialinks/Common/PadButtons/PS4/Options.dds",
	CInputManager::EButton::View => "file://Media/Manialinks/Common/PadButtons/PS4/TouchPad.dds",
	CInputManager::EButton::LeftStick_Left => "file://Media/Manialinks/Common/PadButtons/PS4/LStickLeft.dds",
	CInputManager::EButton::LeftStick_Right => "file://Media/Manialinks/Common/PadButtons/PS4/LStickRight.dds",
	CInputManager::EButton::LeftStick_Up => "file://Media/Manialinks/Common/PadButtons/PS4/LStickUp.dds",
	CInputManager::EButton::LeftStick_Down => "file://Media/Manialinks/Common/PadButtons/PS4/LStickDown.dds",
	CInputManager::EButton::RightStick_Left => "file://Media/Manialinks/Common/PadButtons/PS4/RStickLeft.dds",
	CInputManager::EButton::RightStick_Right => "file://Media/Manialinks/Common/PadButtons/PS4/RStickRight.dds",
	CInputManager::EButton::RightStick_Up => "file://Media/Manialinks/Common/PadButtons/PS4/RStickUp.dds",
	CInputManager::EButton::RightStick_Down => "file://Media/Manialinks/Common/PadButtons/PS4/RStickDown.dds",
	CInputManager::EButton::L2 => "file://Media/Manialinks/Common/PadButtons/PS4/L2.dds",
	CInputManager::EButton::R2 => "file://Media/Manialinks/Common/PadButtons/PS4/R2.dds"
]

#Const {{{P}}}C_ButtonIcons_XBox [
	CInputManager::EButton::Left => "file://Media/Manialinks/Common/PadButtons/XB1/DPadLeft.dds",
	CInputManager::EButton::Right => "file://Media/Manialinks/Common/PadButtons/XB1/DPadRight.dds",
	CInputManager::EButton::Up => "file://Media/Manialinks/Common/PadButtons/XB1/DPadUp.dds",
	CInputManager::EButton::Down => "file://Media/Manialinks/Common/PadButtons/XB1/DPadDown.dds",
	CInputManager::EButton::A => "file://Media/Manialinks/Common/PadButtons/XB1/A.dds",
	CInputManager::EButton::B => "file://Media/Manialinks/Common/PadButtons/XB1/B.dds",
	CInputManager::EButton::X => "file://Media/Manialinks/Common/PadButtons/XB1/X.dds",
	CInputManager::EButton::Y => "file://Media/Manialinks/Common/PadButtons/XB1/Y.dds",
	CInputManager::EButton::L1 => "file://Media/Manialinks/Common/PadButtons/XB1/LB.dds",
	CInputManager::EButton::R1 => "file://Media/Manialinks/Common/PadButtons/XB1/RB.dds",
	CInputManager::EButton::LeftStick => "file://Media/Manialinks/Common/PadButtons/XB1/LStickClick.dds",
	CInputManager::EButton::RightStick => "file://Media/Manialinks/Common/PadButtons/XB1/RStickClick.dds",
	CInputManager::EButton::Menu => "file://Media/Manialinks/Common/PadButtons/XB1/Menu.dds",
	CInputManager::EButton::View => "file://Media/Manialinks/Common/PadButtons/XB1/View.dds",
	CInputManager::EButton::LeftStick_Left => "file://Media/Manialinks/Common/PadButtons/XB1/LStickLeft.dds",
	CInputManager::EButton::LeftStick_Right => "file://Media/Manialinks/Common/PadButtons/XB1/LStickRight.dds",
	CInputManager::EButton::LeftStick_Up => "file://Media/Manialinks/Common/PadButtons/XB1/LStickUp.dds",
	CInputManager::EButton::LeftStick_Down => "file://Media/Manialinks/Common/PadButtons/XB1/LStickDown.dds",
	CInputManager::EButton::RightStick_Left => "file://Media/Manialinks/Common/PadButtons/XB1/RStickLeft.dds",
	CInputManager::EButton::RightStick_Right => "file://Media/Manialinks/Common/PadButtons/XB1/RStickRight.dds",
	CInputManager::EButton::RightStick_Up => "file://Media/Manialinks/Common/PadButtons/XB1/RStickUp.dds",
	CInputManager::EButton::RightStick_Down => "file://Media/Manialinks/Common/PadButtons/XB1/RStickDown.dds",
	CInputManager::EButton::L2 => "file://Media/Manialinks/Common/PadButtons/XB1/LT.dds",
	CInputManager::EButton::R2 => "file://Media/Manialinks/Common/PadButtons/XB1/RT.dds"
]

#Const {{{P}}}C_ButtonIcons_Stadia [
	CInputManager::EButton::Left => "file://Media/Manialinks/Common/PadButtons/Stadia/DPadLeft.dds",
	CInputManager::EButton::Right => "file://Media/Manialinks/Common/PadButtons/Stadia/DPadRight.dds",
	CInputManager::EButton::Up => "file://Media/Manialinks/Common/PadButtons/Stadia/DPadUp.dds",
	CInputManager::EButton::Down => "file://Media/Manialinks/Common/PadButtons/Stadia/DPadDown.dds",
	CInputManager::EButton::A => "file://Media/Manialinks/Common/PadButtons/Stadia/A.dds",
	CInputManager::EButton::B => "file://Media/Manialinks/Common/PadButtons/Stadia/B.dds",
	CInputManager::EButton::X => "file://Media/Manialinks/Common/PadButtons/Stadia/X.dds",
	CInputManager::EButton::Y => "file://Media/Manialinks/Common/PadButtons/Stadia/Y.dds",
	CInputManager::EButton::L1 => "file://Media/Manialinks/Common/PadButtons/Stadia/L1.dds",
	CInputManager::EButton::R1 => "file://Media/Manialinks/Common/PadButtons/Stadia/R1.dds",
	CInputManager::EButton::LeftStick => "file://Media/Manialinks/Common/PadButtons/Stadia/LStickClick.dds",
	CInputManager::EButton::RightStick => "file://Media/Manialinks/Common/PadButtons/Stadia/RStickClick.dds",
	CInputManager::EButton::Menu => "file://Media/Manialinks/Common/PadButtons/Stadia/Menu.dds",
	CInputManager::EButton::View => "file://Media/Manialinks/Common/PadButtons/Stadia/Options.dds",
	CInputManager::EButton::LeftStick_Left => "file://Media/Manialinks/Common/PadButtons/Stadia/LStickLeft.dds",
	CInputManager::EButton::LeftStick_Right => "file://Media/Manialinks/Common/PadButtons/Stadia/LStickRight.dds",
	CInputManager::EButton::LeftStick_Up => "file://Media/Manialinks/Common/PadButtons/Stadia/LStickUp.dds",
	CInputManager::EButton::LeftStick_Down => "file://Media/Manialinks/Common/PadButtons/Stadia/LStickDown.dds",
	CInputManager::EButton::RightStick_Left => "file://Media/Manialinks/Common/PadButtons/Stadia/RStickLeft.dds",
	CInputManager::EButton::RightStick_Right => "file://Media/Manialinks/Common/PadButtons/Stadia/RStickRight.dds",
	CInputManager::EButton::RightStick_Up => "file://Media/Manialinks/Common/PadButtons/Stadia/RStickUp.dds",
	CInputManager::EButton::RightStick_Down => "file://Media/Manialinks/Common/PadButtons/Stadia/RStickDown.dds",
	CInputManager::EButton::L2 => "file://Media/Manialinks/Common/PadButtons/Stadia/L2.dds",
	CInputManager::EButton::R2 => "file://Media/Manialinks/Common/PadButtons/Stadia/R2.dds"
]

#Const {{{P}}}C_ButtonIconUnknow "file://Media/Manialinks/Common/PadButtons/Default/Default.dds"

#Const {{{P}}}C_ControllerType_Pad 0
#Const {{{P}}}C_ControllerType_Mouse 1

#Const {{{P}}}C_Controller_Keyboard 0
#Const {{{P}}}C_Controller_PlayStation 1
#Const {{{P}}}C_Controller_XBox 2

#Const {{{P}}}C_EventType_MouseClick 0
#Const {{{P}}}C_EventType_ChangeController 1
#Const {{{P}}}C_EventType_ActiveControllerUpdate 2

#Const {{{P}}}C_ActivePadBufferDuration 500

#Struct {{{P}}}K_Event {
	Integer Type;
	CMlFrame ButtonIcon;
	Integer ControllerType;
	Ident PreviousPadId;
	CInputPad PreviousPad;
	Ident ActivePadId;
	CInputPad ActivePad;
}
#Struct {{{P}}}K_ButtonState {
	Text ButtonName;
	Real MaxLength;
}
		""",
		"""
declare CMlFrame[] {{{P}}}G_Buttons;
declare Ident {{{P}}}G_ActivePadId;
declare Integer[Ident] {{{P}}}G_ActivePadIds;
declare Ident {{{P}}}G_DefaultKeyboardId;
declare {{{P}}}K_Event[] {{{P}}}PendingEvents;

CInputManager::EButton {{{P}}}Private_ConvertTextToEButton(Text _Button) {
	declare Button = {{{P}}}TL::ToLowerCase(_Button);
	
	switch (Button) {
		case "left": return CInputManager::EButton::Left;
		case "right": return CInputManager::EButton::Right;
		case "up": return CInputManager::EButton::Up;
		case "down": return CInputManager::EButton::Down;
		case "a": return CInputManager::EButton::A;
		case "b": return CInputManager::EButton::B;
		case "x": return CInputManager::EButton::X;
		case "y": return CInputManager::EButton::Y;
		case "cross": return CInputManager::EButton::A;
		case "circle": return CInputManager::EButton::B;
		case "square": return CInputManager::EButton::X;
		case "triangle": return CInputManager::EButton::Y;
		case "l1": return CInputManager::EButton::L1;
		case "r1": return CInputManager::EButton::R1;
		case "lb": return CInputManager::EButton::L1;
		case "rb": return CInputManager::EButton::R1;
		case "leftstick": return CInputManager::EButton::LeftStick;
		case "rightstick": return CInputManager::EButton::RightStick;
		case "menu": return CInputManager::EButton::Menu;
		case "view": return CInputManager::EButton::View;
		case "options": return CInputManager::EButton::Menu;
		case "touchpad": return CInputManager::EButton::View;
		case "leftstick_left": return CInputManager::EButton::LeftStick_Left;
		case "leftstick_right": return CInputManager::EButton::LeftStick_Right;
		case "leftstick_up": return CInputManager::EButton::LeftStick_Up;
		case "leftstick_down": return CInputManager::EButton::LeftStick_Down;
		case "rightstick_left": return CInputManager::EButton::RightStick_Left;
		case "rightstick_right": return CInputManager::EButton::RightStick_Right;
		case "rightstick_up": return CInputManager::EButton::RightStick_Up;
		case "rightstick_down": return CInputManager::EButton::RightStick_Down;
		case "l2": return CInputManager::EButton::L2;
		case "r2": return CInputManager::EButton::R2;
		case "lt": return CInputManager::EButton::L2;
		case "rt": return CInputManager::EButton::R2;
		// For MenuNavAction
		case "select": return CInputManager::EButton::A;
		case "cancel": return CInputManager::EButton::B;
		case "action1": return CInputManager::EButton::X;
		case "action2": return CInputManager::EButton::Y;
		case "action3": return CInputManager::EButton::L2;
		case "action4": return CInputManager::EButton::R2;
		case "pageup": return CInputManager::EButton::L1;
		case "pagedown": return CInputManager::EButton::R1;
		case "appmenu": return CInputManager::EButton::Menu;
		case "scrollup": return CInputManager::EButton::RightStick_Up;
		case "scrolldown": return CInputManager::EButton::RightStick_Down;
	}
	
	return CInputManager::EButton::None;
}

Void {{{P}}}AssertIsButtonContainer(CMlFrame _Frame_ButtonIconContainer) {
	assert(
		_Frame_ButtonIconContainer != Null && _Frame_ButtonIconContainer.HasClass("{{{C_Name}}}-container"),
		"This is not a valid `ButtonIcon` frame container"
	);
}

CMlFrame {{{P}}}GetButtonContainerFromInstance(CMlFrame _Frameinstance_ButtonIcon) {
	assert(
		_Frameinstance_ButtonIcon != Null && _Frameinstance_ButtonIcon.Controls.count > 0 && _Frameinstance_ButtonIcon.Controls[0].HasClass("{{{C_Name}}}-container"),
		"This is not a valid `ButtonIcon` frame instance"
	);
	return (_Frameinstance_ButtonIcon.Controls[0] as CMlFrame);
}

Void {{{P}}}Private_UpdateKeyboardButton(CMlFrame _Button, Text _ButtonName, Real _MaxLength) {
	{{{P}}}AssertIsButtonContainer(_Button);

	declare Quad_ButtonIcon <=> (_Button.GetFirstChild("{{{P}}}quad-button-icon") as CMlQuad);
	declare Label_ButtonName <=> (_Button.GetFirstChild("{{{P}}}label-button-name") as CMlLabel);
	declare Quad_ButtonClick <=> (_Button.GetFirstChild("{{{P}}}quad-button-click") as CMlQuad);
	
	Label_ButtonName.TextSizeReal = (Quad_ButtonIcon.Size.Y * 0.8) - 2;
	Label_ButtonName.Value = _ButtonName;
	
	declare Width = Label_ButtonName.ComputeWidth(_ButtonName);
	declare Size = <Width, Quad_ButtonIcon.Size.Y>;
	if (Size.X > _MaxLength) Size.X = _MaxLength;
	Label_ButtonName.Size = <Size.X - 1.5, Size.Y - 1.5>;
	Quad_ButtonClick.Size = Size;
	
	declare Frame_Outline <=> (_Button.GetFirstChild("{{{P}}}frame-outline") as CMlFrame);
	declare Quad_OutlineLeft <=> (Frame_Outline.Controls[0] as CMlQuad);
	declare Quad_OutlineRight <=> (Frame_Outline.Controls[1] as CMlQuad);
	declare Quad_OutlineTop <=> (Frame_Outline.Controls[2] as CMlQuad);
	declare Quad_OutlineBottom <=> (Frame_Outline.Controls[3] as CMlQuad);
	
	Quad_OutlineLeft.Size.Y = Size.Y;
	Quad_OutlineRight.Size.Y = Size.Y;
	Quad_OutlineTop.RelativePosition_V3.Y = Size.Y * 0.5;
	Quad_OutlineBottom.RelativePosition_V3.Y = Size.Y * -0.5;
	
	Quad_OutlineTop.Size.X = Size.X;
	Quad_OutlineBottom.Size.X = Size.X;
	Quad_OutlineLeft.RelativePosition_V3.X = Size.X * -0.5;
	Quad_OutlineRight.RelativePosition_V3.X = Size.X * 0.5;

	// Try to make the text fit in the button
	if (Width != 0. && Width > Label_ButtonName.Size.X) {
		declare Ratio = Label_ButtonName.Size.X / Width;
		Label_ButtonName.TextSizeReal *= Ratio;
		if (Label_ButtonName.TextSizeReal < 1.) {
			Label_ButtonName.TextSizeReal = 1.;
		}
	}
}

Void {{{P}}}Private_SetButtonName(CMlFrame _Button, Text _ButtonName) {
	{{{P}}}AssertIsButtonContainer(_Button);

	declare {{{P}}}K_ButtonState {{{P}}}ButtonState for _Button;
	if ({{{P}}}ButtonState.ButtonName != _ButtonName) {
		{{{P}}}ButtonState.ButtonName = _ButtonName;
		{{{P}}}Private_UpdateKeyboardButton(_Button, {{{P}}}ButtonState.ButtonName, {{{P}}}ButtonState.MaxLength);
	}
}

Void {{{P}}}Private_SetMaxLength(CMlFrame _Button, Real _MaxLength) {
	{{{P}}}AssertIsButtonContainer(_Button);

	declare {{{P}}}K_ButtonState {{{P}}}ButtonState for _Button;
	if ({{{P}}}ButtonState.MaxLength != _MaxLength) {
		{{{P}}}ButtonState.MaxLength = _MaxLength;
		{{{P}}}Private_UpdateKeyboardButton(_Button, {{{P}}}ButtonState.ButtonName, {{{P}}}ButtonState.MaxLength);
	}
}

CInputPad::EPadType {{{P}}}GetPadTypeEnumFromText (Text _PadTypeText) {
	switch(_PadTypeText) {
		case "CInputPad::EPadType::Keyboard" : {
			return CInputPad::EPadType::Keyboard;
		}
		case "CInputPad::EPadType::Mouse" : {
			return CInputPad::EPadType::Mouse;
		}
		case "CInputPad::EPadType::Generic" : {
			return CInputPad::EPadType::Generic;
		}
		case "CInputPad::EPadType::XBox" : {
			return CInputPad::EPadType::XBox;
		}
		case "CInputPad::EPadType::PlayStation" : {
			return CInputPad::EPadType::PlayStation;
		}
		case "CInputPad::EPadType::Vive" : {
			return CInputPad::EPadType::Vive;
		}
	}
	return CInputPad::EPadType::Keyboard;
}

// Update button color
Void {{{P}}}Private_UpdateButtonColor(CMlFrame _Button) {
	{{{P}}}AssertIsButtonContainer(_Button);

	declare Frame_ButtonName <=> (_Button.GetFirstChild("{{{P}}}frame-button-name") as CMlFrame);
	declare Label_ButtonName <=> (Frame_ButtonName.GetFirstChild("{{{P}}}label-button-name") as CMlLabel);
	declare Quad_ButtonClick <=> (Frame_ButtonName.GetFirstChild("{{{P}}}quad-button-click") as CMlQuad);
	declare Frame_Outline <=> (Frame_ButtonName.GetFirstChild("{{{P}}}frame-outline") as CMlFrame);
	declare Vec3 {{{P}}}Color for _Button;
	Label_ButtonName.TextColor = {{{P}}}Color;
	Quad_ButtonClick.BgColor = {{{P}}}Color;
	foreach (Control in Frame_Outline.Controls) {
		declare Quad_Outline <=> (Control as CMlQuad);
		Quad_Outline.BgColor = {{{P}}}Color;
	}
}

Void {{{P}}}Private_InitButton(CMlFrame _Button, Boolean _Force) {
	{{{P}}}AssertIsButtonContainer(_Button);

	if (!{{{P}}}G_Buttons.exists(_Button)) { {{{P}}}G_Buttons.add(_Button);	} 
	else if (!_Force) { return;	}	
	
	declare CInputManager::EButton {{{P}}}Bind for _Button;
	if (_Button.Parent.DataAttributeExists("bind")) {
		{{{P}}}Bind = {{{P}}}Private_ConvertTextToEButton(_Button.Parent.DataAttributeGet("bind"));
	} else {
		{{{P}}}Bind = CInputManager::EButton::None;
	}

	declare Frame_ButtonIcon <=> (_Button.GetFirstChild("{{{P}}}frame-button-icon") as CMlFrame);
	declare Quad_ButtonIcon <=> (Frame_ButtonIcon.GetFirstChild("{{{P}}}quad-button-icon") as CMlQuad);
	declare Frame_ButtonName <=> (_Button.GetFirstChild("{{{P}}}frame-button-name") as CMlFrame);
	declare Label_ButtonName <=> (Frame_ButtonName.GetFirstChild("{{{P}}}label-button-name") as CMlLabel);
	declare Quad_ButtonClick <=> (Frame_ButtonName.GetFirstChild("{{{P}}}quad-button-click") as CMlQuad);
	declare Frame_Outline <=> (Frame_ButtonName.GetFirstChild("{{{P}}}frame-outline") as CMlFrame);
	
	if (_Button.Parent.DataAttributeExists("size")) {
		declare SizeText = _Button.Parent.DataAttributeGet("size");
		declare SizeTextSplit = {{{P}}}TL::Split(" ", SizeText);
		declare SizeX = 0.;
		declare SizeY = 0.;
		if (SizeTextSplit.existskey(0)) {
			SizeX = {{{P}}}TL::ToReal(SizeTextSplit[0]);
		}
		if (SizeTextSplit.existskey(1)) {
			SizeY = {{{P}}}TL::ToReal(SizeTextSplit[1]);
		} else {
			SizeY = SizeX;
		}
		
		Quad_ButtonIcon.Size = <SizeX, SizeY>;
	}
	
	if (_Button.Parent.DataAttributeExists("max-length")) {
		{{{P}}}Private_SetMaxLength(_Button, {{{P}}}TL::ToReal(_Button.Parent.DataAttributeGet("max-length")));
	} else {
		{{{P}}}Private_SetMaxLength(_Button, Quad_ButtonIcon.Size.X);
	}
	
	if (_Button.Parent.DataAttributeExists("halign")) {
		declare HAlignText = {{{P}}}TL::ToLowerCase(_Button.Parent.DataAttributeGet("halign"));
		declare HAlign = CMlControl::AlignHorizontal::None;
		switch (HAlignText) {
			case "left": HAlign = CMlControl::AlignHorizontal::Left;
			case "center": HAlign = CMlControl::AlignHorizontal::HCenter;
			case "right": HAlign = CMlControl::AlignHorizontal::Right;
		}
		Quad_ButtonIcon.HorizontalAlign = HAlign;
		
		if (HAlign == CMlControl::AlignHorizontal::Left) {
			Label_ButtonName.RelativePosition_V3.X = Quad_ButtonIcon.Size.X * 0.5;
			Quad_ButtonClick.RelativePosition_V3.X = Quad_ButtonIcon.Size.X * 0.5;
			Frame_Outline.RelativePosition_V3.X = Quad_ButtonIcon.Size.X * 0.5;
		} else if (HAlign == CMlControl::AlignHorizontal::Right) {
			Label_ButtonName.RelativePosition_V3.X = Quad_ButtonIcon.Size.X * -0.5;
			Quad_ButtonClick.RelativePosition_V3.X = Quad_ButtonIcon.Size.X * -0.5;
			Frame_Outline.RelativePosition_V3.X = Quad_ButtonIcon.Size.X * -0.5;
		}
	}
	
	if (_Button.Parent.DataAttributeExists("valign")) {
		declare VAlignText = _Button.Parent.DataAttributeGet("valign");
		declare VAlign = CMlControl::AlignVertical::None;
		switch (VAlignText) {
			case "top": VAlign = CMlControl::AlignVertical::Top;
			case "center": VAlign = CMlControl::AlignVertical::VCenter;
			case "bottom": VAlign = CMlControl::AlignVertical::Bottom;
		}
		Quad_ButtonIcon.VerticalAlign = VAlign;
		
		if (VAlign == CMlControl::AlignVertical::Top) {
			Label_ButtonName.RelativePosition_V3.Y = Quad_ButtonIcon.Size.Y * -0.5;
			Quad_ButtonClick.RelativePosition_V3.Y = Quad_ButtonIcon.Size.Y * -0.5;
			Frame_Outline.RelativePosition_V3.Y = Quad_ButtonIcon.Size.Y * -0.5;
		} else if (VAlign == CMlControl::AlignVertical::Bottom) {
			Label_ButtonName.RelativePosition_V3.Y = Quad_ButtonIcon.Size.Y * 0.5;
			Quad_ButtonClick.RelativePosition_V3.Y = Quad_ButtonIcon.Size.Y * 0.5;
			Frame_Outline.RelativePosition_V3.Y = Quad_ButtonIcon.Size.Y * 0.5;
		}
	}

		// Force the type of button style via data attribute
	if(_Button.Parent.DataAttributeExists("pad-type")) {
		declare Text {{{P}}}PadType for _Button;
		declare Text[CInputManager::EButton] ButtonIcons;
		{{{P}}}PadType = _Button.Parent.DataAttributeGet("pad-type");
		declare PadType = {{{P}}}GetPadTypeEnumFromText({{{P}}}PadType);
		switch(PadType) {
			case CInputPad::EPadType::XBox : {
				declare Quad_ButtonIcon <=> (Frame_ButtonIcon.GetFirstChild("{{{P}}}quad-button-icon") as CMlQuad);
				Frame_ButtonIcon.Visible = True;
				Frame_ButtonName.Visible = False;
				ButtonIcons = {{{P}}}C_ButtonIcons_XBox;
				if (ButtonIcons.existskey({{{P}}}Bind)) {
					Quad_ButtonIcon.ImageUrl = ButtonIcons[{{{P}}}Bind];
				} else {
					Quad_ButtonIcon.ImageUrl = {{{P}}}C_ButtonIconUnknow;
				}
			}
			case CInputPad::EPadType::PlayStation		: {
				declare Quad_ButtonIcon <=> (Frame_ButtonIcon.GetFirstChild("{{{P}}}quad-button-icon") as CMlQuad);
				Frame_ButtonIcon.Visible = True;
				Frame_ButtonName.Visible = False;
				ButtonIcons = {{{P}}}C_ButtonIcons_PlayStation;
				if (ButtonIcons.existskey({{{P}}}Bind)) {
					Quad_ButtonIcon.ImageUrl = ButtonIcons[{{{P}}}Bind];
				} else {
					Quad_ButtonIcon.ImageUrl = {{{P}}}C_ButtonIconUnknow;
				}
			}
			case CInputPad::EPadType::Keyboard	: {
				Frame_ButtonIcon.Visible = False;
				Frame_ButtonName.Visible = True;
				declare CInputPad PcPad;
				if(Input.Pads.existskey(1) && Input.Pads[1].Type == CInputPad::EPadType::Keyboard) {
					PcPad = Input.Pads[1];
				} else if (Input.Pads.existskey(0) && Input.Pads[0].Type == CInputPad::EPadType::Keyboard) {
					PcPad = Input.Pads[0];
				}
				if(PcPad == Null) return;
				declare ButtonName = Input.GetPadButtonCurrentBinding(PcPad, {{{P}}}Bind);
				if (ButtonName == "") {
					ButtonName = "{{{Text_NoBind}}}";
				}
				{{{P}}}Private_SetButtonName(_Button, ButtonName);
			}
		}
	}
	
	declare Vec3 {{{P}}}Color for _Button;
	if (_Button.Parent.DataAttributeExists("color")) {
		{{{P}}}Color = {{{P}}}Color::HexToRgb(_Button.Parent.DataAttributeGet("color"));
		{{{P}}}Private_UpdateButtonColor(_Button);
	} else {
		{{{P}}}Color = Label_ButtonName.TextColor;
	}

	declare Boolean {{{P}}}HideForMouse for _Button;
	if (_Button.Parent.DataAttributeExists("hideformouse")) {
		{{{P}}}HideForMouse = {{{P}}}Tools::TextToBoolean(_Button.Parent.DataAttributeGet("hideformouse"));
	} else {
		{{{P}}}HideForMouse = False;
	}
	
	declare Boolean {{{P}}}GenerateEvent for _Button;
	if (_Button.Parent.DataAttributeExists("scriptevents")) {
		{{{P}}}GenerateEvent = {{{P}}}Tools::TextToBoolean(_Button.Parent.DataAttributeGet("scriptevents"));
	} else {
		{{{P}}}GenerateEvent = False;
	}
}
Void {{{P}}}InitButton(CMlFrame _ButtonIconInstance) {
	{{{P}}}Private_InitButton({{{P}}}GetButtonContainerFromInstance(_ButtonIconInstance), True);
}

Boolean {{{P}}}IsVisible(CMlFrame _ButtonIconInstance) {
	return {{{P}}}GetButtonContainerFromInstance(_ButtonIconInstance).Visible;
}
Void {{{P}}}Private_SetVisibility(CMlFrame _Button, Boolean _IsVisible) {
	{{{P}}}AssertIsButtonContainer(_Button);
	_Button.Visible = _IsVisible;
}

// Update button icon
Void {{{P}}}Private_UpdateButton(CMlFrame _Button, CInputPad _Pad, CInputPad _TruePad) {
	{{{P}}}AssertIsButtonContainer(_Button);
	
	declare CInputManager::EButton {{{P}}}Bind for _Button;
	
	declare Frame_ButtonIcon <=> (_Button.GetFirstChild("{{{P}}}frame-button-icon") as CMlFrame);
	declare Frame_ButtonName <=> (_Button.GetFirstChild("{{{P}}}frame-button-name") as CMlFrame);

	// Force the use of the plaform button style on XBox and PlayStation
	if (
		{{{P}}}Platform::IsConsole(System) ||
		_Pad != Null && (
			_Pad.Type == CInputPad::EPadType::XBox ||
			_Pad.Type == CInputPad::EPadType::PlayStation ||
			_Pad.Type == CInputPad::EPadType::Generic
		)
	) {
		Frame_ButtonIcon.Visible = True;
		Frame_ButtonName.Visible = False;
		
		declare Quad_ButtonIcon <=> (Frame_ButtonIcon.GetFirstChild("{{{P}}}quad-button-icon") as CMlQuad);
		
		if ({{{P}}}Platform::IsMicrosoft(System)) {
			Quad_ButtonIcon.ImageUrl = {{{P}}}C_ButtonIcons_XBox.get({{{P}}}Bind, {{{P}}}C_ButtonIconUnknow);
		} else if ({{{P}}}Platform::IsSony(System)) {
			Quad_ButtonIcon.ImageUrl = {{{P}}}C_ButtonIcons_PlayStation.get({{{P}}}Bind, {{{P}}}C_ButtonIconUnknow);
		} else if (_Pad != Null && _Pad.Type == CInputPad::EPadType::XBox) {
			Quad_ButtonIcon.ImageUrl = {{{P}}}C_ButtonIcons_XBox.get({{{P}}}Bind, {{{P}}}C_ButtonIconUnknow);
		} else if (_Pad != Null && _Pad.Type == CInputPad::EPadType::PlayStation) {
			Quad_ButtonIcon.ImageUrl = {{{P}}}C_ButtonIcons_PlayStation.get({{{P}}}Bind, {{{P}}}C_ButtonIconUnknow);
		} else if (_Pad != Null && _Pad.Type == CInputPad::EPadType::Generic) {
			if ({{{P}}}Platform::IsGoogle(System)) {
				Quad_ButtonIcon.ImageUrl = {{{P}}}C_ButtonIcons_Stadia.get({{{P}}}Bind, {{{P}}}C_ButtonIconUnknow);
			} else {
				Quad_ButtonIcon.ImageUrl = {{{P}}}C_ButtonIcons_XBox.get({{{P}}}Bind, {{{P}}}C_ButtonIconUnknow);
			}
		} else {
			Quad_ButtonIcon.ImageUrl = {{{P}}}C_ButtonIcons_XBox.get({{{P}}}Bind, {{{P}}}C_ButtonIconUnknow);
		}
	} else if (_Pad == Null) {
		Frame_ButtonIcon.Visible = True;
		Frame_ButtonName.Visible = False;
		
		declare Quad_ButtonIcon <=> (Frame_ButtonIcon.GetFirstChild("{{{P}}}quad-button-icon") as CMlQuad);
		
		Quad_ButtonIcon.ImageUrl = {{{P}}}C_ButtonIconUnknow;
	} else {
		declare Boolean {{{P}}}HideForMouse for _Button;
		if (
			{{{P}}}HideForMouse &&
			_TruePad != Null &&
			_TruePad.Type == CInputPad::EPadType::Mouse
		) {
			Frame_ButtonIcon.Visible = False;
			Frame_ButtonName.Visible = False;
		} else {
			Frame_ButtonIcon.Visible = False;
			Frame_ButtonName.Visible = True;
			
			declare ButtonName = Input.GetPadButtonCurrentBinding(_Pad, {{{P}}}Bind);
			
			if (ButtonName == "") {
				ButtonName = "{{{Text_NoBind}}}";
			}
			
			{{{P}}}Private_SetButtonName(_Button, ButtonName);
		}
	}

	// Visibility of the component
	{{{P}}}Private_SetVisibility(_Button, Frame_ButtonIcon.Visible || Frame_ButtonName.Visible);
}
Void {{{P}}}Private_UpdateButton(CMlFrame _Button, CInputPad _Pad) {
	{{{P}}}Private_UpdateButton(_Button, _Pad, Null);
}

// Save the current user controller in
// a variable accessible to all pages
// to be able to update the buttons
// on every pages with the correct
// platform
Void {{{P}}}Private_SetUserController(CInputPad _Pad) {
	declare Ident {{{P}}}UserControllerId for This;
	if (_Pad != Null) {
		{{{P}}}UserControllerId = _Pad.Id;
	} else {
		{{{P}}}UserControllerId = NullId;
	}
}
CInputPad {{{P}}}Private_GetUserController() {
	declare Ident {{{P}}}UserControllerId for This;
	if (!Input.Pads.existskey({{{P}}}UserControllerId)) {
		return Null;
	}
	return Input.Pads[{{{P}}}UserControllerId];
}

// Update all buttons icon
Void {{{P}}}Private_UpdateButtons(CInputPad _Pad) {
	// If the controller is neither an XBox or PlayStation controller
	// then check if we can display the keyboard controls
	// If there is no keyboard available then try to display the controller controls
	declare CInputPad SelectedController;
	if (_Pad != Null) {
		if (
			_Pad.Type == CInputPad::EPadType::XBox ||
			_Pad.Type == CInputPad::EPadType::PlayStation
		) {
			SelectedController = _Pad;
		}
		// When not on PS4 we consider a generic controller to be an XBox controller
		else if(
			_Pad.Type == CInputPad::EPadType::Generic &&
			System.Platform != CSystemPlatform::ESystemPlatform::PS4
		) {
			SelectedController = _Pad;
		} else {
			foreach (Pad in Input.Pads) {
				if (Pad.Type == CInputPad::EPadType::Keyboard) {
					SelectedController = Pad;
					break;
				}
			}
			if (SelectedController == Null) {
				SelectedController = _Pad;
			}
		}
	}
	
	{{{P}}}Private_SetUserController(SelectedController);
	
	foreach (Button in {{{P}}}G_Buttons) {
		declare Text {{{P}}}PadType for Button;
		if ({{{P}}}PadType == "") {
			{{{P}}}Private_UpdateButton(Button, SelectedController, _Pad);
		}
	}
}

// An input was detected on a controller
Void {{{P}}}Private_ButtonPress(CInputPad _Pad, Boolean _Forced) {
	if (!_Forced) {
		declare Ident PadId;
		if (_Pad != Null) PadId = _Pad.Id;
		{{{P}}}G_ActivePadIds[PadId] = Now + {{{P}}}C_ActivePadBufferDuration;
	} else {
		declare Ident PreviousActivePadId = {{{P}}}G_ActivePadId;
		if (_Pad == Null) {
			{{{P}}}G_ActivePadId = NullId;
			{{{P}}}Private_UpdateButtons(Null);
		} else if (_Pad != Null) {
			{{{P}}}G_ActivePadId = _Pad.Id;
			{{{P}}}Private_UpdateButtons(_Pad);
		}

		if (PreviousActivePadId != {{{P}}}G_ActivePadId) {
			declare CInputPad PreviousPad;
			if (Input.Pads.existskey(PreviousActivePadId)) {
				PreviousPad = Input.Pads[PreviousActivePadId];
			}
			declare CInputPad ActivePad;
			if (Input.Pads.existskey({{{P}}}G_ActivePadId)) {
				ActivePad = Input.Pads[{{{P}}}G_ActivePadId];
			}
			{{{P}}}PendingEvents.add({{{P}}}K_Event {
				Type = {{{P}}}C_EventType_ActiveControllerUpdate,
				PreviousPadId = PreviousActivePadId,
				PreviousPad = PreviousPad,
				ActivePadId = {{{P}}}G_ActivePadId,
				ActivePad = ActivePad
			});
		}
	}
}

Void {{{P}}}Private_SelectDefaultController() {
	if (Input.Pads.count > 0) {
		{{{P}}}Private_UpdateButtons(Input.Pads[0]);
	} else {
		{{{P}}}Private_UpdateButtons(Null);
	}
}

Void {{{P}}}Private_Focus(CMlFrame _Button) {
	{{{P}}}AssertIsButtonContainer(_Button);

	declare Frame_ButtonName <=> (_Button.GetFirstChild("{{{P}}}frame-button-name") as CMlFrame);
	declare Label_ButtonName <=> (Frame_ButtonName.GetFirstChild("{{{P}}}label-button-name") as CMlLabel);
	declare Quad_ButtonClick <=> (Frame_ButtonName.GetFirstChild("{{{P}}}quad-button-click") as CMlQuad);
	Label_ButtonName.TextColor = {{{P}}}Color::Hex6ToRgb("111111");
	Quad_ButtonClick.Opacity = 1.;
}

Void {{{P}}}Private_Unfocus(CMlFrame _Button) {
	{{{P}}}AssertIsButtonContainer(_Button);

	declare Frame_ButtonName <=> (_Button.GetFirstChild("{{{P}}}frame-button-name") as CMlFrame);
	declare Label_ButtonName <=> (Frame_ButtonName.GetFirstChild("{{{P}}}label-button-name") as CMlLabel);
	declare Quad_ButtonClick <=> (Frame_ButtonName.GetFirstChild("{{{P}}}quad-button-click") as CMlQuad);
	declare Vec3 {{{P}}}Color for _Button;
	Label_ButtonName.TextColor = {{{P}}}Color;
	Quad_ButtonClick.Opacity = 0.;
}

Void {{{P}}}Private_CreateChangeControllerEvent(Integer _NewControllerType) {
	declare Integer {{{P}}}CurrentControllerUsed for LocalUser;
	if (_NewControllerType == {{{P}}}CurrentControllerUsed) return;

	{{{P}}}CurrentControllerUsed = _NewControllerType;
	declare {{{P}}}K_Event ChangeControllerEvent;
	ChangeControllerEvent.Type = {{{P}}}C_EventType_ChangeController;
	ChangeControllerEvent.ControllerType = _NewControllerType;
	{{{P}}}PendingEvents.add(ChangeControllerEvent);
}

Void {{{P}}}ForceUpdate() {
	{{{P}}}Private_ButtonPress({{{P}}}Private_GetUserController(), True);
}
Void {{{P}}}ForceUpdateWithActivePad() {
	if (Input.Pads.existskey({{{P}}}G_ActivePadId)) {
		{{{P}}}Private_ButtonPress(Input.Pads[{{{P}}}G_ActivePadId], True);
	} else {
		{{{P}}}ForceUpdate();
	}
}

Void {{{P}}}SetButton(CMlFrame _ButtonIconInstance, Text _ButtonName) {
	declare CMlFrame Button = {{{P}}}GetButtonContainerFromInstance(_ButtonIconInstance);

	Button.Parent.DataAttributeSet("bind", _ButtonName);
	declare CInputManager::EButton {{{P}}}Bind for Button;
	{{{P}}}Bind = {{{P}}}Private_ConvertTextToEButton(_ButtonName);
	{{{P}}}ForceUpdateWithActivePad();
}

Void {{{P}}}SetColor(CMlFrame _ButtonIconInstance, Text _ButtonColor) {
	declare CMlFrame Button = {{{P}}}GetButtonContainerFromInstance(_ButtonIconInstance);

	Button.Parent.DataAttributeSet("color", _ButtonColor);
	declare Vec3 {{{P}}}Color for Button;
	{{{P}}}Color = {{{P}}}Color::HexToRgb(_ButtonColor);
	{{{P}}}Private_UpdateButtonColor(Button);
	{{{P}}}ForceUpdateWithActivePad();
}

Integer {{{P}}}GetCurrentControllerType() {
	declare Integer {{{P}}}CurrentControllerUsed for LocalUser;
	return {{{P}}}CurrentControllerUsed;
}

***MainInit***
***
declare CInputPad Mouse;
declare Boolean {{{P}}}PrevPageIsVisible;
declare Boolean {{{P}}}EnableMenuNavigationInputs;
declare Integer {{{P}}}ForceUpdateTime;
declare Boolean {{{P}}}IsMouse;
declare Integer {{{P}}}NextActivePadBufferUpdateTime;
***

***MainStart***
***
log("WARNING `ButtonIcon` is deprecated, you should use `ButtonIcon2`."); //< Intended log, do not remove it

Page.GetClassChildren("{{{C_Name}}}-container", Page.MainFrame, True);
foreach (Control in Page.GetClassChildren_Result) {
	declare Container_ButtonIcon = (Control as CMlFrame);
	{{{P}}}Private_InitButton(Container_ButtonIcon, False);
}

{{{P}}}Private_SelectDefaultController();

{{{P}}}IsMouse = {{{P}}}Tools::IsUsingMouse(Input);
if ({{{P}}}IsMouse) {
	{{{P}}}Private_CreateChangeControllerEvent({{{P}}}C_ControllerType_Mouse);
} else {
	{{{P}}}Private_CreateChangeControllerEvent({{{P}}}C_ControllerType_Pad);
}
{{{P}}}NextActivePadBufferUpdateTime = Now;
***

***MainLoop***
***
if ({{{P}}}PrevPageIsVisible != PageIsVisible) {
	{{{P}}}PrevPageIsVisible = PageIsVisible;
	{{{P}}}PendingEvents = [];
	
	if (PageIsVisible) {
		{{{P}}}ForceUpdate();
		{{{P}}}IsMouse = False;
	}	else {
		foreach (Button in {{{P}}}G_Buttons) {
			{{{P}}}Private_Unfocus(Button);
		}
	}
}

if (PageIsVisible) {
	{{{P}}}PendingEvents = [];

	// Detect menu navigation (it changes the binding)
	if ({{{P}}}EnableMenuNavigationInputs != EnableMenuNavigationInputs) {
		{{{P}}}EnableMenuNavigationInputs = EnableMenuNavigationInputs;
		{{{P}}}ForceUpdateTime = Now + 1;
	}
	if ({{{P}}}ForceUpdateTime >= 0 && Now >= {{{P}}}ForceUpdateTime) {
		{{{P}}}ForceUpdateTime = -1;
		{{{P}}}ForceUpdate();
	}
	
	// Detect mouse input
	if ({{{P}}}IsMouse != {{{P}}}Tools::IsUsingMouse(Input)) {
		{{{P}}}IsMouse = {{{P}}}Tools::IsUsingMouse(Input);
		if ({{{P}}}IsMouse) {
			if (Mouse == Null || Mouse.Type != CInputPad::EPadType::Mouse) {
				Mouse = Null;
				foreach (Pad in Input.Pads) {
					if (Pad.Type == CInputPad::EPadType::Mouse) {
						Mouse = Pad;
						break;
					}
				}
			}
			{{{P}}}Private_ButtonPress(Mouse, False);
			{{{P}}}Private_CreateChangeControllerEvent({{{P}}}C_ControllerType_Mouse);
		} else if (Input.PendingEvents.count <= 0) { //< Force update if there are no pending input events (when editing CMlEntry for example)
			{{{P}}}ForceUpdate();
		}
	}
	
	// Detect other devices input
	foreach (Event in Input.PendingEvents) {
		if (Event.Type == CInputEvent::EType::PadButtonPress) {
			{{{P}}}Private_ButtonPress(Event.Pad, False);

			if (Event.Pad.Type != CInputPad::EPadType::Mouse) {
				{{{P}}}Private_CreateChangeControllerEvent({{{P}}}C_ControllerType_Pad);
			}
		}
	}
	
	foreach (Event in PendingEvents) {
		if (Event.Type == CMlScriptEvent::Type::MouseClick) {
			if (Event.ControlId == "{{{P}}}quad-button-icon" || Event.ControlId == "{{{P}}}quad-button-click") {
				declare Boolean {{{P}}}GenerateEvent for Event.Control.Parent.Parent;
				if ({{{P}}}GenerateEvent) {
					declare {{{P}}}K_Event ButtonIconEvent;
					ButtonIconEvent.Type = {{{P}}}C_EventType_MouseClick;
					ButtonIconEvent.ButtonIcon = Event.Control.Parent.Parent.Parent;
					{{{P}}}PendingEvents.add(ButtonIconEvent);
				}
			}
		} else if (Event.Type == CMlScriptEvent::Type::MouseOver) {
			if (Event.ControlId == "{{{P}}}quad-button-icon" || Event.ControlId == "{{{P}}}quad-button-click") {
				declare Boolean {{{P}}}GenerateEvent for Event.Control.Parent.Parent;
				if ({{{P}}}GenerateEvent) {
					{{{P}}}Private_Focus(Event.Control.Parent.Parent);
				}
			}
		} else if (Event.Type == CMlScriptEvent::Type::MouseOut) {
			if (Event.ControlId == "{{{P}}}quad-button-icon" || Event.ControlId == "{{{P}}}quad-button-click") {
				declare Boolean {{{P}}}GenerateEvent for Event.Control.Parent.Parent;
				if ({{{P}}}GenerateEvent) {
					{{{P}}}Private_Unfocus(Event.Control.Parent.Parent);
				}
			}
		}
	}

	// Buffer active controllers to avoid swapping between them
	// if we press a button on several controllers at the same time
	if ({{{P}}}G_ActivePadIds.count >= 1 && Now >= {{{P}}}NextActivePadBufferUpdateTime) {
		{{{P}}}NextActivePadBufferUpdateTime = Now + {{{P}}}C_ActivePadBufferDuration;

		// Remove from the buffer all controllers not used since a given time except the last one
		if ({{{P}}}G_ActivePadIds.count > 1) {
			declare Ident[] ToRemove;
			foreach (PadId => ActiveEndTime in {{{P}}}G_ActivePadIds) {
				if (Now >= ActiveEndTime) ToRemove.add(PadId);
			}
			foreach (PadId in ToRemove) {
				{{{P}}}G_ActivePadIds.removekey(PadId);
				if ({{{P}}}G_ActivePadIds.count <= 1) break;
			}
		}

		// The currently selected pad is not active anymore, find a new one
		if (!{{{P}}}G_ActivePadIds.existskey({{{P}}}G_ActivePadId)) {
			declare Ident LastActivePadId;
			declare Integer LastActiveEndTime;
			foreach (PadId => ActiveEndTime in {{{P}}}G_ActivePadIds) {
				if (LastActivePadId == NullId || LastActiveEndTime <= ActiveEndTime) {
					LastActivePadId = PadId;
					LastActiveEndTime = ActiveEndTime;
				}
			}
			declare CInputPad Pad;
			if (Input.Pads.existskey(LastActivePadId)) {
				Pad = Input.Pads[LastActivePadId];
			}
			{{{P}}}Private_ButtonPress(Pad, True);
		}
	}
}
***
		""",
		[],
		[]
	);
}