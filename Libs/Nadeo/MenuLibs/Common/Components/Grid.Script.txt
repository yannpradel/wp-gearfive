/** 
 *	Create a grid layout in manialink similar to a CSS grid layout
 *
 *	First create a grid configuration object specifying the properties
 *	of the grid: size, padding, gutter, ...
 *	Then add the desired amount of columns/rows to the grid configuration
 *	Compile the grid configuration to get a grid object exposing
 *	the position and size of each column/row in the grid
 *
 *	Available attributes are :
 *	- data-grid-column
 *	- data-grid-row
 */
#Const Version		"2023-02-28"
#Const ScriptName	"Libs/Nadeo/MenuLibs/Common/Components/Grid.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/Helpers.Script.txt" as MLHelpers

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_Class_Container "component-grid-container"
#Const C_Class_Element "component-grid-element"

#Const C_Align_Left 0
#Const C_Align_Center 1
#Const C_Align_Right 2
#Const C_Align_Top 3
#Const C_Align_Bottom 5

#Const C_Direction_Right 0
#Const C_Direction_Top 1
#Const C_Direction_Left 2
#Const C_Direction_Bottom 3

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Structure
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Struct K_GridColumn {
	Real Size;
	Integer Align;
}

#Struct K_GridConfig {
	Real Size;
	Real Padding;
	Real Gutter;
	Integer Direction;
	K_GridColumn[Integer] Columns;
}

#Struct K_Grid {
	K_GridConfig Config;
	Real[Integer] Size;
	Real[Integer] Pos;
	Real[Integer] SizeBg;
	Real[Integer] PosBg;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Set the total width/height allocated to the grid
K_GridConfig SetSize(K_GridConfig _GridConfig, Real _Size) {
	declare GridConfig = _GridConfig;
	GridConfig.Size = ML::Max(0., _Size);
	return GridConfig;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Set the width/height of the padding at both extremities of the grid
K_GridConfig SetGridPadding(K_GridConfig _GridConfig, Real _Padding) {
	declare GridConfig = _GridConfig;
	GridConfig.Padding = ML::Max(0., _Padding);
	return GridConfig;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Set the width/height of the gutter between the columns/rows of the grid
K_GridConfig SetGutter(K_GridConfig _GridConfig, Real _Gutter) {
	declare GridConfig = _GridConfig;
	GridConfig.Gutter = ML::Max(0., _Gutter);
	return GridConfig;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Set the direction in which the columns/rows are added in the grid
K_GridConfig SetDirection(K_GridConfig _GridConfig, Integer _Direction) {
	declare GridConfig = _GridConfig;
	GridConfig.Direction = _Direction;
	return GridConfig;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/**	Add a column/row in the grid
 *
 *	@param	_GridConfig								The grid configuration in which the column/row must be added
 *	@param	_ColumnId									The id of the column/row that will be used afterward to get back its position and size
 *	@param	_Size											The size of the column in the grid. This value won't be used as is.
 *																		Instead the size of each column will be used to determine a ratio based on the width/height of the grid.
 *																		eg: with a grid size of 200, a column 1 of size 50, a column 2 of size 150 and a column 3 of size 200
 *																		the final size of the columns will be 1: 25, 2: 75 and 3: 100
 *																		(if the grid has no padding and gutters, otherwise the size of those must also be taken into account)
 *	@param	_Align										The alignment of the content in the column/row
 *
 *	@return														The grid config updated with the new column/row
 */
K_GridConfig AddColumn(K_GridConfig _GridConfig, Integer _ColumnId, Real _Size, Integer _Align) {
	declare GridConfig = _GridConfig;
	GridConfig.Columns[_ColumnId] = K_GridColumn {
		Size = ML::Max(0., _Size),
		Align = _Align
	};
	return GridConfig;
}
K_GridConfig AddRow(K_GridConfig _GridConfig, Integer _RowId, Real _Size, Integer _Align) {
	return AddColumn(_GridConfig, _RowId, _Size, _Align);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/**	Create a new grid
 *
 *	@param	_Size											The total width/height allocated to the grid content
 *																		The padding, gutters and columns/rows of the grid will be fit into this space
 *	@param	_Padding									The size of the padding at the extremities of the grid
 *	@param	_Gutter										The size of the gutter between each column/row
 *	@param	_Direction								The direction in which the columns/rows are added into the grid
 */
K_GridConfig Create() {
	return K_GridConfig {
		Size = 0.,
		Padding = 0.,
		Gutter = 0.,
		Direction = C_Direction_Right,
		Columns = []
	};
}
K_GridConfig Create(Real _Size, Real _Padding, Real _Gutter, Integer _Direction) {
	declare K_GridConfig GridConfig = Create();
	GridConfig = SetSize(GridConfig, _Size);
	GridConfig = SetGridPadding(GridConfig, _Padding);
	GridConfig = SetGutter(GridConfig, _Gutter);
	GridConfig = SetDirection(GridConfig, _Direction);
	return GridConfig;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/**	Compile a grid configuration object
 *	and get back a grid object with the position
 *	and size of each column/row
 */
K_Grid Compile(K_GridConfig _GridConfig) {
	declare K_Grid Grid;
	Grid.Config = _GridConfig;
	
	declare Real ColumnSizeRatio = 1.;
	if (_GridConfig.Size > 0. && _GridConfig.Columns.count > 0) {
		declare Real GridSizeWithoutPaddingAndGutter = 0.;
		GridSizeWithoutPaddingAndGutter = _GridConfig.Size - (_GridConfig.Gutter * (_GridConfig.Columns.count - 1)) - (2 * _GridConfig.Padding);
		assert(GridSizeWithoutPaddingAndGutter > 0., "[Grid] The cumulated gutter and padding exceed the grid size you provided");
		
		declare Real AllColumnsSize;
		foreach (ColumnId => Column in _GridConfig.Columns) {
			AllColumnsSize += Column.Size;
		}
		
		ColumnSizeRatio = GridSizeWithoutPaddingAndGutter / AllColumnsSize;
	}
	
	declare Real ColumnPosLeft = _GridConfig.Padding;
	declare Real ColumnPosBgLeft = 0.;
	if (_GridConfig.Direction == C_Direction_Left || _GridConfig.Direction == C_Direction_Bottom) {
		ColumnPosLeft *= -1.;
	}
	declare Integer ColumnKey = 0;
	foreach (ColumnId => Column in _GridConfig.Columns) {
		declare Real AlignShift = 0.;
		declare Real ColumnSize = Column.Size * ColumnSizeRatio;
		if (Column.Align == C_Align_Center) {
			if (_GridConfig.Direction == C_Direction_Right || _GridConfig.Direction == C_Direction_Top) {
				AlignShift = ColumnSize * 0.5;
			} else {
				AlignShift = ColumnSize * -0.5;
			}
		} else if (Column.Align == C_Align_Left) {
			if (_GridConfig.Direction == C_Direction_Left) {
				AlignShift = ColumnSize * -1.;
			}
		} else if (Column.Align == C_Align_Top) {
			if (_GridConfig.Direction == C_Direction_Top) {
				AlignShift = ColumnSize * 1.;
			}
		} else if (Column.Align == C_Align_Right) {
			if (_GridConfig.Direction == C_Direction_Right) {
				AlignShift = ColumnSize * 1.;
			}
		} else if (Column.Align == C_Align_Bottom) {
			if (_GridConfig.Direction == C_Direction_Bottom) {
				AlignShift = ColumnSize * -1.;
			}
		}
		declare Real ColumnPos = ColumnPosLeft + AlignShift;
		Grid.Pos[ColumnId] = ColumnPos;
		Grid.Size[ColumnId] = ColumnSize;
		if (_GridConfig.Direction == C_Direction_Right || _GridConfig.Direction == C_Direction_Top) {
			ColumnPosLeft += Grid.Size[ColumnId] + _GridConfig.Gutter;
		} else {
			ColumnPosLeft -= Grid.Size[ColumnId] + _GridConfig.Gutter;
		}

		declare Boolean IsFirstColumn = (ColumnKey == 0);
		declare Boolean IsLastColumn = (ColumnKey == _GridConfig.Columns.count - 1);
		declare Real AlignBgShift = 0.;
		declare Real ColumnBgSize = ColumnSize;
		if (IsFirstColumn || IsLastColumn) {
			ColumnBgSize += _GridConfig.Padding + (_GridConfig.Gutter * 0.5);
		} else {
			ColumnBgSize += _GridConfig.Gutter;
		}
		if (Column.Align == C_Align_Center) {
			if (_GridConfig.Direction == C_Direction_Left || _GridConfig.Direction == C_Direction_Bottom) {
				if (IsFirstColumn) AlignBgShift = ((_GridConfig.Padding * 0.5) - (_GridConfig.Gutter * 0.25));
				if (IsLastColumn) AlignBgShift = -((_GridConfig.Padding * 0.5) - (_GridConfig.Gutter * 0.25));
			} else {
				if (IsFirstColumn) AlignBgShift = -((_GridConfig.Padding * 0.5) - (_GridConfig.Gutter * 0.25));
				else if (IsLastColumn) AlignBgShift = ((_GridConfig.Padding * 0.5) - (_GridConfig.Gutter * 0.25));
			}
		} else if (Column.Align == C_Align_Left || Column.Align == C_Align_Bottom) {
			if (_GridConfig.Direction == C_Direction_Left || _GridConfig.Direction == C_Direction_Bottom) {
				if (IsLastColumn) AlignBgShift = -_GridConfig.Padding;
				else AlignBgShift = (_GridConfig.Gutter * -0.5);
			} else {
				if (IsFirstColumn) AlignBgShift = -_GridConfig.Padding;
				else AlignBgShift = (_GridConfig.Gutter * -0.5);
			}
		} else if (Column.Align == C_Align_Right || Column.Align == C_Align_Top) {
			if (_GridConfig.Direction == C_Direction_Left || _GridConfig.Direction == C_Direction_Bottom) {
				if (IsFirstColumn) AlignBgShift = _GridConfig.Padding;
				else AlignBgShift = (_GridConfig.Gutter * 0.5);
			} else {
				if (IsLastColumn) AlignBgShift = _GridConfig.Padding;
				else AlignBgShift = (_GridConfig.Gutter * 0.5);
			}
		}
		Grid.PosBg[ColumnId] = ColumnPos + AlignBgShift;
		Grid.SizeBg[ColumnId] = ColumnBgSize;

		ColumnKey += 1;
	}
	
	return Grid;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/**	Update the pos of grid elements dynamically
 *
 *	@param	_GridConfig						The grid configuration in which the column/row must be added
 *	@param	_Container						The frame containing the grid elements
 *																The container must have the C_Class_Container class
 *																All grid elements inside the container must have 
 *																	- the C_Class_Element class
 *																	- the data-colum (or data-row) attribute
 *	@param	_Skew									Skew position on X axis depending on the original position of the control
 *	@param	_LockGridSize					Keep the grid size, resize the grid otherwise
 *	@param	_Animate							Animate the resize if true, resize without animation otherwise
 */
K_Grid Update(K_GridConfig _GridConfig, CAnimManager _AnimMgr, CMlFrame _Container, Real _Skew, Boolean _LockGridSize, Boolean _Animate) {
	assert(_Container.HasClass(C_Class_Container), "[Grid] The container you provided is not a grid container.");

	declare K_Grid Grid = K_Grid { Config = _GridConfig };
	declare Real AllHiddenControlsSize = 0.;
	declare CMlControl[Integer] VisibleControls = [];
	
	// Check for hidden controls
	foreach (Control in _Container.Controls) {
		if (Control.HasClass(C_Class_Element) && (Control.DataAttributeExists("grid-column") || Control.DataAttributeExists("grid-row"))) {
			declare Integer ColumnId;
			if (Control.DataAttributeExists("grid-column")) {
				ColumnId = TL::ToInteger(Control.DataAttributeGet("grid-column"));
			} else if (Control.DataAttributeExists("grid-row")) {
				ColumnId = TL::ToInteger(Control.DataAttributeGet("grid-row"));
			}
			if (Grid.Config.Columns.existskey(ColumnId)) {
				if (Control.Visible) {
					VisibleControls[ColumnId] = Control;
				} else {
					AllHiddenControlsSize += Grid.Config.Columns[ColumnId].Size;
					Grid.Config.Columns.removekey(ColumnId);
				}
			}
		} 
	}

	// Adjust the grid size
	if (!_LockGridSize && _GridConfig.Columns.count > 0) {
		declare Real AllColumnsSize;
		foreach (ColumnId => Column in _GridConfig.Columns) {
			AllColumnsSize += Column.Size;
		}
		if (AllColumnsSize != 0.) {
			Grid.Config.Size -= _GridConfig.Size * AllHiddenControlsSize / AllColumnsSize;
		}
	}

	// Compile the grid with the new sizes
	Grid = Compile(Grid.Config);

	// Apply the grid update
	foreach (ColumnId => Control in VisibleControls) {
		declare Boolean IsOriginalPosSaved for Control = False;
		declare Vec2 OriginalPos for Control = <0., 0.>;
		if (!IsOriginalPosSaved) { //< Saves the original position of the control indicated in the ML for the skew calculation
			OriginalPos = Control.RelativePosition_V3;
			IsOriginalPosSaved = True;
		}

		if (Grid.Pos.existskey(ColumnId)) {
			declare Real GridPos = Grid.Pos[ColumnId];
			declare Vec2 Pos = MLHelpers::SkewX(<GridPos, OriginalPos.Y>, _Skew);
			if (_GridConfig.Direction == C_Direction_Top || _GridConfig.Direction == C_Direction_Bottom) {
				Pos = MLHelpers::SkewX(<OriginalPos.X, GridPos>, _Skew);
			}
			if (_Animate) {
				_AnimMgr.Flush(Control);
				_AnimMgr.Add(Control, "<anim pos=\""^Pos.X^" "^Pos.Y^"\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
			} else {
				Control.RelativePosition_V3 = Pos;
			}
		}
	}

	return Grid;
}
K_Grid Update(K_GridConfig _GridConfig, CAnimManager _AnimMgr, CMlFrame _Container, Boolean _LockGridSize, Boolean _Animate) {
	return Update(_GridConfig, _AnimMgr, _Container, 0., _LockGridSize, _Animate);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Generate a manialink `pos` attribute for a grid column
Text Pos(K_Grid _Grid, Integer _Column, Real _OtherPos) {
	if (_Grid.Config.Direction == C_Direction_Right || _Grid.Config.Direction == C_Direction_Left) {
		return "pos=\""^_Grid.Pos[_Column]^" "^_OtherPos^"\"";
	}
	return "pos=\""^_OtherPos^" "^_Grid.Pos[_Column]^"\"";
}
Text Pos(K_Grid _Grid, Integer _Column) {
	return Pos(_Grid, _Column, 0.);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Generate a manialink `pos` attribute for a grid column background
Text PosBg(K_Grid _Grid, Integer _Column, Real _OtherPos) {
	if (_Grid.Config.Direction == C_Direction_Right || _Grid.Config.Direction == C_Direction_Left) {
		return "pos=\""^_Grid.PosBg[_Column]^" "^_OtherPos^"\"";
	}
	return "pos=\""^_OtherPos^" "^_Grid.PosBg[_Column]^"\"";
}
Text PosBg(K_Grid _Grid, Integer _Column) {
	return PosBg(_Grid, _Column, 0.);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Generate a manialink `size` attribute for a grid column
Text Size(K_Grid _Grid, Integer _Column, Real _OtherSize) {
	if (_Grid.Config.Direction == C_Direction_Right || _Grid.Config.Direction == C_Direction_Left) {
		return "size=\""^_Grid.Size[_Column]^" "^_OtherSize^"\"";
	}
	return "size=\""^_OtherSize^" "^_Grid.Size[_Column]^"\"";
}
Text Size(K_Grid _Grid, Integer _Column) {
	return Size(_Grid, _Column, 0.);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the size of a column
Real GetSize(K_Grid _Grid, Integer _Column) {
	return _Grid.Size[_Column];
}
Vec2 GetSize(K_Grid _Grid, Integer _Column, Real _OtherSize) {
	if (_Grid.Config.Direction == C_Direction_Right || _Grid.Config.Direction == C_Direction_Left) {
		return <_Grid.Size[_Column], _OtherSize>;
	}
	return <_OtherSize, _Grid.Size[_Column]>;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Generate a manialink `size` attribute for a grid column background
Text SizeBg(K_Grid _Grid, Integer _Column, Real _OtherSize) {
	if (_Grid.Config.Direction == C_Direction_Right || _Grid.Config.Direction == C_Direction_Left) {
		return "size=\""^_Grid.SizeBg[_Column]^" "^_OtherSize^"\"";
	}
	return "size=\""^_OtherSize^" "^_Grid.SizeBg[_Column]^"\"";
}
Text SizeBg(K_Grid _Grid, Integer _Column) {
	return Size(_Grid, _Column, 0.);
}