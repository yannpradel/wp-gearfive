/** 
 *	Component: AudioManager
 *	DEPRECATED: Use "Libs/Nadeo/CommonLibs/Common/AudioManager_MA.Script.txt" instead
 */
#Const Version		"2019-10-22"
#Const ScriptName	"Libs/Nadeo/CommonLib/Common/AudioManager.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "MathLib" as ML
#Include "TextLib" as TL
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/ManiaView2.Script.txt" as MV
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/Navigation.Script.txt" as Navigation

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_Name "component-menulibs-audio-manager" //< Component name
#Const P "ComponentMenuLibsAudioManager_" //< Prefix used to differentiate functions/variables in the script

#Const C_NullId -1

#Const C_BasePath_CommonSound "file://Media/Sounds/Nadeo/CommonLibs/Common/Common/"
#Const C_BasePath_MenuSound "file://Media/Sounds/Nadeo/CommonLibs/Common/Menu/"
#Const C_BasePath_GameSound "file://Media/Sounds/Nadeo/CommonLibs/Common/Game/"

#Const C_Event_PlaySound "Event_PlaySound"
#Const C_Event_StopSound "Event_StopSound"
#Const C_Event_StopAllSounds "Event_StopAllSounds"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Structures
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Struct K_Sound {
	Text FileName;
	Real[] VolumedB;
	Real[] Pitch;
	CAudioSource AudioSource;
}

#Struct K_Audio {
	K_Sound[] Sounds;
	Boolean IsMusic;
	Boolean IsLooping;
	Boolean IsSpatialized;
	Text Description;
	Integer LastIdPlayed;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Global variables
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
declare K_Audio[Text] G_AudioSources;
declare CAudioSource[Text] G_CreatedAudioSources;

declare Ident G_ReqIdJsonMenu;
declare Ident G_ReqIdJsonGame;
declare Ident G_ReqIdJsonCommon;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Public
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Stop sound according to its name
 *
 *	@param _SoundName										The name of the sound
 */
Void StopSound(Text _SoundName) {
	if (G_AudioSources.existskey(_SoundName)) {
		foreach (Sound in G_AudioSources[_SoundName].Sounds) {
			if (Sound.AudioSource == Null) continue;
			Sound.AudioSource.PlayCursor = 0.;
			Sound.AudioSource.Stop();
		}
	}
}
Void StopAllSounds() {
	foreach (SoundName=>AudioSource in G_AudioSources) {
		StopSound(SoundName);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Play sound according to its name
 *
 *	@param _SoundName										The name of the sound
 *	@param _PanRadiusLfeX								The angle of the sound in 2D space
 */
Void PlaySound(Text _SoundName, Real _PanRadiusLfeX) {
	if (G_AudioSources.existskey(_SoundName)) {
		declare K_Audio AudioDesc = G_AudioSources[_SoundName];
		if (AudioDesc.Sounds.count == 0) return;

		declare K_Sound AudioToPlay;
		if (AudioDesc.Sounds.count == 1) {
			AudioToPlay = AudioDesc.Sounds[0];
		} else {
			declare Integer RandIndex = ML::Rand(0, AudioDesc.Sounds.count-1);
			while (AudioDesc.LastIdPlayed != C_NullId && RandIndex == AudioDesc.LastIdPlayed) {
				RandIndex = ML::Rand(0, AudioDesc.Sounds.count-1);
			}
			G_AudioSources[_SoundName].LastIdPlayed = RandIndex;
			AudioToPlay = AudioDesc.Sounds[RandIndex];
		}

		declare Real[] VolumeRange = AudioToPlay.VolumedB;
		if (VolumeRange.count >= 2) {
			AudioToPlay.AudioSource.VolumedB = ML::Rand(VolumeRange[0], VolumeRange[1]);
		} else if (VolumeRange.count == 1) {
			AudioToPlay.AudioSource.VolumedB = VolumeRange[0];
		}
		declare Real[] PitchRange = AudioToPlay.Pitch;
		if (PitchRange.count >= 2) {
			AudioToPlay.AudioSource.Pitch = ML::Rand(PitchRange[0], PitchRange[1]);
		} else if (PitchRange.count == 1) {
			AudioToPlay.AudioSource.Pitch = PitchRange[0];
		}

		AudioToPlay.AudioSource.PanRadiusLfe.X = _PanRadiusLfeX;

		AudioToPlay.AudioSource.Play();
	}
}
Void PlaySound(Text _SoundName) {
	PlaySound(_SoundName, 0.);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the component
 *
 *	@return														The component id
 */
Text Component() {
	return MV::Component(
		C_Name,
		"""
		""",
		"""
		""",
		"""
/** Play sound according to its name
 *
 *	@param														The name of the sound
 */
Void {{{P}}}PlaySound(Text _SoundName, Real _PanRadiusLfeX) {
	SendCustomEvent("{{{C_Event_PlaySound}}}", [_SoundName, ""^_PanRadiusLfeX]);
}
Void {{{P}}}PlaySound(Text _SoundName) {
	{{{P}}}PlaySound(_SoundName, 0.);
}

/** Stop sound according to its name
 *
 *	@param														The name of the sound
 */
Void {{{P}}}StopSound(Text _SoundName) {
	SendCustomEvent("{{{C_Event_StopSound}}}", [_SoundName]);
}

/** Stop all sounds
 */
Void {{{P}}}StopAllSounds() {
	SendCustomEvent("{{{C_Event_StopAllSounds}}}", []);
}
""",
[],
[]
);
}

Boolean IsLoading() {
	return
		(Http.Requests.existskey(G_ReqIdJsonMenu) && !Http.Requests[G_ReqIdJsonMenu].IsCompleted) ||
		(Http.Requests.existskey(G_ReqIdJsonGame) && !Http.Requests[G_ReqIdJsonGame].IsCompleted) ||
		(Http.Requests.existskey(G_ReqIdJsonCommon) && !Http.Requests[G_ReqIdJsonCommon].IsCompleted);
}

Void AddAudiosToAudioSources(Ident _RequestId, Text _SoundPath) {
	declare CHttpRequest Request = Http.Requests[_RequestId];
	declare Text JsonText = Request.Result;
	Http.Destroy(Request);
	if (JsonText != "") {
		declare K_Audio[Text] Audios;
		declare Boolean FromJsonResult = Audios.fromjson(JsonText);
		foreach (AudioName=>AudioDesc in Audios) {
			G_AudioSources[AudioName] = AudioDesc;
			G_AudioSources[AudioName].Sounds = [];
			G_AudioSources[AudioName].LastIdPlayed = C_NullId;
			foreach (SoundIndex=>Sound in AudioDesc.Sounds) {
				if (Sound.FileName == "") continue;
				G_AudioSources[AudioName].Sounds.add(Sound);
				declare Integer CurrIndex = G_AudioSources[AudioName].Sounds.count-1;
				if (G_CreatedAudioSources.existskey(Sound.FileName)) {
					G_AudioSources[AudioName].Sounds[CurrIndex].AudioSource = G_CreatedAudioSources[Sound.FileName];
				} else {
					declare CAudioSource CreatedAudioSource = Audio.CreateSound(_SoundPath^Sound.FileName, 0., AudioDesc.IsMusic, AudioDesc.IsLooping, AudioDesc.IsSpatialized);
					G_AudioSources[AudioName].Sounds[CurrIndex].AudioSource = CreatedAudioSource;
					G_CreatedAudioSources[Sound.FileName] = CreatedAudioSource;
				}
			}
		}
	}
}

Void CreateAudioSources() {
	if (Http.Requests.existskey(G_ReqIdJsonCommon)) {
		AddAudiosToAudioSources(G_ReqIdJsonCommon, C_BasePath_CommonSound);
		G_ReqIdJsonCommon = NullId;
	}
	if ((This is CManiaAppTitle) && Http.Requests.existskey(G_ReqIdJsonMenu)) {
		AddAudiosToAudioSources(G_ReqIdJsonMenu, C_BasePath_MenuSound);
		G_ReqIdJsonMenu = NullId;
	}
	if ((This is CManiaAppPlayground) && Http.Requests.existskey(G_ReqIdJsonGame)) {
		AddAudiosToAudioSources(G_ReqIdJsonGame, C_BasePath_GameSound);
		G_ReqIdJsonGame = NullId;
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Unload library
Void Unload() {
	foreach (AudioDesc in G_AudioSources) {
		foreach (Sound in AudioDesc.Sounds) {
			Audio.DestroySound(Sound.AudioSource);
		}
	}
	G_AudioSources = [];
	G_CreatedAudioSources = [];

	if (G_ReqIdJsonCommon != NullId) {
		if (Http.Requests.existskey(G_ReqIdJsonCommon)) Http.Destroy(Http.Requests[G_ReqIdJsonCommon]);
		G_ReqIdJsonCommon = NullId;
	}
	if (G_ReqIdJsonMenu != NullId) {
		if (Http.Requests.existskey(G_ReqIdJsonMenu)) Http.Destroy(Http.Requests[G_ReqIdJsonMenu]);
		G_ReqIdJsonMenu = NullId;
	}
	if (G_ReqIdJsonGame != NullId) {
		if (Http.Requests.existskey(G_ReqIdJsonGame)) Http.Destroy(Http.Requests[G_ReqIdJsonGame]);
		G_ReqIdJsonGame = NullId;
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Load the audio files and create audio sources
Void Load(Text _JsonFilePath_AudioCommon, Text _JsonFilePath_AudioMenu, Text _JsonFilePath_AudioGame) {
	Unload();

	declare CHttpRequest Req = Http.CreateGet(_JsonFilePath_AudioCommon);
	if (Req != Null) G_ReqIdJsonCommon = Req.Id;	

	if (This is CManiaAppTitle) {
		Req = Http.CreateGet(_JsonFilePath_AudioMenu);
		if (Req != Null) G_ReqIdJsonMenu = Req.Id;	
	} else if (This is CManiaAppPlayground) {
		Req = Http.CreateGet(_JsonFilePath_AudioGame);
		if (Req != Null) G_ReqIdJsonGame = Req.Id;
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Process ManiaApp events
Void ProcessEvent(CManiaAppEvent _Event) {
	if (_Event.Type == CManiaAppEvent::EType::LayerCustomEvent) {
		switch (_Event.CustomEventType) {
			case C_Event_PlaySound: {
				if (_Event.CustomEventData.count > 1) {
					PlaySound(_Event.CustomEventData[0], TL::ToReal(_Event.CustomEventData[1]));
				} else if (_Event.CustomEventData.count > 0) {
					PlaySound(_Event.CustomEventData[0]);
				}
			}
			case C_Event_StopSound: {
				if (_Event.CustomEventData.count > 0) {
					StopSound(_Event.CustomEventData[0]);
				}
			}
			case C_Event_StopAllSounds: {
				StopAllSounds();
			}
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update library for ManiaApp
Void Yield(CNod _Context) {
	if (_Context is CManiaAppTitle) {
		declare ManiaAppTitle = (_Context as CManiaAppTitle);
		foreach (Event in ManiaAppTitle.PendingEvents) {
			ProcessEvent(Event);
		}
	} else if (_Context is CManiaAppPlayground) {
		declare ManiaAppPlayground = (_Context as CManiaAppPlayground);
		foreach (Event in ManiaAppPlayground.PendingEvents) {
			ProcessEvent(Event);
		}
	}
}