/**
 *	Utilities
 */
#Const Version		"1.0.0"
#Const ScriptName	"Libs/Nadeo/CMGame/Modes/Utils.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Includes
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "TextLib" as TL
#Include "MathLib" as ML

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Structures
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Struct K_BigMessageSound {
	CUIConfig::EUISound Sound;
	Integer Variant;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Globales
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
declare CUIConfig::EUISequence[][Ident] G_UISequenceStack;
declare CUIConfig::EVisibility[][Ident] G_ScoreTableVisibilityStack;
declare K_BigMessageSound[][Ident] G_BigMessageSoundStack;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Push an UI sequence on the stack
Void PushUISequence(CUIConfig _UI) {
	if (_UI == Null) return;
	if (G_UISequenceStack.existskey(_UI.Id)) {
		G_UISequenceStack[_UI.Id].add(_UI.UISequence);
	} else {
		G_UISequenceStack[_UI.Id] = [_UI.UISequence];
	}
}
Void PushAndApplyUISequence(CUIConfig _UI, CUIConfig::EUISequence _NewUISequence) {
	if (_UI == Null) return;
	PushUISequence(_UI);
	_UI.UISequence = _NewUISequence;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Pop an UI sequence from the stack
CUIConfig::EUISequence PopUISequence(CUIConfig _UI) {
	if (_UI == Null) return CUIConfig::EUISequence::None;
	declare CUIConfig::EUISequence UISequence = _UI.UISequence;
	if (G_UISequenceStack.existskey(_UI.Id)) {
		declare Integer Key = G_UISequenceStack[_UI.Id].count - 1;
		UISequence = G_UISequenceStack[_UI.Id][Key];
		// If there is only one element left in the stack, reset the stack
		if (Key == 0) {
			G_UISequenceStack.removekey(_UI.Id);
		} else {
			G_UISequenceStack[_UI.Id].removekey(Key);
		}
	}
	return UISequence;
}
Void PopAndApplyUISequence(CUIConfig _UI) {
	if (_UI != Null && G_UISequenceStack.existskey(_UI.Id)) {
		_UI.UISequence = PopUISequence(_UI);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Reset an UI sequence stack
Void ResetStackUISequence(CUIConfig _UI) {
	if (_UI == Null) return;
	G_UISequenceStack.removekey(_UI.Id);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Push a scores table visibility on the stack
Void PushScoresTableVisibility(CUIConfig _UI) {
	if (_UI == Null) return;
	if (G_ScoreTableVisibilityStack.existskey(_UI.Id)) {
		G_ScoreTableVisibilityStack[_UI.Id].add(_UI.ScoreTableVisibility);
	} else {
		G_ScoreTableVisibilityStack[_UI.Id] = [_UI.ScoreTableVisibility];
	}
}
Void PushAndApplyScoresTableVisibility(CUIConfig _UI, CUIConfig::EVisibility _NewScoreTableVisibility) {
	if (_UI == Null) return;
	PushScoresTableVisibility(_UI);
	_UI.ScoreTableVisibility = _NewScoreTableVisibility;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Pop a scores table visibility from the stack
CUIConfig::EVisibility PopScoresTableVisibility(CUIConfig _UI) {
	if (_UI == Null) return CUIConfig::EVisibility::None;
	declare CUIConfig::EVisibility ScoreTableVisibility = _UI.ScoreTableVisibility;
	if (G_ScoreTableVisibilityStack.existskey(_UI.Id)) {
		declare Integer Key = G_ScoreTableVisibilityStack[_UI.Id].count - 1;
		ScoreTableVisibility = G_ScoreTableVisibilityStack[_UI.Id][Key];
		// If there is only one element left in the stack, reset the stack
		if (Key == 0) {
			G_ScoreTableVisibilityStack.removekey(_UI.Id);
		} else {
			G_ScoreTableVisibilityStack[_UI.Id].removekey(Key);
		}
	}
	return ScoreTableVisibility;
}
Void PopAndApplyScoresTableVisibility(CUIConfig _UI) {
	if (_UI != Null && G_ScoreTableVisibilityStack.existskey(_UI.Id)) {
		_UI.ScoreTableVisibility = PopScoresTableVisibility(_UI);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Reset a scores table visibility stack
Void ResetStackScoresTableVisibility(CUIConfig _UI) {
	if (_UI == Null) return;
	G_ScoreTableVisibilityStack.removekey(_UI.Id);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get a big message sound structure from an UI
K_BigMessageSound Private_GetBigMessageSoundStruct(CUIConfig _UI) {
	return K_BigMessageSound {
		Sound = _UI.BigMessageSound,
		Variant = _UI.BigMessageSoundVariant
	};
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Push an big message sound on the stack
Void PushBigMessageSound(CUIConfig _UI) {
	if (_UI == Null) return;
	if (G_BigMessageSoundStack.existskey(_UI.Id)) {
		G_BigMessageSoundStack[_UI.Id].add(Private_GetBigMessageSoundStruct(_UI));
	} else {
		G_BigMessageSoundStack[_UI.Id] = [Private_GetBigMessageSoundStruct(_UI)];
	}
}
Void PushAndApplyBigMessageSound(CUIConfig _UI, CUIConfig::EUISound _NewBigMessageSound, Integer _NewBigMessageSoundVariant) {
	if (_UI == Null) return;
	PushBigMessageSound(_UI);
	_UI.BigMessageSound = _NewBigMessageSound;
	_UI.BigMessageSoundVariant = _NewBigMessageSoundVariant;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Pop a big message sound from the stack
K_BigMessageSound PopBigMessageSound(CUIConfig _UI) {
	if (_UI == Null) return K_BigMessageSound {
		Sound = CUIConfig::EUISound::Silence,
		Variant = 0
	};
	declare K_BigMessageSound BigMessageSound = K_BigMessageSound {
		Sound = _UI.BigMessageSound,
		Variant = _UI.BigMessageSoundVariant
	};
	if (G_BigMessageSoundStack.existskey(_UI.Id)) {
		declare Integer Key = G_BigMessageSoundStack[_UI.Id].count - 1;
		BigMessageSound = G_BigMessageSoundStack[_UI.Id][Key];
		// If there is only one element left in the stack, reset the stack
		if (Key == 0) {
			G_BigMessageSoundStack.removekey(_UI.Id);
		} else {
			G_BigMessageSoundStack[_UI.Id].removekey(Key);
		}
	}
	return BigMessageSound;
}
Void PopAndApplyBigMessageSound(CUIConfig _UI) {
	if (_UI != Null && G_BigMessageSoundStack.existskey(_UI.Id)) {
		declare K_BigMessageSound BigMessageSound = PopBigMessageSound(_UI);
		_UI.BigMessageSound = BigMessageSound.Sound;
		_UI.BigMessageSoundVariant = BigMessageSound.Variant;
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Reset a big message sound stack
Void ResetStackBigMessageSound(CUIConfig _UI) {
	if (_UI == Null) return;
	G_BigMessageSoundStack.removekey(_UI.Id);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the currently loaded scores table
 *	modules
 *
 *	@return														The scores tables modules
 */
CModulePlaygroundScoresTable[] GetScoresTables() {
	declare CModulePlaygroundScoresTable[] ScoresTables;

	if (Hud != Null) {
		foreach (Module in Hud.Modules) {
			if (Module is CModulePlaygroundScoresTable) {
				ScoresTables.add((Module as CModulePlaygroundScoresTable));
			}
		}
		if (Hud.ScoresTable != Null && !ScoresTables.exists(Hud.ScoresTable)) {
			ScoresTables.add(Hud.ScoresTable);
		}
	}

	return ScoresTables;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Format a time with milliseconds
 *
 *	@param	_Time											The time to format
 */
Text TimeToText(Integer _Time) {
	return TL::TimeToText(_Time, True)^ML::Abs(_Time % 10);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** The players start time are always
 *	rounded up to the hundreth by the C++
 *	whatever start time is given to the
 *	spawn function
 *	This function replicate this behaviour
 *	and convert a time to a valid player
 *	start time
 *	eg: 1450 => 1500, 13410 => 13500, 141200 => 141200
 */
Integer GetPlayerStartTime(Integer _StartTime) {
	declare Integer TrueStartTime = _StartTime - (_StartTime % 100);
	if (_StartTime % 100 != 0) TrueStartTime += 100;
	return TrueStartTime;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get a player from its account id
CSmPlayer GetPlayerFromAccountId(Text _AccountId) {
	foreach (Player in AllPlayers) {
		if (Player.User != Null && Player.User.WebServicesUserId == _AccountId) return Player;
	}
	return Null;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/**	Play a sound
 *
 *	@param	_Name				The name of the sound to play
 *	@param	_Variant		The variant to use
 */
Void PlaySound(CUIConfig::EUISound _Name, Integer _Variant) {
	UIManager.UIAll.SendNotice(
		"",
		CUIConfig::ENoticeLevel::PlayerInfo, Null,
		CUIConfig::EAvatarVariant::Default,
		_Name, _Variant
	);
}