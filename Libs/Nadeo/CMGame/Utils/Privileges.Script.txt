/**
 *	Privileges check helpers
 */
#Const Version		"1.0.1"
#Const ScriptName	"Libs/Nadeo/CMGame/Utils/Privileges.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Includes
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "TextLib" as TL

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Structures
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Struct K_PrivilegeCheck {
	Integer Status;
	CPrivilegeMgr PrivilegeMgr;
	CPrivilegeMgr::EPrivilege Privilege;
	Ident UserId;
	Ident TaskId;
	Text[] TargetedUsersAccountIds;
}
#Struct K_PrivilegesCheck {
	Integer Status;
	Integer CheckKey;
	K_PrivilegeCheck[] Checks;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constant
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_Status_Null 0
#Const C_Status_Pending 1
#Const C_Status_Error 2
#Const C_Status_Ongoing 3
#Const C_Status_HasPrivilege 4
#Const C_Status_MissPrivilege 5
#Const C_Status_Canceled 6

#Const C_AllPrivileges [
	// Should be checked with `CheckPrivilege()`
	CPrivilegeMgr::EPrivilege::CrossPlay,
	CPrivilegeMgr::EPrivilege::PlayMultiplayerAsync,
	CPrivilegeMgr::EPrivilege::PlayMultiplayerAsyncWithUGC,
	CPrivilegeMgr::EPrivilege::PlayMultiplayerMode,
	CPrivilegeMgr::EPrivilege::PlayMultiplayerModeWithUGC,
	CPrivilegeMgr::EPrivilege::PlayMultiplayerSession,
	CPrivilegeMgr::EPrivilege::PlayMultiplayerSessionWithUGC,
	// Can be checked with `CheckPrivilege()` and `CheckTargetedPrivilege()`
	CPrivilegeMgr::EPrivilege::UseUserCreatedContent,
	CPrivilegeMgr::EPrivilege::UseUserCreatedContentRequired,
	// Should be checked with `CheckTargetedPrivilege()`
	CPrivilegeMgr::EPrivilege::ViewOnlinePresence,
	CPrivilegeMgr::EPrivilege::ViewUserGameHistory,
	CPrivilegeMgr::EPrivilege::CommunicationText,
	CPrivilegeMgr::EPrivilege::CommunicationVoice,
	CPrivilegeMgr::EPrivilege::VoiceChat
	// Deprecated. Check: /trackmania-next/tmnext/-/issues/4336#note_220041
	// CPrivilegeMgr::EPrivilege::DownloadUserCreatedContent //< Use `UseUserCreatedContent` instead
	// CPrivilegeMgr::EPrivilege::UploadUserCreatedContent //< Use `UseUserCreatedContent` instead
	// CPrivilegeMgr::EPrivilege::ViewUserCreatedContent //< Use `UseUserCreatedContent` instead
	// CPrivilegeMgr::EPrivilege::ViewUserCreatedContentRequired //< Use `UseUserCreatedContentRequired` instead
]

#Const C_Privilege_Crossplay "CrossPlay"
#Const C_Privilege_PlayMultiplayerAsync "PlayMultiplayerAsync"
#Const C_Privilege_PlayMultiplayerAsyncWithUGC "PlayMultiplayerAsyncWithUGC"
#Const C_Privilege_PlayMultiplayerMode "PlayMultiplayerMode"
#Const C_Privilege_PlayMultiplayerModeWithUGC "PlayMultiplayerModeWithUGC"
#Const C_Privilege_PlayMultiplayerSession "PlayMultiplayerSession"
#Const C_Privilege_PlayMultiplayerSessionWithUGC "PlayMultiplayerSessionWithUGC"
#Const C_Privilege_UseUserCreatedContent "UseUserCreatedContent"
#Const C_Privilege_UseUserCreatedContentRequired "UseUserCreatedContentRequired"
#Const C_Privilege_ViewOnlinePresence "ViewOnlinePresence"
#Const C_Privilege_ViewUserGameHistory "ViewUserGameHistory"
#Const C_Privilege_CommunicationText "CommunicationText"
#Const C_Privilege_CommunicationVoice "CommunicationVoice"
#Const C_Privilege_VoiceChat "VoiceChat"
#Const C_Privilege_DownloadUserCreatedContent "DownloadUserCreatedContent"
#Const C_Privilege_UploadUserCreatedContent "UploadUserCreatedContent"
#Const C_Privilege_ViewUserCreatedContent "ViewUserCreatedContent"
#Const C_Privilege_ViewUserCreatedContentRequired "ViewUserCreatedContentRequired"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Convert a privilege enum value to a Text
Text PrivilegeToText(CPrivilegeMgr::EPrivilege _Privilege) {
	switch (_Privilege) {
		case CPrivilegeMgr::EPrivilege::CrossPlay: return C_Privilege_Crossplay;
		case CPrivilegeMgr::EPrivilege::PlayMultiplayerAsync: return C_Privilege_PlayMultiplayerAsync;
		case CPrivilegeMgr::EPrivilege::PlayMultiplayerAsyncWithUGC: return C_Privilege_PlayMultiplayerAsyncWithUGC;
		case CPrivilegeMgr::EPrivilege::PlayMultiplayerMode: return C_Privilege_PlayMultiplayerMode;
		case CPrivilegeMgr::EPrivilege::PlayMultiplayerModeWithUGC: return C_Privilege_PlayMultiplayerModeWithUGC;
		case CPrivilegeMgr::EPrivilege::PlayMultiplayerSession: return C_Privilege_PlayMultiplayerSession;
		case CPrivilegeMgr::EPrivilege::PlayMultiplayerSessionWithUGC: return C_Privilege_PlayMultiplayerSessionWithUGC;
		case CPrivilegeMgr::EPrivilege::UseUserCreatedContent: return C_Privilege_UseUserCreatedContent;
		case CPrivilegeMgr::EPrivilege::UseUserCreatedContentRequired: return C_Privilege_UseUserCreatedContentRequired;
		case CPrivilegeMgr::EPrivilege::ViewOnlinePresence: return C_Privilege_ViewOnlinePresence;
		case CPrivilegeMgr::EPrivilege::ViewUserGameHistory: return C_Privilege_ViewUserGameHistory;
		case CPrivilegeMgr::EPrivilege::CommunicationText: return C_Privilege_CommunicationText;
		case CPrivilegeMgr::EPrivilege::CommunicationVoice: return C_Privilege_CommunicationVoice;
		case CPrivilegeMgr::EPrivilege::VoiceChat: return C_Privilege_VoiceChat;
		case CPrivilegeMgr::EPrivilege::DownloadUserCreatedContent: return C_Privilege_DownloadUserCreatedContent;
		case CPrivilegeMgr::EPrivilege::UploadUserCreatedContent: return C_Privilege_UploadUserCreatedContent;
		case CPrivilegeMgr::EPrivilege::ViewUserCreatedContent: return C_Privilege_ViewUserCreatedContent;
		case CPrivilegeMgr::EPrivilege::ViewUserCreatedContentRequired: return C_Privilege_ViewUserCreatedContentRequired;
	}
	assert(False, "Unknow privilege `"^_Privilege^"`");
	return "";
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Convert a Text to a privilege enum value
CPrivilegeMgr::EPrivilege TextToPrivilege(Text _Privilege) {
	switch (_Privilege) {
		case C_Privilege_Crossplay: return CPrivilegeMgr::EPrivilege::CrossPlay;
		case C_Privilege_PlayMultiplayerAsync: return CPrivilegeMgr::EPrivilege::PlayMultiplayerAsync;
		case C_Privilege_PlayMultiplayerAsyncWithUGC: return CPrivilegeMgr::EPrivilege::PlayMultiplayerAsyncWithUGC;
		case C_Privilege_PlayMultiplayerMode: return CPrivilegeMgr::EPrivilege::PlayMultiplayerMode;
		case C_Privilege_PlayMultiplayerModeWithUGC: return CPrivilegeMgr::EPrivilege::PlayMultiplayerModeWithUGC;
		case C_Privilege_PlayMultiplayerSession: return CPrivilegeMgr::EPrivilege::PlayMultiplayerSession;
		case C_Privilege_PlayMultiplayerSessionWithUGC: return CPrivilegeMgr::EPrivilege::PlayMultiplayerSessionWithUGC;
		case C_Privilege_UseUserCreatedContent: return CPrivilegeMgr::EPrivilege::UseUserCreatedContent;
		case C_Privilege_UseUserCreatedContentRequired: return CPrivilegeMgr::EPrivilege::UseUserCreatedContentRequired;
		case C_Privilege_ViewOnlinePresence: return CPrivilegeMgr::EPrivilege::ViewOnlinePresence;
		case C_Privilege_ViewUserGameHistory: return CPrivilegeMgr::EPrivilege::ViewUserGameHistory;
		case C_Privilege_CommunicationText: return CPrivilegeMgr::EPrivilege::CommunicationText;
		case C_Privilege_CommunicationVoice: return CPrivilegeMgr::EPrivilege::CommunicationVoice;
		case C_Privilege_VoiceChat: return CPrivilegeMgr::EPrivilege::VoiceChat;
		case C_Privilege_DownloadUserCreatedContent: return CPrivilegeMgr::EPrivilege::DownloadUserCreatedContent;
		case C_Privilege_UploadUserCreatedContent: return CPrivilegeMgr::EPrivilege::UploadUserCreatedContent;
		case C_Privilege_ViewUserCreatedContent: return CPrivilegeMgr::EPrivilege::ViewUserCreatedContent;
		case C_Privilege_ViewUserCreatedContentRequired: return CPrivilegeMgr::EPrivilege::ViewUserCreatedContentRequired;
	}
	assert(False, "Unknow privilege `"^_Privilege^"`");
	return CPrivilegeMgr::EPrivilege::CrossPlay;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Convert a privileges array to query string
Text PrivilegesToQuery(CPrivilegeMgr::EPrivilege[] _Privileges) {
	declare Text[] Query;
	foreach (Privilege in _Privileges) {
		Query.add(PrivilegeToText(Privilege));
	}
	return TL::Join("|", Query);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Convert a query string to a privileges array
CPrivilegeMgr::EPrivilege[] QueryToPrivileges(Text _Query) {
	declare CPrivilegeMgr::EPrivilege[] Privileges;
	declare Text[] Query = TL::Split("|", _Query);
	foreach (Value in Query) {
		Privileges.add(TextToPrivilege(Value));
	}
	return Privileges;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Save in the cache if the user has a given privilege
Void Cache_SetPrivilege(CPrivilegeMgr::EPrivilege _Privilege, Boolean _Enabled) {
	declare CPrivilegeMgr::EPrivilege[] LibCommonPrivileges_CachePrivileges for System = [];
	if (_Enabled) {
		if (!LibCommonPrivileges_CachePrivileges.exists(_Privilege)) {
			LibCommonPrivileges_CachePrivileges.add(_Privilege);
		}
	} else {
		LibCommonPrivileges_CachePrivileges.remove(_Privilege);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Check in the cache if the user has a given privilege
Boolean Cache_HasPrivilege(CPrivilegeMgr::EPrivilege _Privilege) {
	declare CPrivilegeMgr::EPrivilege[] LibCommonPrivileges_CachePrivileges for System = [];
	return LibCommonPrivileges_CachePrivileges.exists(_Privilege);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Check if a user has a given privilege
K_PrivilegeCheck Check_Create(CPrivilegeMgr _PrivilegeMgr, Ident _UserId, CPrivilegeMgr::EPrivilege _Privilege, Text[] _TargetedUsersAccountIds) {
	assert(_PrivilegeMgr != Null, "`_PrivilegeMgr` cannot be `Null`");
	assert(_UserId != NullId, "`_UserId` cannot be `NullId`");

	assert(
		(
			_Privilege != CPrivilegeMgr::EPrivilege::DownloadUserCreatedContent &&
			_Privilege != CPrivilegeMgr::EPrivilege::UploadUserCreatedContent &&
			_Privilege != CPrivilegeMgr::EPrivilege::ViewUserCreatedContent
		),
		"`"^_Privilege^"` is deprecated, use `CPrivilegeMgr::EPrivilege::UseUserCreatedContent` instead"
	);
	assert(
		_Privilege != CPrivilegeMgr::EPrivilege::ViewUserCreatedContentRequired,
		"`"^_Privilege^"` is deprecated, use `CPrivilegeMgr::EPrivilege::UseUserCreatedContentRequired` instead"
	);

	declare K_PrivilegeCheck PrivilegeCheck = K_PrivilegeCheck {
		Status = C_Status_Pending,
		PrivilegeMgr = _PrivilegeMgr,
		Privilege = _Privilege,
		UserId = _UserId,
		TaskId = NullId,
		TargetedUsersAccountIds = _TargetedUsersAccountIds
	};

	return PrivilegeCheck;
}
K_PrivilegeCheck Check_Create(CPrivilegeMgr _PrivilegeMgr, Ident _UserId, CPrivilegeMgr::EPrivilege _Privilege) {
	return Check_Create(_PrivilegeMgr, _UserId, _Privilege, []);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Group several privilege checks into one group
K_PrivilegesCheck Check_Group(K_PrivilegeCheck[] _Checks) {
	return K_PrivilegesCheck {
		Status = C_Status_Pending,
		CheckKey = 0,
		Checks = _Checks
	};
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Check if the privilege check is complete
Boolean Check_IsComplete(Integer _Status) {
	return (
		_Status != C_Status_Pending &&
		_Status != C_Status_Ongoing
	);
}
Boolean Check_IsComplete(K_PrivilegeCheck _PrivilegeCheck) {
	return Check_IsComplete(_PrivilegeCheck.Status);
}
Boolean Check_IsComplete(K_PrivilegesCheck _PrivilegesCheck) {
	return Check_IsComplete(_PrivilegesCheck.Status);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Check if the user has the required privilege
Boolean Check_HasPrivilege(Integer _Status) {
	return _Status == C_Status_HasPrivilege;
}
Boolean Check_HasPrivilege(K_PrivilegeCheck _PrivilegeCheck) {
	return Check_HasPrivilege(_PrivilegeCheck.Status);
}
Boolean Check_HasPrivilege(K_PrivilegesCheck _PrivilegesCheck) {
	return Check_HasPrivilege(_PrivilegesCheck.Status);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Destroy an ongoing privilege check
K_PrivilegeCheck Check_Destroy(K_PrivilegeCheck _PrivilegeCheck) {
	if (Check_IsComplete(_PrivilegeCheck)) return _PrivilegeCheck;

	declare K_PrivilegeCheck PrivilegeCheck = _PrivilegeCheck;

	if (
		PrivilegeCheck.TaskId != NullId &&
		PrivilegeCheck.PrivilegeMgr.TaskResults.existskey(PrivilegeCheck.TaskId)
	) {
		PrivilegeCheck.PrivilegeMgr.TaskResult_Release(PrivilegeCheck.TaskId);
	}
	PrivilegeCheck.TaskId = NullId;
	PrivilegeCheck.Status = C_Status_Canceled;

	return PrivilegeCheck;
}
K_PrivilegesCheck Check_Destroy(K_PrivilegesCheck _PrivilegesCheck) {
	if (Check_IsComplete(_PrivilegesCheck)) return _PrivilegesCheck;

	declare K_PrivilegesCheck PrivilegesCheck = _PrivilegesCheck;

	for (I, 0, PrivilegesCheck.Checks.count - 1) {
		PrivilegesCheck.Checks[I] = Check_Destroy(PrivilegesCheck.Checks[I]);
	}
	PrivilegesCheck.Status = C_Status_Canceled;

	return PrivilegesCheck;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Destroy a previous check and start a new one in its place
K_PrivilegeCheck Check_DestroyAndCreate(K_PrivilegeCheck _OldPrivilegeCheck, CPrivilegeMgr _PrivilegeMgr, Ident _UserId, CPrivilegeMgr::EPrivilege _Privilege, Text[] _TargetedUsersAccountIds) {
	Check_Destroy(_OldPrivilegeCheck);
	return Check_Create(_PrivilegeMgr, _UserId, _Privilege, _TargetedUsersAccountIds);
}
K_PrivilegeCheck Check_DestroyAndCreate(K_PrivilegeCheck _OldPrivilegeCheck, CPrivilegeMgr _PrivilegeMgr, Ident _UserId, CPrivilegeMgr::EPrivilege _Privilege) {
	Check_Destroy(_OldPrivilegeCheck);
	return Check_Create(_PrivilegeMgr, _UserId, _Privilege);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Update an ongoing privilege check
K_PrivilegeCheck Check_Update(K_PrivilegeCheck _PrivilegeCheck) {
	if (Check_IsComplete(_PrivilegeCheck)) return _PrivilegeCheck;

	declare K_PrivilegeCheck PrivilegeCheck = _PrivilegeCheck;

	if (PrivilegeCheck.Status == C_Status_Pending) {
		declare Boolean[CPrivilegeMgr::EPrivilege] LibCommonPrivileges_FakePrivileges for System = [];
		if (LibCommonPrivileges_FakePrivileges.existskey(PrivilegeCheck.Privilege)) {
			if (LibCommonPrivileges_FakePrivileges[PrivilegeCheck.Privilege] == True) {
				PrivilegeCheck.Status = C_Status_HasPrivilege;
			} else {
				PrivilegeCheck.Status = C_Status_MissPrivilege;
			}
			Cache_SetPrivilege(PrivilegeCheck.Privilege, PrivilegeCheck.Status == C_Status_HasPrivilege);
		} else {
			declare CTaskResult Task;
			if (PrivilegeCheck.TargetedUsersAccountIds.count > 0) {
				Task = PrivilegeCheck.PrivilegeMgr.CheckTargetedPrivilege(PrivilegeCheck.UserId, PrivilegeCheck.Privilege, PrivilegeCheck.TargetedUsersAccountIds);
			} else {
				Task = PrivilegeCheck.PrivilegeMgr.CheckPrivilege(PrivilegeCheck.UserId, PrivilegeCheck.Privilege);
			}
			if (Task != Null) {
				PrivilegeCheck.TaskId = Task.Id;
				PrivilegeCheck.Status = C_Status_Ongoing;
			} else {
				PrivilegeCheck.Status = C_Status_Error;
			}
		}
	}
	// Don't use `else if` here so that if the task is completed immediately after its creation
	// we don't wait the next frame to process it
	if (PrivilegeCheck.Status == C_Status_Ongoing) {
		if (PrivilegeCheck.PrivilegeMgr.TaskResults.existskey(PrivilegeCheck.TaskId)) {
			declare CTaskResult Task = PrivilegeCheck.PrivilegeMgr.TaskResults[PrivilegeCheck.TaskId];
			if (!Task.IsProcessing) {
				if (Task.HasSucceeded) {
					PrivilegeCheck.Status = C_Status_HasPrivilege;
				} else {
					PrivilegeCheck.Status = C_Status_MissPrivilege;
				}
				Cache_SetPrivilege(PrivilegeCheck.Privilege, PrivilegeCheck.Status == C_Status_HasPrivilege);
				PrivilegeCheck.PrivilegeMgr.TaskResult_Release(Task.Id);
				PrivilegeCheck.TaskId = NullId;
			}
		} else {
			PrivilegeCheck.Status = C_Status_Error;
		}
	}

	return PrivilegeCheck;
}
K_PrivilegesCheck Check_Update(K_PrivilegesCheck _PrivilegesCheck) {
	if (Check_IsComplete(_PrivilegesCheck)) return _PrivilegesCheck;

	declare K_PrivilegesCheck PrivilegesCheck = _PrivilegesCheck;
	if (PrivilegesCheck.CheckKey < PrivilegesCheck.Checks.count) {
		PrivilegesCheck.Checks[PrivilegesCheck.CheckKey] = Check_Update(PrivilegesCheck.Checks[PrivilegesCheck.CheckKey]);
		if (Check_IsComplete(PrivilegesCheck.Checks[PrivilegesCheck.CheckKey])) {
			if (Check_HasPrivilege(PrivilegesCheck.Checks[PrivilegesCheck.CheckKey])) {
				PrivilegesCheck.CheckKey += 1;
				if (PrivilegesCheck.CheckKey >= PrivilegesCheck.Checks.count) {
					PrivilegesCheck.Status = C_Status_HasPrivilege;
				}
			} else {
				PrivilegesCheck.Status = PrivilegesCheck.Checks[PrivilegesCheck.CheckKey].Status;
			}
		} else {
			PrivilegesCheck.Status = C_Status_Ongoing;
		}
	} else {
		PrivilegesCheck.Status = C_Status_Error;
	}

	if (Check_IsComplete(PrivilegesCheck)) {
		for (I, 0, PrivilegesCheck.Checks.count - 1) {
			PrivilegesCheck.Checks[I] = Check_Destroy(PrivilegesCheck.Checks[I]);
		}
	}

	return PrivilegesCheck;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the privilege being checked
CPrivilegeMgr::EPrivilege Check_GetPrivilege(K_PrivilegeCheck _PrivilegeCheck) {
	return _PrivilegeCheck.Privilege;
}
CPrivilegeMgr::EPrivilege[] Check_GetPrivileges(K_PrivilegesCheck _PrivilegesCheck) {
	declare CPrivilegeMgr::EPrivilege[] Privileges;

	foreach (Check in _PrivilegesCheck.Checks) {
		if (!Privileges.exists(Check.Privilege)) {
			Privileges.add(Check.Privilege);
		}
	}

	return Privileges;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Toggle a fake privilege between on / off / default state
Void ToggleFakePrivilege(CPrivilegeMgr::EPrivilege _Privilege) {
	declare Boolean[CPrivilegeMgr::EPrivilege] LibCommonPrivileges_FakePrivileges for System = [];
	if (LibCommonPrivileges_FakePrivileges.existskey(_Privilege)) {
		if (LibCommonPrivileges_FakePrivileges[_Privilege] == True) {
			LibCommonPrivileges_FakePrivileges[_Privilege] = False;
		} else {
			LibCommonPrivileges_FakePrivileges.removekey(_Privilege);
		}
	} else {
		LibCommonPrivileges_FakePrivileges[_Privilege] = True;
	}
	log("[DEBUG] Fake privileges : "^LibCommonPrivileges_FakePrivileges); //< Do not remove this log
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Toggle all fake privileges between on / off / default state
Void ToggleAllFakePrivileges() {
	declare Boolean[CPrivilegeMgr::EPrivilege] LibCommonPrivileges_FakePrivileges for System = [];
	if (LibCommonPrivileges_FakePrivileges.count < C_AllPrivileges.count) {
		foreach (Privilege in C_AllPrivileges) {
			LibCommonPrivileges_FakePrivileges[Privilege] = True;
		}
	} else if (LibCommonPrivileges_FakePrivileges[C_AllPrivileges[0]] == True) {
		foreach (Privilege in C_AllPrivileges) {
			LibCommonPrivileges_FakePrivileges[Privilege] = False;
		}
	} else {
		LibCommonPrivileges_FakePrivileges = [];
	}
	log("[DEBUG] Fake privileges : "^LibCommonPrivileges_FakePrivileges); //< Do not remove this log
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Toggle fake privileges on key presses
Void ToggleFakePrivilegesOnKeyPress(Text _KeyName) {
	switch (_KeyName) {
		case "1": ToggleFakePrivilege(CPrivilegeMgr::EPrivilege::PlayMultiplayerAsync);
		case "2": ToggleFakePrivilege(CPrivilegeMgr::EPrivilege::PlayMultiplayerAsyncWithUGC);
		case "3": ToggleFakePrivilege(CPrivilegeMgr::EPrivilege::PlayMultiplayerMode);
		case "4": ToggleFakePrivilege(CPrivilegeMgr::EPrivilege::PlayMultiplayerModeWithUGC);
		case "5": ToggleFakePrivilege(CPrivilegeMgr::EPrivilege::PlayMultiplayerSession);
		case "6": ToggleFakePrivilege(CPrivilegeMgr::EPrivilege::PlayMultiplayerSessionWithUGC);
		case "7": ToggleFakePrivilege(CPrivilegeMgr::EPrivilege::UseUserCreatedContent);
		case "8": ToggleFakePrivilege(CPrivilegeMgr::EPrivilege::UseUserCreatedContentRequired);
		case "9": ToggleFakePrivilege(CPrivilegeMgr::EPrivilege::ViewUserGameHistory);
		case "0": ToggleFakePrivilege(CPrivilegeMgr::EPrivilege::ViewOnlinePresence);
		case "Minus": ToggleFakePrivilege(CPrivilegeMgr::EPrivilege::CrossPlay); //< °)] key on azerty keyboard
		case "Grave": ToggleAllFakePrivileges(); //< ² key on azerty keyboard
	}
}