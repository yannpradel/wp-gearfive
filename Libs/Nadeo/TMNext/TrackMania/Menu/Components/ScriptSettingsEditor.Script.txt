/** 
 *	Component: ScriptSettingsEditor
 *	Only supports integer and boolean settings for now
 */
#Const Version		"2023-06-12"
#Const ScriptName	"Libs/Nadeo/TMNext/TrackMania/Menu/Components/ScriptSettingsEditor.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/MenuLibs/Common/Components/Grid.Script.txt" as Grid
#Include "Libs/Nadeo/MenuLibs/Common/FontManager.Script.txt" as FontManager
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/Helpers.Script.txt" as MLHelpers
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/ManiaView2.Script.txt" as MV
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/MenuSounds.Script.txt" as MenuSounds
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/Navigation.Script.txt" as Navigation
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/Scroll.Script.txt" as Scroll
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/Transition.Script.txt" as Transition
#Include "Libs/Nadeo/TMNext/TrackMania/ColorPalette.Script.txt" as ColorPalette
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Components/Checkbox.Script.txt" as Checkbox
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Components/ExpendableButton.Script.txt" as ExpendableButton
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Components/PopUpBackground2.Script.txt" as PopUpBackground
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Components/TextField.Script.txt" as TextField
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Constants.Script.txt" as Const
#Include "Libs/Nadeo/TMNext/TrackMania/Structures/ClubStruct.Script.txt" as ClubStruct

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_Name "component-scriptsettingseditor" //< Component name
#Const P "ComponentScriptSettingsEditor_" //< Prefix used to differentiate functions/variables in the script
#Const C_NavGroupName "navgroup-script-settings-editor"

#Const C_Column_Label 0
#Const C_Column_Value 1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Public
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the component
 *
 *	@return														The component id
 */
Text Component() {
	//L16N [ScriptSettingsEditor] Title of the page to update the settings of the script
	declare Text Text_Title = _("Mode settings");
	//L16N [ScriptSettingsEditor] Reset settings to default
	declare Text Text_Reset = _("Reset");
	//L16N [ScriptSettingsEditor] Apply settings
	declare Text Text_Apply = _("Apply");

	/* Scroll view commons */
	declare Vec2 Size_Header = <0., 0.>;
	declare Vec2 Size_Footer = <0., 0.>;

	/* Settings scroll view */
	declare Integer SettingsColumnsNb = 1;
	declare Integer SettingsRowsNb = 6;
	declare Integer SettingsPerPage = SettingsColumnsNb * SettingsRowsNb;
	declare Vec2 Size_SettingScrollWindow = <250., 60.>;
	declare Vec2 Size_SettingMargin = <3., 5.>;
	declare Vec2 Size_Setting = Scroll::GetElementSize(Size_SettingScrollWindow, Size_SettingMargin, SettingsColumnsNb, SettingsRowsNb);
	declare Integer SettingsElementsNb = Scroll::GetRequiredElementsNb(Size_SettingScrollWindow, Size_Setting, Size_SettingMargin, SettingsColumnsNb);

	declare Grid::K_GridConfig GridConfig_Horizontal = Grid::Create(Size_Setting.X, Size_SettingMargin.X, Size_SettingMargin.Y, Grid::C_Direction_Right);
	GridConfig_Horizontal = Grid::AddColumn(GridConfig_Horizontal, C_Column_Label, 0.83, Grid::C_Align_Right);
	GridConfig_Horizontal = Grid::AddColumn(GridConfig_Horizontal, C_Column_Value, 0.17, Grid::C_Align_Left);
	declare Grid::K_Grid Grid_Horizontal = Grid::Compile(GridConfig_Horizontal);

	declare Text ML_SettingCards = "";
	for (I, 1, SettingsElementsNb) {
		ML_SettingCards ^= """
			<frame id="{{{P}}}frame-setting-{{{I}}}" class="{{{Scroll::C_Class_Element}}}" hidden="1">
				<quad size="{{{Size_Setting.X}}} {{{Size_Setting.Y}}}" opacity="0" scriptevents="1" class="{{{Scroll::C_Class_ActivationZone}}}" z-index="5"/>
				<label id="{{{P}}}label-setting" size="{{{Grid_Horizontal.Size[C_Column_Label]*0.6}}} {{{Size_Setting.Y*2.}}}" pos="{{{Size_Setting.X/2. - Size_SettingMargin.Y/2}}} {{{-Size_Setting.Y/2.}}}" halign="right" class="{{{P}}}text-semibold" textsize="2.5" autonewline="1" maxline="2" z-index="1"/>
				<frameinstance 
					id="{{{P}}}checkbox-setting" pos="{{{Size_Setting.X/2. + Size_SettingMargin.Y/2 + Grid_Horizontal.Size[C_Column_Value]/2}}} {{{-Size_Setting.Y/2.}}}"
					modelid="{{{Checkbox::C_Name}}}"
					data-opacityunfocus="0.5"
					data-iconchecked="{{{Const::C_ImageUrl_Icon_Checkbox_Active_Square}}}"
					data-iconunchecked="{{{Const::C_ImageUrl_Icon_Checkbox_Inactive_Square}}}"
					data-iconcolor="{{{ColorPalette::C_Color_White}}}"
					data-iconsize="10 10"
					data-textitalicslope=".2"
					data-textfont="{{{FontManager::C_GameFontExtraBold}}}"
					data-halign="center" data-valign="center"
					hidden="1"
				/>
				<frameinstance 
					id="{{{P}}}textfield-setting" pos="{{{Size_Setting.X/2. + Size_SettingMargin.Y/2}}} {{{-Size_Setting.Y/2.}}}"
					modelid="{{{TextField::C_Name}}}"
					data-size="{{{Size_Setting.Y*98/14.}}} {{{Size_Setting.Y}}}"
					data-bgopacityunfocus="0.4"
					data-bgcolorfocus="{{{ColorPalette::C_Color_GreenFour}}}"
					data-bgcolorunfocus="{{{ColorPalette::C_Color_GreenFour}}}"
					data-contourcolorfocus="{{{ColorPalette::C_Color_GreenOne}}}"
					data-contouropacityunfocus=".0"
					data-contouropacityfocus="1."
					data-textsize="2."
					data-textcolorunfocus="{{{ColorPalette::C_Color_GreenOne}}}"
					data-halign="left" data-valign="center"
					hidden="1"
				/>
			</frame>
		""";
	}

	return MV::Component(
C_Name,
"""
<stylesheet>
	<style class="{{{P}}}text-semibold" halign="center" valign="center2" textfont="{{{FontManager::C_GameFontSemiBold}}}" textprefix="$i$t" textcolor="FFFFFF"/>
	<style class="{{{P}}}text-extrabold" halign="center" valign="center2" textfont="{{{FontManager::C_GameFontExtraBold}}}" textprefix="$i$t" textcolor="FFFFFF"/>
</stylesheet>

<frame id="{{{P}}}frame-global" hidden="1">
	<frameinstance id="{{{P}}}frame-popup-background" modelid="{{{PopUpBackground::C_Name}}}" z-index="-1"/>
	<label id="{{{P}}}label-title" pos="{{{MLHelpers::Skew(-126.5, 61.5, 10.)}}}" size="150 10" class="{{{P}}}text-extrabold" text="{{{Text_Title}}}" textsize="13" halign="left" z-index="1"/>

	<frame id="{{{P}}}frame-content">
		<frameinstance modelid="{{{Scroll::C_Name}}}" data-scroll-parent="{{{P}}}frame-scroll-settings" z-index="1" />
		<frame
			id="{{{P}}}frame-scroll-settings" pos="{{{Size_SettingScrollWindow.X * -0.5}}} 20.75"
			class="{{{Scroll::C_Class_Window}}} {{{Navigation::C_Class}}}"
			data-elements-per-line="{{{SettingsColumnsNb}}}"
			data-elements-per-page="{{{SettingsPerPage}}}"
			data-element-size="{{{Size_Setting.X}}} {{{Size_Setting.Y}}}"
			data-margin-size="{{{Size_SettingMargin.X}}} {{{Size_SettingMargin.Y}}}"
			data-window-size="{{{Size_SettingScrollWindow.X}}} {{{Size_SettingScrollWindow.Y}}}"
			data-header-height="{{{Size_Header.Y}}}"
			data-footer-height="{{{Size_Footer.Y}}}"
			data-scroll-indicator-x-offset="-5"
			data-scroll-indicator-y-offset="-15."
			data-scroll-indicator-image="{{{Const::C_ImageUrl_Icon_Arrow_Bottom_Oblique}}}"
			data-scroll-indicator-colorize="FFFFFF"
			data-scroll-indicator-size="12"
			data-skew="-10."
			data-skew-valign="{{{Scroll::C_SkewVAlign_Center}}}"
			data-nav-inputs="down"
			data-nav-targets="{{{P}}}button-apply"
			data-nav-group="{{{C_NavGroupName}}}"
		>
			<quad z-index="-1" scriptevents="1" class="{{{Scroll::C_Class_ScrollEvent}}}" />
			{{{ML_SettingCards}}}
		</frame>
	</frame>

	<frameinstance
		id="{{{P}}}button-back" pos="{{{MLHelpers::Skew(-125.5, -67., 10.)}}}" z-index="2"
		modelid="{{{ExpendableButton::C_Name}}}"
		class="{{{Navigation::C_Class}}}"
		data-styles="{{{ExpendableButton::C_Style_SizeExpendable}}} {{{ExpendableButton::C_Style_ButtonSecondary}}} {{{ExpendableButton::C_Style_AlignCenter}}} {{{ExpendableButton::C_Style_PageBack}}}"
		data-nav-inputs="select;cancel;up;right;"
		data-nav-targets="_;_;{{{P}}}frame-scroll-settings;{{{P}}}button-reset"
		data-nav-group="{{{C_NavGroupName}}}"
		data-nav-zone="{{{ExpendableButton::C_NavZone}}}"
	/>

	<frameinstance
		id="{{{P}}}button-reset" pos="{{{MLHelpers::Skew(0., -67., 10.)}}}" z-index="2"
		modelid="{{{ExpendableButton::C_Name}}}"
		class="{{{Navigation::C_Class}}}"
		data-text="{{{Text_Reset}}}"
		data-styles="{{{ExpendableButton::C_Style_SizeExpendable}}} {{{ExpendableButton::C_Style_AlignCenter}}} {{{ExpendableButton::C_Style_ButtonSecondary}}}"
		data-nav-inputs="select;cancel;up;left;right"
		data-nav-targets="_;_;{{{P}}}frame-scroll-settings;{{{P}}}button-back;{{{P}}}button-apply"
		data-nav-group="{{{C_NavGroupName}}}"
		data-nav-zone="{{{ExpendableButton::C_NavZone}}}"
	/>

	<frameinstance
		id="{{{P}}}button-apply" pos="{{{MLHelpers::Skew(127., -67., 10.)}}}" z-index="2"
		modelid="{{{ExpendableButton::C_Name}}}"
		class="{{{Navigation::C_Class}}}"
		data-text="{{{Text_Apply}}}"
		data-styles="{{{ExpendableButton::C_Style_SizeExpendable}}} {{{ExpendableButton::C_Style_AlignCenter}}} {{{ExpendableButton::C_Style_ButtonSecondary}}}"
		data-halign="right"
		data-nav-inputs="select;cancel;up;left;"
		data-nav-targets="_;_;{{{P}}}frame-scroll-settings;{{{P}}}button-reset;"
		data-nav-group="{{{C_NavGroupName}}}"
		data-nav-zone="{{{ExpendableButton::C_NavZone}}}"
	/>
</frame>
""",
"""
#Include "TextLib" as {{{P}}}TL
#Include "ColorLib" as {{{P}}}CL
#Include "Libs/Nadeo/MenuLibs/Common/Components/Tools.Script.txt" as {{{P}}}Tools

#Const {{{P}}}C_Label_OpacityUnfocus 0.6

#Const {{{P}}}C_ModeNames {{{dump(Const::C_ModeNames)}}}
#Const {{{P}}}C_ModeNames_ScriptNames {{{dump(Const::C_ModeNames_ScriptNames)}}}

#Const {{{P}}}C_SettingType_Integer "integer"
#Const {{{P}}}C_SettingType_Boolean "boolean"
#Const {{{P}}}C_SettingType_Text "text"

#Const {{{P}}}C_SettingDesciptionList [
	// Common
	"S_TimeLimit" => _("Time limit"),
	"S_WarmUpNb" => _("Number of warm up"),
	"S_WarmUpDuration" => _("Duration of one warm up"),
	"S_WarmUpTimeout" => _("Warm up timeout"),
	"S_FinishTimeout" => _("Finish timeout"),
	"S_RoundsPerMap" => _("Number of rounds per track"),
	"S_MapsPerMatch" => _("Number of tracks per match"),
	"S_UseTieBreak" => _("Use tie-break"),
	// TimeAttack
	//L16N Setting to set the number of laps in a race
	"S_ForceLapsNb" => _("Forced laps number"),
	// Rounds
	"S_PointsLimit" => _("Points limit"),
	// Laps
	//L16N Enable races with an infinite number of laps
	"S_InfiniteLaps" => _("Infinite laps"),
	"S_DisableGiveUp" => _("Disable give up"),
	// Knockout
	"S_ChatTime" => _("Chat time"),
	// Cup
	"S_NbOfWinners" => _("Number of winners"),
	// Teams
	"S_MaxPointsPerRound" => _("Max points :"),
	"S_PointsGap" => _("Points gap :"),
	"S_UseCustomPointsRepartition" => _("Use a custom points repartition :"),
	"S_CumulatePoints" => _("Cumulate team points :"),
	"S_UseAlternateRules" => _("Use alternate rules :"),
	"S_PointsRepartition" => _("Points repartition"),
	//L16N [Knockout] Setting for the Knockout mode to set different elimination thresholds and corresponds to a number of players above which one more player will be eliminated. By default there is one player eliminated. For example with "4,16,16,32", there will be 1 eliminated player from 1 to 4 players remaining, 3 eliminated players from 5 to 16 players remaining (+2 because 16 is there twice), 4 eliminated players from 17 to 32 players remaining, 5 eliminated players from 33 players remaining and above. 
	"S_EliminatedPlayersNbRanks" => _("Elimination thresholds (+1 eliminated player per threshold)"),
	"S_RoundsWithoutElimination" => _("Rounds without elimination"),
	//L16N Enable the notifications displayed in the top left corner of the screen announcing when a player joins or leaves the server. eg: "PlayerA joined the game" or "PlayerB left the game"
	"S_EnableJoinLeaveNotifications" => _("Enable join and leave notifications")
]

#Const {{{P}}}C_DefaultScriptSettings	[
	{{{Const::C_ModeIndex_TimeAttack}}} => [
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_TimeLimit",
			Value = "300",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpNb",
			Value = "0",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpDuration",
			Value = "0",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpTimeout",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_ForceLapsNb",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_EnableJoinLeaveNotifications",
			Value = "true",
			Type = "boolean"
		}
	],
	{{{Const::C_ModeIndex_Rounds}}} => [
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_PointsRepartition",
			Value = "",
			Type = "text"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_PointsLimit",
			Value = "50",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_FinishTimeout",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_RoundsPerMap",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_MapsPerMatch",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_UseTieBreak",
			Value = "true",
			Type = "boolean"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpNb",
			Value = "0",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpDuration",
			Value = "0",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpTimeout",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_EnableJoinLeaveNotifications",
			Value = "true",
			Type = "boolean"
		}
	],
	{{{Const::C_ModeIndex_Laps}}} => [
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_TimeLimit",
			Value = "0",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_ForceLapsNb",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_InfiniteLaps",
			Value = "false",
			Type = "boolean"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_FinishTimeout",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_DisableGiveUp",
			Value = "false",
			Type = "boolean"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpNb",
			Value = "0",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpDuration",
			Value = "0",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpTimeout",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_EnableJoinLeaveNotifications",
			Value = "true",
			Type = "boolean"
		}
	],
	{{{Const::C_ModeIndex_Knockout}}} => [
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_PointsRepartition",
			Value = "",
			Type = "text"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_FinishTimeout",
			Value = "5",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_RoundsPerMap",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpNb",
			Value = "0",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpDuration",
			Value = "0",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpTimeout",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_ChatTime",
			Value = "6",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_EliminatedPlayersNbRanks",
			Value = "4,16,16",
			Type = "text"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_RoundsWithoutElimination",
			Value = "1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_EnableJoinLeaveNotifications",
			Value = "false",
			Type = "boolean"
		}
	],
	{{{Const::C_ModeIndex_Cup}}} => [
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_PointsRepartition",
			Value = "",
			Type = "text"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_PointsLimit",
			Value = "100",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_FinishTimeout",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_RoundsPerMap",
			Value = "5",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_NbOfWinners",
			Value = "3",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpNb",
			Value = "0",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpDuration",
			Value = "0",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpTimeout",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_EnableJoinLeaveNotifications",
			Value = "true",
			Type = "boolean"
		}
	],
	{{{Const::C_ModeIndex_Teams}}} => [
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_PointsLimit",
			Value = "100",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_FinishTimeout",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_MaxPointsPerRound",
			Value = "6",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_PointsGap",
			Value = "1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_UseCustomPointsRepartition",
			Value = "false",
			Type = "boolean"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_PointsRepartition",
			Value = "",
			Type = "text"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_CumulatePoints",
			Value = "false",
			Type = "boolean"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_RoundsPerMap",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_MapsPerMatch",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpNb",
			Value = "0",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpDuration",
			Value = "0",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_WarmUpTimeout",
			Value = "-1",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_UseAlternateRules",
			Value = "true",
			Type = "boolean"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_EnableJoinLeaveNotifications",
			Value = "true",
			Type = "boolean"
		}
	],
	{{{Const::C_ModeIndex_RoyalTimeAttack}}} => [
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_TimeLimit",
			Value = "150",
			Type = "integer"
		},
		{{{ClubStruct::P}}}K_ScriptSetting {
			Key = "S_EnableJoinLeaveNotifications",
			Value = "true",
			Type = "boolean"
		}
	]
]

#Const {{{P}}}C_Event_Confirm 0
#Const {{{P}}}C_Event_Cancel 1

#Const {{{P}}}C_DiffMethod_Default 0
#Const {{{P}}}C_DiffMethod_Previous 1

#Struct {{{P}}}K_Event {
	Integer	Type;
	{{{ClubStruct::P}}}K_ScriptSetting[] ScriptSettings;
	{{{ClubStruct::P}}}K_ScriptSetting[] ScriptSettingsDiff;
	Text ScriptSettingsXML;
	Text ScriptSettingsDiffXML;
}

#Struct {{{P}}}K_PageState {
	Integer ModeIndex;
	Integer DiffMethodId;
	{{{ClubStruct::P}}}K_ScriptSetting[] ScriptSettings;
	CMlFrame[Integer] TextFieldList; //< Key is the key in ScriptSettings array
	CMlFrame[Integer] CheckboxList; //< Key is the key in ScriptSettings array
}
""",
"""
declare {{{P}}}K_Event[] {{{P}}}PendingEvents;
declare CMlFrame {{{P}}}G_Frame_Global;
declare Integer {{{P}}}G_CurrentModeIndex;
declare Integer {{{P}}}G_CurrentDiffMethodId;
declare {{{ClubStruct::P}}}K_ScriptSetting[] {{{P}}}G_PreviousScriptSettings;

{{{P}}}K_PageState {{{P}}}ShowSetting({{{P}}}K_PageState _State, CMlFrame _Frame_Element, Integer _SettingKey) {
	declare {{{P}}}K_PageState State = _State;
	declare Setting = State.ScriptSettings[_SettingKey];

	declare CMlLabel Label_Setting = (_Frame_Element.GetFirstChild("{{{P}}}label-setting") as CMlLabel);
	declare CMlFrame Checkbox_Setting = (_Frame_Element.GetFirstChild("{{{P}}}checkbox-setting") as CMlFrame);
	declare CMlFrame TextField_Setting = (_Frame_Element.GetFirstChild("{{{P}}}textfield-setting") as CMlFrame);

	Label_Setting.Opacity = {{{P}}}C_Label_OpacityUnfocus;
	Label_Setting.SetText({{{P}}}C_SettingDesciptionList.get(Setting.Key, Setting.Key));
	{{{P}}}Tools::FitLabelValue(Label_Setting, 2.5, 1., .5);

	TextField_Setting.Visible = Setting.Type != {{{P}}}C_SettingType_Boolean;
	Checkbox_Setting.Visible = Setting.Type == {{{P}}}C_SettingType_Boolean;

	if (TextField_Setting.Visible) {
		State.TextFieldList[_SettingKey] = TextField_Setting;
		switch (Setting.Type) {
			case {{{P}}}C_SettingType_Integer: {{{TextField::P}}}SetValueType(This, TextField_Setting, CMlEntry::ValueType::Ml_Integer);
			case {{{P}}}C_SettingType_Text: {{{TextField::P}}}SetValueType(This, TextField_Setting, CMlEntry::ValueType::Ml_String);
			default: {{{TextField::P}}}SetValueType(This, TextField_Setting, CMlEntry::ValueType::Ml_Unknown);
		}
		{{{TextField::P}}}SetValue(This, TextField_Setting, Setting.Value); //< SetValueType erase the value, so do that after
	} else {
		State.CheckboxList[_SettingKey] = Checkbox_Setting;
		{{{Checkbox::P}}}Check(This, Checkbox_Setting, {{{P}}}TL::ToLowerCase(Setting.Value) == "true");
	}

	_Frame_Element.Show();
	return State;
}

Void {{{P}}}HideSetting(CMlFrame _Frame_Element) {
	_Frame_Element.Hide();
}

Void {{{P}}}FocusSetting(CMlFrame _Frame_Setting, Boolean _Focused) {
	if (_Frame_Setting == Null) return;

	declare CMlLabel Label_Setting = (_Frame_Setting.GetFirstChild("{{{P}}}label-setting") as CMlLabel);
	declare CMlFrame Checkbox_Setting = (_Frame_Setting.GetFirstChild("{{{P}}}checkbox-setting") as CMlFrame);
	declare CMlFrame TextField_Setting = (_Frame_Setting.GetFirstChild("{{{P}}}textfield-setting") as CMlFrame);

	AnimMgr.Flush(Label_Setting);
	AnimMgr.Add(Label_Setting, "<anim opacity=\"1.\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	if (TextField_Setting.Visible) {{{TextField::P}}}Focus(This, TextField_Setting);
	if (Checkbox_Setting.Visible) {{{Checkbox::P}}}Focus(This, Checkbox_Setting);
}

Void {{{P}}}UnfocusSetting(CMlFrame _Frame_Setting) {
	if (_Frame_Setting == Null) return;

	declare CMlLabel Label_Setting = (_Frame_Setting.GetFirstChild("{{{P}}}label-setting") as CMlLabel);
	declare CMlFrame Checkbox_Setting = (_Frame_Setting.GetFirstChild("{{{P}}}checkbox-setting") as CMlFrame);
	declare CMlFrame TextField_Setting = (_Frame_Setting.GetFirstChild("{{{P}}}textfield-setting") as CMlFrame);

	AnimMgr.Flush(Label_Setting);
	AnimMgr.Add(Label_Setting, "<anim opacity=\""^{{{P}}}C_Label_OpacityUnfocus^"\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	{{{TextField::P}}}Unfocus(This, TextField_Setting);
	{{{Checkbox::P}}}Unfocus(This, Checkbox_Setting);
}

Void {{{P}}}Focus(CMlControl _From, CMlControl _To) {
	if ({{{Transition::P}}}IsInTransition(This)) return;
	
	if (_From != Null) {
		{{{Navigation::P}}}Unfocus(This, _From);
		if ({{{ExpendableButton::P}}}IsButton(_From)) {
			{{{ExpendableButton::P}}}Unfocus(This, (_From as CMlFrame));
		} else if ({{{Scroll::P}}}IsScroll(_From)) {
			{{{Scroll::P}}}Unfocus(This, (_From as CMlFrame));
		}
	}
	
	if (_To != Null) {
		{{{Navigation::P}}}Focus(This, _To);
		if ({{{ExpendableButton::P}}}IsButton(_To)) {
			{{{ExpendableButton::P}}}Focus(This, (_To as CMlFrame));
		} else if ({{{Scroll::P}}}IsScroll(_To)) {
			{{{Scroll::P}}}Focus(This, (_To as CMlFrame));
		}
	}
}

Void {{{P}}}SetModeIndex(Integer _ModeIndex) {
	{{{P}}}G_CurrentModeIndex = _ModeIndex;
}

Void {{{P}}}SetDiffMethodId(Integer _DiffIdMethod) {
	if (_DiffIdMethod == {{{P}}}C_DiffMethod_Default || _DiffIdMethod == {{{P}}}C_DiffMethod_Previous) {
		{{{P}}}G_CurrentDiffMethodId = _DiffIdMethod;
	} else {
		{{{P}}}G_CurrentDiffMethodId = {{{P}}}C_DiffMethod_Default;
		assert((_DiffIdMethod == {{{P}}}C_DiffMethod_Default || _DiffIdMethod == {{{P}}}C_DiffMethod_Previous), "This differenciation method is not inlcuded in the component.");
	}
}

Void {{{P}}}Private_Display(Boolean _Visible) {
	{{{P}}}G_Frame_Global.Visible = _Visible;
	{{{Navigation::P}}}EnableGroup(This, "{{{C_NavGroupName}}}", _Visible);
	if (!_Visible) {
		{{{P}}}SetModeIndex({{{Const::C_ModeIndex_None}}});
		{{{P}}}G_PreviousScriptSettings = [];
		{{{P}}}G_Frame_Global.GetFirstChild("{{{P}}}frame-content").Hide();

		{{{P}}}PendingEvents.add({{{P}}}K_Event {
			Type = {{{P}}}C_Event_Cancel
		});
	} else {
		{{{P}}}Focus({{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroupName}}}"), {{{P}}}G_Frame_Global.GetFirstChild("{{{P}}}button-apply"));
	}
}

Void {{{P}}}Show(Integer _ModeIndex, {{{ClubStruct::P}}}K_ScriptSetting[] _PreviousScriptSettings) {
	{{{P}}}G_PreviousScriptSettings = _PreviousScriptSettings;
	{{{P}}}SetModeIndex(_ModeIndex);
	{{{P}}}Private_Display(True);
}

Void {{{P}}}Hide() {
	{{{P}}}Private_Display(False);
}

{{{P}}}K_PageState {{{P}}}ResetSettings({{{P}}}K_PageState _State, CMlFrame _Frame_ScrollSettings, {{{ClubStruct::P}}}K_ScriptSetting[] _PreviousScriptSettings) {
	declare {{{P}}}K_PageState State = _State;

	State.ScriptSettings = {{{P}}}C_DefaultScriptSettings[State.ModeIndex];
	if (_PreviousScriptSettings.count > 0) {
		foreach (Index => ScriptSetting in State.ScriptSettings) {
			foreach (PreviousScriptSetting in _PreviousScriptSettings) {
				if (ScriptSetting.Key == PreviousScriptSetting.Key) {
					State.ScriptSettings[Index] = PreviousScriptSetting;
					break;
				}
			}
		}
	}
	{{{Scroll::P}}}SetElementsTotal(This, _Frame_ScrollSettings, State.ScriptSettings.count);

	return State;
}
{{{P}}}K_PageState {{{P}}}ResetSettings({{{P}}}K_PageState _State, CMlFrame _Frame_ScrollSettings) {
	return {{{P}}}ResetSettings(_State, _Frame_ScrollSettings, []);
}

Text {{{P}}}ToXML({{{ClubStruct::P}}}K_ScriptSetting[] ScriptSettings)  {
	declare Text SettingsXML = "";

	SettingsXML = "<script_settings>";
	foreach (Setting in ScriptSettings) {
			SettingsXML ^= "<setting name=\""^Setting.Key^"\" value=\""^{{{P}}}TL::MLEncode(Setting.Value)^"\" type=\""^Setting.Type^"\"/>";
	}
	SettingsXML ^= "</script_settings>";

	return SettingsXML;
}


{{{P}}}K_PageState {{{P}}}Select({{{P}}}K_PageState _State, CMlControl _Control, CMlFrame _Frame_ScrollSettings) {
	if (_Control == Null || {{{Transition::P}}}IsInTransition(This)) return _State;

	declare {{{P}}}K_PageState State = _State;

	switch (_Control.ControlId) {
		case "{{{P}}}button-back": {{{P}}}Hide();
		case "{{{P}}}button-reset": State = {{{P}}}ResetSettings(State, _Frame_ScrollSettings);
		case "{{{P}}}button-apply": {
			declare {{{ClubStruct::P}}}K_ScriptSetting[] ScriptSettingsDiff;
			declare {{{ClubStruct::P}}}K_ScriptSetting[] ScriptSettingsDiffWith;

			switch (State.DiffMethodId) {
				case {{{P}}}C_DiffMethod_Default: {
					ScriptSettingsDiffWith = {{{P}}}C_DefaultScriptSettings[State.ModeIndex];
				}
				case {{{P}}}C_DiffMethod_Previous: {
					ScriptSettingsDiffWith = {{{P}}}G_PreviousScriptSettings;
				}
			}

			foreach (ScriptSetting in State.ScriptSettings) {
				foreach (DiffScriptSetting in ScriptSettingsDiffWith) {
					if (ScriptSetting.Key == DiffScriptSetting.Key) {
						if (ScriptSetting.Value != DiffScriptSetting.Value) {
							ScriptSettingsDiff.add(ScriptSetting);
						}
						break;
					}
				}
			}

			{{{P}}}PendingEvents.add({{{P}}}K_Event {
				Type = {{{P}}}C_Event_Confirm,
				ScriptSettings = State.ScriptSettings,
				ScriptSettingsDiff = ScriptSettingsDiff,
				ScriptSettingsXML = {{{P}}}ToXML(State.ScriptSettings),
				ScriptSettingsDiffXML = {{{P}}}ToXML(ScriptSettingsDiff)
			});
		}
	}

	return State;
}

***MainInit***
***
declare CMlFrame {{{P}}}Frame_PopUpBackground;
declare CMlFrame {{{P}}}Frame_ScrollSettings;
declare CMlFrame {{{P}}}Frame_Content;

declare {{{P}}}K_PageState {{{P}}}State;

// Verify mode constants
assert(
	{{{P}}}C_DefaultScriptSettings.count == {{{P}}}C_ModeNames.count &&
	{{{P}}}C_ModeNames_ScriptNames.count == {{{P}}}C_ModeNames.count &&
	{{{P}}}C_ModeNames.count == {{{Const::C_ModeIndex_Total}}},
	"You forgot to update one of the constant with a mode list (C_ModeNames, C_ModeNames_ScriptNames, C_DefaultScriptSettings or C_ModeIndex_Total)."
);
***

***MainStart***
***
{{{P}}}G_Frame_Global <=> (Page.GetFirstChild("{{{P}}}frame-global") as CMlFrame);
{{{P}}}Frame_PopUpBackground <=> ({{{P}}}G_Frame_Global.GetFirstChild("{{{P}}}frame-popup-background") as CMlFrame);
{{{P}}}Frame_ScrollSettings <=> ({{{P}}}G_Frame_Global.GetFirstChild("{{{P}}}frame-scroll-settings") as CMlFrame);
{{{P}}}Frame_Content <=> ({{{P}}}G_Frame_Global.GetFirstChild("{{{P}}}frame-content") as CMlFrame);

{{{P}}}G_CurrentDiffMethodId = {{{P}}}C_DiffMethod_Default;
{{{P}}}State.DiffMethodId = {{{P}}}G_CurrentDiffMethodId;

{{{P}}}G_CurrentModeIndex = {{{Const::C_ModeIndex_None}}};
{{{P}}}State.ModeIndex = {{{P}}}G_CurrentModeIndex;
***

***MainLoop***
***
if (PageIsVisible) {
	{{{P}}}PendingEvents = [];

	if ({{{P}}}State.ModeIndex != {{{P}}}G_CurrentModeIndex) {
		{{{P}}}State.ModeIndex = {{{P}}}G_CurrentModeIndex;
		if ({{{P}}}G_CurrentModeIndex != {{{Const::C_ModeIndex_None}}}) {
			assert({{{P}}}C_ModeNames.existskey({{{P}}}State.ModeIndex), "This mode is not supported by the component.");
			assert({{{P}}}C_DefaultScriptSettings.existskey({{{P}}}State.ModeIndex), "No default script settings for the mode '"^{{{P}}}C_ModeNames_ScriptNames.get({{{P}}}C_ModeNames[{{{P}}}State.ModeIndex], "")^"'.");

			{{{P}}}State = {{{P}}}ResetSettings({{{P}}}State, {{{P}}}Frame_ScrollSettings, {{{P}}}G_PreviousScriptSettings);
		}
	}

	if ({{{P}}}State.DiffMethodId != {{{P}}}G_CurrentDiffMethodId) {
			{{{P}}}State.DiffMethodId = {{{P}}}G_CurrentDiffMethodId;
	}

	foreach (Event in {{{Scroll::P}}}GetPendingEvents(This)) {
		if (Event.Scroll != Null && Event.Scroll.Id == {{{P}}}Frame_ScrollSettings.Id) {
			switch (Event.Type) {
				case {{{Scroll::P}}}C_EventType_Cancel: {{{P}}}Hide();
				case {{{Scroll::P}}}C_EventType_Select: {
					if (Event.To != Null) {
						declare CMlFrame Checkbox_Setting = (Event.To.GetFirstChild("{{{P}}}checkbox-setting") as CMlFrame);
						declare CMlFrame TextField_Setting = (Event.To.GetFirstChild("{{{P}}}textfield-setting") as CMlFrame);
					
						if (TextField_Setting.Visible && {{{TextField::P}}}IsTextField(TextField_Setting)) {
							{{{TextField::P}}}Select(This, TextField_Setting);
						} else if (Checkbox_Setting.Visible && {{{Checkbox::P}}}IsCheckbox(Checkbox_Setting) && {{{P}}}State.CheckboxList.exists(Checkbox_Setting)) {
							{{{P}}}State.ScriptSettings[{{{P}}}State.CheckboxList.keyof(Checkbox_Setting)].Value = {{{P}}}TL::ToLowerCase(""^{{{Checkbox::P}}}Toggle(This, Checkbox_Setting));
						}
					}
				}
				case {{{Scroll::P}}}C_EventType_Update: {
					{{{P}}}Frame_Content.Show();
					{{{P}}}State.TextFieldList = [];
					{{{P}}}State.CheckboxList = [];

					foreach (Key => Frame_Element in Event.ElementsVisible) {
						declare Integer SettingKey for Frame_Element;
						SettingKey = Key;
						if ({{{P}}}State.ScriptSettings.existskey(Key)) {
							{{{P}}}State = {{{P}}}ShowSetting({{{P}}}State, Frame_Element, Key);
						} else {
							{{{P}}}HideSetting(Frame_Element);
						}
					}
					foreach (Key => Frame_Element in Event.ElementsHidden) {
						declare Integer SettingKey for Frame_Element;
						SettingKey = -1;
						{{{P}}}HideSetting(Frame_Element);
					}

					{{{Navigation::P}}}Lock({{{P}}}Frame_ScrollSettings, Event.ElementsVisible.count <= 0);
				}
				case {{{Scroll::P}}}C_EventType_Focus: {
					if (Event.From != Null) {{{P}}}UnfocusSetting(Event.From);
					if (Event.To != Null && Event.IsMouse) {
						declare CMlControl CurrentFocus = {{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroupName}}}");
						if (CurrentFocus != {{{P}}}Frame_ScrollSettings) {
							{{{P}}}Focus(CurrentFocus, {{{P}}}Frame_ScrollSettings);
						}
					}
					if ({{{Scroll::P}}}IsFocused({{{P}}}Frame_ScrollSettings)) {
						declare Integer SettingKey for Event.To;
						{{{Navigation::P}}}EnableInputs({{{P}}}Frame_ScrollSettings, {{{Scroll::P}}}GetElementsTotal({{{P}}}Frame_ScrollSettings)-1 == SettingKey);
						{{{P}}}FocusSetting(Event.To, True);
					}
				}
			}
		}
	}

	if ({{{P}}}G_Frame_Global.Visible) {
		foreach (Event in {{{TextField::P}}}GetPendingEvents(This)) {
			switch (Event.Type) {
				case {{{TextField::P}}}C_EventType_Update: {
					if (Event.Control != Null && Event.Control.ControlId == "{{{P}}}textfield-setting") {
						if ({{{P}}}State.TextFieldList.exists(Event.Control as CMlFrame)) {
							{{{P}}}State.ScriptSettings[{{{P}}}State.TextFieldList.keyof(Event.Control as CMlFrame)].Value = Event.Value;
						}
					}
				}
			}
		}

		foreach (Event in {{{PopUpBackground::P}}}GetPendingEvents(This)) {
			if (Event.PopUpBackground != Null && Event.PopUpBackground.Id == {{{P}}}Frame_PopUpBackground.Id) {
				if (Event.Type == {{{PopUpBackground::P}}}C_EventType_Close) {
					{{{P}}}Hide();
				}
			}
		}

		foreach (Event in {{{Navigation::P}}}GetPendingEvents(This)) {
			switch (Event.Type) {
				case {{{Navigation::P}}}C_EventType_NavigateInput: {
					if ({{{Navigation::P}}}IsEventFromGroup(This, Event, "{{{C_NavGroupName}}}")) {
						switch (Event.Input) {
							case CMlScriptEvent::EMenuNavAction::Cancel: {{{P}}}Hide();
							case CMlScriptEvent::EMenuNavAction::Select: {{{P}}}State = {{{P}}}Select({{{P}}}State, Event.To, {{{P}}}Frame_ScrollSettings);
							default: {
								declare CMlControl To = Event.To;
								if (Event.To != Null) {
									declare CMlControl[CMlScriptEvent::EMenuNavAction] NavigationMemory for Event.To;
									NavigationMemory[{{{Navigation::P}}}InvertInput(Event.Input)] = Event.From;
								}
								if (Event.From != Null) {
									declare CMlControl[CMlScriptEvent::EMenuNavAction] NavigationMemory for Event.From;
									if (NavigationMemory.existskey(Event.Input) && NavigationMemory[Event.Input] != Null && !{{{Navigation::P}}}IsLocked(NavigationMemory[Event.Input])) {
										To = NavigationMemory[Event.Input];
									}
								}
								{{{P}}}Focus(Event.From, To);
							}
						}
					}
				}
				case {{{Navigation::P}}}C_EventType_NavigateMouse: {
					if ({{{Navigation::P}}}IsEventFromGroup(This, Event, "{{{C_NavGroupName}}}")) {
						switch (Event.Mouse) {
							case CMlScriptEvent::Type::MouseClick: {{{P}}}State = {{{P}}}Select({{{P}}}State, Event.To, {{{P}}}Frame_ScrollSettings);
							case CMlScriptEvent::Type::MouseOver: {{{P}}}Focus(Event.From, Event.To);
						}
					}
				}
			}
		}
	}
}
***
""",
[
	Checkbox::ComponentV2(),
	ClubStruct::Component(),
	ExpendableButton::ComponentV2(),
	MenuSounds::ComponentV2(),
	Navigation::ComponentV2(),
	PopUpBackground::ComponentV2(),
	Scroll::ComponentV2(),
	TextField::ComponentV2(),
	Transition::ComponentV2()
],
[]
	);
}