/** 
 *	Page: BucketItemUploads (Skins, Maps)
 */
#Const Version		"2023-05-22"
#Const ScriptName	"Libs/Nadeo/TMNext/TrackMania/Menu/Pages/BucketItemUploads.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Includes
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/CommonLibs/Common/EnvironmentInfo.Script.txt" as EnvironmentInfo
#Include "Libs/Nadeo/MenuLibs/Common/Components/Grid.Script.txt" as Grid
#Include "Libs/Nadeo/MenuLibs/Common/Components/Tools.Script.txt" as Tools
#Include "Libs/Nadeo/MenuLibs/Common/FontManager.Script.txt" as FontManager
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/Helpers.Script.txt" as MLHelpers
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/ManiaView2.Script.txt" as MV
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/ButtonIcon2.Script.txt" as ButtonIcon
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/ControlBlockList.Script.txt" as ControlBlockList
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/LoadingSpinner.Script.txt" as LoadingSpinner
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/MenuSounds.Script.txt" as MenuSounds
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/Navigation.Script.txt" as Navigation
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/PlayerName.Script.txt" as PlayerName
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/Scroll.Script.txt" as Scroll
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/Transition.Script.txt" as Transition
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Router_ML.Script.txt" as Router
#Include "Libs/Nadeo/TMNext/TrackMania/API/BrowserAPI.Script.txt" as BrowserAPI
#Include "Libs/Nadeo/TMNext/TrackMania/ColorPalette.Script.txt" as ColorPalette
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Components/Button.Script.txt" as Button
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Components/ExpendableButton.Script.txt" as ExpendableButton
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Components/PopUpBackground2.Script.txt" as PopUpBackground
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Components/TrackBrowser.Script.txt" as TrackBrowser
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Constants.Script.txt" as Const
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/RoutePaths.Script.txt" as RoutePaths
#Include "Libs/Nadeo/TMNext/TrackMania/Stores/ClubStore_ML.Script.txt" as ClubStore
#Include "Libs/Nadeo/TMNext/TrackMania/Stores/MapStore_ML.Script.txt" as MapStore
#Include "Libs/Nadeo/TMNext/TrackMania/Stores/UserStore_ML.Script.txt" as UserStore
#Include "Libs/Nadeo/TMNext/TrackMania/Structures/CampaignStruct.Script.txt" as CampaignStruct
#Include "Libs/Nadeo/TMNext/TrackMania/Structures/ClubStruct.Script.txt" as ClubStruct

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_Name "Page_BucketItemUploads"
#Const C_NavGroup_Default "navgroup-page-bucket-item-uploads-default"
#Const C_NavGroup_MouseOnly "navgroup-page-bucket-item-uploads-mouse-only"
#Const C_NavGroup_Global "navgroup-page-bucket-item-uploads-global"
#Const C_Class_ItemButton "class-item-button"
#Const C_Class_Arrow "class-arrow"

#Const C_Privileges [
	CPrivilegeMgr::EPrivilege::UseUserCreatedContentRequired
]

#Const C_Row_Upload 0
#Const C_Row_Apply 1
#Const C_Row_AddGarage 2
#Const C_Row_Download 3
#Const C_Row_Remove 4

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the page manialink
 *
 *	@return														The page manialink
 */
Text GetManialink() {
	declare Text Text_Retrieving = Const::C_Text_RetrievingDataPlaceholder;
	//L16N [MapUploads & SkinUploads] Text displayed while uploading a file.
	declare Text Text_Uploading = _("Uploading...");
	//L16N [MapUploads & SkinUploads] Text of the club button. %1 will be replaced by the name of the club. e.g. "Club Nadeo"
	declare Text Text_Club = _("Club $<%1$>");
	//L16N [MapUploads] Text displayed while removing the selected track from the activity.
	declare Text Text_RemovingTrack = _("Removing track...");
	//L16N [MapUploads] Text displayed while adding (or removing) the selected track of the favorites.
	declare Text Text_UpdatingFavoriteTrack = _("Updating track favorite status...");
	//L16N [MapUploads] Label of a button to upload a new track in a club activity.
	declare Text Text_UploadMap = _("Upload a track");
	//L16N [MapUploads] Information message displayed when there is no track uploaded in a club activity.
	declare Text Text_NoMaps = _("There is no tracks uploaded in this activity.");
	//L16N [MapUploads] %1 MUST STAY AT THE END OF THE STRING !!! %1 will be replaced by the name of the author of the track, e.g. "by PlayerA". If your langage do not permit to keep the %1 at the end of the string, do not translate "By" and just keep the text "%1" 
	declare Text Text_AuthorName = _("|NameOnTheRight|By %1");
	//L16N [SkinUploads] Label of a button to upload a new skin in a club.
	declare Text Text_UploadSkin = _("Upload a skin");
	//L16N [SkinUploads] Text displayed while removing the selected skin from the activity.
	declare Text Text_RemovingSkin = _("Removing skin...");
	//L16N [SkinUploads] Action to add a skin to the garage.
	declare Text Text_AddToGarage = _("Add to garage");
	//L16N [SkinUploads] Action to remove a skin from the garage.
	declare Text Text_RemoveFromGarage = _("Remove from garage");
	//L16N [SkinUploads] Action to use a skin.
	declare Text Text_UseSkin = _("Use skin");
	//L16N [SkinUploads] Action to unset a skin and restore to default region skin.
	declare Text Text_ResetSkin = _("Reset skin");
	//L16N [SkinUploads] Action to delete the skin from the activity.
	declare Text Text_DeleteSkin = _("Delete skin");
	//L16N [SkinUploads] Action to download the skin.
	declare Text Text_DownloadSkin = _("Download skin");
	//L16N [SkinUploads] Information message displayed when there is no skin uploaded in a club activity.
	declare Text Text_NoSkins = _("There is no skins uploaded in this activity.");
	//L16N [SkinUploads] Text displayed while applying selected skin.
	declare Text Text_ApplyingSkin = _("Painting your car...");
	//L16N [SkinUploads] Text displayed while adding the skin to the garage.
	declare Text Text_AddingToGarage = _("Adding skin to the garage...");
	//L16N [SkinUploads] Text displayed while removing the skin from the garage.
	declare Text Text_RemovingFromGarage = _("Removing skin from the garage...");

	/* Scroll view */
	declare Vec2 Size_ItemsScrollWindow = <255., 73.>;
	declare Integer ColumnsNb = 6;
	declare Integer RowsNb = 2;
	declare Integer ItemsPerPage = ColumnsNb * RowsNb;
	declare Vec2 Size_ItemMargin = <3., 3.>;
	declare Vec2 Size_Item = Scroll::GetElementSize(Size_ItemsScrollWindow, Size_ItemMargin, ColumnsNb, RowsNb);
	declare Integer ElementsNb = Scroll::GetRequiredElementsNb(Size_ItemsScrollWindow, Size_Item, Size_ItemMargin, ColumnsNb);

	declare Vec2 Size_ItemImage = MLHelpers::KeepRatioFromY(544., 412., Size_Item.Y);
	declare Vec2 Size_Item_Adjusted = <Size_ItemImage.X - MLHelpers::SkewX(Size_ItemImage.Y, 10.),	Size_ItemImage.Y>;
	declare Vec2 Pos_ItemNameOneLine = <Size_ItemImage.X * 0.06, Size_ItemImage.Y * -0.78>;
	declare Vec2 Pos_ItemNameTwoLines = <Size_ItemImage.X * 0.08, Size_ItemImage.Y * -0.73>;
	declare Vec2 Pos_ItemAuthor = <Size_ItemImage.X * 0.05, Size_ItemImage.Y * -0.9>;
	declare Vec2 Pos_ItemFocusOptions = <Size_ItemImage.X * 0.9, Size_ItemImage.Y * -0.12>;
	declare Vec2 Pos_DownloadButton = <-8., 0.>;
	declare Vec2 Pos_DeleteButton = <-16., 0.>;

	declare Text ML_ItemCards = "";
	for (I, 1, ElementsNb) {
		ML_ItemCards ^= """
			<frameinstance modelid="framemodel-item" class="{{{Scroll::C_Class_Element}}}" hidden="1"/>
		""";
	}

	// Automatic rearranging list of button depending on buttons visibility
	// To add a new button, simply add a new row in the grid and its frameinstance in the ML
	// After buttons visibility update, the grid needs to be updated !
	declare Real Margin = 0.7;
	declare Vec2 Size_SkinButtons = <80., 11.>;
	declare Grid::K_GridConfig GridConfig = Grid::Create(0., 0., 0., Grid::C_Direction_Bottom);
	GridConfig = Grid::AddRow(GridConfig, C_Row_Upload, Size_SkinButtons.Y, Grid::C_Align_Center);
	GridConfig = Grid::AddRow(GridConfig, C_Row_Apply, Size_SkinButtons.Y, Grid::C_Align_Center);
	GridConfig = Grid::AddRow(GridConfig, C_Row_AddGarage, Size_SkinButtons.Y, Grid::C_Align_Center);
	GridConfig = Grid::AddRow(GridConfig, C_Row_Download, Size_SkinButtons.Y, Grid::C_Align_Center);
	GridConfig = Grid::AddRow(GridConfig, C_Row_Remove, Size_SkinButtons.Y, Grid::C_Align_Center);
	GridConfig = Grid::SetSize(GridConfig, Size_SkinButtons.Y * (GridConfig.Columns.count + Margin));
	declare Text GridConfigJson = GridConfig.tojson();

	return MV::Create(
C_Name, 3,
"""
<stylesheet>
	<style class="quad-default" halign="center" valign="center"/>
	<style class="text-regular" halign="center" valign="center2" textfont="{{{FontManager::C_GameFontRegular}}}" textprefix="$i$t" textcolor="FFFFFF"/>
	<style class="text-semibold" halign="center" valign="center2" textfont="{{{FontManager::C_GameFontSemiBold}}}" textprefix="$i$t" textcolor="FFFFFF"/>
	<style class="text-extrabold" halign="center" valign="center2" textfont="{{{FontManager::C_GameFontExtraBold}}}" textprefix="$i$t" textcolor="FFFFFF"/>
</stylesheet>

<!-- Frame models -->
<framemodel id="framemodel-item">
	<frameinstance id="control-block-list-thumbnail" modelid="{{{ControlBlockList::C_Name}}}" data-type="{{{ControlBlockList::C_Type_Quad}}}" z-index="0" data-size="{{{Size_ItemImage.X}}} {{{Size_ItemImage.Y}}}" data-alphamask="{{{Const::C_ImageUrl_Common_Track_Mask}}}" />
	<quad id="quad-gradient" z-index="1" size="{{{Size_ItemImage.X}}} {{{Size_ItemImage.Y}}}" image="{{{Const::C_ImageUrl_Common_Track_Gradient_Full}}}" colorize="{{{ColorPalette::C_Color_DarkBlue}}}"/>
	<frameinstance id="control-block-list-name" modelid="{{{ControlBlockList::C_Name}}}" data-type="{{{ControlBlockList::C_Type_Label}}}" z-index="2" data-textsize="2" data-textsize-fitlabel-min="0.6" data-textsize-fitlabel-step="0.2" data-maxline="2" data-size="{{{Size_ItemImage.X * 0.8}}} 7" data-opacity="0.7" pos="{{{Pos_ItemNameOneLine.X}}} {{{Pos_ItemNameOneLine.Y}}}" data-halign="left" data-valign="center2" filter-profanities="OnlyIfNotTranslated" data-textfont="{{{FontManager::C_GameFontExtraBold}}}" data-textprefix="$i$t" />
	<frameinstance id="playername-author" modelid="{{{PlayerName::C_Name}}}" pos="{{{Pos_ItemAuthor.X}}} {{{Pos_ItemAuthor.Y}}}" data-size="{{{Size_ItemImage.X * 0.8}}} 5" data-opacity="0.7" data-halign="left" data-valign="center" data-textprefix="$t$i" data-textfont="{{{FontManager::C_GameFontRegular}}}" data-textsize="2" data-textcompose="{{{Text_AuthorName}}}" z-index="2" />
	<quad id="quad-focus" z-index="3" size="{{{Size_ItemImage.X}}} {{{Size_ItemImage.Y}}}" image="{{{Const::C_ImageUrl_Common_Track_Contour}}}" opacity="0." colorize="FFF"/>
	<frame id="frame-focus-options" z-index="3" pos="{{{Pos_ItemFocusOptions.X}}} {{{Pos_ItemFocusOptions.Y}}}" halign="right" hidden="1" >
		<quad id="button-favorite" image="{{{Const::C_ImageUrl_Icon_Settings_Favorite_Empty}}}" size="7 7" class="{{{C_Class_ItemButton}}}" colorize="FFF" opacity="0.7" halign="center" valign="center" scriptevents="1"/>
		<quad id="button-download" image="{{{Const::C_ImageUrl_Icon_Settings_Download}}}" size="7 7" pos="{{{Pos_DownloadButton.X}}} {{{Pos_DownloadButton.Y}}}" class="{{{C_Class_ItemButton}}}" colorize="FFF" opacity="0.7" halign="center" valign="center" scriptevents="1"/>
		<quad id="button-delete" image="{{{Const::C_ImageUrl_Icon_Bin_Oblique}}}" size="7 7" ppos="{{{Pos_DeleteButton.X}}} {{{Pos_DeleteButton.Y}}}" class="{{{C_Class_ItemButton}}}" colorize="FFF" opacity="0.7" halign="center" valign="center" scriptevents="1"/>
	</frame>
	<frame size="{{{Size_ItemImage.X}}} {{{Size_ItemImage.Y}}}" pos="{{{Size_ItemImage.X/2}}} {{{-Size_ItemImage.Y/2}}}" halign="center" valign="center" z-index="1">
		<quad id="quad-hitbox" size="{{{Size_Item_Adjusted.X}}} {{{Size_Item_Adjusted.Y*1.5}}}" scriptevents="1" halign="center" valign="center" class="{{{Scroll::C_Class_ActivationZone}}}" rot="10"/>
	</frame>
</framemodel>

<!-- Page -->
<frameinstance id="frame-browser" modelid="{{{BrowserAPI::C_Name}}}" z-index="{{{Const::C_ZIndex_BrowserAPI}}}" hidden="1"/>
<frameinstance id="frame-track-browser" modelid="{{{TrackBrowser::C_Name}}}" data-multi-select="1" z-index="{{{Const::C_ZIndex_BrowserAPI}}}"/>
<frameinstance id="loadingspinner-upload" modelid="{{{LoadingSpinner::C_Name}}}" data-dimmer="true" data-opacity="0." z-index="{{{Const::C_ZIndex_Loading}}}"/>

<!-- Frame global -->
<frame id="frame-global" class="{{{Navigation::C_Class}}}" data-nav-inputs="cancel" data-nav-targets="_" data-nav-group="{{{C_NavGroup_Global}}}" z-index="{{{Const::C_ZIndex_PopUpDisplay}}}">
	<frameinstance id="frame-background" modelid="{{{PopUpBackground::C_Name}}}" z-index="-1"/>
	<frameinstance id="loadingspinner-retrieve-info" modelid="{{{LoadingSpinner::C_Name}}}" pos="{{{MLHelpers::Skew(-120., 20., 10.)}}}" data-label="{{{Text_Retrieving}}}" data-label-side="{{{LoadingSpinner::C_LabelSide_Right}}}" data-size="10 10" scale="0.7" z-index="2"/>	
	<label id="label-info" size="250 10" class="text-semibold" textsize="2.5" halign="left" hidden="1"/>
	
	<!-- Pop-up header -->
	<frame id="frame-header">
		<label id="label-title" pos="{{{MLHelpers::Skew(-126.5, 61.5, 10.)}}}" size="200 20" class="text-extrabold" textsize="13" halign="left" filter-profanities="OnlyIfNotTranslated" z-index="1"/>
		<frameinstance 
			id="button-club" z-index="2"
			pos="{{{MLHelpers::Skew(-126., 53., 10.)}}}"
			modelid="{{{ExpendableButton::C_Name}}}"
			class="{{{Navigation::C_Class}}}"
			data-styles="{{{ExpendableButton::C_Style_NoBackground}}}"
			data-filter-profanities="{{{Tools::C_FilterProfanities_Always}}}"
			data-icon-image="{{{Const::C_ImageUrl_Icon_Link}}}"
			data-icon-colormode="{{{ExpendableButton::C_ColorMode_Colorize}}}"
			data-icon-color-unfocused="{{{ColorPalette::C_Color_White}}}"
			data-icon-color-focused="{{{ColorPalette::C_Color_GreenOne}}}"
			data-text-textcolor-unfocused="{{{ColorPalette::C_Color_White}}}"
			data-text-textcolor-focused="{{{ColorPalette::C_Color_GreenOne}}}"
			data-halign="left" data-valign="center"
			data-nav-inputs="select;down;left;right"
			data-nav-targets="_;frame-scroll-items;_;_"
			data-nav-group="{{{C_NavGroup_Default}}}"
			data-nav-zone="{{{ExpendableButton::C_NavZone}}}"
			data-nav-locked="1"
			hidden="1"
		/>
	</frame>

	<!-- Pop-up body -->
	<frame id="frame-content">
		<frame id="frame-view-list">
			<frameinstance modelid="{{{Scroll::C_Name}}}" data-scroll-parent="frame-scroll-items" z-index="1" />
			<frame
				id="frame-scroll-items" pos="{{{Size_ItemsScrollWindow.X * -0.514}}} {{{Size_ItemsScrollWindow.Y * 0.22}}}"
				class="{{{Scroll::C_Class_Window}}} {{{Navigation::C_Class}}}"
				data-pager-page-size="{{{ItemsPerPage}}}"
				data-elements-per-line="{{{ColumnsNb}}}"
				data-element-size="{{{Size_Item.X}}} {{{Size_Item.Y}}}"
				data-margin-size="{{{Size_ItemMargin.X}}} {{{Size_ItemMargin.Y}}}"
				data-window-size="{{{Size_ItemsScrollWindow.X}}} {{{Size_ItemsScrollWindow.Y}}}"
				data-scroll-indicator-x-offset="-5."
				data-scroll-indicator-y-offset="-12."
				data-scroll-indicator-image="{{{Const::C_ImageUrl_Icon_Arrow_Bottom_Oblique}}}"
				data-scroll-indicator-colorize="FFFFFF"
				data-scroll-indicator-size="12"
				data-scrollbar-visibility="{{{Scroll::C_ScrollBarVisibility_Never}}}"
				data-scrollpadding="17.5"
				data-skew="-10."
				data-skew-valign="{{{Scroll::C_SkewVAlign_Center}}}"
				data-nav-group="{{{C_NavGroup_Default}}}"
			>
				<quad z-index="-1" scriptevents="1" class="{{{Scroll::C_Class_ScrollEvent}}}" />
				{{{ML_ItemCards}}}
			</frame>
		</frame>

		<frame id="frame-view-3d" pos="45 0" hidden="1">
			<label id="label-skin-name" pos="0 12" size="150 10" class="text-regular" textsize="4" textfont="{{{FontManager::C_GameFontExtraBold}}}" filter-profanities="OnlyIfNotTranslated" />
			<camera id="camera-skin" pos="0 -10" halign="center" valign="center" size="320 180" fullscreen="1" hidden="1" z-index="-1" />

			<frame id="frame-skin-pager" pos="0 -62.">
				<frameinstance
					id="button-previous" pos="-75 40.5"
					modelid="{{{Button::C_Name}}}"
					class="{{{Navigation::C_Class}}} {{{MenuSounds::C_Class}}} {{{C_Class_Arrow}}}"
					data-size="10.5 10.5"
					data-bgcolor="FFF"
					data-opacityunfocus="0.6"
					data-image="{{{Const::C_ImageUrl_Icon_Arrow_Left_Oblique}}}"
					data-imagefocus="{{{Const::C_ImageUrl_Icon_Arrow_Left_Oblique}}}"
					data-focuscolor="{{{ColorPalette::C_Color_White}}}"
					data-halign="center" data-valign="center"
					data-nav-inputs="select"
					data-nav-targets="_"
					data-nav-group="{{{C_NavGroup_MouseOnly}}}"
					data-nav-zone="{{{Button::C_NavZone}}}"
					data-menusounds-selectsound="ArrowSelect"
					data-nav-locked="1"
					hidden="1"
				/>
				<label id="label-pager" size="40 10" class="text-regular"/>
				<frameinstance
					id="button-next" pos="75 40.5"
					modelid="{{{Button::C_Name}}}"
					class="{{{Navigation::C_Class}}} {{{MenuSounds::C_Class}}} {{{C_Class_Arrow}}}"
					data-size="10.5 10.5"
					data-bgcolor="FFF"
					data-opacityunfocus="0.6"
					data-image="{{{Const::C_ImageUrl_Icon_Arrow_Right_Oblique}}}"
					data-imagefocus="{{{Const::C_ImageUrl_Icon_Arrow_Right_Oblique}}}"
					data-focuscolor="{{{ColorPalette::C_Color_White}}}"
					data-halign="center" data-valign="center"
					data-nav-inputs="select"
					data-nav-targets="_"
					data-nav-group="{{{C_NavGroup_MouseOnly}}}"
					data-nav-zone="{{{Button::C_NavZone}}}"
					data-menusounds-selectsound="ArrowSelect"
					data-nav-locked="1"
					hidden="1"
				/>
			</frame>

			<frame id="frame-skin-buttons-container" class="{{{Grid::C_Class_Container}}}" pos="{{{MLHelpers::Skew(-130.5, 14., 10.)}}}">
				<frameinstance
					id="button-upload-skin"
					modelid="{{{ExpendableButton::C_Name}}}"
					class="{{{Navigation::C_Class}}} {{{Grid::C_Class_Element}}}"
					data-grid-row="{{{C_Row_Upload}}}"
					data-text="{{{Text_UploadSkin}}}"
					data-width="{{{Size_SkinButtons.X}}}" data-height="{{{Size_SkinButtons.Y}}}"
					data-styles="{{{ExpendableButton::C_Style_SizeExpendable}}} {{{ExpendableButton::C_Style_ButtonTertiary}}}"
					data-icon-align="{{{ExpendableButton::C_IconAlign_Left}}}"
					data-icon-color-focused="{{{ColorPalette::C_Color_White}}}"
					data-icon-color-unfocused="{{{ColorPalette::C_Color_White}}}"
					data-icon-colormode="{{{ExpendableButton::C_ColorMode_Colorize}}}"
					data-icon-image="{{{Const::C_ImageUrl_Icon_Cloud_Inc}}}"
					data-icon-opacity-unfocused="0.6"
					data-halign="center" data-valign="center"
					data-nav-inputs="select;up;down;left;right"
					data-nav-targets="_;button-club;button-apply;_;_"
					data-nav-group="{{{C_NavGroup_Default}}}"
					data-nav-zone="{{{ExpendableButton::C_NavZone}}}"
				/>
				<frameinstance
					id="button-apply"
					modelid="{{{ExpendableButton::C_Name}}}"
					class="{{{Navigation::C_Class}}} {{{Grid::C_Class_Element}}}"
					data-grid-row="{{{C_Row_Apply}}}"
					data-text="{{{Text_UseSkin}}}"
					data-width="{{{Size_SkinButtons.X}}}" data-height="{{{Size_SkinButtons.Y}}}"
					data-styles="{{{ExpendableButton::C_Style_SizeExpendable}}} {{{ExpendableButton::C_Style_ButtonTertiary}}}"
					data-icon-align="{{{ExpendableButton::C_IconAlign_Left}}}"
					data-icon-color-focused="{{{ColorPalette::C_Color_White}}}"
					data-icon-color-unfocused="{{{ColorPalette::C_Color_White}}}"
					data-icon-colormode="{{{ExpendableButton::C_ColorMode_Colorize}}}"
					data-icon-image="{{{Const::C_ImageUrl_Icon_Checkbox_Inactive_Square}}}"
					data-icon-opacity-unfocused="0.6"
					data-halign="center" data-valign="center"
					data-nav-inputs="select;up;down;left;right"
					data-nav-targets="_;button-upload-skin;button-add-garage;_;_"
					data-nav-group="{{{C_NavGroup_Default}}}"
					data-nav-zone="{{{ExpendableButton::C_NavZone}}}"
				/>
				<frameinstance
					id="button-add-garage"
					modelid="{{{ExpendableButton::C_Name}}}"
					class="{{{Navigation::C_Class}}} {{{Grid::C_Class_Element}}}"
					data-grid-row="{{{C_Row_AddGarage}}}"
					data-text="{{{Text_AddToGarage}}}"
					data-width="{{{Size_SkinButtons.X}}}" data-height="{{{Size_SkinButtons.Y}}}"
					data-styles="{{{ExpendableButton::C_Style_SizeExpendable}}} {{{ExpendableButton::C_Style_ButtonTertiary}}}"
					data-icon-align="{{{ExpendableButton::C_IconAlign_Left}}}"
					data-icon-color-focused="{{{ColorPalette::C_Color_White}}}"
					data-icon-color-unfocused="{{{ColorPalette::C_Color_White}}}"
					data-icon-colormode="{{{ExpendableButton::C_ColorMode_Colorize}}}"
					data-icon-image="{{{Const::C_ImageUrl_Icon_Garage_Empty}}}"
					data-icon-opacity-unfocused="0.6"
					data-halign="center" data-valign="center"
					data-nav-inputs="select;up;down;left;right"
					data-nav-targets="_;button-apply;button-download-skin;_;_"
					data-nav-group="{{{C_NavGroup_Default}}}"
					data-nav-zone="{{{ExpendableButton::C_NavZone}}}"
				/>
				<frameinstance
					id="button-download-skin"
					modelid="{{{ExpendableButton::C_Name}}}"
					class="{{{Navigation::C_Class}}} {{{Grid::C_Class_Element}}}"
					data-grid-row="{{{C_Row_Download}}}"
					data-text="{{{Text_DownloadSkin}}}"
					data-width="{{{Size_SkinButtons.X}}}" data-height="{{{Size_SkinButtons.Y}}}"
					data-styles="{{{ExpendableButton::C_Style_SizeExpendable}}} {{{ExpendableButton::C_Style_ButtonTertiary}}}"
					data-icon-align="{{{ExpendableButton::C_IconAlign_Left}}}"
					data-icon-color-focused="{{{ColorPalette::C_Color_White}}}"
					data-icon-color-unfocused="{{{ColorPalette::C_Color_White}}}"
					data-icon-colormode="{{{ExpendableButton::C_ColorMode_Colorize}}}"
					data-icon-image="{{{Const::C_ImageUrl_Icon_Settings_Download}}}"
					data-icon-opacity-unfocused="0.6"
					data-halign="center" data-valign="center"
					data-nav-inputs="select;up;down;left;right"
					data-nav-targets="_;button-add-garage;button-remove;_;_"
					data-nav-group="{{{C_NavGroup_Default}}}"
					data-nav-zone="{{{ExpendableButton::C_NavZone}}}"
				/>
				<frameinstance
					id="button-remove"
					modelid="{{{ExpendableButton::C_Name}}}"
					class="{{{Navigation::C_Class}}} {{{Grid::C_Class_Element}}}"
					data-grid-row="{{{C_Row_Remove}}}"
					data-text="{{{Text_DeleteSkin}}}"
					data-width="{{{Size_SkinButtons.X}}}" data-height="{{{Size_SkinButtons.Y}}}"
					data-styles="{{{ExpendableButton::C_Style_SizeExpendable}}} {{{ExpendableButton::C_Style_ButtonTertiary}}}"
					data-icon-align="{{{ExpendableButton::C_IconAlign_Left}}}"
					data-icon-color-focused="{{{ColorPalette::C_Color_White}}}"
					data-icon-color-unfocused="{{{ColorPalette::C_Color_White}}}"
					data-icon-colormode="{{{ExpendableButton::C_ColorMode_Colorize}}}"
					data-icon-image="{{{Const::C_ImageUrl_Icon_Bin_Oblique}}}"
					data-icon-opacity-unfocused="0.6"
					data-halign="center" data-valign="center"
					data-nav-inputs="select;up;down;left;right"
					data-nav-targets="_;button-download-skin;button-back;_;_"
					data-nav-group="{{{C_NavGroup_Default}}}"
					data-nav-zone="{{{ExpendableButton::C_NavZone}}}"
				/>
			</frame>
		</frame>
	</frame>

	<!-- Bottom buttons -->
	<frameinstance id="button-icon-back" modelid="{{{ButtonIcon::C_Name}}}" pos="{{{MLHelpers::Skew(-125.5, -67., 10.)}}}" data-halign="right" data-size="8 8" data-bind="B" data-hideformouse="1" />
	<frameinstance
		id="button-back" pos="{{{MLHelpers::Skew(-125.5, -67., 10.)}}}" z-index="2"
		modelid="{{{ExpendableButton::C_Name}}}"
		class="{{{Navigation::C_Class}}}"
		data-max-width="60."
		data-styles="{{{ExpendableButton::C_Style_SizeExpendable}}} {{{ExpendableButton::C_Style_AlignCenter}}} {{{ExpendableButton::C_Style_ButtonSecondary}}} {{{ExpendableButton::C_Style_PageBack}}}"
		data-nav-inputs="select;up;left;right"
		data-nav-targets="_;frame-scroll-items;_;button-upload-map"
		data-nav-group="{{{C_NavGroup_Default}}}"
		data-nav-zone="{{{ExpendableButton::C_NavZone}}}"
	/>
	<frameinstance
		id="button-upload-map" pos="{{{MLHelpers::Skew(131.7, -67., 10.)}}}" z-index="2"
		modelid="{{{ExpendableButton::C_Name}}}"
		class="{{{Navigation::C_Class}}}"
		data-text="{{{Text_UploadMap}}}"
		data-max-width="70."
		data-styles="{{{ExpendableButton::C_Style_SizeExpendable}}} {{{ExpendableButton::C_Style_AlignCenter}}} {{{ExpendableButton::C_Style_ButtonSecondary}}}"
		data-halign="right"
		data-nav-inputs="select;up;left"
		data-nav-targets="_;frame-scroll-items;button-back"
		data-nav-group="{{{C_NavGroup_Default}}}"
		data-nav-zone="{{{ExpendableButton::C_NavZone}}}"
		data-nav-locked="1"
		hidden="1"
	/>
</frame>
""",
"""
#Include "Libs/Nadeo/CommonLibs/Common/Error.Script.txt" as Error
#Include "Libs/Nadeo/CommonLibs/Common/Http.Script.txt" as Http
#Include "Libs/Nadeo/CommonLibs/Common/MainUser.Script.txt" as MainUser
#Include "Libs/Nadeo/CommonLibs/Common/Platform.Script.txt" as Platform
#Include "Libs/Nadeo/CommonLibs/Common/ReportContext.Script.txt" as ReportContext
#Include "Libs/Nadeo/CommonLibs/Common/Task.Script.txt" as Task
#Include "Libs/Nadeo/MenuLibs/Common/Components/Grid.Script.txt" as Grid
#Include "Libs/Nadeo/MenuLibs/Common/Components/Tools.Script.txt" as Tools
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/Helpers.Script.txt" as MLHelpers
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/Pager2.Script.txt" as Pager
#Include "Libs/Nadeo/MenuLibs/Common/MenuSceneManager.Script.txt" as MenuSceneManager
#Include "Libs/Nadeo/TMNext/TrackMania/API/ClubAPI.Script.txt" as ClubAPI
#Include "Libs/Nadeo/TMNext/TrackMania/API/MapAPI.Script.txt" as MapAPI
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Overlays/ControllerInfo_ML.Script.txt" as ControllerInfo
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Overlays/ReportSystem.Script.txt" as ReportSystem
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/TitleControl.Script.txt" as TitleControl
#Include "Libs/Nadeo/TMNext/TrackMania/RBAC.Script.txt" as RBAC
#Include "Libs/Nadeo/TMNext/TrackMania/Structures/ReportStruct.Script.txt" as ReportStruct
#Include "TextLib" as TL

#Const C_View_List 0
#Const C_View_3D 1

#Const C_InfoType_None "none"
#Const C_InfoType_Loading "loading"
#Const C_InfoType_Standard "standard"
#Const C_InfoType_Success "success"
#Const C_InfoType_Error "error"

#Struct K_Scene {
	Ident SceneId;
	Ident CurrentItemId;
}

#Struct K_SkinUploads {
	{{{ClubStruct::P}}}K_Skin[Text] Skins; //< Key is the skin id
	Pager::K_Pager SkinsPager;
	Task::K_Task Task_RegisterSkin;
	Task::K_Task Task_GetSkinList;
	Task::K_Task Task_GetFavoriteSkinList;
	Task::K_Task Task_SetUnsetFavoriteSkin;
	Task::K_Task Task_GetUserSkinList;
	Task::K_Task Task_SetUnsetSkin;
	Task::K_Task Task_UnsetPrestige;
	K_Scene Scene;
}

#Struct K_MapUploads {
	{{{CampaignStruct::P}}}K_Map[Text] Maps; //< Key is the map uid
	{{{CampaignStruct::P}}}K_Map[Text] MapsToUpload;
	Task::K_Task[Text] Task_RegisterMapList;
	Task::K_Task Task_GetMapList;
	Integer Total;
}

#Struct K_TracksFavoriteStatus {
	Http::K_Request Request;
	Text[] FavoritesTracksUids;
	Text CurrentTrackUid;
	Text CurrentTrackName;
}

#Struct K_Controls {
	CMlFrame Button_AddToGarage;
	CMlFrame Button_Apply;
	CMlFrame Button_Back;
	CMlFrame Button_Club;
	CMlFrame Button_DownloadSkin;
	CMlFrame Button_Next;
	CMlFrame Button_Previous;
	CMlFrame Button_Remove;
	CMlFrame Button_UploadMap;
	CMlFrame Button_UploadSkin;
	CMlFrame Frame_Browser;
	CMlFrame Frame_Content;
	CMlFrame Frame_ScrollItems;
	CMlFrame Frame_SkinButtonsContainer;
	CMlFrame Frame_View3D;
	CMlFrame Frame_ViewList;
	CMlFrame LoadingSpinner_RetrieveInfo;
	CMlFrame LoadingSpinner_Upload;
	CMlLabel Label_Info;
	CMlLabel Label_Title;
}

#Struct K_State {
	Integer ViewType;
	Boolean BrowserIsInitialized;
	K_Controls Controls;
	K_MapUploads MapUploads;
	K_SkinUploads SkinUploads;
	K_TracksFavoriteStatus TracksFavoriteStatus;
	Http::K_Request GetBucketActivityRequest;
	Http::K_Request GetClubDetailRequest;
	Http::K_Request GetClubMembershipRequest;
	Http::K_Request PostAddBucketItemsRequest;
	Http::K_Request PostRemoveBucketItemsRequest;
	ReportStruct::LibStructuresReport_K_ReportData[Integer] CurrentReportData;
	{{{ClubStruct::P}}}K_Activity Activity;
	{{{ClubStruct::P}}}K_BucketItem[Integer] Items; //< Key is the position in the list
	{{{ClubStruct::P}}}K_Club Club;
	{{{ClubStruct::P}}}K_Member Membership;
}
""",
"""
Boolean UserCanHandleItems(K_State _State) {
	if ({{{Router::P}}}GetCurrentParentPath(This) == "{{{RoutePaths::C_Path_Create}}}") {
		return False;
	} else if (_State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_MapUpload) {
		return RBAC::HasClubPermission(_State.Membership, RBAC::C_ClubPermission_HandleMapUploads);
	} else if (_State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_SkinUpload) {
		return RBAC::HasClubPermission(_State.Membership, RBAC::C_ClubPermission_HandleSkinUploads);
	}
	return False;
}

Void LockNavigation(K_State _State, Boolean _IsLocked) {
	{{{Navigation::P}}}EnableGroup(This, "{{{C_NavGroup_Default}}}", !_IsLocked);
	{{{Navigation::P}}}EnableGroup(This, "{{{C_NavGroup_Global}}}", !_IsLocked);
	{{{Scroll::P}}}LockNavigation(_State.Controls.Frame_ScrollItems, _IsLocked);
}

Void UpdateLoadingSpinner(K_State _State, Text _LoadingText, Boolean _IsLoading, Boolean _IsFullScreenLoading) {
	if (_IsLoading && _IsFullScreenLoading) {
		LockNavigation(_State, True);
		{{{LoadingSpinner::P}}}StartAnimWithFade(This, _State.Controls.LoadingSpinner_Upload, _LoadingText);
	} else if (_IsLoading) {
		{{{LoadingSpinner::P}}}StartAnimWithFade(This, _State.Controls.LoadingSpinner_RetrieveInfo, _LoadingText);
	} else {
		{{{LoadingSpinner::P}}}StopAnimWithFade(This, _State.Controls.LoadingSpinner_RetrieveInfo);
		{{{LoadingSpinner::P}}}StopAnimWithFade(This, _State.Controls.LoadingSpinner_Upload);
		LockNavigation(_State, False);
	}
}

Void DisplayInfo(K_State _State, Text _Text, Text _InfoType) {
	declare Text CurrentlyDisplayedInfoType for _State.Controls.Label_Info = C_InfoType_None;
	declare Boolean IsDisplayingSuccessInfo = (_State.Controls.Label_Info.Visible && CurrentlyDisplayedInfoType == C_InfoType_Success);
	declare Vec2 Pos_Hidden = MLHelpers::SkewX(<-126., 20.>, 10.);
	declare Vec2 Pos_Visible = MLHelpers::SkewX(<-125., 20.>, 10.);

	// Update loading spinner
	// We don't want the loading spinner to override a success message that is being displayed
	UpdateLoadingSpinner(_State, _Text, _InfoType == C_InfoType_Loading && !IsDisplayingSuccessInfo, False);

	// Update label
	if (_InfoType != C_InfoType_Loading && _Text != "") {
		_State.Controls.Label_Info.Show();
		_State.Controls.Label_Info.SetText(_Text);
		_State.Controls.Label_Info.Opacity = 0.;
		_State.Controls.Label_Info.RelativePosition_V3 = Pos_Hidden;
		AnimMgr.Flush(_State.Controls.Label_Info);
		AnimMgr.Add(_State.Controls.Label_Info, "<anim pos=\""^Pos_Visible.X^" "^Pos_Visible.Y^"\" opacity=\"1.\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
		switch (_InfoType) {
			case C_InfoType_Error: _State.Controls.Label_Info.TextColor = {{{ColorPalette::C_Color_Vec3_ErrorRed}}};
			case C_InfoType_Success: {
				_State.Controls.Label_Info.TextColor = {{{ColorPalette::C_Color_Vec3_GreenOne}}};
				AnimMgr.Add(_State.Controls.Label_Info, "<anim pos=\""^Pos_Hidden.X^" "^Pos_Hidden.Y^"\" opacity=\"0.\" hidden=\"1\"/>", Now+5000, 250, CAnimManager::EAnimManagerEasing::QuadOut);
			}
			default: _State.Controls.Label_Info.TextColor = <1., 1., 1.>;
		}
	} else if (!IsDisplayingSuccessInfo || _Text == "") {
		AnimMgr.Flush(_State.Controls.Label_Info);
		AnimMgr.Add(_State.Controls.Label_Info, "<anim pos=\""^Pos_Hidden.X^" "^Pos_Hidden.Y^"\" opacity=\"0.\" hidden=\"1\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	}

	// Update current info type
	CurrentlyDisplayedInfoType = _InfoType;
}

// Update controller hints at the bottom of the screen
Void UpdateControllerInfo(K_State _State, Boolean _IsScrollFocused, Boolean _IsFocusedTrackFavorite) {
	declare Text[Text] ControllerInfos = ["A" => _("Select"), "B" => _("Back")];

	switch (_State.ViewType) {
		case C_View_3D: {
			ControllerInfos["Left"] = ""; //< Empty on purpose
			//L16N [SkinUploads] Navigate through skins with left and right arrows
			ControllerInfos["Right"] = _("Select skin");
		}
		case C_View_List: {
			if (_IsScrollFocused) {
				if (_IsFocusedTrackFavorite) {
					//L16N [MapUploads] Remove the focused track to the player favorite tracks
					ControllerInfos["Action2"] = _("Remove favorite");
				} else {
					//L16N [MapUploads] Add the focused track from the player favorite tracks
					ControllerInfos["Action2"] = _("Add favorite");
				}
				if (UserCanHandleItems(_State)) {
					ControllerInfos["Action1"] = _("Remove");
				}
				if ({{{UserStore::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_UseCustomCollection)) {
					ControllerInfos["A"] = _("Play");
				}
			}
		}
	}

	ControllerInfos["{{{Const::C_NavInput_ReportSystem}}}"] = "{{{Const::C_Text_Report}}}";

	ControllerInfo::SetButtons(ControllerInfos);
}

Void UpdateControllerInfo(K_State _State, Boolean _IsScrollFocused) {
	UpdateControllerInfo(_State, _IsScrollFocused, False);
}

Void ShowMap(K_State _State, CMlFrame _Frame_Item, {{{CampaignStruct::P}}}K_Map _Map) {
	declare CMlFrame PlayerName_Author <=> (_Frame_Item.GetFirstChild("playername-author") as CMlFrame);
	declare CMlFrame ControlBlockList_Name <=> (_Frame_Item.GetFirstChild("control-block-list-name") as CMlFrame);
	declare CMlQuad Button_Delete <=> (_Frame_Item.GetFirstChild("button-delete") as CMlQuad);
	declare CMlQuad Button_Download <=> (_Frame_Item.GetFirstChild("button-download") as CMlQuad);
	declare CMlQuad Button_Favorite <=> (_Frame_Item.GetFirstChild("button-favorite") as CMlQuad);
	declare CMlFrame ControlBlockList_Thumbnail <=> (_Frame_Item.GetFirstChild("control-block-list-thumbnail") as CMlFrame);

	_Frame_Item.Show();
	{{{ControlBlockList::P}}}SetOwnerAndTextValue(This, ControlBlockList_Name, _Map.AuthorLogin, Tools::FormatValue(_Map.Name), False);
	if ({{{ControlBlockList::P}}}GetValueLineCount(This, ControlBlockList_Name) >= 2) {
		ControlBlockList_Name.RelativePosition_V3 = {{{Pos_ItemNameTwoLines}}};
	} else {
		ControlBlockList_Name.RelativePosition_V3 = {{{Pos_ItemNameOneLine}}};
	}
	if (_Map.AuthorDisplayName != "") {
		PlayerName_Author.Show();
		{{{PlayerName::P}}}SetAccountId(This, PlayerName_Author, _Map.AuthorLogin, False);
		{{{ControlBlockList::P}}}SetTTSAltText(
			This,
			ControlBlockList_Name,
			TL::Compose("%2 "^TL::GetTranslatedText(_("By %1")), _Map.AuthorDisplayName, {{{ControlBlockList::P}}}GetTextValue(ControlBlockList_Name)),
			TL::Compose("%2 "^TL::GetTranslatedText(_("By %1")), _Map.AuthorDisplayName, {{{ControlBlockList::P}}}C_DefaultTextValueBlocked),
			False
		);
	} else {
		ControlBlockList_Name.RelativePosition_V3 = {{{Pos_ItemAuthor}}};
		{{{ControlBlockList::P}}}SetTTSAltText(This, ControlBlockList_Name, "", "", False);
		PlayerName_Author.Hide();
	}
	{{{ControlBlockList::P}}}Redraw(This, ControlBlockList_Name);

	Button_Favorite.Visible = True;
	Button_Download.Visible = {{{UserStore::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_UseCustomCollection) && Platform::IsPC(System);
	Button_Delete.Visible = UserCanHandleItems(_State);
	if (Button_Download.Visible) {
		Button_Delete.RelativePosition_V3 = {{{Pos_DeleteButton}}};
	} else {
		Button_Delete.RelativePosition_V3 = {{{Pos_DownloadButton}}};
	}
	if (_State.TracksFavoriteStatus.FavoritesTracksUids.exists(_Map.Uid)) {
		Button_Favorite.ImageUrl = "{{{Const::C_ImageUrl_Icon_Settings_Favorite_Full}}}";
	} else {
		Button_Favorite.ImageUrl = "{{{Const::C_ImageUrl_Icon_Settings_Favorite_Empty}}}";
	} 

	{{{ControlBlockList::P}}}SetOwnerAndImageUrl(This, ControlBlockList_Thumbnail, _Map.AuthorLogin, _Map.ThumbnailUrl);
	ControlBlockList_Thumbnail.Visible = True;
}

Void ShowItemLoading(CMlFrame _Frame_Item) {
	declare CMlFrame ControlBlockList_Name <=> (_Frame_Item.GetFirstChild("control-block-list-name") as CMlFrame);
	declare CMlFrame PlayerName_Author = _Frame_Item.GetFirstChild("playername-author") as CMlFrame;
	declare CMlFrame ControlBlockList_Thumbnail <=> (_Frame_Item.GetFirstChild("control-block-list-thumbnail") as CMlFrame);
	declare CMlFrame Frame_FocusOptions = _Frame_Item.GetFirstChild("frame-focus-options") as CMlFrame;

	_Frame_Item.Show();
	Frame_FocusOptions.Hide();
	PlayerName_Author.Hide();
	{{{ControlBlockList::P}}}SetOwnerAndTextValue(This, ControlBlockList_Name, "", "{{{Text_Retrieving}}}");
	ControlBlockList_Name.RelativePosition_V3 = {{{Pos_ItemAuthor}}};
	{{{ControlBlockList::P}}}SetOwnerAndImageUrl(This, ControlBlockList_Thumbnail, "", "");
	ControlBlockList_Thumbnail.Visible = False;
}

Void FocusMap(K_State _State, Integer _Key, CMlFrame _Frame_Map, Boolean _IsFocused, Boolean _IsAnimated) {
	declare CMlQuad Quad_Focus <=> (_Frame_Map.GetFirstChild("quad-focus") as CMlQuad);
	declare CMlQuad Quad_Gradient <=> (_Frame_Map.GetFirstChild("quad-gradient") as CMlQuad);
	declare CMlFrame ControlBlockList_Name <=> (_Frame_Map.GetFirstChild("control-block-list-name") as CMlFrame);
	declare CMlFrame PlayerName_Author <=> (_Frame_Map.GetFirstChild("playername-author") as CMlFrame);
	declare CMlFrame Frame_FocusOptions <=> (_Frame_Map.GetFirstChild("frame-focus-options") as CMlFrame);

	AnimMgr.Flush(Quad_Gradient);
	AnimMgr.Flush(Quad_Focus);
	
	Frame_FocusOptions.Visible = _IsFocused;
	if (_IsAnimated) {
		if (_IsFocused) {
			AnimMgr.Add(Quad_Gradient, "<anim opacity=\"0.6\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
			AnimMgr.Add(Quad_Focus, "<anim opacity=\"1.\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
			{{{ControlBlockList::P}}}SetOpacity(This, ControlBlockList_Name, 1., 250);
			{{{PlayerName::P}}}SetOpacity(This, PlayerName_Author, 1., 250);
		} else {
			AnimMgr.Add(Quad_Gradient, "<anim opacity=\"1.\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
			AnimMgr.Add(Quad_Focus, "<anim opacity=\"0.\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
			{{{ControlBlockList::P}}}SetOpacity(This, ControlBlockList_Name, 0.7, 250);
			{{{PlayerName::P}}}SetOpacity(This, PlayerName_Author, 0.7, 250);
		}
	} else {
		if (_IsFocused) {
			Quad_Gradient.Opacity = 0.6;
			Quad_Focus.Opacity = 1.;
			{{{ControlBlockList::P}}}SetOpacity(This, ControlBlockList_Name, 1.);
			{{{PlayerName::P}}}SetOpacity(This, PlayerName_Author, 1., 0);
		} else {
			Quad_Gradient.Opacity = 1.;
			Quad_Focus.Opacity = 0.;
			{{{ControlBlockList::P}}}SetOpacity(This, ControlBlockList_Name, 0.7);
			{{{PlayerName::P}}}SetOpacity(This, PlayerName_Author, 0.7, 0);
		}
	}

	// Text to speech
	if (_IsFocused) {
		{{{ControlBlockList::P}}}TTS_Focus(ControlBlockList_Name);
	} else {
		{{{ControlBlockList::P}}}TTS_Unfocus(ControlBlockList_Name);
	}

	// Controller info
	if (_IsFocused && _State.Items.existskey(_Key)) {
		declare Text ItemId = _State.Items[_Key].ItemId;
		if (_State.MapUploads.Maps.existskey(ItemId)) {
			UpdateControllerInfo(_State, True, _State.TracksFavoriteStatus.FavoritesTracksUids.exists(_State.MapUploads.Maps[ItemId].Uid));
		}
	}
}

Void Focus(K_State _State, CMlControl _From, CMlControl _To) {
	if ({{{Transition::P}}}IsInTransition(This)) return;
	
	if (_From != Null) {
		{{{Navigation::P}}}Unfocus(This, _From);
		if ({{{Button::P}}}IsButton(_From)) {
			{{{Button::P}}}Unfocus(This, _From as CMlFrame);
		} else if ({{{ExpendableButton::P}}}IsButton(_From)) {
			{{{ExpendableButton::P}}}Unfocus(This, _From as CMlFrame);
		} else if ({{{Scroll::P}}}IsScroll(_From)) {
			{{{Scroll::P}}}Unfocus(This, (_From as CMlFrame));
		}
	}
	
	if (_To != Null) {
		{{{Navigation::P}}}Focus(This, _To);
		if ({{{Button::P}}}IsButton(_To)) {
			{{{Button::P}}}Focus(This, _To as CMlFrame);
		} else if ({{{ExpendableButton::P}}}IsButton(_To)) {
			{{{ExpendableButton::P}}}Focus(This, _To as CMlFrame);
		} else if ({{{Scroll::P}}}IsScroll(_To)) {
			{{{Scroll::P}}}Focus(This, (_To as CMlFrame));
		}
		UpdateControllerInfo(_State, {{{Scroll::P}}}IsFocused(_To as CMlFrame));
	}
}

Void FocusAvailableControl(K_State _State) {
	if (_State.ViewType == C_View_List && !{{{Navigation::P}}}IsLocked(_State.Controls.Frame_ScrollItems)) {
		Focus(_State, {{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroup_Default}}}"), _State.Controls.Frame_ScrollItems);
	} else if (_State.ViewType == C_View_3D && !{{{Navigation::P}}}IsLocked(_State.Controls.Button_UploadSkin)) {
		Focus(_State, {{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroup_Default}}}"), _State.Controls.Button_UploadSkin);
	} else if (_State.ViewType == C_View_3D && !{{{Navigation::P}}}IsLocked(_State.Controls.Button_Apply)) {
		Focus(_State, {{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroup_Default}}}"), _State.Controls.Button_Apply);
	} else if (!{{{Navigation::P}}}IsLocked(_State.Controls.Button_UploadMap)) {
		Focus(_State, {{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroup_Default}}}"), _State.Controls.Button_UploadMap);
	} else {
		Focus(_State, {{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroup_Default}}}"), _State.Controls.Button_Back);
	}
}

Void PlayMap(K_State _State, {{{CampaignStruct::P}}}K_Map _Map) {
	if (_Map.IsPlayable && _Map.CollectionName == "{{{EnvironmentInfo::C_Collection_Stadium}}}") {
		declare Text MapUrl = _Map.DownloadUrl;
		if (MapUrl == "") MapUrl = _Map.LocalFileName;
		
		SendCustomEvent("{{{Const::C_Event_UpdateLoadingScreen}}}", [_Map.Name]);
		TitleControl::PlayMap(TitleControl, MapUrl, "{{{Const::C_ModeScript_PlayMap}}}", TL::Join("", [
			"<root>",
				"<setting name=\"S_TimeLimit\" value=\"-1\" type=\"integer\"/>",
				"<setting name=\"S_ForceLapsNb\" value=\"-1\" type=\"integer\"/>",
				"<setting name=\"S_DecoImageUrl_Checkpoint\" value=\""^TL::MLEncode(_State.Club.DecalUrl)^"\" type=\"text\"/>",
				"<setting name=\"S_DecoImageUrl_DecalSponsor4x1\" value=\""^TL::MLEncode(_State.Club.DecoImageUrl_DecalSponsor4x1)^"\" type=\"text\"/>",
				"<setting name=\"S_DecoImageUrl_Screen16x9\" value=\""^TL::MLEncode(_State.Club.DecoImageUrl_Screen16x9)^"\" type=\"text\"/>",
				"<setting name=\"S_DecoImageUrl_Screen8x1\" value=\""^TL::MLEncode(_State.Club.DecoImageUrl_Screen8x1)^"\" type=\"text\"/>",
				"<setting name=\"S_DecoImageUrl_Screen16x1\" value=\""^TL::MLEncode(_State.Club.DecoImageUrl_Screen16x1)^"\" type=\"text\"/>",
				"<setting name=\"S_ClubId\" value=\""^_State.Club.Id^"\" type=\"integer\"/>",
				"<setting name=\"S_ClubName\" value=\""^TL::MLEncode(_State.Club.Name)^"\" type=\"text\"/>",
			"</root>"
		]));

		Focus(_State, Null, {{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroup_Default}}}"));
		DisplayInfo(_State, "", C_InfoType_Standard);
	} else {
		//L16N [MapUploads] Message displayed when the selected track is not playable. %1 will be replaced by the name of the track.
		DisplayInfo(_State, TL::Compose(_("Track '%1' is not playable."), FilterProfanities(_Map.Name)), C_InfoType_Error);
	}
}

K_State UpdateSkinDisplayed(K_State _State, Integer _Index) {
	declare K_State State = _State;
	declare CMlFrame Frame_Pager = (State.Controls.Frame_View3D.GetFirstChild("frame-skin-pager") as CMlFrame);
	declare CMlLabel Label_SkinName = (State.Controls.Frame_View3D.GetFirstChild("label-skin-name") as CMlLabel);
	declare CMlLabel Label_Pager = (State.Controls.Frame_View3D.GetFirstChild("label-pager") as CMlLabel);
	declare CMlCamera Camera_Skin = (State.Controls.Frame_View3D.GetFirstChild("camera-skin") as CMlCamera);

	if (State.SkinUploads.Scene.SceneId != NullId && !MenuSceneManager::PageNeedToRecreateScene(Page, LocalUser)) {
		declare {{{ClubStruct::P}}}K_Skin Skin;

		// Get existing skin
		if (State.Items.existskey(_Index) && State.SkinUploads.Skins.existskey(State.Items[_Index].ItemId)) {
			Skin = State.SkinUploads.Skins[State.Items[_Index].ItemId];
			ReportContext::SetBucketItemUploadsFocusedSkin(
				System,
				Skin.Id,
				Skin.Type,
				Skin.Name,
				Skin.DisplayName,
				Skin.CreatorAccountId,
				Skin.CreatorDisplayName,
				Skin.FileName,
				Skin.FileUrl,
				Skin.ThumbnailUrl,
				Skin.TimeStamp,
				Skin.IsFavorite,
				Skin.IsUsed
			);
			ReportSystem::AddData(
				ReportStruct::C_ReportTarget_SkinFromActivity,
				ReportStruct::LibStructuresReport_K_ReportData {
					Details = [Skin.DisplayName],
					Ids = [TL::ToText(State.Activity.Id)], // special case for skin report in an activity (see trackmania-next/tmnext/-/issues/5479)
					Contexts = [["From" => "Menu BucketItemUploads", "skinId" => Skin.Id]]
				}
			);
		}

		// Update pager label
		if (State.SkinUploads.SkinsPager.Total > 0) {
			Label_Pager.SetText(TL::Compose("%1/%2", ""^_Index+1, ""^State.SkinUploads.SkinsPager.Total));
		} else {
			Label_Pager.SetText("");
		}

		// Update camera
		if (State.SkinUploads.Scene.CurrentItemId != NullId) {
			MenuSceneMgr.ItemDestroy(State.SkinUploads.Scene.SceneId, State.SkinUploads.Scene.CurrentItemId);
			State.SkinUploads.Scene.CurrentItemId = NullId;
		}
		State.SkinUploads.Scene.CurrentItemId = MenuSceneMgr.ItemCreate(State.SkinUploads.Scene.SceneId, "{{{Const::C_CameraSkinModel}}}", Skin.Name, Skin.FileUrl);
		MenuSceneMgr.ItemSetPivot(State.SkinUploads.Scene.SceneId, State.SkinUploads.Scene.CurrentItemId, {{{dump(Const::C_CarDefaultPivotInScene)}}});

		// Update controls
		Label_SkinName.SetText(Skin.DisplayName);
		if (Skin.IsUsed) {
			{{{ExpendableButton::P}}}SetIconImageUrl(This, State.Controls.Button_Apply, "{{{Const::C_ImageUrl_Icon_Checkbox_Active_Square}}}", False);
			{{{ExpendableButton::P}}}SetText(This, State.Controls.Button_Apply, "{{{Text_ResetSkin}}}");
		} else {
			{{{ExpendableButton::P}}}SetIconImageUrl(This, State.Controls.Button_Apply, "{{{Const::C_ImageUrl_Icon_Checkbox_Inactive_Square}}}", False);
			{{{ExpendableButton::P}}}SetText(This, State.Controls.Button_Apply, "{{{Text_UseSkin}}}");
		}

		if (Skin.IsFavorite) {
			{{{ExpendableButton::P}}}SetIconImageUrl(This, State.Controls.Button_AddToGarage, "{{{Const::C_ImageUrl_Icon_Garage_Full}}}", False);
			{{{ExpendableButton::P}}}SetText(This, State.Controls.Button_AddToGarage, "{{{Text_RemoveFromGarage}}}");
		} else {
			{{{ExpendableButton::P}}}SetIconImageUrl(This, State.Controls.Button_AddToGarage, "{{{Const::C_ImageUrl_Icon_Garage_Empty}}}", False);
			{{{ExpendableButton::P}}}SetText(This, State.Controls.Button_AddToGarage, "{{{Text_AddToGarage}}}");
		}
	} else {
		Label_Pager.SetText("");
		Label_SkinName.SetText("");
	}

	Camera_Skin.Visible = State.SkinUploads.SkinsPager.Total > 0;
	Frame_Pager.Visible = State.SkinUploads.SkinsPager.Total > 0;
	{{{Button::P}}}SetVisibilityAndNavigation(State.Controls.Button_Previous, State.SkinUploads.SkinsPager.Total > 1);
	{{{Button::P}}}SetVisibilityAndNavigation(State.Controls.Button_Next, State.SkinUploads.SkinsPager.Total > 1);

	return State;
}

Void UpdateSkinUploadButtons(K_State _State, Grid::K_GridConfig _GridConfig) {
	declare Boolean UserCanUseItems = {{{UserStore::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_UseCustomSkin);
	declare Boolean IsVisible = _State.Items.count > 0 && _State.ViewType == C_View_3D;

	/* Update buttons stack */
	{{{ExpendableButton::P}}}SetVisibilityAndNavigation(_State.Controls.Button_UploadSkin, UserCanHandleItems(_State) && Platform::IsPC(System));
	{{{ExpendableButton::P}}}SetVisibilityAndNavigation(_State.Controls.Button_Apply, IsVisible && UserCanUseItems);
	{{{ExpendableButton::P}}}SetVisibilityAndNavigation(_State.Controls.Button_AddToGarage, IsVisible && UserCanUseItems);
	{{{ExpendableButton::P}}}SetVisibilityAndNavigation(_State.Controls.Button_DownloadSkin, IsVisible && UserCanUseItems && Platform::IsPC(System));
	{{{ExpendableButton::P}}}SetVisibilityAndNavigation(_State.Controls.Button_Remove, IsVisible && UserCanHandleItems(_State));
	Grid::Update(_GridConfig, AnimMgr, _State.Controls.Frame_SkinButtonsContainer, 10., False, False);

	/* Update pager buttons */
	{{{Button::P}}}SetVisibilityAndNavigation(_State.Controls.Button_Previous, _State.SkinUploads.SkinsPager.Total > 1);
	{{{Button::P}}}SetVisibilityAndNavigation(_State.Controls.Button_Next, _State.SkinUploads.SkinsPager.Total > 1);

	/* Update navigation */
	FocusAvailableControl(_State);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Display and create the 3D scene or destroy it
K_State Display3DScene(K_State _State, Boolean _IsVisible) {
	declare K_State State = _State;

	// Create or destroy the scene
	if (_IsVisible) {
		if (State.SkinUploads.Scene.SceneId == NullId) {
			State.SkinUploads.Scene.SceneId = MenuSceneMgr.SceneCreate("Empty");
			if (State.SkinUploads.Scene.SceneId != NullId) {
				MenuSceneMgr.CameraSetLocation(State.SkinUploads.Scene.SceneId, <0., 4., -10.5>, 17., 32.);
				MenuSceneMgr.PlaneReflectEnable(State.SkinUploads.Scene.SceneId, 0.63, Null, Null, Null, Null, 10.);
			}
		}
		MenuSceneManager::PageSynchronizeScene(Page, LocalUser);
	} else if (State.SkinUploads.Scene.SceneId != NullId) {
		if (State.SkinUploads.Scene.CurrentItemId != NullId) {
			MenuSceneMgr.ItemDestroy(State.SkinUploads.Scene.SceneId, State.SkinUploads.Scene.CurrentItemId);
			State.SkinUploads.Scene.CurrentItemId = NullId;
		}
		MenuSceneMgr.SceneDestroy(State.SkinUploads.Scene.SceneId);
		State.SkinUploads.Scene.SceneId = NullId;
	}
	
	// Update displayed skin
	State = UpdateSkinDisplayed(State, Pager::GetIndex(State.SkinUploads.SkinsPager));

	return State;
}

K_State SetView(K_State _State, Grid::K_GridConfig _GridConfig, Integer _View) {
	declare K_State State = _State;

	State.ViewType = _View;
	State.Controls.Frame_ViewList.Visible = State.ViewType == C_View_List;
	State.Controls.Frame_View3D.Visible = State.ViewType == C_View_3D;
	State = Display3DScene(State, State.ViewType == C_View_3D);

	switch (State.ViewType) {
		case C_View_3D: {
			State.SkinUploads.SkinsPager = Pager::Create(1, 5, 2, 1000, True);
			{{{Navigation::P}}}ChangeControlTarget(This, State.Controls.Button_Club, "down", State.Controls.Button_UploadSkin.ControlId);
			{{{Navigation::P}}}ChangeControlTargets(This, State.Controls.Button_Back, ["up", "right"], [State.Controls.Button_Remove.ControlId, "_"]);
			UpdateSkinUploadButtons(State, _GridConfig);
		}
		case C_View_List: {
			{{{Scroll::P}}}TriggerPagerUpdate(State.Controls.Frame_ScrollItems);
			{{{Scroll::P}}}SetElementsTotal(This, State.Controls.Frame_ScrollItems, 0);
			{{{Navigation::P}}}ChangeControlTarget(This, State.Controls.Button_Club, "down", State.Controls.Frame_ScrollItems.ControlId);
			{{{Navigation::P}}}ChangeControlTargets(This, State.Controls.Button_Back, ["up", "right"], [State.Controls.Frame_ScrollItems.ControlId, State.Controls.Button_UploadMap.ControlId]);
			{{{ExpendableButton::P}}}SetVisibilityAndNavigation(State.Controls.Button_UploadMap, UserCanHandleItems(State) && State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_MapUpload);
			DisplayInfo(State, "{{{Text_Retrieving}}}", C_InfoType_Loading);
		}
	}
	
	FocusAvailableControl(State);
	
	return State;
}

K_State SetSkinAsFavorite(K_State _State, {{{ClubStruct::P}}}K_Skin _Skin) {
	declare K_State State = _State;

	State.SkinUploads.Task_SetUnsetFavoriteSkin = Task::Destroy(State.SkinUploads.Task_SetUnsetFavoriteSkin);
	// Check `/trackmania-next/tmnext/-/issues/1804` to see why it has been disabled for people without the right to use skins
	if ({{{UserStore::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_UseCustomSkin)) {
		if (_Skin.IsFavorite) {
			DisplayInfo(State, "{{{Text_RemovingFromGarage}}}", C_InfoType_Loading);
			State.SkinUploads.Task_SetUnsetFavoriteSkin = Task::Create(DataFileMgr, DataFileMgr.AccountSkin_NadeoServices_RemoveFavorite(MainUser::GetMainUserId(), _Skin.Id));
			State.SkinUploads.Task_SetUnsetFavoriteSkin = Task::SetMetadata(State.SkinUploads.Task_SetUnsetFavoriteSkin, ["RemoveFavorite" => _Skin.Id]);
		} else {
			DisplayInfo(State, "{{{Text_AddingToGarage}}}", C_InfoType_Loading);
			State.SkinUploads.Task_SetUnsetFavoriteSkin = Task::Create(DataFileMgr, DataFileMgr.AccountSkin_NadeoServices_AddFavorite(MainUser::GetMainUserId(), _Skin.Id));
			State.SkinUploads.Task_SetUnsetFavoriteSkin = Task::SetMetadata(State.SkinUploads.Task_SetUnsetFavoriteSkin, ["AddFavorite" => _Skin.Id]);
		}
	} else {
		{{{Router::P}}}SetParentPath(This, "{{{RoutePaths::C_Path_ClubEditionInfo}}}", {{{Router::P}}}GetCurrentParentPath(This));
		{{{Router::P}}}Push(This, "{{{RoutePaths::C_Path_ClubEditionInfo}}}", [
			"{{{RoutePaths::C_Query_Message}}}" => RBAC::GetGamePermissionMessage(RBAC::C_GamePermissionMessage_UseCustomSkin)
		]);
	}

	return State;
}

K_State SetSkin(K_State _State, {{{ClubStruct::P}}}K_Skin _Skin) {
	declare K_State State = _State;

	State.SkinUploads.Task_SetUnsetSkin = Task::Destroy(State.SkinUploads.Task_SetUnsetSkin);
	// Check `/trackmania-next/tmnext/-/issues/1804` to see why it has been disabled for people without the right to use skins
	if ({{{UserStore::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_UseCustomSkin)) {
		DisplayInfo(State, "{{{Text_ApplyingSkin}}}", C_InfoType_Loading);
		if (_Skin.IsUsed) {
			State.SkinUploads.Task_SetUnsetSkin = Task::Create(DataFileMgr, DataFileMgr.AccountSkin_NadeoServices_Unset(MainUser::GetMainUserId(), _Skin.Type));
		} else {
			State.SkinUploads.Task_SetUnsetSkin = Task::Create(DataFileMgr, DataFileMgr.AccountSkin_NadeoServices_Set(MainUser::GetMainUserId(), _Skin.Id));
		}
	} else {
		{{{Router::P}}}SetParentPath(This, "{{{RoutePaths::C_Path_ClubEditionInfo}}}", {{{Router::P}}}GetCurrentParentPath(This));
		{{{Router::P}}}Push(This, "{{{RoutePaths::C_Path_ClubEditionInfo}}}", [
			"{{{RoutePaths::C_Query_Message}}}" => RBAC::GetGamePermissionMessage(RBAC::C_GamePermissionMessage_UseCustomSkin)
		]);
	}

	return State;
}

Void DownloadItem(K_State _State, Integer _Key) {
	if ({{{UserStore::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_UseCustomCollection)) {
		if (Platform::IsPC(System) && _State.Items.existskey(_Key)) {
			declare Text ItemId = _State.Items[_Key].ItemId;
			if (
				_State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_MapUpload &&
				_State.MapUploads.Maps.existskey(ItemId) &&
				Http.IsValidUrl(_State.MapUploads.Maps[ItemId].DownloadUrl)
			) {
				OpenLink(_State.MapUploads.Maps[ItemId].DownloadUrl, CMlScript::LinkType::ExternalBrowser);
			} else if (
				_State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_SkinUpload &&
				_State.SkinUploads.Skins.existskey(ItemId) &&
				Http.IsValidUrl(_State.SkinUploads.Skins[ItemId].FileUrl)
			) {
				OpenLink(_State.SkinUploads.Skins[ItemId].FileUrl, CMlScript::LinkType::ExternalBrowser);
			}
		}
	} else {
		{{{Router::P}}}SetParentPath(This, "{{{RoutePaths::C_Path_ClubEditionInfo}}}", {{{Router::P}}}GetCurrentParentPath(This));
		{{{Router::P}}}Push(This, "{{{RoutePaths::C_Path_ClubEditionInfo}}}", [
			"{{{RoutePaths::C_Query_Message}}}" => RBAC::GetGamePermissionMessage(RBAC::C_GamePermissionMessage_AddFavoriteItemCollections)
		]);
	}
}

K_State DisplayBrowser(K_State _State, Boolean _IsVisible) {
	declare K_State State = _State;
	
	// Need to refresh view when come back from the browser or destroy scene when entering in browser
	State = Display3DScene(State, State.ViewType == C_View_3D && !_IsVisible);

	// Lock/unlock the navigation
	LockNavigation(State, _IsVisible);

	// Disable ReportSystem when the Track Browser is visible
	if (_IsVisible) {
		State.CurrentReportData = ReportSystem::GetDataList();
		ReportSystem::RemoveUsingId("{{{C_Name}}}");
	} else if (PageIsVisible) {
		ReportSystem::AddUsingId("{{{C_Name}}}");
		ReportSystem::SetDataList(State.CurrentReportData);
	}

	switch (State.Activity.Type) {
		case {{{ClubStruct::P}}}C_ClubActivity_MapUpload: {
			{{{TrackBrowser::P}}}Display(This, _IsVisible, False);
			if (!_IsVisible) {
				UpdateControllerInfo(State, False);
				if (State.Items.count <= 0) {
					DisplayInfo(State, "{{{Text_NoMaps}}}", C_InfoType_Standard);
				}
			}
		}
		case {{{ClubStruct::P}}}C_ClubActivity_SkinUpload: {
			State.Controls.Frame_Browser.Visible = _IsVisible;
			if (_IsVisible) {
				// Initialize the browser only once we need it for the first time
				// instead of doing it in `MainStart` where it would cause a visible
				// lag during the compilation of the menu at the start of the game.
				if (State.BrowserIsInitialized) {
					{{{BrowserAPI::P}}}RefreshBrowserData(This);
				} else {
					declare BrowserSettings = {{{BrowserAPI::P}}}GetDefaultSettings();
					BrowserSettings.FilterByExtension.add("zip");
					{{{BrowserAPI::P}}}SetCurrentBrowser(This, 
						{{{BrowserAPI::C_BrowserType_PathNavigationSmall}}},
						"{{{BrowserAPI::C_BrowserName_Skin}}}",
						[{{{BrowserAPI::C_DataType_Skin}}}],
						"Models/CarSport/",
						BrowserSettings
					);
					State.BrowserIsInitialized = True;
				}
			} else if (State.Items.count <= 0) {
				DisplayInfo(State, "{{{Text_NoSkins}}}", C_InfoType_Standard);
			}
			{{{BrowserAPI::P}}}FocusBrowser(This, _IsVisible);
		}
	}

	return State;
}

K_State Select(K_State _State, CMlControl _Control) {
	if (_Control == Null || {{{Transition::P}}}IsInTransition(This)) return _State;
	declare K_State State = _State;

	DisplayInfo(_State, "", C_InfoType_Standard);
	switch (_Control.ControlId) {
		case "button-back": {{{Router::P}}}PushParent(This);
		case "button-upload-skin": State = DisplayBrowser(State, True);
		case "button-upload-map": State = DisplayBrowser(State, True);
		case "button-previous": State.SkinUploads.SkinsPager = Pager::GoToPreviousPage(State.SkinUploads.SkinsPager);
		case "button-next": State.SkinUploads.SkinsPager = Pager::GoToNextPage(State.SkinUploads.SkinsPager);
		case "button-apply": {	
			if (
				State.Items.existskey(Pager::GetIndex(State.SkinUploads.SkinsPager)) &&
				State.SkinUploads.Skins.existskey(State.Items[Pager::GetIndex(State.SkinUploads.SkinsPager)].ItemId)
			) {
				State = SetSkin(State, State.SkinUploads.Skins[State.Items[Pager::GetIndex(State.SkinUploads.SkinsPager)].ItemId]);
			}
		}
		case "button-remove": {
			if (UserCanHandleItems(State) && State.Items.existskey(Pager::GetIndex(State.SkinUploads.SkinsPager))) {
				DisplayInfo(State, "{{{Text_RemovingSkin}}}", C_InfoType_Loading);
				State.PostRemoveBucketItemsRequest = Http::DestroyAndCreate(
					State.PostRemoveBucketItemsRequest,
					ClubAPI::PostRemoveBucketItems(State.Activity.ClubId, State.Activity.Id, [State.Items[Pager::GetIndex(State.SkinUploads.SkinsPager)].ItemId])
				);
			}
		}
		case "button-add-garage": {
			if (
				State.Items.existskey(Pager::GetIndex(State.SkinUploads.SkinsPager)) &&
				State.SkinUploads.Skins.existskey(State.Items[Pager::GetIndex(State.SkinUploads.SkinsPager)].ItemId)
			) {
				State = SetSkinAsFavorite(State, State.SkinUploads.Skins[State.Items[Pager::GetIndex(State.SkinUploads.SkinsPager)].ItemId]);
			}
		}
		case "button-download-skin": {
			DownloadItem(State, Pager::GetIndex(State.SkinUploads.SkinsPager));
		}
		case "button-club": {
			if (State.Club.Id != {{{ClubStruct::P}}}C_ClubNullId) {
				if ({{{Router::P}}}GetCurrentParentPath(This) == "{{{RoutePaths::C_Path_ClubDetails}}}") {
					{{{Router::P}}}PushParent(This);
				} else {
					{{{Router::P}}}SetParentPath(This, "{{{RoutePaths::C_Path_ClubDetails}}}", {{{Router::P}}}GetCurrentParentPath(This));
					{{{Router::P}}}Push(This, "{{{RoutePaths::C_Path_ClubDetails}}}", ["{{{RoutePaths::C_Query_Club}}}" => State.Club.tojson()]);
				}
			}
		}
	}

	return State;
}

K_State GetFavoriteList(K_State _State) {
	declare K_State State = _State;

	State.SkinUploads.Task_GetFavoriteSkinList = Task::Destroy(State.SkinUploads.Task_GetFavoriteSkinList);
	// Check `/trackmania-next/tmnext/-/issues/1804` to see why it has been disabled for people without the right to use skins
	if ({{{UserStore::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_UseCustomSkin)) {
		State.SkinUploads.Task_GetFavoriteSkinList = Task::Create(DataFileMgr, DataFileMgr.AccountSkin_NadeoServices_GetFavoriteList(MainUser::GetMainUserId()));
	}

	return State;
}

K_State GetUserSkinList(K_State _State) {
	declare K_State State = _State;

	State.SkinUploads.Task_GetUserSkinList = Task::Destroy(State.SkinUploads.Task_GetUserSkinList);
	// Check `/trackmania-next/tmnext/-/issues/1804` to see why it has been disabled for people without the right to use skins
	if ({{{UserStore::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_UseCustomSkin)) {
		State.SkinUploads.Task_GetUserSkinList = Task::Create(DataFileMgr, DataFileMgr.AccountSkin_NadeoServices_GetList(MainUser::GetMainUserId()));
	}

	return State;
}

Void UpdateClubButton(K_State _State) {
	{{{ExpendableButton::P}}}SetText(This, _State.Controls.Button_Club, TL::Compose("{{{Text_Club}}}", _State.Club.Name));
	{{{ExpendableButton::P}}}SetVisibilityAndNavigation(_State.Controls.Button_Club, _State.Club.Name != "");
}

K_State AddOrRemoveFocusedTrackToFavorites(K_State _State, Integer _Key) {
	declare K_State State = _State;

	if (_State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_MapUpload && State.Items.existskey(_Key)) {
		declare Text ItemId = _State.Items[_Key].ItemId;
		if (_State.MapUploads.Maps.existskey(ItemId)) {
			State.TracksFavoriteStatus.CurrentTrackUid = State.MapUploads.Maps[ItemId].Uid;
			State.TracksFavoriteStatus.CurrentTrackName = State.MapUploads.Maps[ItemId].Name;
			DisplayInfo(State, "{{{Text_UpdatingFavoriteTrack}}}", C_InfoType_Loading);
			if (State.TracksFavoriteStatus.FavoritesTracksUids.exists(State.TracksFavoriteStatus.CurrentTrackUid)) {
				{{{MapStore::P}}}Action_RemoveMapFromFavorites(This, State.TracksFavoriteStatus.CurrentTrackUid);
			} else {
				{{{MapStore::P}}}Action_AddMapToFavorites(This, State.TracksFavoriteStatus.CurrentTrackUid);
			}
		}
	}

	return State;
}

K_State AddBucketItems(K_State _State) {
	declare K_State State = _State;

	if (State.MapUploads.MapsToUpload.count > 0) {
		declare Text[] ItemIdList;
		foreach (MapUid => Map in State.MapUploads.MapsToUpload) {
			ItemIdList.add(MapUid);
		}

		State.PostAddBucketItemsRequest = Http::DestroyAndCreate(
			State.PostAddBucketItemsRequest,
			ClubAPI::PostAddBucketItems(State.Activity.ClubId, State.Activity.Id, ItemIdList)
		);
		State.MapUploads.MapsToUpload = [];

		UpdateLoadingSpinner(State, "{{{Text_Uploading}}}", True, True);
	}

	return State;
}

K_State CheckTracksFavoriteStatus(K_State _State, Text[] _TrackUids) {
	declare K_State State = _State;
	declare Text[] UidsToCheck = [];	

	foreach (TrackUid in _TrackUids) {
		if (!State.TracksFavoriteStatus.FavoritesTracksUids.exists(TrackUid) && !UidsToCheck.exists(TrackUid)) {
			UidsToCheck.add(TrackUid);
		}
	}

	State.TracksFavoriteStatus.Request = Http::DestroyAndCreate(
		State.TracksFavoriteStatus.Request,
		MapAPI::GetMaps(UidsToCheck, True)
	);

	return State;
}

***MainInit***
***
declare CMlFrame Frame_Global;

declare K_State State;
declare Grid::K_GridConfig GridConfig;
declare Boolean IsMouse;
***

***MainStart***
***
Frame_Global <=> (Page.GetFirstChild("frame-global") as CMlFrame);

State = K_State {
	ViewType = C_View_List,
	BrowserIsInitialized = False,
	PostAddBucketItemsRequest = Http::GetEmptyRequest(),
	PostRemoveBucketItemsRequest = Http::GetEmptyRequest(),
	GetBucketActivityRequest = Http::GetEmptyRequest(),
	GetClubDetailRequest = Http::GetEmptyRequest(),
	GetClubMembershipRequest = Http::GetEmptyRequest(),
	Controls = K_Controls {
		Frame_Browser = (Page.GetFirstChild("frame-browser") as CMlFrame),
		Frame_Content = (Frame_Global.GetFirstChild("frame-content") as CMlFrame),
		Frame_ScrollItems = (Frame_Global.GetFirstChild("frame-scroll-items") as CMlFrame),
		Frame_SkinButtonsContainer = (Frame_Global.GetFirstChild("frame-skin-buttons-container") as CMlFrame),
		Frame_View3D = (Frame_Global.GetFirstChild("frame-view-3d") as CMlFrame),
		Frame_ViewList = (Frame_Global.GetFirstChild("frame-view-list") as CMlFrame),
		Button_AddToGarage = (Frame_Global.GetFirstChild("button-add-garage") as CMlFrame),
		Button_Apply = (Frame_Global.GetFirstChild("button-apply") as CMlFrame),
		Button_Back = (Frame_Global.GetFirstChild("button-back") as CMlFrame),
		Button_Club = (Frame_Global.GetFirstChild("button-club") as CMlFrame),
		Button_DownloadSkin = (Frame_Global.GetFirstChild("button-download-skin") as CMlFrame),
		Button_Next = (Frame_Global.GetFirstChild("button-next") as CMlFrame),
		Button_Previous = (Frame_Global.GetFirstChild("button-previous") as CMlFrame),
		Button_Remove = (Frame_Global.GetFirstChild("button-remove") as CMlFrame),
		Button_UploadMap = (Frame_Global.GetFirstChild("button-upload-map") as CMlFrame),
		Button_UploadSkin = (Frame_Global.GetFirstChild("button-upload-skin") as CMlFrame),
		Label_Info = (Frame_Global.GetFirstChild("label-info") as CMlLabel),
		Label_Title = (Frame_Global.GetFirstChild("label-title") as CMlLabel),
		LoadingSpinner_RetrieveInfo = (Frame_Global.GetFirstChild("loadingspinner-retrieve-info") as CMlFrame),
		LoadingSpinner_Upload = (Page.GetFirstChild("loadingspinner-upload") as CMlFrame)
	}
};

GridConfig.fromjson({{{"\"\"\""^GridConfigJson^"\"\"\""}}});
{{{TrackBrowser::P}}}SetMapTypeFilters(This, ["{{{Const::C_MapType_Race}}}"]);
***

***MainLoop***
***
if (PageIsVisible) {
	if (
		State.SkinUploads.Scene.SceneId != NullId &&
		MenuSceneManager::PageNeedToRecreateScene(Page, LocalUser)
	) {
		State = Display3DScene(State, False);
		State = Display3DScene(State, True);
	}

	foreach (Event in {{{Router::P}}}GetPendingEvents(This)) {
		switch (Event.Type) {
			case "{{{Router::C_Event_EnteringRoute}}}": {
				ReportSystem::AddUsingId("{{{C_Name}}}");
				declare Text[Text] Query = {{{Router::P}}}GetCurrentRouteQuery(This);
				if (Query.existskey("{{{RoutePaths::C_Query_Activity}}}")) {
					State.Activity.fromjson(Query["{{{RoutePaths::C_Query_Activity}}}"]);
					State.Controls.Label_Title.SetText(State.Activity.Name);
				}
				
				// Update view
				switch (State.Activity.Type) {
					case {{{ClubStruct::P}}}C_ClubActivity_MapUpload: State = SetView(State, GridConfig, C_View_List);
					case {{{ClubStruct::P}}}C_ClubActivity_SkinUpload: State = SetView(State, GridConfig, C_View_3D);
				}

				// Club info and report system
				State.Club = {{{ClubStruct::P}}}K_Club {};
				State.Membership = {{{ClubStruct::P}}}K_Member {};
				UpdateClubButton(State);
				if (State.Activity.ClubId != {{{ClubStruct::P}}}C_ClubNullId) {
					State.GetClubDetailRequest = Http::DestroyAndCreate(State.GetClubDetailRequest, ClubAPI::GetClub(State.Activity.ClubId));
					if ({{{Router::P}}}GetCurrentParentPath(This) == "{{{RoutePaths::C_Path_ClubDetails}}}") {
						ReportSystem::AddData(
							ReportStruct::C_ReportTarget_Club,
							ReportStruct::LibStructuresReport_K_ReportData {
								Details = [{{{ClubStore::P}}}GetUserCurrentClub().Name],
								Ids = [TL::ToText(State.Activity.ClubId)],
								Contexts = [["From" => "Menu BucketItemUploads"]]
							}
						);
					}

					ReportSystem::AddData(
						ReportStruct::C_ReportTarget_Activity,
						ReportStruct::LibStructuresReport_K_ReportData {
							Details = [State.Activity.Name],
							Ids = [TL::ToText(State.Activity.Id)],
							Contexts = [["From" => "Menu BucketItemUploads"]]
						}
					);
				}
			}
		}
	}

	/* BrowserAPI events */
	foreach (Event in {{{BrowserAPI::P}}}GetPendingEvents(This)) {
		switch (Event.Type) {
			case {{{BrowserAPI::P}}}C_EventType_Cancel: State = DisplayBrowser(State, False);
			case {{{BrowserAPI::P}}}C_EventType_Select: {
				State = DisplayBrowser(State, False);
				if (Event.DataType == {{{BrowserAPI::P}}}C_DataType_Skin) {
					declare Text Path = TL::Replace(Event.Data, "\\", "/");
					declare Text[] TmpSplit = TL::Split(".", Path);
					declare Text SkinName = TmpSplit[0];
					TmpSplit = TL::Split("/", SkinName);
					SkinName = TmpSplit[TmpSplit.count-1];

					UpdateLoadingSpinner(State, "{{{Text_Uploading}}}", True, True);
					State.SkinUploads.Task_RegisterSkin = Task::DestroyAndCreate(
						State.SkinUploads.Task_RegisterSkin, 
						DataFileMgr, 
						DataFileMgr.Skin_NadeoServices_Register(MainUser::GetMainUserId(), SkinName, Path)
					);
				}
			}
		}
	}

	/* TrackBrowser events */
	foreach (Event in {{{TrackBrowser::P}}}GetPendingEvents(This)) {
		switch (Event.Type) {
			case {{{TrackBrowser::P}}}C_Event_Exit: State = DisplayBrowser(State, False);
			case {{{TrackBrowser::P}}}C_Event_MultiSelect: {
				State.MapUploads.MapsToUpload = [];
				foreach (Task in State.MapUploads.Task_RegisterMapList) Task::Destroy(Task);
				State.MapUploads.Task_RegisterMapList = [];
				foreach (Map in Event.MultiTracks) {
					State.MapUploads.MapsToUpload[Map.Uid] = Map;
					if (Map.DownloadUrl == "") { //< Do not register map already registered
						State.MapUploads.Task_RegisterMapList[Map.Uid] = Task::Create(DataFileMgr, DataFileMgr.Map_NadeoServices_Register(MainUser::GetMainUserId(), Map.Uid));
					}
				}

				if (State.MapUploads.Task_RegisterMapList.count > 0) {
					UpdateLoadingSpinner(State, "{{{Text_Uploading}}}", True, True);
				} else {
					State = AddBucketItems(State); 
				}

				State = DisplayBrowser(State, False);
			}
		}
	}

	/* Report system events */
	foreach (Event in ReportSystem::GetPendingEvents()) {
		if (Event.LastUsingId == "{{{C_Name}}}") {
			switch (Event.Type) {
				case ReportSystem::C_EventType_Open: LockNavigation(State, True);
				case ReportSystem::C_EventType_Close: {
					UpdateControllerInfo(State, {{{Scroll::P}}}IsFocused(State.Controls.Frame_ScrollItems));
					LockNavigation(State, False);
				}
			}
		}
	}

	/* Navigation events */
	foreach (Event in {{{Navigation::P}}}GetPendingEvents(This)) {
		switch (Event.Type) {
			case {{{Navigation::P}}}C_EventType_NavigateInput: {
				if ({{{Navigation::P}}}IsEventFromGroup(This, Event, "{{{C_NavGroup_Global}}}")) {
					switch (Event.Input) {
						case CMlScriptEvent::EMenuNavAction::Cancel: {{{Router::P}}}PushParent(This);
					}
				} else if ({{{Navigation::P}}}IsEventFromGroup(This, Event, "{{{C_NavGroup_Default}}}")) {
					switch (Event.Input) {
						case CMlScriptEvent::EMenuNavAction::Select: State = Select(State, Event.To);
						default: {
							if (Event.Input == CMlScriptEvent::EMenuNavAction::Left && State.Controls.Button_Previous.Visible) {
								State = Select(State, State.Controls.Button_Previous);
							} else if (Event.Input == CMlScriptEvent::EMenuNavAction::Right && State.Controls.Button_Next.Visible) {
								State = Select(State, State.Controls.Button_Next);
							} else {
								Focus(State, Event.From, Event.To);
							}
						}
					}
				}
			}
			case {{{Navigation::P}}}C_EventType_NavigateMouse: {
				if ({{{Navigation::P}}}IsEventFromGroup(This, Event, "{{{C_NavGroup_Default}}}")) {
					switch (Event.Mouse) {
						case CMlScriptEvent::Type::MouseClick: State = Select(State, Event.To);
						case CMlScriptEvent::Type::MouseOver: Focus(State, Event.From, Event.To);
					}
				} else if ({{{Navigation::P}}}IsEventFromGroup(This, Event, "{{{C_NavGroup_MouseOnly}}}")) {
					switch (Event.Mouse) {
						case CMlScriptEvent::Type::MouseClick: State = Select(State, Event.To);
						case CMlScriptEvent::Type::MouseOver: Focus(State, Event.From, Event.To);
						case CMlScriptEvent::Type::MouseOut: Focus(State, Event.From, Event.To);
					}
				}
			}
		}
	}

	/* ClubStore events */
	foreach (Event in PendingEvents) {
		switch (Event.Type) {
			case CMlScriptEvent::Type::PluginCustomEvent: {
				switch (Event.CustomEventType) {
					case {{{MapStore::P}}}C_Event_CurrentMapUpdated: {			
						declare {{{MapStore::P}}}K_CurrentMap CurrentMap = {{{MapStore::P}}}GetCurrentMap();					
						// Display error if necessary
						if (CurrentMap.Status == {{{MapStore::P}}}C_CurrentMapStatus_Error) {
							if (CurrentMap.ErrorCode == {{{MapStore::P}}}C_ErrorCode_FailedRemoveFavorites) {
								//L16N Error while removing a track from the player's favorites. e.g %1 will be replaced by the track name and %2 by a code. e.g "Error while removing the track 'Ice circuit' from your favorites. (Error code: 500)"
								DisplayInfo(State, TL::Compose(_("Error while removing the track '%1' from your favorites. (Error code: %2)"), "$<"^Tools::FormatValue(State.TracksFavoriteStatus.CurrentTrackName)^"$>", Error::C_Code_BucketItemUploads_RemoveFavoriteMap), C_InfoType_Error);
							} else if (CurrentMap.ErrorCode == {{{MapStore::P}}}C_ErrorCode_FailedAddFavorites) {
								//L16N Error while adding a track to the player's favorites. e.g %1 will be replaced by the track name and %2 by a code. e.g "Error while adding the track 'Ice circuit' to your favorites. (Error code: 500)"
								DisplayInfo(State, TL::Compose(_("Error while adding the track '%1' to your favorites. (Error code: %2)"), "$<"^Tools::FormatValue(State.TracksFavoriteStatus.CurrentTrackName)^"$>", Error::C_Code_BucketItemUploads_AddFavoriteMap), C_InfoType_Error);
							}
						} else if (CurrentMap.Status == {{{MapStore::P}}}C_CurrentMapStatus_Success && State.TracksFavoriteStatus.CurrentTrackUid == CurrentMap.Uid) {
							if (CurrentMap.IsFavorite) {
								State.TracksFavoriteStatus.FavoritesTracksUids.add(State.TracksFavoriteStatus.CurrentTrackUid);
							} else {
								State.TracksFavoriteStatus.FavoritesTracksUids.remove(State.TracksFavoriteStatus.CurrentTrackUid);
							}
							// To update favorite icons in the tracks scroll
							{{{Scroll::P}}}SetElementsTotal(This, State.Controls.Frame_ScrollItems, State.MapUploads.Total);
						}

						// Reset map uid and name at the end
						if (CurrentMap.Status == {{{MapStore::P}}}C_CurrentMapStatus_Success || CurrentMap.Status == {{{MapStore::P}}}C_CurrentMapStatus_Error) {
							State.TracksFavoriteStatus.CurrentTrackUid = "";
							State.TracksFavoriteStatus.CurrentTrackName = "";
						}
					}					
				}
			}
		}
	}

	/* Get club details */
	if (Http::IsInitialized(State.GetClubDetailRequest)) {
		State.GetClubDetailRequest = Http::Update(State.GetClubDetailRequest);
		if (!Http::IsRunning(State.GetClubDetailRequest)) {
			if (Http::IsSuccess(State.GetClubDetailRequest)) {
				State.Club = ClubAPI::GetResponseFromGetClub(State.GetClubDetailRequest);
				State.GetClubMembershipRequest = Http::DestroyAndCreate(State.GetClubMembershipRequest, ClubAPI::GetClubMemberWithId(State.Club.Id, LocalUser.WebServicesUserId));
				UpdateClubButton(State);
				if (State.Club.Id != {{{ClubStruct::P}}}C_ClubNullId) {
					ReportSystem::AddData(
						ReportStruct::C_ReportTarget_Club,
						ReportStruct::LibStructuresReport_K_ReportData {
							Details = [State.Club.Name],
							Ids = [TL::ToText(State.Club.Id)],
							Contexts = [["From" => "Menu BucketItemUploads"]]
						}
					);
				}
			}
			State.GetClubDetailRequest = Http::Destroy(State.GetClubDetailRequest);
		}
	}

	/* Get club membership */
	if (Http::IsInitialized(State.GetClubMembershipRequest)) {
		State.GetClubMembershipRequest = Http::Update(State.GetClubMembershipRequest);
		if (!Http::IsRunning(State.GetClubMembershipRequest)) {
			if (Http::IsSuccess(State.GetClubMembershipRequest)) {
				State.Membership = ClubAPI::GetResponseFromGetClubMemberWithId(State.GetClubMembershipRequest);
			}
			State.GetClubMembershipRequest = Http::Destroy(State.GetClubMembershipRequest);
			{{{ExpendableButton::P}}}SetVisibilityAndNavigation(State.Controls.Button_UploadMap, UserCanHandleItems(State) && State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_MapUpload);
			if (State.ViewType == C_View_3D) {
				UpdateSkinUploadButtons(State, GridConfig);
			}
		}
	}

	/* Check all tracks favorite status */
	if (Http::IsInitialized(State.TracksFavoriteStatus.Request)) {
		State.TracksFavoriteStatus.Request = Http::Update(State.TracksFavoriteStatus.Request);
		if (!Http::IsRunning(State.TracksFavoriteStatus.Request)) {
			if (Http::IsSuccess(State.TracksFavoriteStatus.Request)) {
				declare Response = MapAPI::GetResponseFromGetMaps(State.TracksFavoriteStatus.Request);
				foreach (I => Track in State.MapUploads.Maps) {
					if (Response.Maps.existskey(Track.Uid) && Response.Maps[Track.Uid].IsFavorite) {
						State.TracksFavoriteStatus.FavoritesTracksUids.add(Track.Uid);
					}
				}
				// To update favorite icons in the tracks scroll
				{{{Scroll::P}}}SetElementsTotal(This, State.Controls.Frame_ScrollItems, State.MapUploads.Total);
			}
			State.TracksFavoriteStatus.Request = Http::Destroy(State.TracksFavoriteStatus.Request);
			{{{LoadingSpinner::P}}}StopAnimWithFade(This, State.Controls.LoadingSpinner_RetrieveInfo);
		}
	}

	/* Register maps request */
	declare Task::K_Task[Text] TmpTask = State.MapUploads.Task_RegisterMapList;
	foreach (MapUid => Task_RegisterMap in TmpTask) {
		if (Task::IsInitialized(Task_RegisterMap)) {
			State.MapUploads.Task_RegisterMapList[MapUid] = Task::Update(Task_RegisterMap);
			if (!Task::IsRunning(State.MapUploads.Task_RegisterMapList[MapUid])) {
				declare CTaskResult_NSMap SourceTask = Task::GetSourceTask_NSMap(State.MapUploads.Task_RegisterMapList[MapUid]);
				if (Task::IsSuccess(State.MapUploads.Task_RegisterMapList[MapUid]) && SourceTask != Null) {
					State.MapUploads.Task_RegisterMapList.removekey(MapUid);
					if (State.MapUploads.Task_RegisterMapList.count <= 0) {
						State = AddBucketItems(State); 
					}
				} else {
					//L16N [MapUploads] Message displayed when the track cannot be uploaded. %1 will be replaced by the name of the track, %2 will be replaced by an error code.
					DisplayInfo(State, TL::Compose(_("Track '%1' could not be uploaded. Please try again. (Error: %2)"), FilterProfanities(State.MapUploads.MapsToUpload.get(MapUid, {{{CampaignStruct::P}}}K_Map {}).Name), SourceTask.ErrorCode), C_InfoType_Error);
					foreach (Task in State.MapUploads.Task_RegisterMapList) Task::Destroy(Task);
					State.MapUploads.Task_RegisterMapList.clear();
					UpdateLoadingSpinner(State, "", False, True);
					break;
				}
				Task::Destroy(Task_RegisterMap);
			}
		}
	}

	/* Register skin request */
	if (Task::IsInitialized(State.SkinUploads.Task_RegisterSkin)) {
		State.SkinUploads.Task_RegisterSkin = Task::Update(State.SkinUploads.Task_RegisterSkin);
		if (!Task::IsRunning(State.SkinUploads.Task_RegisterSkin)) {
			declare CTaskResult_NSSkin SourceTask = Task::GetSourceTask_NSSkin(State.SkinUploads.Task_RegisterSkin);
			if (Task::IsSuccess(State.SkinUploads.Task_RegisterSkin) && SourceTask != Null) {
				State.PostAddBucketItemsRequest = Http::DestroyAndCreate( //< Send skin Id to LIVE
					State.PostAddBucketItemsRequest,
					ClubAPI::PostAddBucketItems(State.Activity.ClubId, State.Activity.Id, [SourceTask.Skin.Id])
				);
			} else {
				//L16N [SkinUploads] Message displayed when there is an error while uploading the skin. %1 will be replaced with an error code.
				DisplayInfo(State, TL::Compose(_("Skin upload failed. (Error: %1)"), SourceTask.ErrorCode), C_InfoType_Error);
				UpdateLoadingSpinner(State, "", False, True);
			}
			State.SkinUploads.Task_RegisterSkin = Task::Destroy(State.SkinUploads.Task_RegisterSkin);
		}
	}

	/* Add item request */
	if (Http::IsInitialized(State.PostAddBucketItemsRequest)) {
		State.PostAddBucketItemsRequest = Http::Update(State.PostAddBucketItemsRequest);
		if (!Http::IsRunning(State.PostAddBucketItemsRequest)) {
			if (Http::IsSuccess(State.PostAddBucketItemsRequest)) {
				if (State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_MapUpload)	{
					//L16N [MapUploads] Message displayed when a track has successfully been uploaded in the club activity.
					DisplayInfo(State, _("Tracks have successfully been uploaded!"), C_InfoType_Success);
					{{{Scroll::P}}}TriggerPagerUpdate(State.Controls.Frame_ScrollItems);
				}	else if (State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_SkinUpload) {
					//L16N [SkinUploads] Message displayed when a skin has successfully been uploaded in the club activity.
					DisplayInfo(State, _("Skins have successfully been uploaded!"), C_InfoType_Success);
					State.SkinUploads.SkinsPager = Pager::ForceRangeUpdate(State.SkinUploads.SkinsPager);
					State.SkinUploads.SkinsPager = Pager::SetIndex(State.SkinUploads.SkinsPager, 0); // new skin will be uploaded in first position
				}
			} else if (State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_MapUpload)	{
				//L16N [MapUploads] Message displayed when the track cannot be uploaded. %1 will be replaced by an error code.
				DisplayInfo(State, TL::Compose(_("Tracks could not be uploaded. Please try again. (Error: %1)"), ""^Http::GetStatusCode(State.PostAddBucketItemsRequest)), C_InfoType_Error);
			}	else if (State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_SkinUpload) {
				//L16N [SkinUploads] Message displayed when the skin cannot be uploaded. %1 will be replaced by an error code.
				DisplayInfo(State, TL::Compose(_("Skins could not be uploaded. Please try again. (Error: %1)"), ""^Http::GetStatusCode(State.PostAddBucketItemsRequest)), C_InfoType_Error);
			}
			State.PostAddBucketItemsRequest = Http::Destroy(State.PostAddBucketItemsRequest);
			UpdateLoadingSpinner(State, "", False, True);
		}
	}

	/* Remove item request */
	if (Http::IsInitialized(State.PostRemoveBucketItemsRequest)) {
		State.PostRemoveBucketItemsRequest = Http::Update(State.PostRemoveBucketItemsRequest);
		if (!Http::IsRunning(State.PostRemoveBucketItemsRequest)) {
			if (Http::IsSuccess(State.PostRemoveBucketItemsRequest)) {
				{{{LoadingSpinner::P}}}StopAnimWithFade(This, State.Controls.LoadingSpinner_RetrieveInfo);
				if (State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_MapUpload)	{
					{{{Scroll::P}}}TriggerPagerUpdate(State.Controls.Frame_ScrollItems);
				} else if (State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_SkinUpload) {
					State.SkinUploads.SkinsPager = Pager::ForceRangeUpdate(State.SkinUploads.SkinsPager);
				}
			} else {
				declare Text ErrorMessage = "";
				if (State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_MapUpload)	{
					//L16N [MapUploads] Message displayed when the track cannot be removed. %1 will be replaced by an error code.
					ErrorMessage = _("Track could not be removed. Please try again. (Error: %1)");
				}	else if (State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_SkinUpload) {
					//L16N [SkinUploads] Message displayed when the skin cannot be removed. %1 will be replaced by an error code.
					ErrorMessage = _("Skin could not be removed. Please try again. (Error: %1)");
				}
				DisplayInfo(State, TL::Compose(ErrorMessage, ""^Http::GetStatusCode(State.PostAddBucketItemsRequest)), C_InfoType_Error);
			}
			State.PostRemoveBucketItemsRequest = Http::Destroy(State.PostRemoveBucketItemsRequest);
		}
	}

	/* Update skins pager and check if the range changed */
	if (State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_SkinUpload) {
		State.SkinUploads.SkinsPager = Pager::Update(State.SkinUploads.SkinsPager);
		if (Pager::RangeUpdated(State.SkinUploads.SkinsPager)) {
			State.SkinUploads.SkinsPager = Pager::ProcessRangeUpdate(State.SkinUploads.SkinsPager);
			DisplayInfo(State, "{{{Text_Retrieving}}}", C_InfoType_Loading);
			State.GetBucketActivityRequest = Http::DestroyAndCreate(
				State.GetBucketActivityRequest,
				ClubAPI::GetBucketActivity(
					State.Activity.ClubId,
					State.Activity.Id,
					Pager::GetRangeOffset(State.SkinUploads.SkinsPager),
					Pager::GetRangeLength(State.SkinUploads.SkinsPager)
				)
			);
		}
		if (Pager::PageUpdated(State.SkinUploads.SkinsPager)) {
			State.SkinUploads.SkinsPager = Pager::ProcessPageUpdate(State.SkinUploads.SkinsPager);
			State = UpdateSkinDisplayed(State, Pager::GetIndex(State.SkinUploads.SkinsPager));
		}
	}

	/* Pager request (maps and skins) */
	if (Http::IsInitialized(State.GetBucketActivityRequest)) {
		State.GetBucketActivityRequest = Http::Update(State.GetBucketActivityRequest);
		if (!Http::IsRunning(State.GetBucketActivityRequest)) {
			State.Items = [];
			if (Http::IsSuccess(State.GetBucketActivityRequest)) {
				declare BucketActivity = ClubAPI::GetResponseFromGetBucketActivity(State.GetBucketActivityRequest);

				switch (State.Activity.Type) {
					case {{{ClubStruct::P}}}C_ClubActivity_MapUpload: {
						declare Text[] MapUidList;
						State.MapUploads.Total = BucketActivity.BucketItemCount;
						foreach (Key => BucketItem in BucketActivity.BucketItemList) {
							State.Items[BucketItem.Position] = BucketItem;
							if (!State.MapUploads.Maps.existskey(BucketItem.ItemId)) {
								State.MapUploads.Maps[BucketItem.ItemId] = {{{CampaignStruct::P}}}K_Map {
									Uid = BucketItem.ItemId,
									Position = BucketItem.Position
								};
								MapUidList.add(BucketItem.ItemId);
							}
						}

						if (MapUidList.count > 0) {
							State.MapUploads.Task_GetMapList = Task::DestroyAndCreate(
								State.MapUploads.Task_GetMapList, 
								DataFileMgr, 
								DataFileMgr.Map_NadeoServices_GetListFromUid(MainUser::GetMainUserId(), MapUidList)
							);
						} else {
							{{{Scroll::P}}}SetElementsTotal(This, State.Controls.Frame_ScrollItems, State.MapUploads.Total);
							{{{LoadingSpinner::P}}}StopAnimWithFade(This, State.Controls.LoadingSpinner_RetrieveInfo);
							if (State.Items.count <= 0) DisplayInfo(State, "{{{Text_NoMaps}}}", C_InfoType_Standard);
						}
					}
					case {{{ClubStruct::P}}}C_ClubActivity_SkinUpload: {
						declare Integer PagerTotal = Pager::GetTotal(State.SkinUploads.SkinsPager);
						declare Text[] SkinIdList;

						foreach (Key => BucketItem in BucketActivity.BucketItemList) {
							State.Items[BucketItem.Position] = BucketItem;
							SkinIdList.add(BucketItem.ItemId);
						}

						if (PagerTotal != BucketActivity.BucketItemCount) {
							State.SkinUploads.SkinsPager = Pager::SetTotal(State.SkinUploads.SkinsPager, BucketActivity.BucketItemCount);
							if (BucketActivity.BucketItemCount <= 0 || PagerTotal <= 0) {
								UpdateSkinUploadButtons(State, GridConfig);
							}
						}

						if (SkinIdList.count > 0) {
							State.SkinUploads.Task_GetSkinList = Task::DestroyAndCreate(
								State.SkinUploads.Task_GetSkinList, 
								DataFileMgr, 
								DataFileMgr.Skin_NadeoServices_GetList(MainUser::GetMainUserId(), SkinIdList)
							);
						} else {
							{{{LoadingSpinner::P}}}StopAnimWithFade(This, State.Controls.LoadingSpinner_RetrieveInfo);
							if (State.Items.count <= 0) DisplayInfo(State, "{{{Text_NoSkins}}}", C_InfoType_Standard);
							State = Display3DScene(State, False);
						}
					}
					default: {
						{{{Scroll::P}}}SetElementsTotal(This, State.Controls.Frame_ScrollItems, 0);
						{{{LoadingSpinner::P}}}StopAnimWithFade(This, State.Controls.LoadingSpinner_RetrieveInfo);
					}
				}
			}

			State.GetBucketActivityRequest = Http::Destroy(State.GetBucketActivityRequest);
		}
	}

	/* Get map list task */
	if (Task::IsInitialized(State.MapUploads.Task_GetMapList)) {
		State.MapUploads.Task_GetMapList = Task::Update(State.MapUploads.Task_GetMapList);
		if (!Task::IsRunning(State.MapUploads.Task_GetMapList)) {
			declare CTaskResult_NSMapList SourceTask = Task::GetSourceTask_NSMapList(State.MapUploads.Task_GetMapList);
			if (Task::IsSuccess(State.MapUploads.Task_GetMapList) && SourceTask != Null) {
				declare Text[] MapUids = [];
				foreach (NSMap in SourceTask.MapList) {
					State.MapUploads.Maps[NSMap.Uid] = {{{CampaignStruct::P}}}GetMapFromNSMap(State.MapUploads.Maps.get(NSMap.Uid, {{{CampaignStruct::P}}}K_Map {}), NSMap);
					MapUids.add(NSMap.Uid);
				}
				State = CheckTracksFavoriteStatus(State, MapUids);
			} else {
				//L16N [MapUploads] Message displayed when tracks cannot be fetched from Ubisoft servers. %1 will be replaced by an internal error code. e.g. "Error while fetching tracks, please try again. \n(Error code: 32354)".
				DisplayInfo(State, TL::Compose(_("Error while fetching tracks, please try again. (Error code: %1)"), SourceTask.ErrorCode), C_InfoType_Error);
			}
			State.MapUploads.Task_GetMapList = Task::Destroy(State.MapUploads.Task_GetMapList);
			{{{Scroll::P}}}SetElementsTotal(This, State.Controls.Frame_ScrollItems, State.MapUploads.Total);
		}
	}

	/* Get skin list task */
	if (Task::IsInitialized(State.SkinUploads.Task_GetSkinList)) {
		State.SkinUploads.Task_GetSkinList = Task::Update(State.SkinUploads.Task_GetSkinList);
		if (!Task::IsRunning(State.SkinUploads.Task_GetSkinList)) {
			declare CTaskResult_NSSkinList SourceTask = Task::GetSourceTask_NSSkinList(State.SkinUploads.Task_GetSkinList);
			if (Task::IsSuccess(State.SkinUploads.Task_GetSkinList) && SourceTask != Null) {
				foreach (NSSkin in SourceTask.SkinList) {
					State.SkinUploads.Skins[NSSkin.Id] = {{{ClubStruct::P}}}GetSkinFromNSSkin(NSSkin);
				}
				State = GetFavoriteList(State);
				State = GetUserSkinList(State);
				if (!Task::IsInitialized(State.SkinUploads.Task_GetUserSkinList) && !Task::IsInitialized(State.SkinUploads.Task_GetFavoriteSkinList)) {
					State = UpdateSkinDisplayed(State, Pager::GetIndex(State.SkinUploads.SkinsPager));
					{{{LoadingSpinner::P}}}StopAnimWithFade(This, State.Controls.LoadingSpinner_RetrieveInfo);
				}
			} else {
				//L16N [SkinUploads] Message displayed when skins cannot be fetched from Ubisoft servers. %1 will be replaced by an internal error code. e.g. "Error while fetching skins, please try again. \n(Error code: 32354)".
				DisplayInfo(State, TL::Compose(_("Error while fetching skins, please try again. (Error code: %1)"), SourceTask.ErrorCode), C_InfoType_Error);
			}
			State.SkinUploads.Task_GetSkinList = Task::Destroy(State.SkinUploads.Task_GetSkinList);
		}
	}

	/* Get user favorite skin list task */
	if (Task::IsInitialized(State.SkinUploads.Task_GetFavoriteSkinList)) {
		State.SkinUploads.Task_GetFavoriteSkinList = Task::Update(State.SkinUploads.Task_GetFavoriteSkinList);
		if (!Task::IsRunning(State.SkinUploads.Task_GetFavoriteSkinList)) {
			declare CTaskResult_NSSkinList SourceTask = Task::GetSourceTask_NSSkinList(State.SkinUploads.Task_GetFavoriteSkinList);
			if (Task::IsSuccess(State.SkinUploads.Task_GetFavoriteSkinList) && SourceTask != Null) {
				foreach (SkinId => Skin in State.SkinUploads.Skins) {
					State.SkinUploads.Skins[SkinId].IsFavorite = False;
				}
				foreach (NSSkin in SourceTask.SkinList) {
					if (State.SkinUploads.Skins.existskey(NSSkin.Id)) {
						State.SkinUploads.Skins[NSSkin.Id].IsFavorite = True;
					}
				}
				if (!Task::IsInitialized(State.SkinUploads.Task_GetUserSkinList)) {
					State = UpdateSkinDisplayed(State, Pager::GetIndex(State.SkinUploads.SkinsPager));
					{{{LoadingSpinner::P}}}StopAnimWithFade(This, State.Controls.LoadingSpinner_RetrieveInfo);
				}
			} else {
				//L16N [SkinUploads] Message displayed when player favorite skins cannot be fetched from Ubisoft servers. %1 will be replaced by an internal error code. e.g. "Error while fetching your favorite skins, please try again. \n(Error code: 32354)".
				DisplayInfo(State, TL::Compose(_("Error while fetching your favorite skins, please try again. (Error code: %1)"), SourceTask.ErrorCode), C_InfoType_Error);
			}
			State.SkinUploads.Task_GetFavoriteSkinList = Task::Destroy(State.SkinUploads.Task_GetFavoriteSkinList);
		}
	}

	/* Get user skin list task */
	if (Task::IsInitialized(State.SkinUploads.Task_GetUserSkinList)) {
		State.SkinUploads.Task_GetUserSkinList = Task::Update(State.SkinUploads.Task_GetUserSkinList);
		if (!Task::IsRunning(State.SkinUploads.Task_GetUserSkinList)) {
			declare CTaskResult_NSSkinList SourceTask = Task::GetSourceTask_NSSkinList(State.SkinUploads.Task_GetUserSkinList);
			if (Task::IsSuccess(State.SkinUploads.Task_GetUserSkinList) && SourceTask != Null) {
				foreach (SkinId => Skin in State.SkinUploads.Skins) {
					State.SkinUploads.Skins[SkinId].IsUsed = False;
				}
				foreach (NSSkin in SourceTask.SkinList) {
					if (State.SkinUploads.Skins.existskey(NSSkin.Id)) {
						State.SkinUploads.Skins[NSSkin.Id].IsUsed = True;
						State.SkinUploads.Skins[NSSkin.Id].IsFavorite = True;
					}
				}
				if (!Task::IsInitialized(State.SkinUploads.Task_GetFavoriteSkinList)) {
					State = UpdateSkinDisplayed(State, Pager::GetIndex(State.SkinUploads.SkinsPager));
					{{{LoadingSpinner::P}}}StopAnimWithFade(This, State.Controls.LoadingSpinner_RetrieveInfo);
				}
			} else {
				//L16N [SkinUploads] Message displayed when player skins cannot be fetched from Ubisoft servers. %1 will be replaced by an internal error code. e.g. "Error while fetching your skins, please try again. \n(Error code: 32354)".
				DisplayInfo(State, TL::Compose(_("Error while fetching your skins, please try again. (Error code: %1)"), SourceTask.ErrorCode), C_InfoType_Error);
			}
			State.SkinUploads.Task_GetUserSkinList = Task::Destroy(State.SkinUploads.Task_GetUserSkinList);
		}
	}

	/* Set favorite skin task */
	if (Task::IsInitialized(State.SkinUploads.Task_SetUnsetFavoriteSkin)) {
		State.SkinUploads.Task_SetUnsetFavoriteSkin = Task::Update(State.SkinUploads.Task_SetUnsetFavoriteSkin);
		if (!Task::IsRunning(State.SkinUploads.Task_SetUnsetFavoriteSkin)) {
			declare CTaskResult SourceTask = Task::GetSourceTask(State.SkinUploads.Task_SetUnsetFavoriteSkin);
			if (Task::IsSuccess(State.SkinUploads.Task_SetUnsetFavoriteSkin) && SourceTask != Null) {
				declare Text[Text] Metadata = Task::GetMetadata(State.SkinUploads.Task_SetUnsetFavoriteSkin);
				declare Text SkinId = Metadata.get("AddFavorite", Metadata.get("RemoveFavorite", ""));
				if (State.SkinUploads.Skins.existskey(SkinId)) {
					State.SkinUploads.Skins[SkinId].IsFavorite = Metadata.existskey("AddFavorite");
					State = UpdateSkinDisplayed(State, Pager::GetIndex(State.SkinUploads.SkinsPager));
					{{{LoadingSpinner::P}}}StopAnimWithFade(This, State.Controls.LoadingSpinner_RetrieveInfo);
				} else {
					State = GetFavoriteList(State);
				}
			} else {
				//L16N [SkinUploads] Message displayed when the selected skin cannot be added or removed from player skins. %1 goes for the type of error.
				DisplayInfo(State, TL::Compose(_("Error while adding or removing the skin, please try again. (Error code: %1)"), SourceTask.ErrorCode), C_InfoType_Error);
			}
			State.SkinUploads.Task_SetUnsetFavoriteSkin = Task::ResetMetadata(State.SkinUploads.Task_SetUnsetFavoriteSkin);
			State.SkinUploads.Task_SetUnsetFavoriteSkin = Task::Destroy(State.SkinUploads.Task_SetUnsetFavoriteSkin);
		}
	}

	/* Set skin task */
	if (Task::IsInitialized(State.SkinUploads.Task_SetUnsetSkin)) {
		State.SkinUploads.Task_SetUnsetSkin = Task::Update(State.SkinUploads.Task_SetUnsetSkin);
		if (!Task::IsRunning(State.SkinUploads.Task_SetUnsetSkin)) {
			declare CTaskResult SourceTask = Task::GetSourceTask(State.SkinUploads.Task_SetUnsetSkin);
			if (Task::IsSuccess(State.SkinUploads.Task_SetUnsetSkin) && SourceTask != Null) {
				if (!UserMgr.MainUserProfile.User_CombinePrestigeAndSkins && LocalUser.Prestige_SkinOptions != "") { //< Remove prestige if the combine feature is not enabled
					State.SkinUploads.Task_UnsetPrestige = Task::DestroyAndCreate(State.SkinUploads.Task_UnsetPrestige, UserMgr, UserMgr.Prestige_ResetCurrentAccountPrestige(MainUser::GetMainUserId()));
				} else {
					//L16N [SkinUploads] Message displayed when the selected skin has successfully been applied to the player's car.
					DisplayInfo(State, _("Skin successfully applied!"), C_InfoType_Success);
					State = GetUserSkinList(State);
				}
			} else {
				//L16N [SkinUploads] Message displayed when the selected skin cannot be applied on the car. %1 will be replaced by an internal error code. e.g. "Error while applying the skin, please try again. (Error code: 32354)".
				DisplayInfo(State, TL::Compose(_("Error while applying the skin, please try again. (Error code: %1)"), SourceTask.ErrorCode), C_InfoType_Error);
			}
			State.SkinUploads.Task_SetUnsetSkin = Task::Destroy(State.SkinUploads.Task_SetUnsetSkin);
		}
	}

	/* Unset prestige task */
	if (Task::IsInitialized(State.SkinUploads.Task_UnsetPrestige)) {
		State.SkinUploads.Task_UnsetPrestige = Task::Update(State.SkinUploads.Task_UnsetPrestige);
		if (!Task::IsRunning(State.SkinUploads.Task_UnsetPrestige)) {
			declare CTaskResult_UserPrestige SourceTask = Task::GetSourceTask_UserPrestige(State.SkinUploads.Task_UnsetPrestige);
			if (Task::IsSuccess(State.SkinUploads.Task_UnsetPrestige) && SourceTask != Null) {
				//L16N [SkinUploads] Message displayed when the selected skin has successfully been applied to the player's car.
				DisplayInfo(State, _("Skin successfully applied!"), C_InfoType_Success);
				State = GetUserSkinList(State);
			} else {
				//L16N [SkinUploads] Message displayed when the selected skin cannot be applied on the car. %1 will be replaced by an internal error code. e.g. "Error while applying the skin, please try again. (Error code: 32354)".
				DisplayInfo(State, TL::Compose(_("Error while applying the skin, please try again. (Error code: %1)"), SourceTask.ErrorCode), C_InfoType_Error);
			}
			State.SkinUploads.Task_UnsetPrestige = Task::Destroy(State.SkinUploads.Task_UnsetPrestige);
		}
	}

	/* Scroll events */
	foreach (Event in {{{Scroll::P}}}GetPendingEvents(This)) {
		if (Event.Scroll != Null && Event.Scroll.Id == State.Controls.Frame_ScrollItems.Id && State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_MapUpload) {
			switch (Event.Type) {
				case {{{Scroll::P}}}C_EventType_Select: {
					if ({{{UserStore::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_PlayLocalMap)) {
						if (State.Items.existskey(Event.ToKey) && State.MapUploads.Maps.existskey(State.Items[Event.ToKey].ItemId)) {
							PlayMap(State, State.MapUploads.Maps[State.Items[Event.ToKey].ItemId]);
						}
					} else {
						{{{Router::P}}}SetParentPath(This, "{{{RoutePaths::C_Path_ClubEditionInfo}}}", {{{Router::P}}}GetCurrentParentPath(This));
						{{{Router::P}}}Push(This, "{{{RoutePaths::C_Path_ClubEditionInfo}}}", [
							"{{{RoutePaths::C_Query_Message}}}" => RBAC::GetGamePermissionMessage(RBAC::C_GamePermissionMessage_PlayLocalMap)
						]);
					}
				}
				case {{{Scroll::P}}}C_EventType_PagerUpdate: {
					State.GetBucketActivityRequest = Http::DestroyAndCreate(
						State.GetBucketActivityRequest,
						ClubAPI::GetBucketActivity(
							State.Activity.ClubId,
							State.Activity.Id,
							Event.PagerOffset,
							Event.PagerCount
						)
					);
				}
				case {{{Scroll::P}}}C_EventType_Update: {
					declare Text[] MapUids;
					
					foreach (Key => Frame_Element in Event.ElementsVisible) {
						declare Integer ItemKey for Frame_Element;
						ItemKey = Key;
						if (State.Items.existskey(Key)) {
							declare ItemId = State.Items[Key].ItemId;
							if (State.MapUploads.Maps.existskey(ItemId)) {
								declare Map = State.MapUploads.Maps[ItemId];
								ShowMap(State, Frame_Element, Map);
								MapUids.add(Map.Uid);
							}
						} else {
							ShowItemLoading(Frame_Element);
						}
					}
					foreach (Key => Frame_Element in Event.ElementsHidden) {
						declare Integer ItemKey for Frame_Element;
						ItemKey = -1;
						Frame_Element.Hide();
					}
					
					ReportContext::SetBucketItemUploadsMapUids(System, MapUids);
					State.Controls.Frame_ScrollItems.Visible = Event.ElementsVisible.count > 0;
					{{{Navigation::P}}}Lock(State.Controls.Frame_ScrollItems, Event.ElementsVisible.count <= 0);
					FocusAvailableControl(State);
					if (Event.ElementsVisible.count > 0) {
						{{{LoadingSpinner::P}}}StopAnimWithFade(This, State.Controls.LoadingSpinner_RetrieveInfo);
					}
				}
				case {{{Scroll::P}}}C_EventType_Focus: {
					if (Event.From != Null) FocusMap(State, Event.FromKey, Event.From, False, Event.PlayFocusAnimation);
					if (Event.To != Null && {{{Scroll::P}}}IsFocused(Event.Scroll)) FocusMap(State, Event.ToKey, Event.To, True, Event.PlayFocusAnimation);
					if (Event.IsMouse && Event.To != Null && !{{{Scroll::P}}}IsFocused(Event.Scroll)) {
						Focus(State, {{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroup_Default}}}"), Event.Scroll);
					}
					if (Event.ToKey >= 0 && State.Items.existskey(Event.ToKey)) {
						if (State.Activity.Type == {{{ClubStruct::P}}}C_ClubActivity_MapUpload && State.MapUploads.Maps.existskey(State.Items[Event.ToKey].ItemId)) {
							declare Map = State.MapUploads.Maps[State.Items[Event.ToKey].ItemId];
							ReportContext::SetBucketItemUploadsFocusedMap(
								System,
								Map.Uid,
								Map.Name,
								Map.AuthorLogin,
								Map.AuthorDisplayName,
								Map.SubmitterAccountId,
								Map.LocalFileName,
								Map.DownloadUrl,
								Map.ThumbnailUrl,
								Map.UploadTimestamp,
								Map.IsPlayable,
								Map.CollectionName,
								Map.CreatedWithSimpleEditor,
								Map.CreatedWithGamepadEditor
							);	
							ReportSystem::AddData(
								ReportStruct::C_ReportTarget_Track,
								ReportStruct::LibStructuresReport_K_ReportData {
									Details = [Map.Name],
									Ids = [Map.Uid],
									Contexts = [["From" => "Menu BucketItemUploads"]]
								}
							);
						}
					}
				}
				case {{{Scroll::P}}}C_EventType_ReachLimit: {
					switch (Event.NavAction) {
						case CMlScriptEvent::EMenuNavAction::Up: {
							if (!{{{Navigation::P}}}IsLocked(State.Controls.Button_Club)) {
								Focus(State, {{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroup_Default}}}"), State.Controls.Button_Club);
							}
						}
						case CMlScriptEvent::EMenuNavAction::Right: {
							if (!{{{Navigation::P}}}IsLocked(State.Controls.Button_UploadMap)) {
								Focus(State, {{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroup_Default}}}"), State.Controls.Button_UploadMap);
							}
						}
						case CMlScriptEvent::EMenuNavAction::Left, CMlScriptEvent::EMenuNavAction::Down: {
							if (!{{{Navigation::P}}}IsLocked(State.Controls.Button_Back)) {
								Focus(State, {{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroup_Default}}}"), State.Controls.Button_Back);
							}
						}
					}
				}
				case {{{Scroll::P}}}C_EventType_NavAction: {
					if (State.Items.existskey(Event.ToKey)) {
						declare Text ItemId = State.Items[Event.ToKey].ItemId;
						switch (Event.NavAction) {
							case CMlScriptEvent::EMenuNavAction::Action2: State = AddOrRemoveFocusedTrackToFavorites(State, Event.ToKey);
							case CMlScriptEvent::EMenuNavAction::Action1: {
								if (UserCanHandleItems(State)) {
									DisplayInfo(State, "{{{Text_RemovingTrack}}}", C_InfoType_Loading);
									State.PostRemoveBucketItemsRequest = Http::DestroyAndCreate(
										State.PostRemoveBucketItemsRequest,
										ClubAPI::PostRemoveBucketItems(State.Activity.ClubId, State.Activity.Id, [ItemId])
									);
								} 
							}
						}
					}
				}
			}
		}
	}

	/* Track buttons events */
	foreach (Event in PendingEvents) {
		switch (Event.Type) {
			case CMlScriptEvent::Type::MouseOver: {
				if (Event.Control.HasClass("{{{C_Class_ItemButton}}}")) {
					AnimMgr.Flush(Event.Control);
					AnimMgr.Add(Event.Control, "<anim opacity=\"1.\" scale=\"1.2\"/>", 200, CAnimManager::EAnimManagerEasing::QuadOut);
				}
			}
			case CMlScriptEvent::Type::MouseOut: {
				if (Event.Control.HasClass("{{{C_Class_ItemButton}}}")) {
					AnimMgr.Flush(Event.Control);
					AnimMgr.Add(Event.Control, "<anim opacity=\"0.7\" scale=\"1.\"/>", 200, CAnimManager::EAnimManagerEasing::QuadOut);
				}
			}
			case CMlScriptEvent::Type::MouseClick: {
				if (Event.Control.HasClass("{{{C_Class_ItemButton}}}")) {
					declare Integer ItemKey for Event.Control.Parent.Parent;
					if (State.Items.existskey(ItemKey)) {
						declare Text ItemId = State.Items[ItemKey].ItemId;

						DisplayInfo(State, "", C_InfoType_Standard);
						switch (Event.ControlId) {
							case "button-favorite": State = AddOrRemoveFocusedTrackToFavorites(State, ItemKey);
							case "button-download": DownloadItem(State, ItemKey);
							case "button-delete": {
								if (UserCanHandleItems(State)) {
									DisplayInfo(State, "{{{Text_RemovingTrack}}}", C_InfoType_Loading);
									State.PostRemoveBucketItemsRequest = Http::DestroyAndCreate(
										State.PostRemoveBucketItemsRequest,
										ClubAPI::PostRemoveBucketItems(State.Activity.ClubId, State.Activity.Id, [ItemId])
									);
								}
							}
						}
					}
				}
			}
		}
	}

	/* PopUpBackground events */
	foreach (Event in {{{PopUpBackground::P}}}GetPendingEvents(This)) {
		if (Event.PopUpBackground != Null && Event.PopUpBackground.ControlId == "frame-background" && {{{Navigation::P}}}GroupIsEnabled(This, "{{{C_NavGroup_Default}}}")) {
			switch (Event.Type) {
				case {{{PopUpBackground::P}}}C_EventType_Close: {
					{{{Router::P}}}PushParent(This);
				}
			}
		}
	}

	/* Change actions icons opacity depending on the current controller */
	if (IsMouse != Tools::IsUsingMouse(Input)) {
		IsMouse = Tools::IsUsingMouse(Input);
		if (IsMouse) {
			{{{Button::P}}}Unfocus(This, State.Controls.Button_Previous);
			{{{Button::P}}}Unfocus(This, State.Controls.Button_Next);
		} else {
			{{{Button::P}}}Focus(This, State.Controls.Button_Previous);
			{{{Button::P}}}Focus(This, State.Controls.Button_Next);
		}
	}
} else {
	foreach (Event in {{{Router::P}}}GetPendingEvents(This)) {
		switch (Event.Type) {
			case "{{{Router::C_Event_LeavingRoute}}}": {
				ReportSystem::RemoveUsingId("{{{C_Name}}}");
				State = Display3DScene(State, False);
				State = K_State { Controls = State.Controls };
				DisplayInfo(State, "", C_InfoType_Standard);
				UpdateSkinUploadButtons(State, GridConfig);
				LockNavigation(State, False);
			}
		}
	}
}
***
""",
[
	BrowserAPI::ComponentV2(),
	Button::ComponentV2(),
	ButtonIcon::ComponentV2(),
	CampaignStruct::Component(),
	ClubStore::ComponentV2(),
	ClubStruct::Component(),
	ExpendableButton::ComponentV2(),
	LoadingSpinner::ComponentV2(),
	MapStore::ComponentV2(),
	MenuSounds::ComponentV2(),
	Navigation::ComponentV2(),
	PlayerName::ComponentV2(),
	PopUpBackground::ComponentV2(),
	Router::ComponentV2(),
	Scroll::ComponentV2(),
	TrackBrowser::ComponentV2(),
	Transition::ComponentV2(),
	UserStore::ComponentV2(),
	ControlBlockList::ComponentV2()
],
[]
	);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update from the ManiaApp
Void Yield() {
	
}