/** 
 *	Page: ArcadeChannel
 */
#Const Version		"2023-05-24"
#Const ScriptName	"Libs/Nadeo/TMNext/TrackMania/Menu/Pages/ArcadeChannel.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Includes
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/MenuLibs/Common/FontManager.Script.txt" as FontManager
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/Helpers.Script.txt" as MLHelpers
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/ManiaView2.Script.txt" as MV
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/ButtonIcon2.Script.txt" as ButtonIcon
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/LoadingSpinner.Script.txt" as LoadingSpinner
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/MenuSounds.Script.txt" as MenuSounds
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/Navigation.Script.txt" as Navigation
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/Scroll.Script.txt" as Scroll
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Components/Transition.Script.txt" as Transition
#Include "Libs/Nadeo/MenuLibs/Common/Menu/Router_ML.Script.txt" as Router
#Include "Libs/Nadeo/TMNext/TrackMania/ColorPalette.Script.txt" as ColorPalette
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Components/Button.Script.txt" as Button
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Components/ExpendableButton.Script.txt" as ExpendableButton
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Components/NavigationTabs.Script.txt" as NavigationTabs
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Components/PopUpBackground2.Script.txt" as PopUpBackground
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Constants.Script.txt" as Const
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/RoutePaths.Script.txt" as RoutePaths
#Include "Libs/Nadeo/TMNext/TrackMania/Stores/UserStore_ML.Script.txt" as UserStore
#Include "Libs/Nadeo/TMNext/TrackMania/UbisoftChallenges.Script.txt" as UbisoftChallenges
#Include "Libs/Nadeo/TMNext/TrackMania/Structures/ClubStruct.Script.txt" as ClubStruct
#Include "TextLib" as TL

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_Name "Page_ArcadeChannel"
#Const C_NavGroup_ArcadeChannel "navgroup-arcade-channel"

#Const C_Privileges [
	CPrivilegeMgr::EPrivilege::PlayMultiplayerModeWithUGC
]

#Const C_Class_ScheduleTime "class-arcade-channel-schedule-time"
#Const C_Schedule_ElementsTotal 384

#Const C_Tab_CurrentProgram 0
#Const C_Tab_Schedule 1
#Const C_TabNames [
	//L16N [ArcadeChannel] Text of the current arcade program tab
	0 => _("Current"),
	//L16N [ArcadeChannel] Text of the arcade schedule tab
	1 => _("Schedule")
]

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the page manialink
 *
 *	@return														The page manialink
 */
Text GetManialink() {
	//L16N [ArcadeChannel] Title of the page.
	declare Text Text_Title = _("Arcade Program");
	//L16N [ArcadeChannel] Subtitle of the page.
	declare Text Text_SubTitle = _("Featured online rooms");
	//L16N [ArcadeChannel] Text of the button to join the current room.
	declare Text Text_Join = _("Join");
	//L16N [ArcadeChannel] Text of the button when the player is trying to join the room.
	declare Text Text_Joining = _("Joining...");
	//L16N [ArcadeChannel] Text displayed while retrieving the arcade channel program
	declare Text Text_RetrievingProgram = _("Retrieving arcade program");
	//L16N [ArcadeChannel] Showcase the current channel being played
	declare Text Text_Now = _("Now");
	//L16N [ArcadeChannel] Action of scrolling with the mouse wheel
	declare Text Text_Scroll = _("|Mouse|Scroll");

	/* Preview variables */
	declare Vec2 Size_Preview = MLHelpers::KeepRatioFromY(608., 272., 46.);
	declare Vec2 Pos_PreviewName = <Size_Preview.X * 0.06, Size_Preview.Y * -0.75>;
	declare Vec2 Pos_PreviewTimer = <Size_Preview.X * 0.05, Size_Preview.Y * -0.88>;

	/* Scroll view commons */
	declare Vec2 Size_ProgramsScrollWindow = <301., 72.5>;
	declare Vec2 Size_Header = <0., 0.>;
	declare Vec2 Size_Footer = <0., 0.>;

	/* Scroll view */
	declare Integer ColumnsNb = 8;
	declare Integer RowsNb = 5;
	declare Integer ProgramsPerPage = ColumnsNb * RowsNb;
	declare Vec2 Size_ProgramMargin = <0., 1.8>;
	declare Vec2 Size_ScrollOverflow = <(ColumnsNb-1)*Size_ProgramMargin.X, (RowsNb-1)*Size_ProgramMargin.Y>;
	declare Vec2 Size_Program = Scroll::GetElementSize(Size_ProgramsScrollWindow, Size_ProgramMargin, ColumnsNb, RowsNb, Size_ScrollOverflow);
	declare Integer ElementsNb = Scroll::GetRequiredElementsNb(Size_ProgramsScrollWindow, Size_Program, Size_ProgramMargin, ColumnsNb);

	declare Vec2 Size_ProgramImage = MLHelpers::KeepRatioFromY(608., 272., Size_Program.Y);
	declare Vec2 Size_LongProgramBg = MLHelpers::KeepRatioFromY(456., 400., Size_Program.Y*2 + Size_ProgramMargin.Y + 0.6);
	declare Vec2 Size_AdjustedProgramImage = <Size_ProgramImage.X - MLHelpers::SkewX(Size_ProgramImage.Y, 10.),	Size_ProgramImage.Y>;
	declare Vec2 Size_TimeLabel = <Size_Program.X * 0.5, Size_Program.Y>;
	declare Vec2 Pos_ProgramName = <Size_ProgramImage.X * 0.05, Size_ProgramImage.Y * -0.85>;
	declare Vec2 Pos_LongProgramName = <Size_ProgramImage.X * 0.5, Size_ProgramImage.Y * -0.5>;
	declare Vec2 Pos_LongProgram = <-0.3, Size_ProgramImage.Y + Size_ProgramMargin.Y + 0.25>;
	declare Vec2 Pos_LongProgramContour = <Pos_LongProgram.X-MLHelpers::SkewX(Size_ProgramImage.Y, 10.)-0.3, 0.3>;
	declare Vec2 Pos_TimeLabel = <Size_Program.X, -Size_Program.Y * 0.08>;

	declare Text ML_Program = "";
	for (I, 1, ElementsNb) {
		if (I % ColumnsNb == 1) {
			ML_Program ^= """
				<frame class="{{{Scroll::C_Class_Element}}} {{{C_Class_ScheduleTime}}}">
					<label id="label-time" class="text-time" pos="{{{Pos_TimeLabel.X}}} {{{Pos_TimeLabel.Y}}}" size="{{{Size_TimeLabel.X}}} {{{Size_TimeLabel.Y}}}" opacity="0.4"/>
				</frame>
			""";
		} else {
			ML_Program ^= """
				<frameinstance
					modelid="framemodel-schedule-element"
					class="{{{Scroll::C_Class_Element}}}"
					hidden="1"
				/>
			""";
		}
	}

	/* Generate week days labels */
	declare Text ML_WeekDays = "";
	foreach (Index => WeekDay in Const::C_Day_Names) {
		ML_WeekDays ^= """
			<label id="label-{{{Index}}}" text="{{{WeekDay}}}" pos="{{{Index*Size_Program.X}}} 0" size="25 10" opacity="0.4" class="text-weekday"/>
		""";
	}

	return MV::Create(
C_Name, 3,
"""
<stylesheet>
	<style class="text-name" halign="center" valign="center2" textfont="{{{FontManager::C_GameFontSemiBold}}}" textprefix="$i" textsize="3.5" textcolor="FFFFFF" autonewline="1" maxline="2"/>
	<style class="text-title" halign="left" valign="center2" textfont="{{{FontManager::C_GameFontExtraBold}}}" textsize="15" textcolor="FFF" textprefix="$i$t"/>
	<style class="text-weekday" halign="center" valign="center2" textfont="{{{FontManager::C_GameFontExtraBold}}}" textsize="2" textcolor="{{{ColorPalette::C_Color_GreenFive}}}" textprefix="$i$t"/>
	<style class="text-time" halign="right" valign="center2" textfont="{{{FontManager::C_GameFontExtraBold}}}" textsize="1" textcolor="{{{ColorPalette::C_Color_GreenFive}}}" textprefix="$i$t"/>
	<style class="text-semibold" halign="center" valign="center2" textfont="{{{FontManager::C_GameFontSemiBold}}}" textprefix="$i$t" textcolor="FFFFFF"/>
	<style class="text-extrabold" halign="center" valign="center2" textfont="{{{FontManager::C_GameFontExtraBold}}}" textprefix="$i$t" textcolor="FFFFFF"/>
</stylesheet>

<!-- Frame models -->
<framemodel id="framemodel-schedule-element">
	<quad id="quad-activation" size="{{{Size_Program.X}}} {{{Size_Program.Y}}}" opacity="0" scriptevents="1" class="{{{Scroll::C_Class_ActivationZone}}}" z-index="-1"/>
	<quad id="quad-long-program-bg" size="{{{Size_LongProgramBg.X}}} {{{Size_LongProgramBg.Y}}}" pos="{{{Pos_LongProgram.X}}} {{{Pos_LongProgram.Y}}}" image="{{{Const::C_ImageUrl_PopUp_Arcade_OneHourProgram}}}" colorize="{{{ColorPalette::C_Color_GreenFour}}}" z-index="0"/>
	<quad id="quad-image" size="{{{Size_ProgramImage.X}}} {{{Size_ProgramImage.Y}}}" image="{{{Const::C_ImageUrl_ClubActivity_Default}}}" alphamask="{{{Const::C_ImageUrl_ClubActivity_Mask}}}" z-index="1"/>
	<quad id="quad-gradient" size="{{{Size_ProgramImage.X}}} {{{Size_ProgramImage.Y}}}" image="{{{Const::C_ImageUrl_ClubActivity_Gradient}}}" opacity="0.7" colorize="{{{ColorPalette::C_Color_DarkBlue}}}" z-index="2"/>
	<quad id="quad-contour" size="{{{Size_ProgramImage.X}}} {{{Size_ProgramImage.Y}}}" image="{{{Const::C_ImageUrl_ClubActivity_Contour}}}" opacity="0." colorize="FFF" z-index="3"/>
	<quad id="quad-long-program-contour" size="{{{Size_LongProgramBg.X}}} {{{Size_LongProgramBg.Y}}}" pos="{{{Pos_LongProgramContour.X}}} {{{Pos_LongProgramContour.Y}}}" image="{{{Const::C_ImageUrl_PopUp_Arcade_OneHourProgramFocus}}}" opacity="0." colorize="FFF" z-index="3"/>
	<label id="label-name" size="{{{Size_AdjustedProgramImage.X*0.9}}} {{{Size_AdjustedProgramImage.Y}}}" pos="{{{Pos_ProgramName.X}}} {{{Pos_ProgramName.Y}}}" class="text-semibold" textsize="1.5" opacity="0.7" filter-profanities="OnlyIfNotTranslated" z-index="3"/>
</framemodel>

<!-- Frame global -->
<frame id="frame-global" z-index="{{{Const::C_ZIndex_PopUpDisplay}}}">
	<frameinstance id="frame-background" modelid="{{{PopUpBackground::C_Name}}}" data-header-image="{{{Const::C_ImageUrl_PopUp_Arcade_Header}}}" z-index="-1"/>
	<frameinstance id="frame-navigation-tabs" modelid="{{{NavigationTabs::C_Name}}}" pos="{{{MLHelpers::Skew(-125.5, 34.5, 10.)}}}" data-tabs="{{{TL::MLEncode(C_TabNames.tojson())}}}" data-halign="left" z-index="1"/>
	<label id="label-title" pos="{{{MLHelpers::Skew(-126.5, 61.5, 10.)}}}" size="250 20" class="text-extrabold" text="{{{Text_Title}}}" textsize="13" halign="left" z-index="1"/>
	<label id="label-subtitle" pos="{{{MLHelpers::Skew(-125.5, 51.5, 10.)}}}" size="250 20" class="text-semibold" text="{{{Text_SubTitle}}}" textsize="4" halign="left" z-index="1"/>
	<label id="label-error" pos="{{{MLHelpers::Skew(0., -70., 10.)}}}" size="120 10" class="text-semibold" textsize="2.5" textcolor="{{{ColorPalette::C_Color_ErrorRed}}}"/>

	<!-- Tab live programs -->
	<frame id="frame-programs" pos="{{{MLHelpers::Skew(0., 5.5, 10.)}}}">
		<frame id="frame-program-now" pos="{{{-Size_Preview.X - 4.}}} 0">
			<quad id="quad-bg" size="{{{Size_Preview.X}}} {{{Size_Preview.Y}}}" image="{{{Const::C_ImageUrl_ClubActivity_Bg}}}" alphamask="{{{Const::C_ImageUrl_ClubActivity_Mask}}}" keepratio="clip" z-index="0"/>
			<quad id="quad-image" size="{{{Size_Preview.X}}} {{{Size_Preview.Y}}}" image="{{{Const::C_ImageUrl_ClubActivity_Default}}}" alphamask="{{{Const::C_ImageUrl_ClubActivity_Mask}}}" keepratio="clip" z-index="1"/>
			<quad id="quad-gradient" size="{{{Size_Preview.X}}} {{{Size_Preview.Y}}}" image="{{{Const::C_ImageUrl_ClubActivity_Gradient}}}" opacity="0.4" colorize="{{{ColorPalette::C_Color_DarkBlue}}}" z-index="2"/>
			<label id="label-name" size="{{{Size_Preview.X * 0.75}}} 7" pos="{{{Pos_PreviewName.X}}} {{{Pos_PreviewName.Y}}}" class="text-extrabold" opacity="1." textsize="5" halign="left" filter-profanities="OnlyIfNotTranslated" z-index="3"/>
			<label id="label-timer" size="{{{Size_Preview.X * 0.75}}} 7" pos="{{{Pos_PreviewTimer.X}}} {{{Pos_PreviewTimer.Y}}}" class="text-semibold" opacity="1." textsize="3" halign="left" z-index="3"/>
			<quad id="quad-contour" size="{{{Size_Preview.X}}} {{{Size_Preview.Y}}}" image="{{{Const::C_ImageUrl_ClubActivity_Contour}}}" opacity="1." colorize="FFF" z-index="4"/>
		</frame>
		<frame id="frame-program-next" pos="2. 0">
			<quad id="quad-bg" size="{{{Size_Preview.X}}} {{{Size_Preview.Y}}}" image="{{{Const::C_ImageUrl_ClubActivity_Bg}}}" alphamask="{{{Const::C_ImageUrl_ClubActivity_Mask}}}" keepratio="clip" z-index="0"/>
			<quad id="quad-image" size="{{{Size_Preview.X}}} {{{Size_Preview.Y}}}" image="{{{Const::C_ImageUrl_ClubActivity_Default}}}" alphamask="{{{Const::C_ImageUrl_ClubActivity_Mask}}}" keepratio="clip" z-index="1"/>
			<quad id="quad-gradient" size="{{{Size_Preview.X}}} {{{Size_Preview.Y}}}" image="{{{Const::C_ImageUrl_ClubActivity_Gradient}}}" opacity="0.7" colorize="{{{ColorPalette::C_Color_DarkBlue}}}" z-index="2"/>
			<label id="label-name" size="{{{Size_Preview.X * 0.75}}} 7" pos="{{{Pos_PreviewName.X}}} {{{Pos_PreviewName.Y}}}" class="text-extrabold" opacity="0.7" textsize="5" halign="left" filter-profanities="OnlyIfNotTranslated" z-index="3"/>
			<label id="label-timer" size="{{{Size_Preview.X * 0.75}}} 7" pos="{{{Pos_PreviewTimer.X}}} {{{Pos_PreviewTimer.Y}}}" class="text-semibold" opacity="0.7" textsize="3" halign="left" z-index="3"/>
			<quad id="quad-contour" size="{{{Size_Preview.X}}} {{{Size_Preview.Y}}}" image="{{{Const::C_ImageUrl_ClubActivity_Contour}}}" opacity="0." colorize="FFF" z-index="4"/>
		</frame>
	</frame>

	<!-- Tab schedule -->
	<frame id="frame-schedule" hidden="1">
		<frameinstance id="frame-loading-spinner" modelid="{{{LoadingSpinner::C_Name}}}" pos="{{{MLHelpers::Skew(0., -10., 10.)}}}" data-label="{{{Text_RetrievingProgram}}}" scale="1." />
		<frame id="frame-week-days" pos="{{{MLHelpers::Skew(-111., 20., 10.)}}}">
			{{{ML_WeekDays}}}
		</frame>
		<frame id="frame-scroll-view" z-index="1">
			<frameinstance modelid="{{{Scroll::C_Name}}}" data-scroll-parent="frame-scroll-view-schedule" z-index="1" />
			<frame
				id="frame-scroll-view-schedule" pos="{{{Size_ProgramsScrollWindow.X * -0.558}}} 16."
				class="{{{Scroll::C_Class_Window}}} {{{Navigation::C_Class}}}"
				data-elements-per-line="{{{ColumnsNb}}}"
				data-elements-per-page="{{{ProgramsPerPage}}}"
				data-element-size="{{{Size_Program.X}}} {{{Size_Program.Y}}}"
				data-margin-size="{{{Size_ProgramMargin.X}}} {{{Size_ProgramMargin.Y}}}"
				data-window-size="{{{Size_ProgramsScrollWindow.X}}} {{{Size_ProgramsScrollWindow.Y}}}"
				data-header-height="{{{Size_Header.Y}}}"
				data-footer-height="{{{Size_Footer.Y}}}"
				data-scrollbar-visibility="never"
				data-scroll-indicator-x-offset="9."
				data-scroll-indicator-y-offset="-12."
				data-scroll-indicator-image="{{{Const::C_ImageUrl_Icon_Arrow_Bottom_Oblique}}}"
				data-scroll-indicator-colorize="FFFFFF"
				data-scroll-indicator-size="12"
				data-scrollpadding="7.5."
				data-skew="-10."
				data-skew-valign="{{{Scroll::C_SkewVAlign_Center}}}"
				data-nav-group="{{{C_NavGroup_ArcadeChannel}}}"
			>
				<quad z-index="-1" scriptevents="1" class="{{{Scroll::C_Class_ScrollEvent}}}" />
				<frame id="frame-time-indicator" class="{{{Scroll::C_Class_StickControl}}}" pos="{{{Size_ProgramsScrollWindow.X * 0.58}}} 0" z-index="2">
					<quad id="quad-time-line" size="{{{(ColumnsNb - 1)*Size_Program.X - 4.}}} 0.5" pos="2. 0" halign="center" valign="center" bgcolor="FFF"/>
					<label id="label-current-time" pos="-128.5 0" class="text-time" size="{{{Size_TimeLabel.X+2}}} {{{Size_TimeLabel.Y}}}" textsize="1.5" textcolor="FFF"/>
				</frame>
				{{{ML_Program}}}
			</frame>
		</frame>
	</frame>
	
	<!-- Bottom buttons -->
	<frameinstance id="button-icon-back" modelid="{{{ButtonIcon::C_Name}}}" pos="{{{MLHelpers::Skew(-125.5, -67., 10.)}}}" data-halign="right" data-size="8 8" data-bind="B" data-hideformouse="1" />
	<frameinstance
		id="button-back" pos="{{{MLHelpers::Skew(-106.5, -67., 10.)}}}" z-index="2"
		modelid="{{{ExpendableButton::C_Name}}}"
		class="{{{Navigation::C_Class}}}"
		data-max-width="60."
		data-styles="{{{ExpendableButton::C_Style_PageBack}}} {{{ExpendableButton::C_Style_SizeExpendable}}} {{{ExpendableButton::C_Style_AlignCenter}}} {{{ExpendableButton::C_Style_ButtonSecondary}}}"
		data-nav-inputs="select;cancel;right;up;down"
		data-nav-targets="_;_;button-join;_;_"
		data-nav-group="{{{C_NavGroup_ArcadeChannel}}}"
		data-nav-zone="{{{ExpendableButton::C_NavZone}}}"
	/>
	<frameinstance
		id="button-join" pos="{{{MLHelpers::Skew(98., -67., 10.)}}}" z-index="2"
		modelid="{{{ExpendableButton::C_Name}}}"
		class="{{{Navigation::C_Class}}}"
		data-max-width="60."
		data-text="{{{Text_Join}}}"
		data-styles="{{{ExpendableButton::C_Style_PageNextAnimated}}} {{{ExpendableButton::C_Style_SizeExpendable}}} {{{ExpendableButton::C_Style_AlignCenter}}} {{{ExpendableButton::C_Style_ButtonSecondary}}}"
		data-nav-inputs="select;cancel;left;up;down"
		data-nav-targets="_;_;button-back;_;_"
		data-nav-group="{{{C_NavGroup_ArcadeChannel}}}"
		data-nav-zone="{{{ExpendableButton::C_NavZone}}}"
	/>
</frame>
""",
"""
#Include "TextLib" as TL
#Include "TimeLib" as TiL
#Include "MathLib" as ML
#Include "ColorLib" as CL
#Include "Libs/Nadeo/CommonLibs/Common/Privileges.Script.txt" as Privileges
#Include "Libs/Nadeo/CommonLibs/Common/Http.Script.txt" as Http
#Include "Libs/Nadeo/CommonLibs/Common/MainUser.Script.txt" as MainUser
#Include "Libs/Nadeo/CommonLibs/Common/ReportContext.Script.txt" as ReportContext
#Include "Libs/Nadeo/TMNext/TrackMania/RBAC.Script.txt" as RBAC
#Include "Libs/Nadeo/TMNext/TrackMania/API/ChannelAPI.Script.txt" as ChannelAPI
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/TitleControl.Script.txt" as TitleControl
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Overlays/ControllerInfo_ML.Script.txt" as ControllerInfo
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Overlays/ReportSystem.Script.txt" as ReportSystem
#Include "Libs/Nadeo/TMNext/TrackMania/Structures/ReportStruct.Script.txt" as ReportStruct

#Const C_DelayBetweenTimeUpdate 10000 //< milliseconds

#Const C_Tab_CurrentProgram {{{dump(C_Tab_CurrentProgram)}}}
#Const C_Tab_Schedule {{{dump(C_Tab_Schedule)}}}

#Struct K_ProgramInfo {
	Integer Id;
	Integer RoomId;
	Text Name;
	Integer RelativeStartTime;
	Text MediaUrl;
	Integer ChronoRef;
}

#Struct K_Controls {
	CMlFrame Frame_Global;
	CMlFrame Frame_NavigationTabs;
	CMlFrame Frame_LoadingSpinner;
	CMlFrame Frame_ScrollSchedule;
	CMlFrame Frame_WeekDays;
	CMlFrame Frame_ProgramNow;
	CMlFrame Frame_ProgramNext;
	CMlFrame Frame_Programs;
	CMlFrame Frame_Schedule;
	CMlFrame Button_Join;
	CMlLabel Label_Error;
}

#Struct K_State {
	Http::K_Request ChannelInfoRequest;
	Http::K_Request ChannelGridRequest;
	Http::K_Request JoinLinkRequest;
	K_ProgramInfo ProgramNow;
	K_ProgramInfo ProgramNext;
	K_ProgramInfo[] ProgramGrid;
	Boolean NeedProgramUpdate;
	Boolean NeedScheduleUpdate;
	Integer CurrentDay;
	Integer CurrentHour;
	Integer CurrentProgram;
	Integer CurrentTimeZone;
	Privileges::K_PrivilegeCheck PlayPrivilegeCheck;
}
""",
"""
Void DisplayArcadeChannel(K_Controls _Controls, Boolean _IsVisible) {
	{{{Navigation::P}}}EnableGroup(This, "{{{C_NavGroup_ArcadeChannel}}}", _IsVisible);
	_Controls.Frame_Global.Visible = _IsVisible;

	if (!_IsVisible) {
		{{{Router::P}}}PushParent(This);
	}
}

// Update controller hints at the bottom of the screen
Void UpdateControllerInfo(K_Controls _Controls) {
	declare Text[Text] ControllerInfos = ["A" => _("Select")];

	if (_Controls.Frame_Schedule.Visible) {
		ControllerInfos["up"] = ""; //< empty on purpose
		ControllerInfos["down"] = "{{{Text_Scroll}}}";
	}

	ControllerInfos["{{{Const::C_NavInput_ReportSystem}}}"] = "{{{Const::C_Text_Report}}}";

	ControllerInfo::SetButtons(ControllerInfos);
}

Void LockPage(K_Controls _Controls, Boolean _Lock) {
	{{{Navigation::P}}}EnableGroup(This, "{{{C_NavGroup_ArcadeChannel}}}", !_Lock);
	{{{Scroll::P}}}LockNavigation(_Controls.Frame_ScrollSchedule, _Lock);
	{{{NavigationTabs::P}}}LockTabs(This, _Controls.Frame_NavigationTabs, _Lock);
}

K_State SwitchView(K_State _State, K_Controls _Controls, Integer _CurrentTab) {
	declare K_State State = _State;

	_Controls.Label_Error.Value = "";
	_Controls.Frame_Programs.Visible = _CurrentTab == C_Tab_CurrentProgram;
	_Controls.Frame_Schedule.Visible = _CurrentTab == C_Tab_Schedule;
	{{{Scroll::P}}}LockNavigation(_Controls.Frame_ScrollSchedule, !_Controls.Frame_Schedule.Visible);

	if (_Controls.Frame_Schedule.Visible) {
		{{{Scroll::P}}}ScrollToElement(This, _Controls.Frame_ScrollSchedule, _State.CurrentProgram);
		if (_State.ProgramGrid.count <= 0) {
			State.NeedScheduleUpdate = True;
			_Controls.Frame_ScrollSchedule.Hide();
			{{{LoadingSpinner::P}}}StartAnimation(This, _Controls.Frame_LoadingSpinner);
			State.ChannelGridRequest = ChannelAPI::GetChannelGrid("{{{Const::C_ChannelUid_Arcade}}}");
		}
	}

	UpdateControllerInfo(_Controls);

	return State;
}

Void Focus(CMlControl _From, CMlControl _To) {
	if ({{{Transition::P}}}IsInTransition(This)) return;
	
	if (_From != Null) {
		{{{Navigation::P}}}Unfocus(This, _From);
		if ({{{Button::P}}}IsButton(_From)) {
			{{{Button::P}}}Unfocus(This, (_From as CMlFrame));
		} else if ({{{ExpendableButton::P}}}IsButton(_From)) {
			{{{ExpendableButton::P}}}Unfocus(This, (_From as CMlFrame));
		}
	}
	
	if (_To != Null) {
		{{{Navigation::P}}}Focus(This, _To);
		if ({{{Button::P}}}IsButton(_To)) {
			{{{Button::P}}}Focus(This, (_To as CMlFrame));
		} else if ({{{ExpendableButton::P}}}IsButton(_To)) {
			{{{ExpendableButton::P}}}Focus(This, (_To as CMlFrame));
		}
	}
}

Void UpdateScheduleCurrentTime(K_State _State, CMlFrame _Frame_ScrollSchedule, Boolean _AllowAnim) {
	declare CMlFrame Frame_TimeIndicator <=> (_Frame_ScrollSchedule.GetFirstChild("frame-time-indicator") as CMlFrame);
	declare CMlLabel Label_TimeIndicator <=> (_Frame_ScrollSchedule.GetFirstChild("label-current-time") as CMlLabel);

	/* Update time indicator */
	AnimMgr.Flush(Frame_TimeIndicator);
	declare Real DayCycle = TiL::Clamp01TZDay(TiL::GetCurrent());
	declare Vec2 IndicatorPos = <Frame_TimeIndicator.RelativePosition_V3.X, -DayCycle * {{{Size_Program.Y + Size_ProgramMargin.Y}}} * 48>;
	Label_TimeIndicator.SetText(TiL::FormatDate(TiL::GetCurrent(), TiL::EDateFormats::TimeShort));
	if (_AllowAnim) {
		AnimMgr.Add(Frame_TimeIndicator, "<anim pos=\""^IndicatorPos.X^" "^IndicatorPos.Y^"\" />", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	} else {
		Frame_TimeIndicator.RelativePosition_V3 = IndicatorPos;
	}

	/* Update time labels */
	foreach (Key => Frame_Element in {{{Scroll::P}}}GetElementsVisible(_Frame_ScrollSchedule)) {
		if (Frame_Element.HasClass("{{{C_Class_ScheduleTime}}}")) {
			declare Label_Time <=> (Frame_Element.GetFirstChild("label-time") as CMlLabel);
			declare Integer Index = Key / {{{ColumnsNb}}};
			declare Integer IndexToFormat = Index - _State.CurrentTimeZone;
			AnimMgr.Flush(Label_Time);

			// Change the color of past times
			declare Text TextColor = "{{{ColorPalette::C_Color_GreenOne}}}";
			if (Index < _State.CurrentHour) TextColor = "{{{ColorPalette::C_Color_GreenFour}}}";

			// Change opacity if the time indicator is over this label
			declare Real Opacity = ML::Distance(TiL::Clamp01TZDay(TiL::GetCurrent()) * 48, ML::ToReal(Index));
			if (Opacity <= 1. && Opacity > .3) Opacity = 1.;
			else if (Opacity > 1.) Opacity = 0.6;
			
			// Handle animations
			if (_AllowAnim) {
				AnimMgr.Add(Label_Time, "<anim opacity=\""^Opacity^"\" textcolor=\""^TextColor^"\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
			} else {
				Label_Time.TextColor = CL::Hex6ToRgb(TextColor);
				Label_Time.Opacity = Opacity;
			}

			// Set the text for this label with the corresponding time
			if (IndexToFormat < 0) IndexToFormat += 48;
			Label_Time.SetText(TiL::FormatDate(TL::ToText(IndexToFormat * 1800), TiL::EDateFormats::TimeShort));
		}
	}

}


Void UpdateScheduleCurrentDay(CMlFrame _Frame_WeekDays, Integer _CurrentDay) {
	foreach (Index => Control in _Frame_WeekDays.Controls) {
		declare CMlLabel Label_WeekDay = (Control as CMlLabel);
		declare Real Opacity = 0.6;
		declare Real TextScale = 1.;
		declare Text TextColor = "{{{ColorPalette::C_Color_GreenFour}}}";
		AnimMgr.Flush(Label_WeekDay);

		if (Index > _CurrentDay) {
			TextColor = "{{{ColorPalette::C_Color_GreenOne}}}";
		} else if (Index == _CurrentDay) {
			TextColor = "{{{ColorPalette::C_Color_White}}}";
			TextScale = 1.3;
			Opacity = 1.;
		}

		AnimMgr.Add(Label_WeekDay, "<anim opacity=\""^Opacity^"\" scale=\""^TextScale^"\" textcolor=\""^TextColor^"\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
	}
}

K_State UpdateSchedule(K_State _State, CMlFrame _Frame_ScrollSchedule, Boolean _AllowAnim) {
	declare K_State State = _State;

	/* Update the current program */
	State.CurrentProgram = {{{ColumnsNb}}} * _State.CurrentHour + _State.CurrentDay + 1;

	/* Update all schedule elements */
	foreach (Key => Frame_Element in {{{Scroll::P}}}GetElementsVisible(_Frame_ScrollSchedule)) {
		Frame_Element.Visible = True;
		if (!Frame_Element.HasClass("{{{C_Class_ScheduleTime}}}")) {
			declare Label_Name <=> (Frame_Element.GetFirstChild("label-name") as CMlLabel);
			declare CMlQuad Quad_Image <=> (Frame_Element.GetFirstChild("quad-image") as CMlQuad);
			declare CMlQuad Quad_Contour <=> (Frame_Element.GetFirstChild("quad-contour") as CMlQuad);
			declare CMlQuad Quad_Gradient <=> (Frame_Element.GetFirstChild("quad-gradient") as CMlQuad);
			declare CMlQuad Quad_LongProgramBg <=> (Frame_Element.GetFirstChild("quad-long-program-bg") as CMlQuad);
			declare CMlQuad Quad_LongProgramContour <=> (Frame_Element.GetFirstChild("quad-long-program-contour") as CMlQuad);
			declare Boolean IsLongProgramTop = (
				ML::FloorInteger(Key/{{{ColumnsNb}}}.) % 2 == 0 && 
				_State.ProgramGrid.existskey(Key + {{{ColumnsNb}}}) && 
				_State.ProgramGrid[Key].Id == _State.ProgramGrid[Key + {{{ColumnsNb}}}].Id
			);
			declare Boolean IsLongProgramBottom = (
				ML::FloorInteger(Key/{{{ColumnsNb}}}.) % 2 != 0 && 
				_State.ProgramGrid.existskey(Key - {{{ColumnsNb}}}) && 
				_State.ProgramGrid[Key].Id == _State.ProgramGrid[Key - {{{ColumnsNb}}}].Id
			);
			declare Boolean IsShortProgram = !IsLongProgramBottom && !IsLongProgramTop;

			AnimMgr.Flush(Label_Name);
			AnimMgr.Flush(Quad_Contour);
			AnimMgr.Flush(Quad_Gradient);
			AnimMgr.Flush(Quad_LongProgramContour);

			// Highlight the current program
			if (State.CurrentProgram == Key || 
				(IsLongProgramBottom && State.CurrentProgram == Key - {{{ColumnsNb}}}) || 
				(IsLongProgramTop && State.CurrentProgram == Key + {{{ColumnsNb}}})
			) {
				if (IsLongProgramBottom) Frame_Element.ZIndex = 9.;
				else Frame_Element.ZIndex = 10.;

				if (_AllowAnim) {
					AnimMgr.Add(Label_Name, "<anim opacity=\"1.\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
					AnimMgr.Add(Quad_Contour, "<anim opacity=\"1.\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
					AnimMgr.Add(Quad_Gradient, "<anim opacity=\"0.4\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
					AnimMgr.Add(Quad_LongProgramContour, "<anim opacity=\"1.\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
				} else {
					Label_Name.Opacity = 1.;
					Quad_Contour.Opacity = 1.;
					Quad_Gradient.Opacity = 0.4;
					Quad_LongProgramContour.Opacity = 1.;
				}
			} else {
				declare Real Opacity_Gradient = 0.7;
				declare Real Opacity_Name = 0.7;
				declare Integer ProgramDay = Key % {{{ColumnsNb}}} - 1;
				declare Integer ProgramHour = Key / {{{ColumnsNb}}};
				if (ProgramDay < State.CurrentDay || ProgramDay == State.CurrentDay && ProgramHour < State.CurrentHour) { //< Past program
					Opacity_Gradient = 1.;
					Opacity_Name = 0.4;
				}

				if (IsLongProgramBottom) Frame_Element.ZIndex = 0.;
				else Frame_Element.ZIndex = 1.;

				if (_AllowAnim) {
					AnimMgr.Add(Label_Name, "<anim opacity=\""^Opacity_Name^"\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
					AnimMgr.Add(Quad_Gradient, "<anim opacity=\""^Opacity_Gradient^"\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
					AnimMgr.Add(Quad_Contour, "<anim opacity=\"0.\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
					AnimMgr.Add(Quad_LongProgramContour, "<anim opacity=\"0.\"/>", 250, CAnimManager::EAnimManagerEasing::QuadOut);
				} else {
					Label_Name.Opacity = Opacity_Name;
					Quad_Gradient.Opacity = Opacity_Gradient;
					Quad_Contour.Opacity = 0.;
					Quad_LongProgramContour.Opacity = 0.;
				}
			}
	
			// Update program name and thumbnail
			if (_State.ProgramGrid.existskey(Key)) {
				Quad_LongProgramBg.Visible = IsLongProgramBottom;
				Quad_LongProgramContour.Visible = IsLongProgramTop;
				Quad_Contour.Visible = IsShortProgram;
				Quad_Image.Visible = !IsLongProgramBottom;
				Quad_Gradient.Visible = Quad_Image.Visible;
				Label_Name.Visible = !IsLongProgramTop;

				Label_Name.SetText(_State.ProgramGrid[Key].Name);
				if (IsLongProgramBottom) {
					Label_Name.HorizontalAlign = CMlControl::AlignHorizontal::HCenter;
					Label_Name.RelativePosition_V3 = {{{Pos_LongProgramName}}};
				} else {
					Label_Name.HorizontalAlign = CMlControl::AlignHorizontal::Left;
					Label_Name.RelativePosition_V3 = {{{Pos_ProgramName}}};
				}

				if (_State.ProgramGrid[Key].MediaUrl != "" && Http.IsValidUrl(_State.ProgramGrid[Key].MediaUrl)) {
					Quad_Image.ChangeImageUrl(_State.ProgramGrid[Key].MediaUrl);
				} else {
					Quad_Image.ChangeImageUrl("{{{Const::C_ImageUrl_ClubActivity_Default}}}");
				}
			} else {
				Label_Name.SetText("{{{Const::C_Text_RetrievingDataPlaceholder}}}");
				Quad_Image.ChangeImageUrl("{{{Const::C_ImageUrl_ClubActivity_Default}}}");
			}
		} 
	}

	/* Update time labels */
	UpdateScheduleCurrentTime(_State, _Frame_ScrollSchedule, _AllowAnim);

	return State;
}

K_State JoinRoom(K_State _State, K_Controls _Controls, Boolean _CheckPrivilege) {
	declare K_State State = _State;

	if (!{{{UserStore::P}}}HasGamePermission(PrivilegeMgr, RBAC::C_GamePermission_PlayArcadeChannel)) {
		DisplayArcadeChannel(_Controls, False);
		// Cannot use GetCurrentRoutePath function because we lose the background behind the pop-up
		{{{Router::P}}}SetParentPath(This, "{{{RoutePaths::C_Path_ClubEditionInfo}}}", {{{Router::P}}}GetCurrentParentPath(This));
		{{{Router::P}}}Push(This, "{{{RoutePaths::C_Path_ClubEditionInfo}}}", ["{{{RoutePaths::C_Query_Message}}}" => RBAC::GetGamePermissionMessage(RBAC::C_GamePermissionMessage_PlayArcadeChannel)]);
	} else if (_CheckPrivilege) {
		State.PlayPrivilegeCheck = Privileges::Check_DestroyAndCreate(
			State.PlayPrivilegeCheck,
			PrivilegeMgr,
			MainUser::GetMainUserId(),
			CPrivilegeMgr::EPrivilege::PlayMultiplayerSessionWithUGC
		);
	} else {
		State.JoinLinkRequest = Http::DestroyAndCreate(State.JoinLinkRequest, ChannelAPI::GetJoinLink("{{{Const::C_ChannelUid_Arcade}}}"));
		{{{ExpendableButton::P}}}SetIconImageUrl(This, _Controls.Button_Join, "", False);
		{{{ExpendableButton::P}}}SetText(This, _Controls.Button_Join, "{{{Text_Joining}}}");
	}

	return State;
}

K_State Select(CMlControl _Control, K_Controls _Controls, K_State _State) {
	if (_Control == Null || {{{Transition::P}}}IsInTransition(This)) return _State;
	declare K_State State = _State;

	if (_Controls.Label_Error.Value != "") {
		_Controls.Label_Error.Value = "";
	}

	switch (_Control.ControlId) {
		case "button-back": DisplayArcadeChannel(_Controls, False);
		case "button-join": State = JoinRoom(State, _Controls, True);	
	}

	return State;
}

Void UpdateProgram(CMlFrame _Frame_Program, K_ProgramInfo _ProgramInfo) {
	if (_Frame_Program == Null) return;
	declare Label_Name <=> (_Frame_Program.GetFirstChild("label-name") as CMlLabel);
	declare Quad_Image <=> (_Frame_Program.GetFirstChild("quad-image") as CMlQuad);
	
	Label_Name.SetText(_ProgramInfo.Name);
	if (_ProgramInfo.MediaUrl != "") {
		Quad_Image.ChangeImageUrl(_ProgramInfo.MediaUrl);
	} else {
		Quad_Image.ChangeImageUrl("{{{Const::C_ImageUrl_ClubActivity_Default}}}");
	}
}

K_State UpdateProgramTimer(CMlFrame _Frame_Program, K_ProgramInfo _ProgramInfo, K_State _State) {
	if (_Frame_Program == Null) return _State;
	declare K_State State = _State;

	if (_ProgramInfo.RelativeStartTime <= 0) { 
		(_Frame_Program.GetFirstChild("label-timer") as CMlLabel).SetText("{{{Text_Now}}}");
	} else {
		declare Integer TimerLeft = (_ProgramInfo.RelativeStartTime)*1000 - (Now - _ProgramInfo.ChronoRef) + 1;		
		if (TimerLeft <= 1) {
			State.NeedProgramUpdate = True;
			if (Http::IsInitialized(State.ChannelInfoRequest)) {
				Http::Destroy(State.ChannelInfoRequest);
			}
			State.ChannelInfoRequest = ChannelAPI::GetChannelInfo("{{{Const::C_ChannelUid_Arcade}}}");
			TimerLeft = 0;
		}
		declare Text TimerText = TL::TimeToText(TimerLeft, True);
		declare Text[] TmpSplit = TL::Split(".", TimerText);
		//L16N [ArcadeChannel] Title announcing how many minutes are left before the next program will be playable in the arcade channel. %1 is the amount of minutes left
		if (TmpSplit.count >= 0) (_Frame_Program.GetFirstChild("label-timer") as CMlLabel).SetText(TmpSplit[0]);
	}
	return State;
}

***MainInit***
***
declare CMlFrame Frame_Global;

declare K_Controls Controls;
declare K_State State;

declare Boolean NeedChannelUpdate;
declare Integer AllowTimeIndicatorUpdate;
***

***MainStart***
***
Frame_Global <=> (Page.GetFirstChild("frame-global") as CMlFrame);

Controls = K_Controls {
	Frame_Global = Frame_Global,
	Frame_NavigationTabs = (Frame_Global.GetFirstChild("frame-navigation-tabs") as CMlFrame),
	Frame_LoadingSpinner = (Frame_Global.GetFirstChild("frame-loading-spinner") as CMlFrame),
	Frame_ScrollSchedule = (Frame_Global.GetFirstChild("frame-scroll-view-schedule") as CMlFrame),
	Frame_WeekDays = (Frame_Global.GetFirstChild("frame-week-days") as CMlFrame),
	Frame_ProgramNow = (Frame_Global.GetFirstChild("frame-program-now") as CMlFrame),
	Frame_ProgramNext = (Frame_Global.GetFirstChild("frame-program-next") as CMlFrame),
	Frame_Programs = (Frame_Global.GetFirstChild("frame-programs") as CMlFrame),
	Frame_Schedule = (Frame_Global.GetFirstChild("frame-schedule") as CMlFrame),
	Button_Join = (Frame_Global.GetFirstChild("button-join") as CMlFrame),
	Label_Error = (Frame_Global.GetFirstChild("label-error") as CMlLabel)
};

State = K_State {
	ChannelInfoRequest = Http::GetEmptyRequest(),
	ChannelGridRequest = Http::GetEmptyRequest(),
	JoinLinkRequest = Http::GetEmptyRequest(),
	CurrentDay = -1,
	CurrentHour = -1,
	CurrentProgram = -1
};

NeedChannelUpdate = False;
AllowTimeIndicatorUpdate = -1;
***

***MainLoop***
***
foreach (Event in {{{Router::P}}}GetPendingEvents(This)) {
	switch (Event.Type) {
		case "{{{Router::C_Event_EnteringRoute}}}": {
			ReportSystem::AddUsingId("{{{C_Name}}}");
			if (Controls.Frame_Programs.Visible) {
				State.NeedProgramUpdate = True;
				State.ChannelInfoRequest = ChannelAPI::GetChannelInfo("{{{Const::C_ChannelUid_Arcade}}}");
			} else if (Controls.Frame_Schedule.Visible) {
				State.NeedScheduleUpdate = True;
				Controls.Frame_ScrollSchedule.Hide();
				{{{LoadingSpinner::P}}}StartAnimation(This, Controls.Frame_LoadingSpinner);
				State.ChannelGridRequest = ChannelAPI::GetChannelGrid("{{{Const::C_ChannelUid_Arcade}}}");
			}
			UpdateControllerInfo(Controls);
			DisplayArcadeChannel(Controls, True);
			{{{NavigationTabs::P}}}LockTabs(This, Controls.Frame_NavigationTabs, False);
			{{{Scroll::P}}}SetElementsTotal(This, Controls.Frame_ScrollSchedule, {{{C_Schedule_ElementsTotal}}});
			Focus({{{Navigation::P}}}GetFocusedControl(This, "{{{C_NavGroup_ArcadeChannel}}}"), Controls.Button_Join);
			Controls.Label_Error.Value = "";
		}
		case "{{{Router::C_Event_LeavingRoute}}}": {
			ReportSystem::RemoveUsingId("{{{C_Name}}}");
			State.PlayPrivilegeCheck = Privileges::Check_Destroy(State.PlayPrivilegeCheck);
		}
	}
}

if ({{{Router::P}}}PageIsRunning(This, "{{{RoutePaths::C_Path_ArcadeChannel}}}")) {
	/* Handle HTTP Requests */
	if (Http::IsInitialized(State.ChannelInfoRequest) && State.NeedProgramUpdate) {
		State.ChannelInfoRequest = Http::Update(State.ChannelInfoRequest);
		if (!Http::IsRunning(State.ChannelInfoRequest)) {
			if (Http::IsSuccess(State.ChannelInfoRequest)) {
				declare ChannelInfoResponse = ChannelAPI::GetResponseFromGetChannelInfo(State.ChannelInfoRequest);

				State.ProgramNow.Name = ChannelInfoResponse.CurrentTimeSlot.Name;
				State.ProgramNow.MediaUrl = ChannelInfoResponse.CurrentTimeSlot.MediaUrl;
				State.ProgramNow.RelativeStartTime = ChannelInfoResponse.CurrentTimeSlot.RelativeStart;
				State.ProgramNow.RoomId = ChannelInfoResponse.CurrentTimeSlot.RoomId;
				State.ProgramNow.ChronoRef = Now;
				
				State.ProgramNext.Name = ChannelInfoResponse.NextTimeSlot.Name;
				State.ProgramNext.MediaUrl = ChannelInfoResponse.NextTimeSlot.MediaUrl;
				State.ProgramNext.RelativeStartTime = ChannelInfoResponse.NextTimeSlot.RelativeStart;
				State.ProgramNext.RoomId = ChannelInfoResponse.NextTimeSlot.RoomId;
				State.ProgramNext.ChronoRef = Now;

				UpdateProgram(Controls.Frame_ProgramNow, State.ProgramNow);		
				UpdateProgram(Controls.Frame_ProgramNext, State.ProgramNext);

				if (State.ProgramNow.RoomId != {{{ClubStruct::P}}}C_RoomNullId && State.ProgramNext.RoomId != {{{ClubStruct::P}}}C_RoomNullId) {
					ReportSystem::AddData(
						ReportStruct::C_ReportTarget_Room,
						ReportStruct::LibStructuresReport_K_ReportData {
							Details = [State.ProgramNow.Name, State.ProgramNext.Name],
							Ids = [TL::ToText(State.ProgramNow.RoomId), TL::ToText(State.ProgramNext.RoomId)],
							Contexts = [["channelUid" => ChannelInfoResponse.Uid], ["channelUid" => ChannelInfoResponse.Uid]]
						}
					);
				}

				ReportContext::SetArcadePrograms(
					System,
					State.ProgramNow.Name,
					State.ProgramNow.MediaUrl,
					State.ProgramNext.Name,
					State.ProgramNext.MediaUrl
				);

				State.NeedProgramUpdate = False;
			} else {
				//L16N [Online] Message displayed when there is an http error when fetching arcade schedule. %1 is a http error code, e.g. 'Error code: 500'
				Controls.Label_Error.SetText(TL::Compose(_("Error while fetching the arcade schedule, please try again. (Error code: %1)"), ""^Http::GetStatusCode(State.ChannelInfoRequest)));
			}
			Http::Destroy(State.ChannelInfoRequest);
		}
	}
	
	if (!Http::IsRunning(State.ChannelInfoRequest)) {
		State = UpdateProgramTimer(Controls.Frame_ProgramNow, State.ProgramNow, State);
		State = UpdateProgramTimer(Controls.Frame_ProgramNext, State.ProgramNext, State);
	}

	if (Http::IsInitialized(State.ChannelGridRequest) && State.NeedScheduleUpdate) {
		State.ChannelGridRequest = Http::Update(State.ChannelGridRequest);
		if (!Http::IsRunning(State.ChannelGridRequest)) {
			if (Http::IsSuccess(State.ChannelGridRequest)) {
				State.ProgramGrid.clear();
				{{{LoadingSpinner::P}}}StopAnimation(This, Controls.Frame_LoadingSpinner);
				declare ChannelGridResponse = ChannelAPI::GetResponseFromGetChannelGrid(State.ChannelGridRequest);

				// We need to convert the grid schedule retrieved from the API (UTC time zone) into the player's time zone
				State.CurrentTimeZone = ML::FloorInteger((TiL::Clamp01TZDay(TiL::GetCurrent()) - TiL::Clamp01UTCDay(TiL::GetCurrent())) * 48);
				for (Hour, 0, 47) {
					State.ProgramGrid.add(K_ProgramInfo{});
					for (Day, 0, 6) {
						declare Integer DayIndex = Day;
						declare Integer HourIndex = Hour - State.CurrentTimeZone;
						if (HourIndex < 0) { //< If the player's time zone is positive
							HourIndex += 48; 
							DayIndex -= 1;
							if (DayIndex < 0) DayIndex += 7;
						} else if (HourIndex > 47) { //< If the player's time zone is negative
							HourIndex -= 48; 
							DayIndex += 1;
							if (DayIndex > 6) DayIndex -= 7;
						}
						State.ProgramGrid.add(K_ProgramInfo{
							Id = ChannelGridResponse.Days[DayIndex].Hours[HourIndex].Program.Id,
							Name = ChannelGridResponse.Days[DayIndex].Hours[HourIndex].Program.Name,
							MediaUrl = ChannelGridResponse.Days[DayIndex].Hours[HourIndex].Program.MediaUrl
						});
					}
				}

				State = UpdateSchedule(State, Controls.Frame_ScrollSchedule, True);
				{{{Scroll::P}}}ScrollToElement(This, Controls.Frame_ScrollSchedule, State.CurrentProgram);
				State.NeedScheduleUpdate = False;
				Controls.Frame_ScrollSchedule.Show();
			} else {
				//L16N [Online] Message displayed when there is an http error when fetching arcade schedule. %1 is a http error code, e.g. 'Error code: 500'
				Controls.Label_Error.SetText(TL::Compose(_("Error while fetching the arcade schedule, please try again. (Error code: %1)"), ""^Http::GetStatusCode(State.ChannelGridRequest)));
			}
			Http::Destroy(State.ChannelGridRequest);
		}
	}

	if (!Http::IsRunning(State.ChannelGridRequest) && Now >= AllowTimeIndicatorUpdate + C_DelayBetweenTimeUpdate) {
		AllowTimeIndicatorUpdate = Now;

		// We need to switch current program focus if we pass to the next hour
		declare Integer CurrentHour = ML::TruncInteger(TiL::Clamp01TZDay(TiL::GetCurrent()) * 48);
		if (State.CurrentHour != CurrentHour) {
			State.CurrentHour = CurrentHour;
			State = UpdateSchedule(State, Controls.Frame_ScrollSchedule, True);
		} else {
			UpdateScheduleCurrentTime(State, Controls.Frame_ScrollSchedule, True);
		}
		
		// We need to update the current day if we pass to the next day
		declare Integer CurrentDay = ML::FloorInteger(((TL::ToReal(TiL::GetCurrent()) + State.CurrentTimeZone / 2 * 60 * 60) / 86400) + 3) % 7; 
		if (State.CurrentDay != CurrentDay) {
			State.CurrentDay = CurrentDay;
			UpdateScheduleCurrentDay(Controls.Frame_WeekDays, CurrentDay);
			State = UpdateSchedule(State, Controls.Frame_ScrollSchedule, True);
		}
	}
	
	if (Http::IsInitialized(State.JoinLinkRequest)) {
		State.JoinLinkRequest = Http::Update(State.JoinLinkRequest);
		if (!Http::IsRunning(State.JoinLinkRequest)) {
			if (Http::IsSuccess(State.JoinLinkRequest)) {
				declare Text JoinLink = ChannelAPI::GetResponseFromGetJoinLink(State.JoinLinkRequest);
				if (JoinLink != "") {
					SendCustomEvent("{{{Const::C_Event_UpdateLoadingScreen}}}", [State.ProgramNow.Name]);
					TitleControl::OpenLinkAndWait(This, TitleControl, JoinLink, CMlScript::LinkType::ManialinkBrowser);
					SendCustomEvent("{{{UbisoftChallenges::C_Challenge_OnlineMultiplayer}}}", []);
				} else {
					//L16N [Online] Message displayed when there is no joinlink to join a server.
					Controls.Label_Error.SetText(_("Servers are offline or in maintenance, please try again later."));
				}
				NeedChannelUpdate = True;
			} else {
				//L16N [Online] Message displayed when there is a http error when joining a server. %1 is a http error code, e.g. 'Error code: 500'
				Controls.Label_Error.SetText(TL::Compose(_("Error while joining the server, please try again. (Error code: %1)"), ""^Http::GetStatusCode(State.JoinLinkRequest)));
			}
			State.JoinLinkRequest = Http::Destroy(State.JoinLinkRequest);
			{{{ExpendableButton::P}}}SetIconImageUrl(This, Controls.Button_Join, "{{{Const::C_ImageUrl_Icon_Animated_Triple_Arrow_Right}}}", False);
			{{{ExpendableButton::P}}}SetText(This, Controls.Button_Join, "{{{Text_Join}}}");
		}
	}

	/* Report system events */
	foreach (Event in ReportSystem::GetPendingEvents()) {
		if (Event.LastUsingId == "{{{C_Name}}}") {
			switch (Event.Type) {
				case ReportSystem::C_EventType_Open: {
					LockPage(Controls, True);
				}
				case ReportSystem::C_EventType_Close: {
					LockPage(Controls, False);
					UpdateControllerInfo(Controls);
				}
			}
		}
	}

	/* Navigation events */
	foreach (Event in {{{Navigation::P}}}GetPendingEvents(This)) {
		switch (Event.Type) {
			case {{{Navigation::P}}}C_EventType_NavigateInput: {
				if ({{{Navigation::P}}}IsEventFromGroup(This, Event, "{{{C_NavGroup_ArcadeChannel}}}")) {
					switch (Event.Input) {
						case CMlScriptEvent::EMenuNavAction::Select: State = Select(Event.To, Controls, State);
						case CMlScriptEvent::EMenuNavAction::Cancel: DisplayArcadeChannel(Controls, False);
						case CMlScriptEvent::EMenuNavAction::Up: {{{Scroll::P}}}ScrollDelta(This, Controls.Frame_ScrollSchedule, -10., 250);
						case CMlScriptEvent::EMenuNavAction::Down: {{{Scroll::P}}}ScrollDelta(This, Controls.Frame_ScrollSchedule, 10., 250);
						default: Focus(Event.From, Event.To);
					}
				}
			}
			case {{{Navigation::P}}}C_EventType_NavigateMouse: {
				if ({{{Navigation::P}}}IsEventFromGroup(This, Event, "{{{C_NavGroup_ArcadeChannel}}}")) {
					if (Event.Mouse == CMlScriptEvent::Type::MouseClick) {
						State = Select(Event.To, Controls, State);
					} else if (Event.Mouse == CMlScriptEvent::Type::MouseOver) {
						Focus(Event.From, Event.To);
					}
				}
			}
		}
	}

	/* Scroll events */
	foreach (Event in {{{Scroll::P}}}GetPendingEvents(This)) {
		if (Event.Scroll != Null && Event.Scroll.Id == Controls.Frame_ScrollSchedule.Id) {
			switch (Event.Type) {
				case {{{Scroll::P}}}C_EventType_Update: {
					if (State.ProgramGrid.count == {{{C_Schedule_ElementsTotal}}}) {
						State = UpdateSchedule(State, Controls.Frame_ScrollSchedule, False);
					}
					foreach (Key => Frame_Element in Event.ElementsHidden) {
						Frame_Element.Visible = False;
					}
				}
			}
		}
	}

	/* NavigationTabs events */
	foreach (Event in {{{NavigationTabs::P}}}GetPendingEvents(This)) {
		switch (Event.Type) {
			case {{{NavigationTabs::P}}}C_EventType_Select: {
				if (Event.Frame_NavigationTabs.ControlId == Controls.Frame_NavigationTabs.ControlId) {
					State = SwitchView(State, Controls, Event.CurrentTab);
				}
			}
		}
	}

	/* PopUpBackground events */
	foreach (Event in {{{PopUpBackground::P}}}GetPendingEvents(This)) {
		if (Event.PopUpBackground != Null && Event.PopUpBackground.ControlId == "frame-background") {
			switch (Event.Type) {
				case {{{PopUpBackground::P}}}C_EventType_Close:	DisplayArcadeChannel(Controls, False);
			}
		}
	}

	/* Handle Channel Updates */
	if (NeedChannelUpdate) {
		NeedChannelUpdate = False;
		TitleControl::WaitIsReady(TitleControl);
		State.NeedProgramUpdate = True;
		State.NeedScheduleUpdate = True;
		if (Http::IsInitialized(State.ChannelInfoRequest)) {
			Http::Destroy(State.ChannelInfoRequest);
		}
		if (Http::IsInitialized(State.ChannelGridRequest)) {
			Http::Destroy(State.ChannelGridRequest);
		}
		State.ChannelInfoRequest = ChannelAPI::GetChannelInfo("{{{Const::C_ChannelUid_Arcade}}}");
		State.ChannelGridRequest = ChannelAPI::GetChannelGrid("{{{Const::C_ChannelUid_Arcade}}}");
	}

	// Check play privilege
	if (!Privileges::Check_IsComplete(State.PlayPrivilegeCheck)) {
		State.PlayPrivilegeCheck = Privileges::Check_Update(State.PlayPrivilegeCheck);
		if (Privileges::Check_IsComplete(State.PlayPrivilegeCheck)) {
			State.PlayPrivilegeCheck = Privileges::Check_Destroy(State.PlayPrivilegeCheck);
			if (Privileges::Check_HasPrivilege(State.PlayPrivilegeCheck)) {
				State = JoinRoom(State, Controls, False);
			}
		}
	}
}
***
""",
[
	Button::ComponentV2(),
	ButtonIcon::ComponentV2(),
	ExpendableButton::ComponentV2(),
	LoadingSpinner::ComponentV2(),
	MenuSounds::ComponentV2(),
	Navigation::ComponentV2(),
	NavigationTabs::ComponentV2(),
	PopUpBackground::ComponentV2(),
	Router::ComponentV2(),
	Scroll::ComponentV2(),
	Transition::ComponentV2(),
	UserStore::ComponentV2(),
	ClubStruct::Component()
],
[]
	);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update from the ManiaApp
Void Yield() {
	
}