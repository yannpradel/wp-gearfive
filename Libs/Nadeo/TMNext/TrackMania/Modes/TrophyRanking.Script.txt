/** 
 *	Manage players' trophy ranking
 */
#Const Version		"2020-06-29"
#Const ScriptName	"Libs/Nadeo/TMNext/TrackMania/Modes/TrophyRanking.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/CommonLibs/Common/Http.Script.txt" as Http
#Include "Libs/Nadeo/TMNext/TrackMania/API/LeaderboardAPI.Script.txt" as LeaderboardAPI

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_NotInitialized -2
#Const C_NotRanked -1
#Const C_ValidRank 1
#Const C_RequestGetTrophyRankingCooldownDuration 1000

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Globales
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
declare Http::K_Request G_RequestGetTrophyRanking;
declare Integer G_RequestGetTrophyRanking_CooldownEndTime;
declare Text[] G_RequestGetTrophyRanking_AccountIdsToRequest;
declare Text[] G_RequestGetTrophyRanking_AccountIdsRequested;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Check if a user is ranked
Boolean UserIsRanked(CUser _User) {
	declare Integer LibTMNextTrophyRanking_Rank for _User = C_NotInitialized;
	return LibTMNextTrophyRanking_Rank >= C_ValidRank;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the trophy ranking of a user.
 *	The return value can be negative.
 *	It means that we did not retrieve
 *	the rank from the API yet.
 */
Integer GetUserRank(CUser _User) {
	declare Integer LibTMNextTrophyRanking_Rank for _User = C_NotInitialized;
	return LibTMNextTrophyRanking_Rank;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Initalize a user
Void InitializeUser(CUser _User, Boolean _ForceUpdate) {
	declare Integer LibTMNextTrophyRanking_Rank for _User = C_NotInitialized;
	if (_ForceUpdate || LibTMNextTrophyRanking_Rank == C_NotInitialized) {
		LibTMNextTrophyRanking_Rank = C_NotInitialized;
		if (!G_RequestGetTrophyRanking_AccountIdsToRequest.exists(_User.WebServicesUserId)) {
			G_RequestGetTrophyRanking_AccountIdsToRequest.add(_User.WebServicesUserId);
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Check if we are missing a rank on a user
Void UpdateUsersRank() {
	foreach (User in Users) {
		InitializeUser(User, False);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update library
Void Yield() {
	if (Http::IsInitialized(G_RequestGetTrophyRanking)) {
		G_RequestGetTrophyRanking = Http::Update(G_RequestGetTrophyRanking);
		if (!Http::IsRunning(G_RequestGetTrophyRanking)) {
			if (Http::IsSuccess(G_RequestGetTrophyRanking)) {
				declare Response = LeaderboardAPI::GetResponseFromGetPlayersTrophyRankingServer(G_RequestGetTrophyRanking);
				declare Integer[Text] AccountsRank;
				foreach (AccountId in G_RequestGetTrophyRanking_AccountIdsRequested) {
					AccountsRank[AccountId] = Response.Total + 1;
				}
				foreach (Player in Response.Players) {
					// Answer must contain only world zone
					if (Player.Ranking.count >= 1) {
						AccountsRank[Player.AccountId] = Player.Ranking[0].Position;
					}
				}
				foreach (User in Users) {
					declare Integer LibTMNextTrophyRanking_Rank for User = C_NotInitialized;
					if (LibTMNextTrophyRanking_Rank == C_NotInitialized && AccountsRank.existskey(User.WebServicesUserId)) {
						LibTMNextTrophyRanking_Rank = AccountsRank[User.WebServicesUserId];
					}
				}
			}
			G_RequestGetTrophyRanking = Http::Destroy(G_RequestGetTrophyRanking);
		}
	} else if (G_RequestGetTrophyRanking_AccountIdsToRequest.count > 0 && Now >= G_RequestGetTrophyRanking_CooldownEndTime) {
		G_RequestGetTrophyRanking = LeaderboardAPI::GetPlayersTrophyRankingServer(G_RequestGetTrophyRanking_AccountIdsToRequest);
		G_RequestGetTrophyRanking_CooldownEndTime = Now + C_RequestGetTrophyRankingCooldownDuration;
		G_RequestGetTrophyRanking_AccountIdsRequested = G_RequestGetTrophyRanking_AccountIdsToRequest;
		G_RequestGetTrophyRanking_AccountIdsToRequest = [];
	}
}