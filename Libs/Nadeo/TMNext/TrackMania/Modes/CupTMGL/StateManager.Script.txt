/** 
 *	State manager for the Cup TMGL mode
 */
#Const Version		"2021-11-16"
#Const ScriptName	"Libs/Nadeo/TMNext/TrackMania/Modes/CupTMGL/StateManager.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/ModeLibs/Common/UIModules_Server.Script.txt" as UIModules
#Include "Libs/Nadeo/TMNext/TrackMania/Modes/CupCommon/Constants.Script.txt" as CupCommon_Const
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/Chrono_Server.Script.txt" as UIModules_Chrono_Default
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/Countdown_Server.Script.txt" as UIModules_Countdown_Default
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/DisplayMessage_Server.Script.txt" as UIModules_DisplayMessage_Default
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/LapsCounter_Server.Script.txt" as UIModules_LapsCounter_Default
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/RespawnHelper_Server.Script.txt" as UIModules_RespawnHelper_Default
#Include "ManiaApps/Nadeo/TMNext/TrackMania/Rounds/UIModules/SmallScoresTable_Server.Script.txt" as UIModules_SmallScoresTable_Default
#Include "ManiaApps/Nadeo/TMNext/TrackMania/ChampionCommon/UIModules/KOVictory_Server.Script.txt" as UIModules_KOVictory
#Include "ManiaApps/Nadeo/TMNext/TrackMania/UIModules/TMGLMarkers_Server.Script.txt" as UIModules_TMGLMarkers
#Include "ManiaApps/Nadeo/TMNext/TrackMania/ChampionTMGL/UIModules/InfoPanels_2x3_Server.Script.txt" as UIModules_InfoPanels_2x3
#Include "ManiaApps/Nadeo/TMNext/TrackMania/ChampionCommon/UIModules/Sign16x9_Server.Script.txt" as UIModules_Sign16x9
#Include "ManiaApps/Nadeo/TMNext/TrackMania/ChampionCommon/UIModules/Sign64x10_Server.Script.txt" as UIModules_Sign64x10
#Include "ManiaApps/Nadeo/TMNext/TrackMania/Champion/UIModules/SpectatorInfo_Server.Script.txt" as UIModules_SpectatorInfo
#Include "ManiaApps/Nadeo/TMNext/TrackMania/Champion/UIModules/CountDown_Server.Script.txt" as UIModules_CountDown
#Include "ManiaApps/Nadeo/TMNext/TrackMania/Champion/UIModules/ChronoChampion_Server.Script.txt" as UIModules_Chrono
#Include "ManiaApps/Nadeo/TMNext/TrackMania/Champion/UIModules/LapsCounter_Server.Script.txt" as UIModules_LapsCounter
#Include "ManiaApps/Nadeo/TMNext/TrackMania/Champion/UIModules/WarmUp_Server.Script.txt" as UIModules_WarmUp
#Include "ManiaApps/Nadeo/TMNext/TrackMania/Champion/UIModules/MapInfo_Server.Script.txt" as UIModules_MapInfo
#Include "ManiaApps/Nadeo/TMNext/TrackMania/Champion/UIModules/LiveRankingChampion_Server.Script.txt" as UIModules_LiveRanking
#Include "ManiaApps/Nadeo/TMNext/TrackMania/ChampionTMGL/UIModules/Chat_Server.Script.txt" as UIModules_Chat
#Include "ManiaApps/Nadeo/TMNext/TrackMania/ChampionCommon/UIModules/AmbientSound_Server.Script.txt" as UIModules_AmbientSound

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/*	Enabling this setting will have
 *	a big impact on the script performances
 *	in crowded server. The library
 *	will do a check on every player
 *	of the server on every frame.
 *	If the script respect the convention
 *	to always use MB_Yield() instead of yield;
 *	then it should not have to enforce
 *	the state at each frame. Any new
 *	player will be initialized when
 *	they join the server
 */
#Const C_ForceStatesEveryFrame False

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Globales
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
declare Integer[] G_ForcedStates;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Apply the given states to the given player
 *
 *	@param	_Player										The player to update
 *	@param	_States										The states to apply
 */
Void Private_Apply(CPlayer _Player, Integer[] _States) {
	if (_Player == Null) return;
	
	UIModules_InfoPanels_2x3::SetVisibility(_Player, True);
	UIModules_Sign16x9::SetVisibility(_Player, True);
	UIModules_Sign64x10::SetVisibility(_Player, True);
	UIModules_TMGLMarkers::SetVisibility(_Player, False);
	UIModules_SpectatorInfo::SetVisibility(_Player, False);
	UIModules_CountDown::SetVisibility(_Player, False);
	UIModules_Chrono::SetVisibility(_Player, False);
	UIModules_LapsCounter::SetVisibility(_Player, False);
	UIModules_WarmUp::SetVisibility(_Player, False);
	UIModules_MapInfo::SetVisibility(_Player, False);
	UIModules_LiveRanking::SetVisibility(_Player, False);
	UIModules_Chat::SetVisibility(_Player, True);
	UIModules_AmbientSound::SetVisibility(_Player, True);
	UIModules_KOVictory::SetVisibility(_Player, False);
	
	foreach (State in _States) {
		switch (State) {
			case CupCommon_Const::C_State_Playing: {
				UIModules_TMGLMarkers::SetVisibility(_Player, True);
				UIModules_SpectatorInfo::SetVisibility(_Player, True);
				UIModules_CountDown::SetVisibility(_Player, True);
				UIModules_Chrono::SetVisibility(_Player, True);
				UIModules_LapsCounter::SetVisibility(_Player, True);
				UIModules_LiveRanking::SetVisibility(_Player, True);
				UIModules_KOVictory::SetVisibility(_Player, True);
			}
			case CupCommon_Const::C_State_WarmUp: {
				UIModules_WarmUp::SetVisibility(_Player, True);
				UIModules_MapInfo::SetVisibility(_Player, True);
			}
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Add a state to a player
 *
 *	@param	_Player										The player to update
 *	@param	_State										The state to add
 */
Void Add(CPlayer _Player, Integer _State) {
	if (_Player == Null) return;
	declare Integer[] LibStateMgr_States for _Player;
	if (!LibStateMgr_States.exists(_State)) {
		LibStateMgr_States.add(_State);
		if (G_ForcedStates.count <= 0) {
			Private_Apply(_Player, LibStateMgr_States);
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Remove a state from a player
 *
 *	@param	_Player										The player to update
 *	@param	_State										The state to remove
 */
Void Remove(CPlayer _Player, Integer _State) {
	if (_Player == Null) return;
	declare Integer[] LibStateMgr_States for _Player;
	if (LibStateMgr_States.exists(_State)) {
		declare Removed = LibStateMgr_States.remove(_State);
		if (G_ForcedStates.count <= 0) {
			Private_Apply(_Player, LibStateMgr_States);
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Remove all state from a player
 *
 *	@param	_Player										The player to reset
 */
Void Reset(CPlayer _Player) {
	if (_Player == Null) return;
	declare Integer[] LibStateMgr_States for _Player;
	LibStateMgr_States = [];
	if (G_ForcedStates.count <= 0) {
		Private_Apply(_Player, LibStateMgr_States);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Check if the player has the given state
 *
 *	@param	_Player										The player to check
 *	@param	_State										The state to find
 *
 *	@return														True if the player has the state
 *																		False otherwise
 */
Boolean HasState(CPlayer _Player, Integer _State) {
	if (_Player == Null) return False;

	declare Integer[] LibStateMgr_States for _Player;
	return LibStateMgr_States.exists(_State) || G_ForcedStates.exists(_State);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Check if the players have the given state as forced
 *
 *	@param	_State										The state to find
 *
 *	@return														True if the players has the state
 *																		False otherwise
 */
Boolean HasForcedState(Integer _State) {
	return G_ForcedStates.exists(_State);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the currently forced states
Integer[] GetForcedStates() {
	return G_ForcedStates;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Force the states applied to all players
 *	To disable the forced states use an empty array
 *
 *	@param	_States									The states to force
 */
Void ForcePlayersStates(Integer[] _States) {
	G_ForcedStates = _States;
	
	foreach (Player in AllPlayers) {
		declare Boolean LibStateMgr_IsForcedStates for Player = False;
		// Enable
		if (G_ForcedStates.count > 0) {
			LibStateMgr_IsForcedStates = True;
			Private_Apply(Player, G_ForcedStates);
		}
		// Disable
		else {
			LibStateMgr_IsForcedStates = False;
			declare Integer[] LibStateMgr_States for Player;
			Private_Apply(Player, LibStateMgr_States);
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the library
Void Yield() {
	if (C_ForceStatesEveryFrame && G_ForcedStates.count > 0) {
		foreach (Player in AllPlayers) {
			declare Boolean LibStateMgr_IsForcedStates for Player = False;
			if (!LibStateMgr_IsForcedStates) {
				LibStateMgr_IsForcedStates = True;
				Private_Apply(Player, G_ForcedStates);
			}
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Initialize a player
 *
 *	@param	_Player										The player to initialize
 */
Void InitializePlayer(CPlayer _Player) {
	if (_Player == Null) return;
	
	UIModules_TMGLMarkers::InitializePlayer(_Player);
	UIModules_InfoPanels_2x3::InitializePlayer(_Player);
	UIModules_Sign16x9::InitializePlayer(_Player);
	UIModules_Sign64x10::InitializePlayer(_Player);
	UIModules_SpectatorInfo::InitializePlayer(_Player);
	UIModules_CountDown::InitializePlayer(_Player);
	UIModules_Chrono::InitializePlayer(_Player);
	UIModules_LapsCounter::InitializePlayer(_Player);
	UIModules_WarmUp::InitializePlayer(_Player);
	UIModules_MapInfo::InitializePlayer(_Player);
	UIModules_LiveRanking::InitializePlayer(_Player);
	UIModules_Chat::InitializePlayer(_Player);
	UIModules_AmbientSound::InitializePlayer(_Player);
	UIModules_KOVictory::InitializePlayer(_Player);
	
	Reset(_Player);
	
	if (G_ForcedStates.count > 0) {
		declare Boolean LibStateMgr_IsForcedStates for _Player = False;
		LibStateMgr_IsForcedStates = True;
		Private_Apply(_Player, G_ForcedStates);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Unload the library
Void Unload() {
	ForcePlayersStates([]);
	
	foreach (Player in AllPlayers) {
		InitializePlayer(Player);
	}
	
	UIModules_KOVictory::Unload();
	UIModules_AmbientSound::Unload();
	UIModules_Chat::Unload();
	UIModules_LiveRanking::Unload();
	UIModules_MapInfo::Unload();
	UIModules_WarmUp::Unload();
	UIModules_LapsCounter::Unload();
	UIModules_Chrono::Unload();
	UIModules_CountDown::Unload();
	UIModules_SpectatorInfo::Unload();
	UIModules_InfoPanels_2x3::Unload();
	UIModules_Sign64x10::Unload();
	UIModules_Sign16x9::Unload();
	UIModules_TMGLMarkers::Unload();
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Load the library
Void Load() {
	Unload();
	
	UIModules_TMGLMarkers::Load();
	UIModules_InfoPanels_2x3::Load();
	UIModules_Sign16x9::Load();
	UIModules_Sign64x10::Load();
	UIModules_SpectatorInfo::Load();
	UIModules_CountDown::Load();
	UIModules_Chrono::Load();
	UIModules_LapsCounter::Load();
	UIModules_WarmUp::Load();
	UIModules_MapInfo::Load();
	UIModules_LiveRanking::Load();
	UIModules_Chat::Load();
	UIModules_AmbientSound::Load();
	UIModules_KOVictory::Load();
	
	UIModules::InitializeCustomizableModule(UIModules_KOVictory::GetConfig());
	UIModules::InitializeCustomizableModule(UIModules_Sign16x9::GetConfig());
	UIModules::InitializeCustomizableModule(UIModules_Sign64x10::GetConfig());
	
	declare Text[] Modules = [
		UIModules_TMGLMarkers::C_Id,
		UIModules_InfoPanels_2x3::C_Id,
		UIModules_SpectatorInfo::C_Id,
		UIModules_CountDown::C_Id,
		UIModules_Chrono::C_Id,
		UIModules_LapsCounter::C_Id,
		UIModules_WarmUp::C_Id,
		UIModules_MapInfo::C_Id,
		UIModules_LiveRanking::C_Id,
		UIModules_Chat::C_Id,
		UIModules_AmbientSound::C_Id,
		UIModules_KOVictory::GetId()
	];

	// Add C_LayersCount times the layers to repeat it on the screen
	for (I, 1, UIModules_Sign16x9::C_InstancesNb) {
		Modules.add(UIModules_Sign16x9::GetId(I));
	}

	foreach (AttachId in UIModules_Sign64x10::C_AttachIds) {
		Modules.add(UIModules_Sign64x10::GetId(AttachId));
	}

	UIModules::LoadModules(Modules);
	
	// Unload some default modules
	UIModules::UnloadModules([
		UIModules_Chrono_Default::GetId(),
		UIModules_Countdown_Default::GetId(),
		UIModules_DisplayMessage_Default::GetId(),
		UIModules_LapsCounter_Default::GetId(),
		UIModules_RespawnHelper_Default::GetId(),
		UIModules_SmallScoresTable_Default::GetId()
	]);
}