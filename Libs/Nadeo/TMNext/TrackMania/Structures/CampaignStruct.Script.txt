/**
 *	Structures for Campaigns
 */
#Const Version		"2023-06-12"
#Const ScriptName	"Libs/Nadeo/TMNext/TrackMania/Structures/CampaignStruct.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "TextLib" as TL
#Include "Libs/Nadeo/MenuLibs/Common/Manialink/ManiaView2.Script.txt" as MV
#Include "Libs/Nadeo/TMNext/TrackMania/Structures/HttpStruct.Script.txt" as HttpStruct
#Include "Libs/Nadeo/TMNext/TrackMania/Structures/ClubStruct.Script.txt" as ClubStruct
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Constants.Script.txt" as Const
#Include "Libs/Nadeo/TMNext/TrackMania/Config.Script.txt" as Config

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_ComponentName "lib-campaign-struct"
#Const P "LibCampaignStruct_"

#Const C_Campaign_NullId 0 //< Same value as in the LIVE database
#Const C_MonthlyCampaign_NullId 0
#Const C_TrainingCampaign_Id -1

#Const C_CampaignType_None -1
#Const C_CampaignType_Quarterly 0
#Const C_CampaignType_Monthly 1
#Const C_CampaignType_Club 2
#Const C_CampaignType_Training 3
#Const C_CampaignType_Royal 4
//L16N [TypeOfCampaign]
#Const C_CampaignType_Labels [
	-1 => _("|Campaign|Unknown"),
	0 => _("|Campaign|Quarterly"),
	1 => _("|Campaign|Monthly"),
	2 => _("|Campaign|Club"),
	3 => _("|Campaign|Training"),
	4 => _("|Campaign|Royal")
]
#Const C_CampaignType_ContextNames [
	-1 => "Unknown",
	0 => "Quarterly",
	1 => "Monthly",
	2 => "Club",
	3 => "Training",
	4 => "Royal"
]

#Const C_MapsByColumn 5

#Const C_LoadStatus_NotLoaded 0
#Const C_LoadStatus_Loaded 1
#Const C_LoadStatus_Error 2

#Const Const::C_Season_Names as C_Season_Names

// Map categories in official campaign
#Const C_CategoryWhite 0
#Const C_CategoryGreen 1
#Const C_CategoryBlue 2
#Const C_CategoryRed 3
#Const C_CategoryBlack 4

#Const C_MinBronzeMedalsToPlayBlueSection 10
#Const C_MinSilverMedalsToPlayRedSection 15
#Const C_MinGoldMedalsToPlayBlackSection 20

#Const C_MinBronzeMedalsToPlayBlueSectionDebug 1
#Const C_MinSilverMedalsToPlayRedSectionDebug 2
#Const C_MinGoldMedalsToPlayBlackSectionDebug 3

#Const C_CategoriesToMedalsNames [
	//L16N [Campaign] Name of the Bronze medal
	2 => _("Bronze"),
	//L16N [Campaign] Name of the Silver medal
	3 => _("Silver"),
	//L16N [Campaign] Name of the Gold medal
	4 => _("Gold")
]

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Structures
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Struct LibCampaignStruct_K_Top {
	Text AccountId;
	Text DisplayName;
	Text ZoneId;
	Integer Position;
	Text SP;
}

#Struct LibCampaignStruct_K_TopScore {
	Text AccountId;
	Text DisplayName;
	Text ZoneId;
	Integer Position;
	Integer Score;
}

#Struct LibCampaignStruct_K_TopRanking {
	Text ZoneName;
	LibCampaignStruct_K_Top[] Tops;
}

#Struct LibCampaignStruct_K_MapTopRanking {
	Text ZoneName;
	LibCampaignStruct_K_TopScore[] Tops;
}

#Struct LibCampaignStruct_K_Ranking {
	Text ZoneId;
	Text ZoneName;
	Integer Position;
	Integer Length;
}

#Struct LibCampaignStruct_K_CampaignRanking {
	LibCampaignStruct_K_Ranking[] Rankings;
	Text SP;
}

#Struct LibCampaignStruct_K_Season {
	Text Uid;
	Text Name;
	Integer StartTimestamp;
	Integer StartDate;
	Integer EndTimestamp;
	Integer EndDate;
	Integer RelativeStart;
	Integer RelativeEnd;
	Integer RelativeNow;
	Integer CampaignId;
	Boolean Active;
}

#Struct LibCampaignStruct_K_PlayerCloseToMedal {
	Text Medal;
	Text AccountId;
	Text ZoneId;
	Text ZoneName;
	Integer Score;
}

#Struct LibCampaignStruct_K_Map {
	Integer Position;
	Text Uid;
	Text Name;
	Text Type;
	Text Style;
	Text AuthorLogin;
	Text AuthorDisplayName;
	Boolean AuthorIsFirstPartyDisplayName;
	Text SubmitterAccountId;
	Integer AuthorTime;
	Integer GoldTime;
	Integer SilverTime;
	Integer BronzeTime;
	Integer NbLaps;
	Text LocalFileName;
	Text DownloadUrl;
	Text ThumbnailUrl;
	Integer UploadTimestamp;
	Integer Score;
	Integer[Text] ScoreBySeason; //< Key is the uid of the season
	LibCampaignStruct_K_Ranking[] Rankings;
	Integer[Integer] ClubRankings; //< Key is the club id, Value is the position
	LibCampaignStruct_K_MapTopRanking[] TopRankings;
	LibCampaignStruct_K_TopScore[][Integer] ClubTopRankings; //< Key is the club id
	LibCampaignStruct_K_TopScore[][Text] SurroundingRankings; //< Key is the zone
	LibCampaignStruct_K_TopScore[][Text] RankingLevels; //< Key is the zone
	Integer UpdateTime_Rankings;
	Integer[Integer] UpdateTime_ClubRankings;
	Integer UpdateTime_TopRankings;
	Integer[Integer] UpdateTime_ClubTopRankings;
	Integer UpdateTime_SurroundingRankings;
	Integer UpdateTime_RankingLevels;
	Integer Medal;
	Integer Top;
	Text Zone;
	Boolean IsPlayable;
	Boolean IsFavorite;
	Text CollectionName;
	Boolean CreatedWithSimpleEditor;
	Boolean CreatedWithGamepadEditor;
}

#Struct LibCampaignStruct_K_Category {
	Text Name;
	LibCampaignStruct_K_Map[] Playlist;
}

#Struct LibCampaignStruct_K_Media {
	Text ButtonBackgroundUrl;
	Text ButtonForegroundUrl;
	Text DecalUrl;
	Text PopUpBackgroundUrl;
	Text PopUpImageUrl;
	Text LiveButtonBackgroundUrl;
	Text LiveButtonForegroundUrl;
}

#Struct LibCampaignStruct_K_Campaign {
	Integer Id;
	Text SeasonId;
	Integer ActivityId;
	Integer Type;
	Text Name;
	Text Color;
	Text LeaderboardGroupUid;
	ClubStruct::LibStructuresClub_K_Club Club;
	Boolean Published;
	Boolean IsSeasonLive;
	Boolean IsLoaded;
	Boolean IsFetched; //< True if the campaign has all the info to be loaded (SeasonId, LeaderboardGroupUid, etc.)
	Boolean FailedToGetMapUrl; //< True if we failed to retrieve the url to play one of the map from CORE services
	Boolean IsPrivate;
	Integer MapCount;
	LibCampaignStruct_K_Category[] Categories;
	LibCampaignStruct_K_CampaignRanking CampaignRanking;
	LibCampaignStruct_K_TopRanking[] TopRankings;
	LibCampaignStruct_K_Top[][Integer] ClubTopRankings; //< Key is the club id
	LibCampaignStruct_K_Top[Integer] ClubPlayerRanking; //< Key is the club id
	Integer UpdateTime_CampaignRanking;
	Integer UpdateTime_TopRankings;
	Integer[Integer] UpdateTime_ClubTopRankings;
	Integer[Integer] UpdateTime_ClubPlayerRanking;
	LibCampaignStruct_K_Media Media;
	Integer PopularityLevel;
	Boolean ClubOfficialTrophiesEnabled;
	LibCampaignStruct_K_Season[] Seasons;
	Integer EditionTimestamp;
	Integer Year;
	Integer SeasonName;
	Text CreatorAccountId;
	Text LatestEditorAccountId;
}

#Struct LibCampaignStruct_K_DailyMap {
	Integer CampaignId;
	Text SeasonId;
	Integer Day;
	Integer MonthDay;
	LibCampaignStruct_K_Map Map;
	Integer RelativeStart; //< If negative or zero, the map started
	Integer RelativeEnd; //< If negative or zero, the map ended
	Integer RelativeNow; //< `Now` value when we received the `RelativeStart` and `RelativeEnd` values
	Integer LoadStatus;
}

#Struct LibCampaignStruct_K_MonthlyCampaign {
	Integer Id; //< This is NOT an Id of a campaign, it is a homemade Id to find it more easily
	Integer Year;
	Integer Month;
	Integer LastDay;
	LibCampaignStruct_K_DailyMap[Integer] DailyMaps; //< Key is the day
	LibCampaignStruct_K_Media Media;
	Boolean IsLoaded;
	Boolean IsLive;
}

#Struct LibCampaignStruct_K_CampaignName {
	Boolean IsValid;
	Text Season;
	Text Year;
	Text Name;
	Text TranslatedName;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Find the season name in the campaign name
Integer GetSeasonNameInCampaignName(Text _CampaignName) {
	foreach (SeasonName => SeasonIndex in Const::C_Season_Name_To_Index) {
		if (TL::Find(SeasonName, _CampaignName, False, False)) return SeasonIndex;
	}
	return Const::C_SeasonIndex_Null;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Find the year in the campaign name
Integer GetYearInCampaignName(Text _CampaignName) {
	declare Text[] Result = TL::RegexFind("""\b\d{4,}\b""", _CampaignName, "");
	if (Result.count > 0) return TL::ToInteger(Result[0]);
	return 0;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
LibCampaignStruct_K_Campaign GetCampaignFromHttpCampaign(HttpStruct::LibHttpStruct_K_HttpCampaign _HttpCampaign) {
	declare Integer MapCount = 0;
	declare LibCampaignStruct_K_Category[] Categories;
	foreach (HttpCategory in _HttpCampaign.categories) {
		declare LibCampaignStruct_K_Map[] Playlist;
		for (HttpMapIndex, HttpCategory.position*C_MapsByColumn, (HttpCategory.position*C_MapsByColumn+HttpCategory.length*C_MapsByColumn)-1) {
			declare Text MapUid = "";
			if (_HttpCampaign.playlist.existskey(HttpMapIndex)) {
				MapUid = _HttpCampaign.playlist[HttpMapIndex].mapUid;
				if (MapUid != "") MapCount += 1;
			}
			Playlist.add(
				LibCampaignStruct_K_Map {
					Position = HttpMapIndex,
					Uid = MapUid
				}
			);
		}

		Categories.add(LibCampaignStruct_K_Category {
			Name = HttpCategory.name,
			Playlist = Playlist
		});
	}

	declare Boolean IsSeasonLive = False;
	declare LibCampaignStruct_K_Season[] Seasons;
	foreach (latestSeason in _HttpCampaign.latestSeasons) {
		Seasons.add(LibCampaignStruct_K_Season {
			Uid = latestSeason.uid,
			Name = latestSeason.name,
			StartTimestamp = latestSeason.startTimestamp,
			StartDate = latestSeason.startDate,
			EndTimestamp = latestSeason.endTimestamp,
			EndDate = latestSeason.endDate,
			RelativeStart = latestSeason.relativeStart,
			RelativeEnd = latestSeason.relativeEnd,
			RelativeNow = Now,
			CampaignId = latestSeason.campaignId,
			Active = latestSeason.active
		});
		if (!IsSeasonLive && latestSeason.active) {
			IsSeasonLive = True;
		}
	}

	return LibCampaignStruct_K_Campaign {
		Id = _HttpCampaign.id,
		SeasonId = _HttpCampaign.seasonUid,
		Type = _HttpCampaign.useCase,
		Name = _HttpCampaign.name,
		Color = _HttpCampaign.color,
		LeaderboardGroupUid = _HttpCampaign.leaderboardGroupUid,
		Club = ClubStruct::LibStructuresClub_K_Club {
			Id = _HttpCampaign.clubId
		},
		Published = _HttpCampaign.published,
		IsSeasonLive = IsSeasonLive,
		IsLoaded = False,
		IsFetched = False,
		FailedToGetMapUrl = False,
		MapCount = MapCount,
		Categories = Categories,
		CampaignRanking = LibCampaignStruct_K_CampaignRanking {},
		TopRankings = [],
		ClubTopRankings = [],
		Media = LibCampaignStruct_K_Media {
			ButtonBackgroundUrl = _HttpCampaign.media.buttonBackgroundUrl,
			ButtonForegroundUrl = _HttpCampaign.media.buttonForegroundUrl,
			DecalUrl = _HttpCampaign.media.decalUrl,
			PopUpBackgroundUrl = _HttpCampaign.media.popUpBackgroundUrl,
			PopUpImageUrl = _HttpCampaign.media.popUpImageUrl,
			LiveButtonBackgroundUrl = _HttpCampaign.media.liveButtonBackgroundUrl,
			LiveButtonForegroundUrl = _HttpCampaign.media.liveButtonForegroundUrl
		},
		Seasons = Seasons,
		EditionTimestamp = _HttpCampaign.editionTimestamp,
		SeasonName = GetSeasonNameInCampaignName(_HttpCampaign.name),
		Year = GetYearInCampaignName(_HttpCampaign.name)
	};
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get an empty campaign structure
LibCampaignStruct_K_Campaign GetEmptyCampaign() {
	return LibCampaignStruct_K_Campaign {
		Id = C_Campaign_NullId
	};
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get an empty monthly campaign structure
LibCampaignStruct_K_MonthlyCampaign GetEmptyMonthlyCampaign() {
	return LibCampaignStruct_K_MonthlyCampaign {
		Id = C_MonthlyCampaign_NullId
	};
}

LibCampaignStruct_K_Map GetMapFromNSMap(LibCampaignStruct_K_Map _OldMap, CNadeoServicesMap _NSMap) {
	declare LibCampaignStruct_K_Map NewMap = _OldMap;
	NewMap.Position = _OldMap.Position;
	NewMap.Uid = _NSMap.Uid;
	NewMap.Name = _NSMap.Name;
	NewMap.Type = _NSMap.Type;
	NewMap.Style = _NSMap.Style;
	NewMap.AuthorLogin = _NSMap.AuthorAccountId;
	NewMap.AuthorDisplayName = _NSMap.AuthorDisplayName;
	NewMap.AuthorIsFirstPartyDisplayName = _NSMap.AuthorIsFirstPartyDisplayName;
	NewMap.SubmitterAccountId = _NSMap.SubmitterAccountId;
	NewMap.CreatedWithSimpleEditor = _NSMap.CreatedWithSimpleEditor;
	NewMap.CreatedWithGamepadEditor = _NSMap.CreatedWithGamepadEditor;
	NewMap.AuthorTime = _NSMap.AuthorScore;
	NewMap.GoldTime = _NSMap.GoldScore;
	NewMap.SilverTime = _NSMap.SilverScore;
	NewMap.BronzeTime = _NSMap.BronzeScore;
	NewMap.DownloadUrl = _NSMap.FileUrl;
	NewMap.ThumbnailUrl = _NSMap.ThumbnailUrl;
	NewMap.UploadTimestamp = _NSMap.TimeStamp;
	NewMap.IsPlayable = _NSMap.IsPlayable;
	NewMap.CollectionName = _NSMap.CollectionName;

	return NewMap;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Parse a campaign name into a struct containing its season (see Const::C_Season_Names) and its year
 *
 *	@param _CampaignName		The name of the campaign to parse
 *
 *	@return									A struct LibCampaignStruct_K_CampaignName
 */
LibCampaignStruct_K_CampaignName ParseCampaignName(Text _CampaignName) {
	declare LibCampaignStruct_K_CampaignName CampaignName = LibCampaignStruct_K_CampaignName {
		IsValid = False,
		Name = _CampaignName
	};

	declare Text[] NameSplit = TL::Split(" ", _CampaignName);
	if (NameSplit.count >= 2) {
		CampaignName.Season = NameSplit[0];
		CampaignName.Year = NameSplit[1];
		CampaignName.IsValid = C_Season_Names.existskey(CampaignName.Season) && TL::ToInteger(CampaignName.Year) > 0;
		if (CampaignName.IsValid) {
			//L16N Campaign translated name. %1 will be replaced by the campaign season, %2 by the year, i.e. "Winter 2023"
			CampaignName.TranslatedName = TL::Compose(_("|CampaignName|%1 %2"), C_Season_Names[CampaignName.Season], CampaignName.Year);
		}
	}

	return CampaignName;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/**
 * Translate map if it's an official map from a quarterly campaign
 *
 *	@param _MapName							The name of the map to translate
 *	@param _ForceTranslation		Force the translation of the map name
 *
 *	@return											The translated name
 */
Text TranslateOfficialMapName(Text _MapName, Text _AuthorLogin, Boolean _ForceTranslation) {
	declare Text LocalMapName = _MapName;
	if (_ForceTranslation || _AuthorLogin == Const::C_Nadeo_Login) {
		declare Text[] NameSplit = TL::Split(" ", LocalMapName);
		if (NameSplit.count > 0) {
			declare Text MapNameEnd = TL::Trim(TL::Replace(LocalMapName, NameSplit[0], ""));
			if (NameSplit[0] == Const::C_Training_TrackName) {
				LocalMapName = TL::Compose("%1 %2", Const::C_Training_TranslatedName, MapNameEnd);
			} else {
				LocalMapName = TL::Compose("%1 %2", C_Season_Names.get(NameSplit[0], NameSplit[0]), MapNameEnd);
			}
		}
	}
	return LocalMapName;
}
Text TranslateOfficialMapName(Text _MapName, Text _AuthorLogin) {
	return TranslateOfficialMapName(_MapName, _AuthorLogin, False);
}

LibCampaignStruct_K_Map GetMapFromMapInfo(CMapInfo _MapInfo) {
	return LibCampaignStruct_K_Map {
		Uid = _MapInfo.MapUid,
		Name = _MapInfo.Name,
		LocalFileName = _MapInfo.FileName,
		Type = _MapInfo.MapType,
		Style = _MapInfo.MapStyle,
		AuthorLogin = _MapInfo.AuthorLogin,
		AuthorDisplayName = _MapInfo.AuthorNickName,
		AuthorTime = _MapInfo.TMObjective_AuthorTime,
		GoldTime = _MapInfo.TMObjective_GoldTime,
		SilverTime = _MapInfo.TMObjective_SilverTime,
		BronzeTime = _MapInfo.TMObjective_BronzeTime,
		ThumbnailUrl = "file://Thumbnails/MapUid/"^_MapInfo.MapUid,
		IsPlayable = _MapInfo.IsPlayable,
		CollectionName = _MapInfo.CollectionName,
		CreatedWithSimpleEditor = _MapInfo.CreatedWithSimpleEditor,
		CreatedWithGamepadEditor = _MapInfo.CreatedWithGamepadEditor
	};
}

// Get the minimum medals needed to unlock this category
Integer GetMedalsMinToUnlockCategory(Integer _CategoryIndex) {
	switch (_CategoryIndex) {
		case C_CategoryBlue: {
			if (Config::HasFeature(Config::C_Feature_DebugFakeCampaignUnlock)) return C_MinBronzeMedalsToPlayBlueSectionDebug;
			else return C_MinBronzeMedalsToPlayBlueSection;
		}
		case C_CategoryRed: {
			if (Config::HasFeature(Config::C_Feature_DebugFakeCampaignUnlock)) return C_MinSilverMedalsToPlayRedSectionDebug;
			else return C_MinSilverMedalsToPlayRedSection;
		}
		case C_CategoryBlack: {
			if (Config::HasFeature(Config::C_Feature_DebugFakeCampaignUnlock)) return C_MinGoldMedalsToPlayBlackSectionDebug;
			else return C_MinGoldMedalsToPlayBlackSection;
		}
	}

	return 0;
}

// Get the current medal image url to unlock this category
Text GetCurrentMedalUrlForCategory(Integer _CategoryIndex) {
	switch (_CategoryIndex) {
		case C_CategoryBlue: return Const::C_ImageUrl_Medal_Bronze_Small;
		case C_CategoryRed: return Const::C_ImageUrl_Medal_Silver_Small;
		case C_CategoryBlack: return Const::C_ImageUrl_Medal_Gold_Small;
	}
	return "";
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the manialink component
Text Component() {
	return MV::Component(
		C_ComponentName,
		"""
		""",
		"""
#Include "TextLib" as {{{P}}}TL
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Constants.Script.txt" as {{{P}}}Const
#Include "Libs/Nadeo/TMNext/TrackMania/Config.Script.txt" as {{{P}}}Config

#Const {{{P}}}C_CampaignType_None {{{dump(C_CampaignType_None)}}}
#Const {{{P}}}C_CampaignType_Quarterly {{{dump(C_CampaignType_Quarterly)}}}
#Const {{{P}}}C_CampaignType_Club {{{dump(C_CampaignType_Club)}}}
#Const {{{P}}}C_CampaignType_Training {{{dump(C_CampaignType_Training)}}}
#Const {{{P}}}C_CampaignType_Monthly {{{dump(C_CampaignType_Monthly)}}}
#Const {{{P}}}C_CampaignType_Royal {{{dump(C_CampaignType_Royal)}}}

#Const {{{P}}}C_CampaignType_ContextNames {{{dump(C_CampaignType_ContextNames)}}}

#Const {{{P}}}C_Campaign_NullId {{{dump(C_Campaign_NullId)}}}
#Const {{{P}}}C_MonthlyCampaign_NullId {{{dump(C_MonthlyCampaign_NullId)}}}

#Const {{{P}}}C_LoadStatus_NotLoaded {{{dump(C_LoadStatus_NotLoaded)}}}
#Const {{{P}}}C_LoadStatus_Loaded {{{dump(C_LoadStatus_Loaded)}}}
#Const {{{P}}}C_LoadStatus_Error {{{dump(C_LoadStatus_Error)}}}

#Const {{{P}}}C_Season_Names {{{dump(C_Season_Names)}}}

#Const {{{P}}}C_CategoryWhite {{{dump(C_CategoryWhite)}}}
#Const {{{P}}}C_CategoryGreen {{{dump(C_CategoryGreen)}}}
#Const {{{P}}}C_CategoryBlue {{{dump(C_CategoryBlue)}}}
#Const {{{P}}}C_CategoryRed {{{dump(C_CategoryRed)}}}
#Const {{{P}}}C_CategoryBlack {{{dump(C_CategoryBlack)}}}

#Const {{{P}}}C_MinBronzeMedalsToPlayBlueSection {{{dump(C_MinBronzeMedalsToPlayBlueSection)}}}
#Const {{{P}}}C_MinSilverMedalsToPlayRedSection {{{dump(C_MinSilverMedalsToPlayRedSection)}}}
#Const {{{P}}}C_MinGoldMedalsToPlayBlackSection {{{dump(C_MinGoldMedalsToPlayBlackSection)}}}

#Const {{{P}}}C_MinBronzeMedalsToPlayBlueSectionDebug {{{dump(C_MinBronzeMedalsToPlayBlueSectionDebug)}}}
#Const {{{P}}}C_MinSilverMedalsToPlayRedSectionDebug {{{dump(C_MinSilverMedalsToPlayRedSectionDebug)}}}
#Const {{{P}}}C_MinGoldMedalsToPlayBlackSectionDebug {{{dump(C_MinGoldMedalsToPlayBlackSectionDebug)}}}

#Const {{{P}}}C_CategoriesToMedalsNames {{{dump(C_CategoriesToMedalsNames)}}}

{{{dumptype(LibCampaignStruct_K_Top)}}}
{{{dumptype(LibCampaignStruct_K_TopScore)}}}
{{{dumptype(LibCampaignStruct_K_TopRanking)}}}
{{{dumptype(LibCampaignStruct_K_MapTopRanking)}}}
{{{dumptype(LibCampaignStruct_K_PlayerCloseToMedal)}}}
{{{dumptype(LibCampaignStruct_K_Ranking)}}}
{{{dumptype(LibCampaignStruct_K_CampaignRanking)}}}
{{{dumptype(LibCampaignStruct_K_Season)}}}
{{{dumptype(LibCampaignStruct_K_Map)}}}
{{{dumptype(LibCampaignStruct_K_Category)}}}
{{{dumptype(LibCampaignStruct_K_Media)}}}
{{{dumptype(LibCampaignStruct_K_Campaign)}}}
{{{dumptype(LibCampaignStruct_K_DailyMap)}}}
{{{dumptype(LibCampaignStruct_K_MonthlyCampaign)}}}
{{{dumptype(LibCampaignStruct_K_CampaignName)}}}
		""",
		"""
Integer {{{P}}}GetSeasonNameInCampaignName(Text _CampaignName) {
	foreach (SeasonName => SeasonIndex in {{{P}}}Const::C_Season_Name_To_Index) {
		if ({{{P}}}TL::Find(SeasonName, _CampaignName, False, False)) return SeasonIndex;
	}
	return {{{P}}}Const::C_SeasonIndex_Null;
}

Integer {{{P}}}GetYearInCampaignName(Text _CampaignName) {
	declare Text[] Result = {{{P}}}TL::RegexFind({{{"\"\"\""^"""\b\d{4,}\b"""^"\"\"\""}}}, _CampaignName, "");
	if (Result.count > 0) return {{{P}}}TL::ToInteger(Result[0]);
	return 0;
}

{{{P}}}K_Campaign {{{P}}}GetCampaignFromHttpCampaign({{{HttpStruct::P}}}K_HttpCampaign _HttpCampaign) {
	declare Integer MapCount = 0;
	declare {{{P}}}K_Category[] Categories;
	foreach (HttpCategory in _HttpCampaign.categories) {
		declare {{{P}}}K_Map[] Playlist;
		for (HttpMapIndex, HttpCategory.position*{{{C_MapsByColumn}}}, (HttpCategory.position*{{{C_MapsByColumn}}}+HttpCategory.length*{{{C_MapsByColumn}}})-1) {
			declare Text MapUid = "";
			if (_HttpCampaign.playlist.existskey(HttpMapIndex)) {
				MapUid = _HttpCampaign.playlist[HttpMapIndex].mapUid;
				if (MapUid != "") MapCount += 1;
			}
			Playlist.add(
				{{{P}}}K_Map {
					Position = HttpMapIndex,
					Uid = MapUid
				}
			);
		}

		Categories.add({{{P}}}K_Category {
			Name = HttpCategory.name,
			Playlist = Playlist
		});
	}

	declare Boolean IsSeasonLive = False;
	declare {{{P}}}K_Season[] Seasons;
	foreach (latestSeason in _HttpCampaign.latestSeasons) {
		Seasons.add({{{P}}}K_Season {
			Uid = latestSeason.uid,
			Name = latestSeason.name,
			StartTimestamp = latestSeason.startTimestamp,
			StartDate = latestSeason.startDate,
			EndTimestamp = latestSeason.endTimestamp,
			EndDate = latestSeason.endDate,
			RelativeStart = latestSeason.relativeStart,
			RelativeEnd = latestSeason.relativeEnd,
			RelativeNow = Now,
			CampaignId = latestSeason.campaignId,
			Active = latestSeason.active
		});
		if (!IsSeasonLive && latestSeason.active) {
			IsSeasonLive = True;
		}
	}

	return {{{P}}}K_Campaign {
		Id = _HttpCampaign.id,
		SeasonId = _HttpCampaign.seasonUid,
		Type = _HttpCampaign.useCase,
		Name = _HttpCampaign.name,
		Color = _HttpCampaign.color,
		LeaderboardGroupUid = _HttpCampaign.leaderboardGroupUid,
		Club = {{{ClubStruct::P}}}K_Club {
			Id = _HttpCampaign.clubId
		},
		Published = _HttpCampaign.published,
		IsSeasonLive = IsSeasonLive,
		IsLoaded = False,
		IsFetched = False,
		FailedToGetMapUrl = False,
		MapCount = MapCount,
		Categories = Categories,
		CampaignRanking = {{{P}}}K_CampaignRanking {},
		TopRankings = [],
		ClubTopRankings = [],
		Media = {{{P}}}K_Media {
			ButtonBackgroundUrl = _HttpCampaign.media.buttonBackgroundUrl,
			ButtonForegroundUrl = _HttpCampaign.media.buttonForegroundUrl,
			DecalUrl = _HttpCampaign.media.decalUrl,
			PopUpBackgroundUrl = _HttpCampaign.media.popUpBackgroundUrl,
			PopUpImageUrl = _HttpCampaign.media.popUpImageUrl,
			LiveButtonBackgroundUrl = _HttpCampaign.media.liveButtonBackgroundUrl,
			LiveButtonForegroundUrl = _HttpCampaign.media.liveButtonForegroundUrl
		},
		Seasons = Seasons,
		EditionTimestamp = _HttpCampaign.editionTimestamp,
		SeasonName = {{{P}}}GetSeasonNameInCampaignName(_HttpCampaign.name),
		Year = {{{P}}}GetYearInCampaignName(_HttpCampaign.name)
	};
}

{{{P}}}K_Map {{{P}}}GetMapFromNSMap({{{P}}}K_Map _OldMap, CNadeoServicesMap _NSMap) {
	declare {{{P}}}K_Map NewMap = _OldMap;
	NewMap.Position = _OldMap.Position;
	NewMap.Uid = _NSMap.Uid;
	NewMap.Name = _NSMap.Name;
	NewMap.Type = _NSMap.Type;
	NewMap.Style = _NSMap.Style;
	NewMap.AuthorLogin = _NSMap.AuthorAccountId;
	NewMap.AuthorDisplayName = _NSMap.AuthorDisplayName;
	NewMap.AuthorIsFirstPartyDisplayName = _NSMap.AuthorIsFirstPartyDisplayName;
	NewMap.SubmitterAccountId = _NSMap.SubmitterAccountId;
	NewMap.CreatedWithSimpleEditor = _NSMap.CreatedWithSimpleEditor;
	NewMap.CreatedWithGamepadEditor = _NSMap.CreatedWithGamepadEditor;
	NewMap.AuthorTime = _NSMap.AuthorScore;
	NewMap.GoldTime = _NSMap.GoldScore;
	NewMap.SilverTime = _NSMap.SilverScore;
	NewMap.BronzeTime = _NSMap.BronzeScore;
	NewMap.DownloadUrl = _NSMap.FileUrl;
	NewMap.ThumbnailUrl = _NSMap.ThumbnailUrl;
	NewMap.UploadTimestamp = _NSMap.TimeStamp;
	NewMap.IsPlayable = _NSMap.IsPlayable;
	NewMap.CollectionName = _NSMap.CollectionName;

	return NewMap;
}

{{{P}}}K_Map {{{P}}}GetMapFromMapInfo(CMapInfo _MapInfo) {
	return {{{P}}}K_Map {
		Uid = _MapInfo.MapUid,
		Name = _MapInfo.Name,
		LocalFileName = _MapInfo.FileName,
		Type = _MapInfo.MapType,
		Style = _MapInfo.MapStyle,
		AuthorLogin = _MapInfo.AuthorLogin,
		AuthorDisplayName = _MapInfo.AuthorNickName,
		AuthorTime = _MapInfo.TMObjective_AuthorTime,
		GoldTime = _MapInfo.TMObjective_GoldTime,
		SilverTime = _MapInfo.TMObjective_SilverTime,
		BronzeTime = _MapInfo.TMObjective_BronzeTime,
		ThumbnailUrl = "file://Thumbnails/MapUid/"^_MapInfo.MapUid,
		IsPlayable = _MapInfo.IsPlayable,
		CollectionName = _MapInfo.CollectionName,
		CreatedWithSimpleEditor = _MapInfo.CreatedWithSimpleEditor,
		CreatedWithGamepadEditor = _MapInfo.CreatedWithGamepadEditor
	};
}

{{{P}}}K_Campaign {{{P}}}GetEmptyCampaign() {
	return {{{P}}}K_Campaign {
		Id = {{{P}}}C_Campaign_NullId
	};
}

{{{P}}}K_MonthlyCampaign {{{P}}}GetEmptyMonthlyCampaign() {
	return {{{P}}}K_MonthlyCampaign {
		Id = {{{P}}}C_MonthlyCampaign_NullId
	};
}

Boolean {{{P}}}IsNull({{{P}}}K_MonthlyCampaign _MonthlyCampaign) {
	return _MonthlyCampaign.Id == {{{P}}}C_MonthlyCampaign_NullId;
}

/**
 * Parse a campaign name into a struct containing its season (see Const::C_Season_Names) and its year
 *
 *	@param _CampaignName		The name of the campaign to parse
 *
 *	@return									A struct {{{P}}}K_CampaignName
 */
{{{P}}}K_CampaignName {{{P}}}ParseCampaignName(Text _CampaignName) {
	declare {{{P}}}K_CampaignName CampaignName = {{{P}}}K_CampaignName {
		IsValid = False,
		Name = _CampaignName
	};

	declare Text[] NameSplit = {{{P}}}TL::Split(" ", _CampaignName);
	if (NameSplit.count >= 2) {
		CampaignName.Season = NameSplit[0];
		CampaignName.Year = NameSplit[1];
		CampaignName.IsValid = {{{P}}}C_Season_Names.existskey(CampaignName.Season) && {{{P}}}TL::ToInteger(CampaignName.Year) > 0;
		if (CampaignName.IsValid) {
			CampaignName.TranslatedName = {{{P}}}TL::Compose("%1 %2", {{{P}}}C_Season_Names[CampaignName.Season], CampaignName.Year);
		}
	}

	return CampaignName;
}

/**
 * Translate map if it's an official map from a quarterly campaign
 *
 *	@param _MapName							The name of the map to translate
 *	@param _ForceTranslation		Force the translation of the map name
 *
 *	@return											The translated name
 */
Text {{{P}}}TranslateOfficialMapName(Text _MapName, Text _AuthorLogin, Boolean _ForceTranslation) {
	declare Text LocalMapName = _MapName;
	if (_ForceTranslation || _AuthorLogin == "{{{Const::C_Nadeo_Login}}}") {
		declare Text[] NameSplit = {{{P}}}TL::Split(" ", LocalMapName);
		if (NameSplit.count > 0) {
			declare Text MapNameEnd = {{{P}}}TL::Trim({{{P}}}TL::Replace(LocalMapName, NameSplit[0], ""));
			LocalMapName = {{{P}}}TL::Compose("%1 %2", {{{P}}}C_Season_Names.get(NameSplit[0], NameSplit[0]), MapNameEnd);
		}
	}
	return LocalMapName;
}
Text {{{P}}}TranslateOfficialMapName(Text _MapName, Text _AuthorLogin) {
	return {{{P}}}TranslateOfficialMapName(_MapName, _AuthorLogin, False);
}

// Get the minimum medals needed to unlock this category
Integer {{{P}}}GetMedalsMinToUnlockCategory(Integer _CategoryIndex) {
	switch (_CategoryIndex) {
		case {{{P}}}C_CategoryBlue: {
			if ({{{P}}}Config::HasFeature({{{P}}}Config::C_Feature_DebugFakeCampaignUnlock)) return {{{P}}}C_MinBronzeMedalsToPlayBlueSectionDebug;
			else return {{{P}}}C_MinBronzeMedalsToPlayBlueSection;
		}
		case {{{P}}}C_CategoryRed: {
			if ({{{P}}}Config::HasFeature({{{P}}}Config::C_Feature_DebugFakeCampaignUnlock)) return {{{P}}}C_MinSilverMedalsToPlayRedSectionDebug;
			else return {{{P}}}C_MinSilverMedalsToPlayRedSection;
		}
		case {{{P}}}C_CategoryBlack: {
			if ({{{P}}}Config::HasFeature({{{P}}}Config::C_Feature_DebugFakeCampaignUnlock)) return {{{P}}}C_MinGoldMedalsToPlayBlackSectionDebug;
			else return {{{P}}}C_MinGoldMedalsToPlayBlackSection;
		}
	}

	return 0;
}

""",
[HttpStruct::Component(), ClubStruct::Component()],
[]
	);
}