/** 
 *	Tracking management
 */
#Const Version		"2023-06-15"
#Const ScriptName	"Libs/Nadeo/CommonLibs/Common/Tracking.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "TextLib" as TL
#Include "Libs/Nadeo/CommonLibs/Common/MainUser.Script.txt" as MainUser
#Include "Libs/Nadeo/CommonLibs/Common/Http.Script.txt" as Http
#Include "Libs/Nadeo/TMNext/TrackMania/API/CampaignAPI.Script.txt" as CampaignAPI
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/RoutePaths.Script.txt" as RoutePaths

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Structure
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Struct K_GameModeNCS {
	Text Name;
	Text CustomData;
	Text ScopeType;
	Text ScopeId;
}

#Struct K_MapInfo {
	Text MapUid;
	Boolean IsCampaignOfficial;
	Boolean IsCampaignMonthly;
	Integer OfficialYear;
	Integer OfficialSeason;
	Text[] OfficialMapsUids;
	Integer MonthlyYear;
	Integer MonthlyWeek;
	Text[] MonthlyMapsUids;
}

#Struct K_Campaign {
	Integer Year;
	CTrackingMgr::EEventSeason Season;
	Integer Week;
	Text[] MapUids;
}

#Struct K_State {
	Integer CurrentContext;
	Text GameMode;
	Text ActivityId;
	Text EditorMapFileName;
	Text EditorMapUid;
	Text ModeMapUid;
	Text[][Text] NewsImpression;
	K_GameModeNCS GameModeNCS;
	Integer CurrentTrackMedal;
	Integer CurrentTrackRecord;
	K_Campaign[Integer] OfficialCampaigns;
	Text[] TOTDMapUids;
	Text ServerMapUid;
	K_MapInfo ServerMapInfo;
	Http::K_Request GetMapInfoRequest;
	Text MenuPageId;
	CTrackingMgr::EPlayTimeContext MenuSection;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constant
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_Context_Null 0
#Const C_Context_Menu 1
#Const C_Context_Mode 2
#Const C_Context_TrackEditor 3

#Const C_GameMode_Null ""
// Local
#Const C_GameMode_Campaign "Campaign"
#Const C_GameMode_HotSeat "HotSeat"
#Const C_GameMode_PlayMap "PlayMap"
#Const C_GameMode_RaceTest "RaceTest"
#Const C_GameMode_RaceValidation "RaceValidation"
#Const C_GameMode_RoyalValidation "RoyalValidation"
// Online
#Const C_GameMode_Champion "Champion"
#Const C_GameMode_ChampionCup "ChampionCup"
#Const C_GameMode_ChampionOGL "ChampionOGL"
#Const C_GameMode_ChampionSpring2022 "ChampionSpring2022"
#Const C_GameMode_ChampionTMGL "ChampionTMGL"
#Const C_GameMode_Cup "Cup"
#Const C_GameMode_CupTMGL "CupTMGL"
#Const C_GameMode_FinalTMGL "FinalTMGL"
#Const C_GameMode_Knockout "Knockout"
#Const C_GameMode_KnockoutDaily "KnockoutDaily"
#Const C_GameMode_Laps "Laps"
#Const C_GameMode_LapsOGL "LapsOGL"
#Const C_GameMode_MultiTeams "MultiTeams"
#Const C_GameMode_Rounds "Rounds"
#Const C_GameMode_RoundsBonus "RoundsBonus"
#Const C_GameMode_RoundsBoulet "RoundsBoulet"
#Const C_GameMode_Royal "Royal"
#Const C_GameMode_RoyalTimeAttack "RoyalTimeAttack"
#Const C_GameMode_Teams "Teams"
#Const C_GameMode_TeamsMatchmaking "TeamsMatchmaking"
#Const C_GameMode_TimeAttack "TimeAttack"
#Const C_GameMode_TimeAttackDaily "TimeAttackDaily"
#Const C_GameMode_TMWTTeams "TMWTTeams"
#Const C_GameMode_TMWTMatchmaking "TMWTMatchmaking"
#Const C_GameMode_COTDQualifications "COTDQualifications"

#Const C_ActivityId_Null ""
#Const C_ActivityId_Campaign "Activity_OfficialCampaign"
#Const C_ActivityId_Ranked "Activity_Ranked"
#Const C_ActivityIds [
	"Activity_OfficialCampaign",
	"Activity_Ranked"
]

#Const C_Medal_None 0
#Const C_Medal_Bronze 1
#Const C_Medal_Silver 2
#Const C_Medal_Gold 3
#Const C_Medal_Author 4

#Const C_Season_Winter 0
#Const C_Season_Spring 1
#Const C_Season_Summer 2
#Const C_Season_Fall 3

#Const C_NoTrackRecord -1
#Const C_OfficialCampaigns_Max 10
#Const C_TOTDMapUids_Max 365

#Const C_DefaultState K_State {
	CurrentContext = 0,
	GameMode = "",
	ActivityId = "",
	EditorMapFileName = "",
	EditorMapUid = "",
	ModeMapUid = "",
	NewsImpression = [],
	GameModeNCS = K_GameModeNCS {
		Name = "",
		CustomData = "",
		ScopeType = "",
		ScopeId = ""
	},
	CurrentTrackMedal = 0,
	CurrentTrackRecord = -1,
	OfficialCampaigns = [],
	TOTDMapUids = [],
	ServerMapUid = "",
	ServerMapInfo = K_MapInfo {},
	GetMapInfoRequest = Http::K_Request {},
	MenuPageId = "",
	MenuSection = CTrackingMgr::EPlayTimeContext::None
}
#Const C_MapInfo_Null K_MapInfo {}
#Const C_Campaign_Null K_Campaign {}
#Const C_Page_NullId ""

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Track news impression
K_State Private_NewsImpression(
	CTrackingMgr _TrackingMgr,
	K_State _State,
	Text _Placement,
	Text _NewsId,
	Integer _DisplayTime
) {
	declare K_State State = _State;

	if (!State.NewsImpression.existskey(_Placement)) {
		State.NewsImpression[_Placement] = [];
	}
	if (!State.NewsImpression[_Placement].exists(_NewsId)) {
		State.NewsImpression[_Placement].add(_NewsId);
		_TrackingMgr.Track_News_PlayerImpression(MainUser::GetMainUserId(), _NewsId, _Placement, _DisplayTime);
	}

	return State;
}
Void SendNewsImpression(
	CTrackingMgr _TrackingMgr,
	CSystemPlatform _System,
	Text _Placement,
	Text _NewsId,
	Integer _DisplayTime
) {
	declare K_State LibTMNextTracking_State for _System = C_DefaultState;
	LibTMNextTracking_State = Private_NewsImpression(_TrackingMgr, LibTMNextTracking_State, _Placement, _NewsId, _DisplayTime);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Track news interaction
Void SendNewsInteraction(
	CTrackingMgr _TrackingMgr,
	Text _Placement,
	Text _NewsId,
	Text _ActionName
) {
	_TrackingMgr.Track_News_PlayerAction(MainUser::GetMainUserId(), _NewsId, _Placement, _ActionName);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Track trophies earned by the player
Integer Private_TrophiesEarned(
	CTrackingMgr _TrackingMgr,
	Integer _TrophiesUpdated,
	Integer _TrophiesReceived,
	Integer[Integer][Integer] _Trophies
) {
	declare Integer[Integer] TotalTrophies;
	for (I, _TrophiesReceived + 1, _TrophiesUpdated) {
		declare Integer[Integer] ReceivedTrophies = _Trophies.get(I, []);
		foreach (TrophyKey => TrophyAmount in ReceivedTrophies) {
			TotalTrophies[TrophyKey] = TotalTrophies.get(TrophyKey, 0) + TrophyAmount;
		}
	}
	
	if (TotalTrophies.count > 0) {
		_TrackingMgr.Track_Player_TrophyEarned(
			MainUser::GetMainUserId(),
			TotalTrophies.get(1, 0),
			TotalTrophies.get(2, 0),
			TotalTrophies.get(3, 0),
			TotalTrophies.get(4, 0),
			TotalTrophies.get(5, 0),
			TotalTrophies.get(6, 0),
			TotalTrophies.get(7, 0),
			TotalTrophies.get(8, 0),
			TotalTrophies.get(9, 0)
		);
	}

	return _TrophiesUpdated;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Send the trophies earned by the player
Void SendPlayerTrophiesEarned(CUIConfig _UI, Integer[Integer] _Trophies) {
	if (_UI == Null || _Trophies.count <= 0) return;

	declare netwrite Integer Net_LibTMNextTracking_TrophiesUpdated for _UI = 0;
	declare netwrite Integer[Integer][Integer] Net_LibTMNextTracking_Trophies for _UI = [];
	declare netread Integer Net_LibTMNextTracking_TrophiesReceived for _UI = 0;

	// Remove already received trophies
	declare Integer[Integer][Integer] TrophiesToSend;
	foreach (Key => Trophies in Net_LibTMNextTracking_Trophies) {
		if (Key > Net_LibTMNextTracking_TrophiesReceived) {
			TrophiesToSend[Key] = Trophies;
		}
	}

	// Add new trophies
	TrophiesToSend[Net_LibTMNextTracking_TrophiesUpdated + 1] = _Trophies;

	Net_LibTMNextTracking_TrophiesUpdated += 1;
	Net_LibTMNextTracking_Trophies = TrophiesToSend;
}
Void SendPlayerTrophiesEarned(CUIConfigMgr _UIManager, CPlayer _Player, Integer[Integer] _Trophies) {
	if (_Player != Null) {
		SendPlayerTrophiesEarned(_UIManager.GetUI(_Player), _Trophies);
	}
}
Void SendPlayerTrophiesEarned(CUIConfigMgr _UIManager, CUser _User, Integer[Integer] _Trophies) {
	if (_User != Null) {
		SendPlayerTrophiesEarned(_UIManager.GetUI(_User), _Trophies);
	}
}
Void SendPlayerTrophiesEarned(CUIConfigMgr _UIManager, CClient _Client, Integer[Integer] _Trophies) {
	if (_Client != Null) {
		SendPlayerTrophiesEarned(_UIManager.GetUI(_Client), _Trophies);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Complete a match
Integer Private_CompleteMatch(
	CTrackingMgr _TrackingMgr,
	K_State _State,
	Integer _MatchUpdated,
	Integer _Rank,
	Boolean _Win,
	Boolean _IsSuperRoyalFinale,
	Text _SuperRoyalDivision,
	Boolean _IsSplitscreen
) {
	if (_State.GameMode != C_GameMode_Null && _Rank > 0) {
		if (_IsSplitscreen) {
			_TrackingMgr.Track_Local_SplitScreenPlayed_V2(MainUser::GetMainUserId());
		} else {
			switch (_State.GameMode) {
				case C_GameMode_TeamsMatchmaking, C_GameMode_TMWTMatchmaking: {
					_TrackingMgr.Track_Live_RankedPlayed(MainUser::GetMainUserId(), _Rank, _Win);
				}
				case C_GameMode_KnockoutDaily: {
					_TrackingMgr.Track_Live_COTDPlayed(MainUser::GetMainUserId(), _Rank, _Win);
				}
				case C_GameMode_Royal: {
					_TrackingMgr.Track_Live_RoyalPlayed_V2(MainUser::GetMainUserId(), _Rank, _Win, _IsSuperRoyalFinale, _SuperRoyalDivision);
				}
				case C_GameMode_HotSeat: {
					_TrackingMgr.Track_Local_HotseatPlayed_V2(MainUser::GetMainUserId());
				}
				default: {
					_TrackingMgr.Track_Live_MultiplayerPlayed(MainUser::GetMainUserId(), _Rank, _Win);
				}
			}
		}
	}

	return _MatchUpdated;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Send the match result of a player
Void SendPlayerMatchResult(CUIConfig _UI, Integer _Rank, Boolean _Win, Boolean _IsSuperRoyalFinale, Text _SuperRoyalDivision) {
	if (_UI == Null) return;

	declare netwrite Integer Net_LibTMNextTracking_MatchUpdated for _UI = 0;
	declare netwrite Integer Net_LibTMNextTracking_MatchRank for _UI = 0;
	declare netwrite Boolean Net_LibTMNextTracking_MatchWin for _UI = False;
	declare netwrite Boolean Net_LibTMNextTracking_MatchIsSuperRoyalFinale for _UI = False;
	declare netwrite Text Net_LibTMNextTracking_MatchSuperRoyalDivision for _UI = "";
	Net_LibTMNextTracking_MatchUpdated += 1;
	Net_LibTMNextTracking_MatchRank = _Rank;
	Net_LibTMNextTracking_MatchWin = _Win;
	Net_LibTMNextTracking_MatchIsSuperRoyalFinale = _IsSuperRoyalFinale;
	Net_LibTMNextTracking_MatchSuperRoyalDivision = _SuperRoyalDivision;
}
Void SendPlayerMatchResult(CUIConfig _UI, Integer _Rank, Boolean _Win) {
	SendPlayerMatchResult(_UI, _Rank, _Win, False, "");
}
Void SendPlayerMatchResult(CUIConfigMgr _UIManager, CPlayer _Player, Integer _Rank, Boolean _Win, Boolean _IsSuperRoyalFinale, Text _SuperRoyalDivision) {
	if (_Player != Null) {
		SendPlayerMatchResult(_UIManager.GetUI(_Player), _Rank, _Win, _IsSuperRoyalFinale, _SuperRoyalDivision);
	}
}
Void SendPlayerMatchResult(CUIConfigMgr _UIManager, CPlayer _Player, Integer _Rank, Boolean _Win) {
	if (_Player != Null) {
		SendPlayerMatchResult(_UIManager.GetUI(_Player), _Rank, _Win);
	}
}
Void SendPlayerMatchResult(CUIConfigMgr _UIManager, CUser _User, Integer _Rank, Boolean _Win, Boolean _IsSuperRoyalFinale, Text _SuperRoyalDivision) {
	if (_User != Null) {
		SendPlayerMatchResult(_UIManager.GetUI(_User), _Rank, _Win, _IsSuperRoyalFinale, _SuperRoyalDivision);
	}
}
Void SendPlayerMatchResult(CUIConfigMgr _UIManager, CUser _User, Integer _Rank, Boolean _Win) {
	if (_User != Null) {
		SendPlayerMatchResult(_UIManager.GetUI(_User), _Rank, _Win);
	}
}
Void SendPlayerMatchResult(CUIConfigMgr _UIManager, CClient _Client, Integer _Rank, Boolean _Win, Boolean _IsSuperRoyalFinale, Text _SuperRoyalDivision) {
	if (_Client != Null) {
		SendPlayerMatchResult(_UIManager.GetUI(_Client), _Rank, _Win, _IsSuperRoyalFinale, _SuperRoyalDivision);
	}
}
Void SendPlayerMatchResult(CUIConfigMgr _UIManager, CClient _Client, Integer _Rank, Boolean _Win) {
	if (_Client != Null) {
		SendPlayerMatchResult(_UIManager.GetUI(_Client), _Rank, _Win);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Convert a segment number to a segment color
CTrackingMgr::EEventColorLevel Private_SegmentToColorLevel(Integer _Segment) {
	if (_Segment <= 1) {
		return CTrackingMgr::EEventColorLevel::White;
	} else if (_Segment >= 5) {
		return CTrackingMgr::EEventColorLevel::Black;
	}
	switch (_Segment) {
		case 2: return CTrackingMgr::EEventColorLevel::Green;
		case 3: return CTrackingMgr::EEventColorLevel::Blue;
		case 4: return CTrackingMgr::EEventColorLevel::Red;
	}
	return CTrackingMgr::EEventColorLevel::White;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Complete a royal segment
Integer Private_CompleteRoyalSegment(CTrackingMgr _TrackingMgr, K_State _State, Integer _RoyalSegmentUpdated, Integer _Segment) {
	if (_State.GameMode == C_GameMode_Royal && _Segment > 0) {
		_TrackingMgr.Track_Live_RoyalSectionFinished_V2(MainUser::GetMainUserId(), Private_SegmentToColorLevel(_Segment));
	}

	return _RoyalSegmentUpdated;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Send the royal segment the player just completed
Void SendPlayerRoyalSegment(CUIConfigMgr _UIManager, CSmPlayer _Player, Integer _Segment) {
	if (_Player == Null) return;
	declare CUIConfig PlayerUI <=> _UIManager.GetUI(_Player);
	if (PlayerUI == Null) return;

	declare netwrite Integer Net_LibTMNextTracking_RoyalSegmentUpdated for PlayerUI = 0;
	declare netwrite Integer Net_LibTMNextTracking_RoyalSegment for PlayerUI = 0;
	Net_LibTMNextTracking_RoyalSegmentUpdated += 1;
	Net_LibTMNextTracking_RoyalSegment = _Segment;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Send the game mode name and custom data to the players
 *	This is mainly used to record and medal retrieval
 */
Void SendGameModeNCS(CTeam _Team, Text _Name, Text _CustomDataLeaderboard, Text _ScopeType) {
	declare netwrite Integer Net_LibTMNextTracking_GameModeNCSUpdated for _Team = 0;
	declare netwrite Text Net_LibTMNextTracking_GameModeNCSName for _Team = "";
	declare netwrite Text Net_LibTMNextTracking_GameModeNCSCustomDataLeaderboard for _Team = "";
	declare netwrite Text Net_LibTMNextTracking_GameModeNCSScopeType for _Team = "";
	Net_LibTMNextTracking_GameModeNCSUpdated += 1;
	Net_LibTMNextTracking_GameModeNCSName = _Name;
	Net_LibTMNextTracking_GameModeNCSCustomDataLeaderboard = _CustomDataLeaderboard;
	Net_LibTMNextTracking_GameModeNCSScopeType = _ScopeType;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Send the server map info to the clients
K_State Private_SendServerMapInfo(CTeam _Team, K_State _State, Text _MapUid, CampaignAPI::LibCampaignAPI_K_ResponseGetMapInfo _ResponseGetMapInfo) {
	declare K_State State = _State;
	declare netwrite K_MapInfo Net_LibTMNextTracking_ServerMapInfo for _Team = C_MapInfo_Null;
	Net_LibTMNextTracking_ServerMapInfo = K_MapInfo {
		MapUid = _MapUid,
		IsCampaignOfficial = _ResponseGetMapInfo.IsCampaignOfficial,
		IsCampaignMonthly = _ResponseGetMapInfo.IsCampaignMonthly,
		OfficialYear = _ResponseGetMapInfo.OfficialYear,
		OfficialSeason = _ResponseGetMapInfo.OfficialSeason,
		OfficialMapsUids = _ResponseGetMapInfo.OfficialMapsUids,
		MonthlyYear = _ResponseGetMapInfo.MonthlyYear,
		MonthlyWeek = _ResponseGetMapInfo.MonthlyWeek,
		MonthlyMapsUids = _ResponseGetMapInfo.MonthlyMapsUids
	};
	State.ServerMapInfo = Net_LibTMNextTracking_ServerMapInfo;
	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the server map info sent from the server
K_MapInfo Private_GetServerMapInfo(CTeam _Team) {
	declare netread K_MapInfo Net_LibTMNextTracking_ServerMapInfo for _Team = C_MapInfo_Null;
	return Net_LibTMNextTracking_ServerMapInfo;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the medal the user currently have on the track
Integer Private_GetTrackMedal(K_State _State, Text _MapUid) {
	if (_MapUid == "" || _State.GameModeNCS.ScopeType == "" || _State.GameModeNCS.Name == "") {
		return C_Medal_None;
	}
	return ScoreMgr.Map_GetMedal(
		MainUser::GetMainUserId(),
		_MapUid,
		_State.GameModeNCS.ScopeType,
		_State.GameModeNCS.ScopeId,
		_State.GameModeNCS.Name,
		_State.GameModeNCS.CustomData
	);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the record the user currently has on the track
Integer Private_GetTrackRecord(K_State _State, Text _MapUid) {
	if (_MapUid == "" || _State.GameModeNCS.ScopeType == "" || _State.GameModeNCS.Name == "") {
		return C_NoTrackRecord;
	}
	return ScoreMgr.Map_GetRecord_v2(
		MainUser::GetMainUserId(),
		_MapUid,
		_State.GameModeNCS.ScopeType,
		_State.GameModeNCS.ScopeId,
		_State.GameModeNCS.Name,
		_State.GameModeNCS.CustomData
	);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the medal and record the user currently has on the track
K_State Private_UpdateTrackMedalAndRecord(K_State _State) {
	declare K_State State = _State;

	State.CurrentTrackMedal = Private_GetTrackMedal(State, State.ModeMapUid);
	State.CurrentTrackRecord = Private_GetTrackRecord(State, State.ModeMapUid);

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Check if the user unlocked a new medal
Integer Private_HasUnlockedMedal(
	Integer _UnlockedMedal,
	Integer _PreviousMedal,
	Integer _NewMedal,
	Integer _PreviousRecord,
	Integer _NewRecord
) {
	if (
		_NewRecord != C_NoTrackRecord &&
		(_NewRecord < _PreviousRecord || _PreviousRecord == C_NoTrackRecord) &&
		_NewMedal >= _UnlockedMedal &&
		((_NewMedal > _PreviousMedal && _UnlockedMedal > _PreviousMedal) || (_PreviousMedal == C_Medal_None && _PreviousRecord == C_NoTrackRecord))
	) {
		return 1;
	}
	return 0;
}

// Convert a season constant from the API to an event season for tracking manager
CTrackingMgr::EEventSeason Private_SeasonToEventSeason(Integer _Season) {
	switch (_Season) {
		case C_Season_Winter: return CTrackingMgr::EEventSeason::Winter;
		case C_Season_Spring: return CTrackingMgr::EEventSeason::Spring;
		case C_Season_Summer: return CTrackingMgr::EEventSeason::Summer;
		case C_Season_Fall: return CTrackingMgr::EEventSeason::Fall;
	}
	return CTrackingMgr::EEventSeason::Winter;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Add tracks to the official campaign tracks cache
K_State Private_SetOfficialCampaign(K_State _State, Integer _CampaignId, Integer _Year, Integer _Season, Text[] _MapUids) {
	if (_MapUids.count <= 0) return _State;
	declare K_State State = _State;

	if (!State.OfficialCampaigns.existskey(_CampaignId)) {
		State.OfficialCampaigns[_CampaignId] = K_Campaign {
			MapUids = _MapUids,
			Year = _Year,
			Season = Private_SeasonToEventSeason(_Season)
		};
	}

	if (State.OfficialCampaigns.count > C_OfficialCampaigns_Max) {
		declare Integer[] CampaignIdsToRemove;
		foreach (CampaignId => Campaign in State.OfficialCampaigns) {
			CampaignIdsToRemove.add(CampaignId);
			if (CampaignIdsToRemove.count >= State.OfficialCampaigns.count - C_OfficialCampaigns_Max) {
				break;
			}
		}
		foreach (CampaignId in CampaignIdsToRemove) {
			State.OfficialCampaigns.removekey(CampaignId);
		}
	}

	return State;
}
Void SetOfficialCampaign(CSystemPlatform _System, Integer _CampaignId, Integer _Year, Integer _Season, Text[] _MapUids) {
	if (_MapUids.count <= 0) return;
	declare K_State LibTMNextTracking_State for _System = C_DefaultState;
	LibTMNextTracking_State = Private_SetOfficialCampaign(LibTMNextTracking_State, _CampaignId, _Year, _Season, _MapUids);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the official campaign the track appears in
 *	It is assumed that a track can only be in one official campaign
 */
K_Campaign Private_GetOfficialCampaign(K_State _State, K_MapInfo _ServerMapInfo, Text _MapUid) {
	if (_ServerMapInfo.MapUid == _MapUid && _ServerMapInfo.IsCampaignOfficial) {
		return K_Campaign {
			MapUids = _ServerMapInfo.OfficialMapsUids,
			Year = _ServerMapInfo.OfficialYear,
			Season = Private_SeasonToEventSeason(_ServerMapInfo.OfficialSeason)
		};
	}
	foreach (OfficialCampaign in _State.OfficialCampaigns) {
		if (OfficialCampaign.MapUids.exists(_MapUid)) {
			return OfficialCampaign;
		}
	}
	return C_Campaign_Null;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Check if an official campaign is valid
Boolean Private_IsOfficialCampaignTrack(K_Campaign _Campaign, Text _MapUid) {
	return (
		_Campaign.Year >= 0 &&
		_Campaign.MapUids.count > 0 &&
		_Campaign.MapUids.exists(_MapUid)
	);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Add a track to the TOTD tracks cache
K_State Private_SetIsTOTDTracks(K_State _State, Text[] _MapUids) {
	if (_MapUids.count <= 0) return _State;
	declare K_State State = _State;

	foreach (MapUid in _MapUids) {
		if (MapUid != "" && !State.TOTDMapUids.exists(MapUid)) {
			State.TOTDMapUids.add(MapUid);
		}
	}

	while (State.TOTDMapUids.count > C_TOTDMapUids_Max) {
		State.TOTDMapUids.removekey(0);
	}

	return State;
}
Void SetIsTOTDTracks(CSystemPlatform _System, Text[] _MapUids) {
	if (_MapUids.count <= 0) return;
	declare K_State LibTMNextTracking_State for _System = C_DefaultState;
	LibTMNextTracking_State = Private_SetIsTOTDTracks(LibTMNextTracking_State, _MapUids);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Check if the track is a TOTD track
Boolean Private_IsTOTDTrack(K_State _State, K_MapInfo _ServerMapInfo, Text _MapUid) {
	return (
		(_ServerMapInfo.MapUid == _MapUid && _ServerMapInfo.IsCampaignMonthly) ||
		_State.TOTDMapUids.exists(_MapUid)
	);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the weekly TOTD campaign the track appears in
 *	It is assumed that a track can only be TOTD one time
 *	It is also assumed that the player must be online to get this info
 *	The player could play offline a map saved locally in its cache that was TOTD
 *	It is not possible to be sure if a track was TOTD or not without requesting the info from the API
 */
K_Campaign Private_GetTOTDWeeklyCampaign(K_MapInfo _ServerMapInfo, Text _MapUid) {
	if (_ServerMapInfo.MapUid == _MapUid && _ServerMapInfo.IsCampaignMonthly) {
		return K_Campaign {
			MapUids = _ServerMapInfo.MonthlyMapsUids,
			Year = _ServerMapInfo.MonthlyYear,
			Week = _ServerMapInfo.MonthlyWeek
		};
	}
	return C_Campaign_Null;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Check if the track is part of a complete weekly TOTD campaign
Boolean Private_IsCompleteWeeklyTrack(K_Campaign _Campaign, Text _MapUid) {
	return (
		_Campaign.Year >= 0 &&
		_Campaign.Week >= 0 &&
		_Campaign.MapUids.count >= 7 &&
		_Campaign.MapUids.exists(_MapUid)
	);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get all unlocked medals
Integer[] Private_GetUnlockedMedals(
	Integer _HasUnlockedFirstFinish,
	Integer _HasUnlockedBronzeMedal,
	Integer _HasUnlockedSilverMedal,
	Integer _HasUnlockedGoldMedal,
	Integer _HasUnlockedAuthorMedal
) {
	declare Integer[] UnlockedMedals;
	if (_HasUnlockedFirstFinish == 1) UnlockedMedals.add(C_Medal_None);
	if (_HasUnlockedBronzeMedal == 1) UnlockedMedals.add(C_Medal_Bronze);
	if (_HasUnlockedSilverMedal == 1) UnlockedMedals.add(C_Medal_Silver);
	if (_HasUnlockedGoldMedal == 1) UnlockedMedals.add(C_Medal_Gold);
	if (_HasUnlockedAuthorMedal == 1) UnlockedMedals.add(C_Medal_Author);
	return UnlockedMedals;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Convert a medal to a medal level
CTrackingMgr::EEventMedalLevel Private_MedalToMedalLevel(Integer _Medal) {
	switch (_Medal) {
		case C_Medal_None: return CTrackingMgr::EEventMedalLevel::Finished;
		case C_Medal_Bronze: return CTrackingMgr::EEventMedalLevel::Bronze;
		case C_Medal_Silver: return CTrackingMgr::EEventMedalLevel::Silver;
		case C_Medal_Gold: return CTrackingMgr::EEventMedalLevel::Gold;
		case C_Medal_Author: return CTrackingMgr::EEventMedalLevel::Author;
	}
	return CTrackingMgr::EEventMedalLevel::Finished;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Get the newly unlocked medals on all tracks of a campaign
Integer[] Private_GetCampaignNewlyUnlockedMedals(
	K_State _State,
	K_Campaign _Campaign,
	Integer _HasUnlockedFirstFinish,
	Integer _HasUnlockedBronzeMedal,
	Integer _HasUnlockedSilverMedal,
	Integer _HasUnlockedGoldMedal,
	Integer _HasUnlockedAuthorMedal
) {
	declare Integer[] UnlockedMedals = Private_GetUnlockedMedals(
		_HasUnlockedFirstFinish,
		_HasUnlockedBronzeMedal,
		_HasUnlockedSilverMedal,
		_HasUnlockedGoldMedal,
		_HasUnlockedAuthorMedal
	);
	if (UnlockedMedals.count > 0) {
		// Browse all tracks of the campaign to see if the player
		// has already unlocked the medals of the same value on all tracks
		foreach (MapUid in _Campaign.MapUids) {
			declare Integer[] MedalsToRemove;
			foreach (Medal in UnlockedMedals) {
				if (
					(Medal == C_Medal_None && Private_GetTrackRecord(_State, MapUid) == C_NoTrackRecord) ||
					(Medal != C_Medal_None && Private_GetTrackMedal(_State, MapUid) < Medal)
				) {
					MedalsToRemove.add(Medal);
				}
			}
			foreach (MedalToRemove in MedalsToRemove) {
				UnlockedMedals.remove(MedalToRemove);
			}
			if (UnlockedMedals.count <= 0) break;
		}
	}
	return UnlockedMedals;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Track medals unlock by the player
Void Private_UnlockMedal(
	CTrackingMgr _TrackingMgr,
	K_State _State,
	Text _MapUid,
	Integer _PreviousMedal,
	Integer _NewMedal,
	Integer _PreviousRecord,
	Integer _NewRecord,
	K_MapInfo _ServerMapInfo
) {
	if (
		_NewRecord != C_NoTrackRecord &&
		(_NewRecord < _PreviousRecord || _PreviousRecord == C_NoTrackRecord) &&
		(_NewMedal > _PreviousMedal || (_PreviousMedal == C_Medal_None && _PreviousRecord == C_NoTrackRecord))
	) {
		declare K_Campaign OfficialCampaign = Private_GetOfficialCampaign(_State, _ServerMapInfo, _MapUid);
		declare K_Campaign TOTDCampaign = Private_GetTOTDWeeklyCampaign(_ServerMapInfo, _MapUid);
		declare Integer HasUnlockedFirstFinish = Private_HasUnlockedMedal(C_Medal_None, _PreviousMedal, _NewMedal, _PreviousRecord, _NewRecord);
		declare Integer HasUnlockedBronzeMedal = Private_HasUnlockedMedal(C_Medal_Bronze, _PreviousMedal, _NewMedal, _PreviousRecord, _NewRecord);
		declare Integer HasUnlockedSilverMedal = Private_HasUnlockedMedal(C_Medal_Silver, _PreviousMedal, _NewMedal, _PreviousRecord, _NewRecord);
		declare Integer HasUnlockedGoldMedal = Private_HasUnlockedMedal(C_Medal_Gold, _PreviousMedal, _NewMedal, _PreviousRecord, _NewRecord);
		declare Integer HasUnlockedAuthorMedal = Private_HasUnlockedMedal(C_Medal_Author, _PreviousMedal, _NewMedal, _PreviousRecord, _NewRecord);
		_TrackingMgr.Track_Player_MedalEarned(
			MainUser::GetMainUserId(),
			HasUnlockedFirstFinish,
			HasUnlockedBronzeMedal,
			HasUnlockedSilverMedal,
			HasUnlockedGoldMedal,
			HasUnlockedAuthorMedal,
			Private_IsOfficialCampaignTrack(OfficialCampaign, _MapUid),
			Private_IsTOTDTrack(_State, _ServerMapInfo, _MapUid)
		);

		// Check if the player unlocked all medals on an official campaign
		if (Private_IsOfficialCampaignTrack(OfficialCampaign, _MapUid)) {
			declare Integer[] UnlockedMedals = Private_GetCampaignNewlyUnlockedMedals(
				_State,
				OfficialCampaign,
				HasUnlockedFirstFinish,
				HasUnlockedBronzeMedal,
				HasUnlockedSilverMedal,
				HasUnlockedGoldMedal,
				HasUnlockedAuthorMedal
			);
			foreach (Medal in UnlockedMedals) {
				_TrackingMgr.Track_Player_OfficialCampaignAllTrackCompleted_V2(
					MainUser::GetMainUserId(),
					OfficialCampaign.Year,
					OfficialCampaign.Season,
					Private_MedalToMedalLevel(Medal)
				);
			}
		}

		// Check if the player unlocked all medals on the weekly TOTD tracks
		if (Private_IsCompleteWeeklyTrack(TOTDCampaign, _MapUid)) {
			declare Integer[] UnlockedMedals = Private_GetCampaignNewlyUnlockedMedals(
				_State,
				TOTDCampaign,
				HasUnlockedFirstFinish,
				HasUnlockedBronzeMedal,
				HasUnlockedSilverMedal,
				HasUnlockedGoldMedal,
				HasUnlockedAuthorMedal
			);
			foreach (Medal in UnlockedMedals) {
				_TrackingMgr.Track_Player_TrackOfTheDayWeekAllTrackCompleted_V2(
					MainUser::GetMainUserId(),
					TOTDCampaign.Year,
					TOTDCampaign.Week,
					Private_MedalToMedalLevel(Medal)
				);
			}
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the currently played track info
K_State Private_SetModeTrack(CTrackingMgr _TrackingMgr, K_State _State, CMap _Map) {
	// `Track_Context_MapStart()` and `Track_Context_MapStop()` can only be called if
	// `Track_Context_GameModeStart()` has been called beforehand and we did not call
	// `Track_Context_GameModeStop()` since then.
	if (_State.GameMode == C_GameMode_Null) return _State;

	declare K_State State = _State;

	if (_Map == Null || _Map.MapInfo == Null) {
		if (State.ModeMapUid != "") {
			_TrackingMgr.Track_Context_MapStop(MainUser::GetMainUserId(), State.ModeMapUid);
		}
		State.ModeMapUid = "";
	} else if (State.ModeMapUid != _Map.MapInfo.MapUid) {
		if (State.ModeMapUid != "") {
			_TrackingMgr.Track_Context_MapStop(MainUser::GetMainUserId(), State.ModeMapUid);
		}
		State.ModeMapUid = _Map.MapInfo.MapUid;
		_TrackingMgr.Track_Context_MapStart(MainUser::GetMainUserId(), State.ModeMapUid, _Map.CollectionName);
	}

	State = Private_UpdateTrackMedalAndRecord(State);

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the track played on the server
K_State Private_SetServerTrack(K_State _State, CMap _Map) {
	declare K_State State = _State;

	if (_Map == Null || _Map.MapInfo == Null) {
		State.ServerMapUid = "";
	} else if (State.ServerMapUid != _Map.MapInfo.MapUid) {
		State.ServerMapUid = _Map.MapInfo.MapUid;
		State.GetMapInfoRequest = Http::DestroyAndCreate(State.GetMapInfoRequest, CampaignAPI::GetMapInfo(State.ServerMapUid));
	}

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the opened map info in the track editor
K_State Private_SetEditorMapInfo(CMapType _This, K_State _State) {
	declare K_State State = _State;

	State.EditorMapFileName = _This.MapFileName;
	if (_This.Map != Null && _This.Map.MapInfo != Null) {
		State.EditorMapUid = _This.Map.MapInfo.MapUid;
	} else {
		State.EditorMapUid = "";
	}

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Call this just after saving a track in the track editor
K_State Private_EditorTrackSaved(CMapType _This, CTrackingMgr _TrackingMgr, K_State _State) {
	declare K_State State = _State;

	if (
		_This.Map != Null &&
		_This.Map.MapInfo != Null &&
		State.EditorMapFileName != _This.MapFileName &&
		State.EditorMapUid != _This.Map.MapInfo.MapUid
	) {
		_TrackingMgr.Track_Create_NewMapCreated(MainUser::GetMainUserId(), _This.Map.CollectionName, False);
	}
	State = Private_SetEditorMapInfo(_This, State);

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the game mode the user is playing
K_State Private_SetGameMode(CTrackingMgr _TrackingMgr, K_State _State, Text _NewGameMode, CMap _Map) {
	if (_State.GameMode == _NewGameMode) return _State;

	declare K_State State = _State;

	// Stop the previous game mode
	if (State.GameMode != C_GameMode_Null) {
		State = Private_SetModeTrack(_TrackingMgr, State, Null);
		_TrackingMgr.Track_Context_GameModeStop(MainUser::GetMainUserId(), State.GameMode);
	}

	// Start new game mode
	State.GameMode = _NewGameMode;
	if (State.GameMode != C_GameMode_Null) {
		_TrackingMgr.Track_Context_GameModeStart(MainUser::GetMainUserId(), State.GameMode);
		State = Private_SetModeTrack(_TrackingMgr, State, _Map);
	}

	return State;
}
Void SetGameMode(CTrackingMgr _TrackingMgr, CSystemPlatform _System, Text _NewGameMode, CMap _Map) {
	declare K_State LibTMNextTracking_State for _System = C_DefaultState;
	LibTMNextTracking_State = Private_SetGameMode(_TrackingMgr, LibTMNextTracking_State, _NewGameMode, _Map);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the activity the user is playing
K_State Private_SetActivity(CTrackingMgr _TrackingMgr, K_State _State, Text _NewActivityId) {
	if (_State.ActivityId == _NewActivityId) return _State;
	assert(_NewActivityId == C_ActivityId_Null || C_ActivityIds.exists(_NewActivityId), "Unknown activity id '"^_NewActivityId^"'");

	declare K_State State = _State;

	// Stop the previous activity
	if (State.ActivityId != C_ActivityId_Null) {
		_TrackingMgr.Track_Player_EndActivity(MainUser::GetMainUserId(), State.ActivityId);
	}

	// Start new activity
	State.ActivityId = _NewActivityId;
	if (State.ActivityId != C_ActivityId_Null) {
		_TrackingMgr.Track_Player_StartActivity(MainUser::GetMainUserId(), State.ActivityId);
	}

	return State;
}
Void StartActivity(CTrackingMgr _TrackingMgr, CSystemPlatform _System, Text _NewActivityId) {
	declare K_State LibTMNextTracking_State for _System = C_DefaultState;
	LibTMNextTracking_State = Private_SetActivity(_TrackingMgr, LibTMNextTracking_State, _NewActivityId);
}
Void StopActivity(CTrackingMgr _TrackingMgr, CSystemPlatform _System) {
	declare K_State LibTMNextTracking_State for _System = C_DefaultState;
	LibTMNextTracking_State = Private_SetActivity(_TrackingMgr, LibTMNextTracking_State, C_ActivityId_Null);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Make sure all activities are reset at the launch of the game
// see: /trackmania-next/tmnext/-/issues/5397#note_279231
Void ResetAllActivities(CTrackingMgr _TrackingMgr, CSystemPlatform _System) {
	foreach (ActivityId in C_ActivityIds) {
		_TrackingMgr.Track_Player_EndActivity(MainUser::GetMainUserId(), ActivityId);
	}
	declare K_State LibTMNextTracking_State for _System = C_DefaultState;
	LibTMNextTracking_State.ActivityId = C_ActivityId_Null;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the context in which the user is
K_State Private_SetContext(CTrackingMgr _TrackingMgr, K_State _State, Integer _NewContext) {
	if (_State.CurrentContext == _NewContext) return _State;

	declare K_State State = _State;

	// If we are leaving a game mode
	if (State.CurrentContext == C_Context_Mode && _NewContext != C_Context_Mode) {
		State = Private_SetGameMode(_TrackingMgr, State, C_GameMode_Null, Null);
	}

	State.CurrentContext = _NewContext;
	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the section of the menu the user is viewing
K_State Private_SetMenuSection(CTrackingMgr _TrackingMgr, K_State _State, Text _ForceSection) {
	declare CTrackingMgr::EPlayTimeContext NewMenuSection = CTrackingMgr::EPlayTimeContext::None;
	declare Text RawMenuSection = _ForceSection;

	if (_ForceSection == "") {
		declare Text[] Matches = TL::RegexMatch("^/(clubs|create|live|local|solo)(?:/.*)?$", _State.MenuPageId, "");
		if (Matches.count >= 2) {
			RawMenuSection = Matches[1];
		}
	}
	switch (RawMenuSection) {
		case "clubs": NewMenuSection = CTrackingMgr::EPlayTimeContext::Club;
		case "create": NewMenuSection = CTrackingMgr::EPlayTimeContext::Create;
		case "live": NewMenuSection = CTrackingMgr::EPlayTimeContext::Live;
		case "local": NewMenuSection = CTrackingMgr::EPlayTimeContext::Local;
		case "solo": NewMenuSection = CTrackingMgr::EPlayTimeContext::Solo;
	}

	if (_State.MenuSection == NewMenuSection) return _State;

	declare K_State State = _State;

	State.MenuSection = NewMenuSection;
	_TrackingMgr.Track_Context_PlayTime(MainUser::GetMainUserId(), State.MenuSection);

	return State;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the menu page the user is viewing
K_State Private_SetMenuPage(CTrackingMgr _TrackingMgr, K_State _State, Text _NewMenuPageId, Text _ForceSection) {
	if (_State.MenuPageId == _NewMenuPageId) return _State;

	declare K_State State = _State;

	// Stop previous page
	if (State.MenuPageId != C_Page_NullId) {
		_TrackingMgr.Track_Context_MenuStop(MainUser::GetMainUserId(), State.MenuPageId);
	}

	// Start new page
	State.MenuPageId = _NewMenuPageId;
	if (State.MenuPageId != C_Page_NullId) {
		_TrackingMgr.Track_Context_MenuStart(MainUser::GetMainUserId(), State.MenuPageId);
	}

	// Set squad enabled on specific page
	if (State.MenuPageId != C_Page_NullId && State.MenuPageId == RoutePaths::C_Path_MatchmakingMainPage) {
		UserMgr.Squad_SetEnabled(MainUser::GetMainUserId(), True);
	} else {
		UserMgr.Squad_SetEnabled(MainUser::GetMainUserId(), False);
	}

	State = Private_SetMenuSection(_TrackingMgr, State, _ForceSection);

	return State;
}
Void SetMenuPage(CTrackingMgr _TrackingMgr, CSystemPlatform _System, Text _PageId, Text _ForceSection) {
	declare K_State LibTMNextTracking_State for _System = C_DefaultState;
	LibTMNextTracking_State = Private_SetMenuPage(_TrackingMgr, LibTMNextTracking_State, _PageId, _ForceSection);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update tracking in the game menu
Void Yield_Menu(CSystemPlatform _System, CManiaAppTitle _This) {
	declare K_State LibTMNextTracking_State for _System = C_DefaultState;
	if (LibTMNextTracking_State.CurrentContext != C_Context_Menu) {
		LibTMNextTracking_State = Private_SetContext(_This.TrackingMgr, LibTMNextTracking_State, C_Context_Menu);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update tracking in the modes on the client
Void Yield_ModeClient(CSystemPlatform _System, CManiaAppPlayground _This) {
	declare K_State LibTMNextTracking_State for _System = C_DefaultState;
	if (LibTMNextTracking_State.CurrentContext != C_Context_Mode) {
		LibTMNextTracking_State = Private_SetContext(_This.TrackingMgr, LibTMNextTracking_State, C_Context_Mode);
	}

	if (
		((_This.Map == Null || _This.Map.MapInfo == Null) && LibTMNextTracking_State.ModeMapUid != "") ||
		(_This.Map != Null  && _This.Map.MapInfo != Null && LibTMNextTracking_State.ModeMapUid != _This.Map.MapInfo.MapUid)
	) {
		LibTMNextTracking_State = Private_SetModeTrack(_This.TrackingMgr, LibTMNextTracking_State, _This.Map);
	}

	declare netread Integer Net_LibTMNextTracking_MatchUpdated for _This.UI = 0;
	// We cannot store this variable in the state. The state is saved on `System`.
	// Which means that it will be saved on the client until the game is closed.
	// `Net_LibTMNextTracking_MatchUpdated` is sent by the server and will be reinitialiazed
	// to 0 each time we join a server. So we need the variable on the client to be reinitialized too.
	declare Integer Local_LibTMNextTracking_MatchUpdated for _This.UI = 0; 
	if (Local_LibTMNextTracking_MatchUpdated != Net_LibTMNextTracking_MatchUpdated) {
		declare netread Integer Net_LibTMNextTracking_MatchRank for _This.UI = 0;
		declare netread Boolean Net_LibTMNextTracking_MatchWin for _This.UI = False;
		declare netread Boolean Net_LibTMNextTracking_MatchIsSuperRoyalFinale for _This.UI = False;
		declare netread Text Net_LibTMNextTracking_MatchSuperRoyalDivision for _This.UI = "";
		Local_LibTMNextTracking_MatchUpdated = Private_CompleteMatch(
			_This.TrackingMgr,
			LibTMNextTracking_State,
			Net_LibTMNextTracking_MatchUpdated,
			Net_LibTMNextTracking_MatchRank,
			Net_LibTMNextTracking_MatchWin,
			Net_LibTMNextTracking_MatchIsSuperRoyalFinale,
			Net_LibTMNextTracking_MatchSuperRoyalDivision,
			_This.SplitScreenCount > 1
		);
	}

	declare netread Integer Net_LibTMNextTracking_RoyalSegmentUpdated for _This.UI = 0;
	// We cannot store this variable in the state. The state is saved on `System`.
	// See `Local_LibTMNextTracking_MatchUpdated` above to know why.
	declare Integer Local_LibTMNextTracking_RoyalSegmentUpdated for _This.UI = 0;
	if (Local_LibTMNextTracking_RoyalSegmentUpdated != Net_LibTMNextTracking_RoyalSegmentUpdated) {
		declare netread Integer Net_LibTMNextTracking_RoyalSegment for _This.UI = 0;
		Local_LibTMNextTracking_RoyalSegmentUpdated = Private_CompleteRoyalSegment(
			_This.TrackingMgr,
			LibTMNextTracking_State,
			Net_LibTMNextTracking_RoyalSegmentUpdated,
			Net_LibTMNextTracking_RoyalSegment
		);
	}

	declare netread Integer Net_LibTMNextTracking_TrophiesUpdated for _This.UI = 0;
	declare netwrite Integer Net_LibTMNextTracking_TrophiesReceived for _This.UI = 0;
	if (Net_LibTMNextTracking_TrophiesReceived != Net_LibTMNextTracking_TrophiesUpdated) {
		declare netread Integer[Integer][Integer] Net_LibTMNextTracking_Trophies for _This.UI = [];
		Net_LibTMNextTracking_TrophiesReceived = Private_TrophiesEarned(
			_This.TrackingMgr,
			Net_LibTMNextTracking_TrophiesUpdated,
			Net_LibTMNextTracking_TrophiesReceived,
			Net_LibTMNextTracking_Trophies
		);
	}

	declare netread Integer Net_LibTMNextTracking_GameModeNCSUpdated for _This.Playground.Teams[0] = 0;
	// We cannot store this variable in the state. The state is saved on `System`.
	// See `Local_LibTMNextTracking_MatchUpdated` above to know why.
	declare Integer Local_LibTMNextTracking_GameModeNCSUpdated for _This.UI = 0;
	if (Local_LibTMNextTracking_GameModeNCSUpdated != Net_LibTMNextTracking_GameModeNCSUpdated) {
		declare netread Text Net_LibTMNextTracking_GameModeNCSName for _This.Playground.Teams[0] = "";
		declare netread Text Net_LibTMNextTracking_GameModeNCSCustomDataLeaderboard for _This.Playground.Teams[0] = "";
		declare netread Text Net_LibTMNextTracking_GameModeNCSScopeType for _This.Playground.Teams[0] = "";
		Local_LibTMNextTracking_GameModeNCSUpdated = Net_LibTMNextTracking_GameModeNCSUpdated;
		LibTMNextTracking_State.GameModeNCS = K_GameModeNCS {
			Name = Net_LibTMNextTracking_GameModeNCSName,
			CustomData = Net_LibTMNextTracking_GameModeNCSCustomDataLeaderboard,
			ScopeType = Net_LibTMNextTracking_GameModeNCSScopeType,
			ScopeId = ""
		};
		LibTMNextTracking_State = Private_UpdateTrackMedalAndRecord(LibTMNextTracking_State);
	}

	foreach (Event in _This.PendingEvents) {
		if (
			Event.PlaygroundType == CManiaAppPlaygroundEvent::Type::RecordUpdated &&
			LibTMNextTracking_State.ModeMapUid != ""
		) {
			declare Integer PreviousTrackMedal = LibTMNextTracking_State.CurrentTrackMedal;
			declare Integer PreviousTrackRecord = LibTMNextTracking_State.CurrentTrackRecord;
			LibTMNextTracking_State = Private_UpdateTrackMedalAndRecord(LibTMNextTracking_State);
			Private_UnlockMedal(
				_This.TrackingMgr,
				LibTMNextTracking_State,
				LibTMNextTracking_State.ModeMapUid,
				PreviousTrackMedal,
				LibTMNextTracking_State.CurrentTrackMedal,
				PreviousTrackRecord,
				LibTMNextTracking_State.CurrentTrackRecord,
				Private_GetServerMapInfo(_This.Playground.Teams[0])
			);
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update tracking in the modes on the server
Void Yield_ModeServer(CSystemPlatform _System, CSmMode _This) {
	declare K_State LibTMNextTracking_State for _System = C_DefaultState;
	if (
		((_This.Map == Null || _This.Map.MapInfo == Null) && LibTMNextTracking_State.ServerMapUid != "") ||
		(_This.Map != Null  && _This.Map.MapInfo != Null && LibTMNextTracking_State.ServerMapUid != _This.Map.MapInfo.MapUid)
	) {
		LibTMNextTracking_State = Private_SetServerTrack(LibTMNextTracking_State, _This.Map);
	}

	// If a player create a local server with a given track
	// Stop and restart the server with the same track
	// `State.ServerMapUid` will be the same because it's saved on `System`
	// but `Net_LibTMNextTracking_ServerMapInfo` will be reset, so we restore it here
	declare netwrite K_MapInfo Net_LibTMNextTracking_ServerMapInfo for _This.Teams[0] = C_MapInfo_Null;
	if (Net_LibTMNextTracking_ServerMapInfo.MapUid != LibTMNextTracking_State.ServerMapInfo.MapUid) {
		Net_LibTMNextTracking_ServerMapInfo = LibTMNextTracking_State.ServerMapInfo;
	}

	if (Http::IsInitialized(LibTMNextTracking_State.GetMapInfoRequest)) {
		LibTMNextTracking_State.GetMapInfoRequest = Http::Update(LibTMNextTracking_State.GetMapInfoRequest);
		if (!Http::IsRunning(LibTMNextTracking_State.GetMapInfoRequest)) {
			if (Http::IsSuccess(LibTMNextTracking_State.GetMapInfoRequest)) {
				LibTMNextTracking_State = Private_SendServerMapInfo(_This.Teams[0], LibTMNextTracking_State, LibTMNextTracking_State.ServerMapUid, CampaignAPI::GetResponseFromGetMapInfo(LibTMNextTracking_State.GetMapInfoRequest));
			}
			LibTMNextTracking_State.GetMapInfoRequest = Http::Destroy(LibTMNextTracking_State.GetMapInfoRequest);
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update tracking in the track editor
Void Yield_TrackEditor(CSystemPlatform _System, CMapType _This) {
	declare K_State LibTMNextTracking_State for _System = C_DefaultState;
	if (LibTMNextTracking_State.CurrentContext != C_Context_TrackEditor) {
		LibTMNextTracking_State = Private_SetContext(_This.TrackingMgr, LibTMNextTracking_State, C_Context_TrackEditor);
		LibTMNextTracking_State = Private_SetEditorMapInfo(_This, LibTMNextTracking_State);
	}

	foreach (Event in _This.PendingEvents) {
		switch (Event.Type) {
			case CMapEditorPluginEvent::Type::MapSavedOrSaveCancelled: {
				LibTMNextTracking_State = Private_EditorTrackSaved(_This, _This.TrackingMgr, LibTMNextTracking_State);
			}
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update tracking
Void Yield(CSystemPlatform _System, CNod _This) {
	switchtype (_This) {
		case CManiaAppPlayground: {
			Yield_ModeClient(_System, _This as CManiaAppPlayground);
		}
		case CSmMode: {
			Yield_ModeServer(_System, _This as CSmMode);
		}
		case CManiaAppTitle: {
			Yield_Menu(_System, _This as CManiaAppTitle);
		}
		case CMapType: {
			Yield_TrackEditor(_System, _This as CMapType);
		}
	}
}